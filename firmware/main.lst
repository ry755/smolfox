00000                 | 
00000                 | #line 1 "C:/Users/ryans/Documents/smolfox/firmware/main.p2asm"
00000                 | con
00000                 | 	_clkfreq = 160000000
00000                 | 	_clkmode = 16779259
00000                 | '     _clkfreq = 160_000_000
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 160000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $10007fb
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 A6 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 02 90 5D |  if_ne	jmp	#spininit
0040c 002 D2 F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 01 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 03 80 80 FF 
00420 007 00 F0 67 FD | 	hubset	##16779256
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 03 80 00 FF 
00430 00b FB ED 07 F6 | 	mov	pa, ##16779259
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e B4 C4 84 FF 
00440 00f 14 00 6C FC | 	wrlong	##160000000, #20
00444 010 BC 01 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
005fc 07e 00 00 00 00 
00600 07f 00 00 00 00 | 	orgf	128
00604 080             | skip_clock_set_
00604 080 58 07 A0 FD | 	call	#_Main
00608 081             | cogexit
00608 081 38 01 80 FF 
0060c 082 1F 00 66 FD | 	waitx	##160000
00610 083 01 C2 61 FD | 	cogid	arg01
00614 084 03 C2 61 FD | 	cogstop	arg01
00618 085             | spininit
00618 085 61 91 05 FB | 	rdlong	objptr, ptra++
0061c 086 61 A7 05 FB | 	rdlong	result1, ptra++
00620 087 28 06 64 FD | 	setq	#3
00624 088 00 C3 05 FB | 	rdlong	arg01, ptra
00628 089 04 F0 87 F1 | 	sub	ptra, #4
0062c 08a 2D A6 61 FD | 	call	result1
00630 08b D4 FF 9F FD | 	jmp	#cogexit
00634 08c             | FCACHE_LOAD_
00634 08c F9 2D 01 F6 |     mov	fcache_tmpb_,ptrb
00638 08d 2B F2 63 FD |     pop	ptrb
0063c 08e 95 EC 8B F9 |     altd	pa,ret_instr_
00640 08f 95 00 00 F6 |     mov	 0-0, ret_instr_
00644 090 28 EC 63 FD |     setq	pa
00648 091 E1 01 04 FB |     rdlong	$0, ptrb++
0064c 092 2A F2 63 FD |     push	ptrb
00650 093 96 F2 03 F6 |     mov ptrb,fcache_tmpb_
00654 094 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00658 095             | ret_instr_
00658 095 00 FE 07 02 |     _ret_ cmp inb,#0
0065c 096             | fcache_tmpb_
0065c 096 00 00 00 00 |     long 0
00660 097             | fcache_load_ptr_
00660 097 8C 00 00 00 |     long FCACHE_LOAD_
00664 098             | builtin_bytefill_
00664 098 01 C6 55 F0 |         shr	arg03, #1 wc
00668 099 E1 C4 41 CC |  if_c   wrbyte	arg02, arg01
0066c 09a 01 C2 05 C1 |  if_c   add	arg01, #1
00670 09b 00 C4 FD F9 |         movbyts	arg02, #0
00674 09c             | builtin_wordfill_
00674 09c 01 C6 55 F0 |         shr	arg03, #1 wc
00678 09d E1 C4 51 CC |  if_c   wrword	arg02, arg01
0067c 09e 02 C2 05 C1 |  if_c   add	arg01, #2
00680 09f E2 C4 29 F9 |         setword	arg02, arg02, #1
00684 0a0             | builtin_longfill_
00684 0a0 E1 00 88 FC |         wrfast	#0,arg01
00688 0a1 00 C6 0D F2 |         cmp	arg03, #0 wz
0068c 0a2 E3 02 D8 5C |  if_nz  rep	#1, arg03
00690 0a3 17 C4 61 5D |  if_nz  wflong	arg02
00694 0a4 2D 00 64 FD |         ret
00698 0a5             | COUNT_
00698 0a5 00 00 00 00 |     long 0
0069c 0a6             | RETADDR_
0069c 0a6 00 00 00 00 |     long 0
006a0 0a7             | fp
006a0 0a7 00 00 00 00 |     long 0
006a4 0a8             | pushregs_
006a4 0a8 2B EC 63 FD |     pop  pa
006a8 0a9 2B 4C 61 FD |     pop  RETADDR_
006ac 0aa 03 4A 95 FB |     tjz  COUNT_, #pushregs_done_
006b0 0ab FF 4B 8D F9 |     altd  COUNT_, #511
006b4 0ac 28 00 64 FD |     setq #0-0
006b8 0ad 61 D9 65 FC |     wrlong local01, ptra++
006bc 0ae             | pushregs_done_
006bc 0ae 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
006c0 0af 61 4B 65 FC |     wrlong COUNT_, ptra++
006c4 0b0 F8 4F 01 F6 |     mov    fp, ptra
006c8 0b1 2C EC 63 FD |     jmp  pa
006cc 0b2             |  popregs_
006cc 0b2 2B EC 63 FD |     pop    pa
006d0 0b3 28 04 64 FD |     setq   #2
006d4 0b4 5F 4B 05 FB |     rdlong COUNT_, --ptra
006d8 0b5 02 4A 75 FB |     djf    COUNT_, #popregs__ret
006dc 0b6 28 4A 61 FD |     setq   COUNT_
006e0 0b7 5F D9 05 FB |     rdlong local01, --ptra
006e4 0b8             | popregs__ret
006e4 0b8 2A 4C 61 FD |     push   RETADDR_
006e8 0b9 2C EC 63 FD |     jmp    pa
006ec 0ba             | 
006ec 0ba             | divide_
006ec 0ba 13 27 5A F6 |        abs     muldivb_,muldivb_     wcz      'abs(y)
006f0 0bb 6C 8E 61 FD |        wrc     itmp2_                         'store sign of y
006f4 0bc 12 25 52 F6 |        abs     muldiva_,muldiva_     wc       'abs(x)
006f8 0bd 13 25 12 FD |        qdiv    muldiva_, muldivb_             'queue divide
006fc 0be 01 8E 65 C5 |  if_c  xor     itmp2_,#1                      'store sign of x
00700 0bf 18 26 62 FD |        getqx   muldivb_                       'get quotient
00704 0c0 19 24 62 FD |        getqy   muldiva_                       'get remainder
00708 0c1 12 25 82 F6 |        negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
0070c 0c2 00 8E 15 F4 |        testb   itmp2_,#0             wc       'restore sign, division result
00710 0c3 13 27 82 06 |  _ret_ negc    muldivb_,muldivb_     
00714 0c4             | 
00714 0c4             | __heap_ptr
00714 0c4 78 7A 01 00 | 	long	@__heap_base
00718 0c5             | __methods__
00718 0c5 00 7A 01 00 | 	long	@__methodtable__
0071c 0c6             | itmp1_
0071c 0c6 00 00 00 00 | 	long	0
00720 0c7             | itmp2_
00720 0c7 00 00 00 00 | 	long	0
00724 0c8             | objptr
00724 0c8 F0 91 01 00 | 	long	@objmem
00728 0c9             | ptr___system__dat__
00728 0c9 28 77 01 00 | 	long	@__system__dat_
0072c 0ca             | ptr__bus_dat__
0072c 0ca 44 FF 00 00 | 	long	@_bus_dat_
00730 0cb             | ptr__fatfs_cc_dat__
00730 0cb 70 FD 00 00 | 	long	@_fatfs_cc_dat_
00734 0cc             | ptr__fs9p_cc_dat__
00734 0cc 0C 73 01 00 | 	long	@_fs9p_cc_dat_
00738 0cd             | ptr__libc_a_dat__
00738 0cd 64 FB 00 00 | 	long	@_libc_a_dat_
0073c 0ce             | ptr__memory_dat__
0073c 0ce 6C FF 00 00 | 	long	@_memory_dat_
00740 0cf             | ptr__p2textdrv_dat__
00740 0cf 70 32 01 00 | 	long	@_p2textdrv_dat_
00744 0d0             | ptr__p2videodrv_dat__
00744 0d0 B0 42 01 00 | 	long	@_p2videodrv_dat_
00748 0d1             | ptr__usbnew_0016_dat__
00748 0d1 40 54 01 00 | 	long	@_usbnew_0016_dat_
0074c 0d2             | ptr_stackspace_
0074c 0d2 B0 18 07 00 | 	long	@stackspace
00750 0d3             | result1
00750 0d3 00 00 00 00 | 	long	0
00754 0d4             | result2
00754 0d4 01 00 00 00 | 	long	1
00758 0d5             | COG_BSS_START
00758 0d5             | 	fit	480
00758                 | 	orgh
00758                 | hubentry
00758                 | 
00758                 | ' 
00758                 | ' PUB Main
00758                 | _Main
00758     01 4A 05 F6 | 	mov	COUNT_, #1
0075c     A8 00 A0 FD | 	call	#pushregs_
00760                 | '     _mount(@"/sd", c._vfs_open_sdcard())
00760     7C 00 00 FF 
00764     48 D9 05 F6 | 	mov	local01, ##@LR__2094
00768                 | ' _vfs_open_sdcard()
00768                 | ' {
00768                 | '     return _vfs_open_sdcardx(61, 60, 59, 58);
00768     3D C2 05 F6 | 	mov	arg01, #61
0076c     3C C4 05 F6 | 	mov	arg02, #60
00770     3B C6 05 F6 | 	mov	arg03, #59
00774     3A C8 05 F6 | 	mov	arg04, #58
00778     3C 00 B0 FD | 	call	#_libc_a__vfs_open_sdcardx
0077c     D3 C4 01 F6 | 	mov	arg02, result1
00780     EC C2 01 F6 | 	mov	arg01, local01
00784     08 DF B0 FD | 	call	#__system___mount
00788                 | '     hostfs.GetDiskFromHost
00788     C1 02 00 FF 
0078c     78 90 05 F1 | 	add	objptr, ##361080
00790     3C C7 B0 FD | 	call	#_hostfs_GetDiskFromHost
00794     C1 02 00 FF 
00798     78 90 85 F1 | 	sub	objptr, ##361080
0079c                 | '     cpu.Initialize
0079c     EC 83 B0 FD | 	call	#_cpu_Initialize
007a0                 | ' 
007a0                 | '     repeat
007a0                 | LR__0001
007a0                 | '         cpu.Execute($FFFFFFFF)
007a0     01 C2 65 F6 | 	neg	arg01, #1
007a4     0C 84 B0 FD | 	call	#_cpu_Execute
007a8     F4 FF 9F FD | 	jmp	#LR__0001
007ac     A7 F0 03 F6 | 	mov	ptra, fp
007b0     B2 00 A0 FD | 	call	#popregs_
007b4                 | _Main_ret
007b4     2D 00 64 FD | 	ret
007b8                 | 
007b8                 | _libc_a__vfs_open_sdcardx
007b8     0B 4A 05 F6 | 	mov	COUNT_, #11
007bc     A8 00 A0 FD | 	call	#pushregs_
007c0     E1 DC 01 F6 | 	mov	local03, arg01
007c4     E2 DE 01 F6 | 	mov	local04, arg02
007c8     E3 E0 01 F6 | 	mov	local05, arg03
007cc     E4 E2 01 F6 | 	mov	local06, arg04
007d0     28 C2 05 F6 | 	mov	arg01, #40
007d4     84 E7 B0 FD | 	call	#__system___gc_alloc_managed
007d8     D3 E4 01 F6 | 	mov	local07, result1
007dc     01 00 00 FF 
007e0     30 C2 05 F6 | 	mov	arg01, ##560
007e4     74 E7 B0 FD | 	call	#__system___gc_alloc_managed
007e8     D3 E6 01 F6 | 	mov	local08, result1
007ec     EE C8 01 F6 | 	mov	arg04, local03
007f0     1F C8 C5 F0 | 	sar	arg04, #31
007f4     EE C6 01 F6 | 	mov	arg03, local03
007f8     01 C2 05 F6 | 	mov	arg01, #1
007fc     00 C4 05 F6 | 	mov	arg02, #0
00800     54 E4 B0 FD | 	call	#__system___int64_shl
00804     D3 D8 01 F6 | 	mov	local01, result1
00808     D4 E8 01 F6 | 	mov	local09, result2
0080c     EF C8 01 F6 | 	mov	arg04, local04
00810     1F C8 C5 F0 | 	sar	arg04, #31
00814     EF C6 01 F6 | 	mov	arg03, local04
00818     01 C2 05 F6 | 	mov	arg01, #1
0081c     00 C4 05 F6 | 	mov	arg02, #0
00820     34 E4 B0 FD | 	call	#__system___int64_shl
00824     D3 D8 41 F5 | 	or	local01, result1
00828     D4 E8 41 F5 | 	or	local09, result2
0082c     F0 C8 01 F6 | 	mov	arg04, local05
00830     1F C8 C5 F0 | 	sar	arg04, #31
00834     F0 C6 01 F6 | 	mov	arg03, local05
00838     01 C2 05 F6 | 	mov	arg01, #1
0083c     00 C4 05 F6 | 	mov	arg02, #0
00840     14 E4 B0 FD | 	call	#__system___int64_shl
00844     D3 D8 41 F5 | 	or	local01, result1
00848     D4 E8 41 F5 | 	or	local09, result2
0084c     F1 C8 01 F6 | 	mov	arg04, local06
00850     1F C8 C5 F0 | 	sar	arg04, #31
00854     F1 C6 01 F6 | 	mov	arg03, local06
00858     01 C2 05 F6 | 	mov	arg01, #1
0085c     00 C4 05 F6 | 	mov	arg02, #0
00860     F4 E3 B0 FD | 	call	#__system___int64_shl
00864     F4 C4 01 F6 | 	mov	arg02, local09
00868     D3 D8 41 F5 | 	or	local01, result1
0086c     E2 A8 41 F5 | 	or	result2, arg02
00870     D4 DA 01 F6 | 	mov	local02, result2
00874     EC C2 01 F6 | 	mov	arg01, local01
00878     ED C4 01 F6 | 	mov	arg02, local02
0087c     10 E4 B0 FD | 	call	#__system___usepins
00880     00 A6 0D F2 | 	cmp	result1, #0 wz
00884     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
00888     C9 2C 68 AC |  if_e	wrlong	#22, ptr___system__dat__
0088c     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
00890                 | '         _seterror( 22 );
00890                 | '         return 0;
00890     00 A6 05 A6 |  if_e	mov	result1, #0
00894     AC 00 90 AD |  if_e	jmp	#LR__0012
00898     EC EA 01 F6 | 	mov	local10, local01
0089c     ED E8 01 F6 | 	mov	local09, local02
008a0     08 E4 05 F1 | 	add	local07, #8
008a4     F2 EA 61 FC | 	wrlong	local10, local07
008a8     04 E4 05 F1 | 	add	local07, #4
008ac     F2 E8 61 FC | 	wrlong	local09, local07
008b0     0C E4 85 F1 | 	sub	local07, #12
008b4     F1 CA 01 F6 | 	mov	arg05, local06
008b8     00 C2 05 F6 | 	mov	arg01, #0
008bc     EE C4 01 F6 | 	mov	arg02, local03
008c0     EF C6 01 F6 | 	mov	arg03, local04
008c4     F0 C8 01 F6 | 	mov	arg04, local05
008c8     C8 EA 01 F6 | 	mov	local10, objptr
008cc     F2 90 01 F6 | 	mov	objptr, local07
008d0     70 1D B0 FD | 	call	#_fatfs_cc_disk_setpins
008d4     F5 90 01 F6 | 	mov	objptr, local10
008d8     D3 EC 09 F6 | 	mov	local11, result1 wz
008dc     24 00 90 5D |  if_ne	jmp	#LR__0010
008e0     7C 00 00 FF 
008e4     4C C5 05 F6 | 	mov	arg02, ##@LR__2095
008e8     F3 C2 01 F6 | 	mov	arg01, local08
008ec     00 C6 05 F6 | 	mov	arg03, #0
008f0     C8 EC 01 F6 | 	mov	local11, objptr
008f4     F2 90 01 F6 | 	mov	objptr, local07
008f8     5C 3C B0 FD | 	call	#_fatfs_cc_f_mount
008fc     F6 90 01 F6 | 	mov	objptr, local11
00900     D3 EC 01 F6 | 	mov	local11, result1
00904                 | LR__0010
00904     00 EC 0D F2 | 	cmp	local11, #0 wz
00908     24 00 90 AD |  if_e	jmp	#LR__0011
0090c     EC C2 01 F6 | 	mov	arg01, local01
00910     ED C4 01 F6 | 	mov	arg02, local02
00914     CC E3 B0 FD | 	call	#__system___freepins
00918     F6 C2 69 F6 | 	neg	arg01, local11 wz
0091c     20 92 05 F1 | 	add	ptr___system__dat__, #32
00920     C9 C2 61 FC | 	wrlong	arg01, ptr___system__dat__
00924     20 92 85 F1 | 	sub	ptr___system__dat__, #32
00928                 | ' #line 39 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs_vfs.c"
00928                 | '        _freepins(pmask);
00928                 | '        _seterror(-r);
00928                 | '        return 0;
00928     00 A6 05 F6 | 	mov	result1, #0
0092c     14 00 90 FD | 	jmp	#LR__0012
00930                 | LR__0011
00930     F2 C2 01 F6 | 	mov	arg01, local07
00934     C8 EC 01 F6 | 	mov	local11, objptr
00938     F2 90 01 F6 | 	mov	objptr, local07
0093c     60 78 B0 FD | 	call	#_fatfs_cc_get_vfs
00940     F6 90 01 F6 | 	mov	objptr, local11
00944                 | '     }
00944                 | '     v = FFS->get_vfs(FFS);
00944                 | ' #line 50 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs_vfs.c"
00944                 | '     return v;
00944                 | LR__0012
00944     A7 F0 03 F6 | 	mov	ptra, fp
00948     B2 00 A0 FD | 	call	#popregs_
0094c                 | _libc_a__vfs_open_sdcardx_ret
0094c     2D 00 64 FD | 	ret
00950                 | 
00950                 | _libc_a_fflush
00950     03 4A 05 F6 | 	mov	COUNT_, #3
00954     A8 00 A0 FD | 	call	#pushregs_
00958     00 D8 05 F6 | 	mov	local01, #0
0095c     2C C2 05 F1 | 	add	arg01, #44
00960     E1 A6 09 FB | 	rdlong	result1, arg01 wz
00964     2C C2 85 F1 | 	sub	arg01, #44
00968     38 00 90 AD |  if_e	jmp	#LR__0020
0096c     2C C2 05 F1 | 	add	arg01, #44
00970     E1 D8 01 FB | 	rdlong	local01, arg01
00974     EC DA 01 F6 | 	mov	local02, local01
00978     2C C2 85 F1 | 	sub	arg01, #44
0097c     13 DA 45 F7 | 	zerox	local02, #19
00980     14 D8 45 F0 | 	shr	local01, #20
00984     02 D8 65 F0 | 	shl	local01, #2
00988     C5 D8 01 F1 | 	add	local01, __methods__
0098c     EC D8 01 FB | 	rdlong	local01, local01
00990     C8 DC 01 F6 | 	mov	local03, objptr
00994     ED 90 01 F6 | 	mov	objptr, local02
00998     2D D8 61 FD | 	call	local01
0099c     EE 90 01 F6 | 	mov	objptr, local03
009a0     D3 D8 01 F6 | 	mov	local01, result1
009a4                 | LR__0020
009a4                 | '         r = (*f->flush)(f);
009a4                 | '     }
009a4                 | '     return r;
009a4     EC A6 01 F6 | 	mov	result1, local01
009a8     A7 F0 03 F6 | 	mov	ptra, fp
009ac     B2 00 A0 FD | 	call	#popregs_
009b0                 | _libc_a_fflush_ret
009b0     2D 00 64 FD | 	ret
009b4                 | 
009b4                 | _libc_a_fgetc
009b4     03 4A 05 F6 | 	mov	COUNT_, #3
009b8     A8 00 A0 FD | 	call	#pushregs_
009bc     E1 D8 01 F6 | 	mov	local01, arg01
009c0     10 D8 05 F1 | 	add	local01, #16
009c4     EC A6 09 FB | 	rdlong	result1, local01 wz
009c8     10 D8 85 F1 | 	sub	local01, #16
009cc     10 D8 05 51 |  if_ne	add	local01, #16
009d0     EC DA 01 5B |  if_ne	rdlong	local02, local01
009d4     01 DA 85 51 |  if_ne	sub	local02, #1
009d8     EC 00 68 5C |  if_ne	wrlong	#0, local01
009dc     3C 00 90 5D |  if_ne	jmp	#LR__0030
009e0     20 D8 05 F1 | 	add	local01, #32
009e4     EC DA 01 FB | 	rdlong	local02, local01
009e8     ED DC 01 F6 | 	mov	local03, local02
009ec     20 D8 85 F1 | 	sub	local01, #32
009f0     13 DC 45 F7 | 	zerox	local03, #19
009f4     14 DA 45 F0 | 	shr	local02, #20
009f8     02 DA 65 F0 | 	shl	local02, #2
009fc     C5 DA 01 F1 | 	add	local02, __methods__
00a00     ED DA 01 FB | 	rdlong	local02, local02
00a04     EC C2 01 F6 | 	mov	arg01, local01
00a08     C8 D8 01 F6 | 	mov	local01, objptr
00a0c     EE 90 01 F6 | 	mov	objptr, local03
00a10     2D DA 61 FD | 	call	local02
00a14     EC 90 01 F6 | 	mov	objptr, local01
00a18     D3 DA 01 F6 | 	mov	local02, result1
00a1c                 | LR__0030
00a1c                 | '         c = f->getcf(f);
00a1c                 | '     }
00a1c                 | '     return c;
00a1c     ED A6 01 F6 | 	mov	result1, local02
00a20     A7 F0 03 F6 | 	mov	ptra, fp
00a24     B2 00 A0 FD | 	call	#popregs_
00a28                 | _libc_a_fgetc_ret
00a28     2D 00 64 FD | 	ret
00a2c                 | 
00a2c                 | _libc_a_fopen
00a2c     02 4A 05 F6 | 	mov	COUNT_, #2
00a30     A8 00 A0 FD | 	call	#pushregs_
00a34     E1 D8 01 F6 | 	mov	local01, arg01
00a38     E2 DA 01 F6 | 	mov	local02, arg02
00a3c     6C 0C B0 FD | 	call	#_libc_a__find_free_file
00a40     D3 C6 01 F6 | 	mov	arg03, result1
00a44     00 C6 55 F2 | 	cmps	arg03, #0 wc
00a48     00 A6 05 C6 |  if_b	mov	result1, #0
00a4c     18 00 90 CD |  if_b	jmp	#LR__0040
00a50     E3 C2 01 F6 | 	mov	arg01, arg03
00a54     58 0A B0 FD | 	call	#_libc_a___getftab
00a58     D3 C6 01 F6 | 	mov	arg03, result1
00a5c                 | ' 
00a5c                 | '     ftab = __getftab(fd);
00a5c                 | '     return _fopenraw(pathname, mode, ftab);
00a5c     EC C2 01 F6 | 	mov	arg01, local01
00a60     ED C4 01 F6 | 	mov	arg02, local02
00a64     68 0A B0 FD | 	call	#_libc_a__fopenraw
00a68                 | LR__0040
00a68     A7 F0 03 F6 | 	mov	ptra, fp
00a6c     B2 00 A0 FD | 	call	#popregs_
00a70                 | _libc_a_fopen_ret
00a70     2D 00 64 FD | 	ret
00a74                 | 
00a74                 | _libc_a_fseek
00a74     04 4A 05 F6 | 	mov	COUNT_, #4
00a78     A8 00 A0 FD | 	call	#pushregs_
00a7c     E1 D8 01 F6 | 	mov	local01, arg01
00a80     E2 DA 01 F6 | 	mov	local02, arg02
00a84     E3 DC 01 F6 | 	mov	local03, arg03
00a88                 | ' {
00a88                 | '     return (f -  __getftab(0) );
00a88     EC C6 01 F6 | 	mov	arg03, local01
00a8c     00 C2 05 F6 | 	mov	arg01, #0
00a90     1C 0A B0 FD | 	call	#_libc_a___getftab
00a94     D3 C6 81 F1 | 	sub	arg03, result1
00a98     34 C6 15 FD | 	qdiv	arg03, #52
00a9c     EC C2 01 F6 | 	mov	arg01, local01
00aa0     18 DE 61 FD | 	getqx	local04
00aa4     A8 FE BF FD | 	call	#_libc_a_fflush
00aa8     10 D8 05 F1 | 	add	local01, #16
00aac     EC 00 68 FC | 	wrlong	#0, local01
00ab0     EF C2 01 F6 | 	mov	arg01, local04
00ab4     ED C4 01 F6 | 	mov	arg02, local02
00ab8     EE C6 01 F6 | 	mov	arg03, local03
00abc     50 05 B0 FD | 	call	#_libc_a_lseek
00ac0     FF FF 7F FF 
00ac4     FF A7 0D F2 | 	cmp	result1, ##-1 wz
00ac8     00 A6 05 56 |  if_ne	mov	result1, #0
00acc                 | '         r = 0;
00acc                 | '     }
00acc                 | '     return r;
00acc     A7 F0 03 F6 | 	mov	ptra, fp
00ad0     B2 00 A0 FD | 	call	#popregs_
00ad4                 | _libc_a_fseek_ret
00ad4     2D 00 64 FD | 	ret
00ad8                 | 
00ad8                 | _libc_a_ftell
00ad8     02 4A 05 F6 | 	mov	COUNT_, #2
00adc     A8 00 A0 FD | 	call	#pushregs_
00ae0     E1 D8 01 F6 | 	mov	local01, arg01
00ae4                 | ' {
00ae4                 | '     return (f -  __getftab(0) );
00ae4     E1 C6 01 F6 | 	mov	arg03, arg01
00ae8     00 C2 05 F6 | 	mov	arg01, #0
00aec     C0 09 B0 FD | 	call	#_libc_a___getftab
00af0     D3 C6 81 F1 | 	sub	arg03, result1
00af4     34 C6 15 FD | 	qdiv	arg03, #52
00af8     EC C2 01 F6 | 	mov	arg01, local01
00afc     18 DA 61 FD | 	getqx	local02
00b00     4C FE BF FD | 	call	#_libc_a_fflush
00b04     ED C2 01 F6 | 	mov	arg01, local02
00b08     00 C4 05 F6 | 	mov	arg02, #0
00b0c     01 C6 05 F6 | 	mov	arg03, #1
00b10     FC 04 B0 FD | 	call	#_libc_a_lseek
00b14     10 D8 05 F1 | 	add	local01, #16
00b18     EC DA 09 FB | 	rdlong	local02, local01 wz
00b1c     01 A6 55 52 |  if_ne	cmps	result1, #1 wc
00b20     01 A6 85 11 |  if_a	sub	result1, #1
00b24                 | '         --r;
00b24                 | '     }
00b24                 | '     return r;
00b24     A7 F0 03 F6 | 	mov	ptra, fp
00b28     B2 00 A0 FD | 	call	#popregs_
00b2c                 | _libc_a_ftell_ret
00b2c     2D 00 64 FD | 	ret
00b30                 | 
00b30                 | _libc_a_fwrite
00b30     03 4A 05 F6 | 	mov	COUNT_, #3
00b34     A8 00 A0 FD | 	call	#pushregs_
00b38     E3 C4 01 FD | 	qmul	arg02, arg03
00b3c     E1 D8 01 F6 | 	mov	local01, arg01
00b40     E4 DA 01 F6 | 	mov	local02, arg04
00b44     ED C2 01 F6 | 	mov	arg01, local02
00b48     18 DC 61 FD | 	getqx	local03
00b4c     00 FE BF FD | 	call	#_libc_a_fflush
00b50                 | ' {
00b50                 | '     size *= n;
00b50                 | '     fflush(f);
00b50                 | '     return _vfswrite(f, ptr, size);
00b50     ED C2 01 F6 | 	mov	arg01, local02
00b54     EC C4 01 F6 | 	mov	arg02, local01
00b58     EE C6 01 F6 | 	mov	arg03, local03
00b5c     9C 0B B0 FD | 	call	#_libc_a__vfswrite
00b60     A7 F0 03 F6 | 	mov	ptra, fp
00b64     B2 00 A0 FD | 	call	#popregs_
00b68                 | _libc_a_fwrite_ret
00b68     2D 00 64 FD | 	ret
00b6c                 | 
00b6c                 | _libc_a_fread
00b6c     06 4A 05 F6 | 	mov	COUNT_, #6
00b70     A8 00 A0 FD | 	call	#pushregs_
00b74     E3 C4 01 FD | 	qmul	arg02, arg03
00b78     E1 D8 01 F6 | 	mov	local01, arg01
00b7c     E4 DA 01 F6 | 	mov	local02, arg04
00b80     00 DC 05 F6 | 	mov	local03, #0
00b84     08 DA 05 F1 | 	add	local02, #8
00b88     ED DE 01 FB | 	rdlong	local04, local02
00b8c     08 DA 85 F1 | 	sub	local02, #8
00b90     00 DF CD F7 | 	test	local04, #256 wz
00b94     18 E0 61 FD | 	getqx	local05
00b98     30 00 90 AD |  if_e	jmp	#LR__0052
00b9c     EC E2 01 F6 | 	mov	local06, local01
00ba0                 | '         while (size > 0) {
00ba0                 | LR__0050
00ba0     01 E0 15 F2 | 	cmp	local05, #1 wc
00ba4     1C 00 90 CD |  if_b	jmp	#LR__0051
00ba8     ED C2 01 F6 | 	mov	arg01, local02
00bac     04 FE BF FD | 	call	#_libc_a_fgetc
00bb0     00 A6 55 F2 | 	cmps	result1, #0 wc
00bb4     F1 A6 41 3C |  if_ae	wrbyte	result1, local06
00bb8     01 DC 05 31 |  if_ae	add	local03, #1
00bbc     01 E2 05 31 |  if_ae	add	local06, #1
00bc0     DC FF 9F 3D |  if_ae	jmp	#LR__0050
00bc4                 | LR__0051
00bc4                 | '             *dst++ = c;
00bc4                 | '             r++;
00bc4                 | '         }
00bc4                 | '         return r;
00bc4     EE A6 01 F6 | 	mov	result1, local03
00bc8     58 00 90 FD | 	jmp	#LR__0054
00bcc                 | LR__0052
00bcc     10 DA 05 F1 | 	add	local02, #16
00bd0     ED DE 09 FB | 	rdlong	local04, local02 wz
00bd4     10 DA 85 F1 | 	sub	local02, #16
00bd8     00 E0 0D 52 |  if_ne	cmp	local05, #0 wz
00bdc     1C 00 90 AD |  if_e	jmp	#LR__0053
00be0     EC DE 01 F6 | 	mov	local04, local01
00be4     ED C2 01 F6 | 	mov	arg01, local02
00be8     01 D8 05 F1 | 	add	local01, #1
00bec     C4 FD BF FD | 	call	#_libc_a_fgetc
00bf0     EF A6 41 FC | 	wrbyte	result1, local04
00bf4     01 E0 85 F1 | 	sub	local05, #1
00bf8     01 DC 05 F1 | 	add	local03, #1
00bfc                 | LR__0053
00bfc     00 E0 0D F2 | 	cmp	local05, #0 wz
00c00     EE A6 01 A6 |  if_e	mov	result1, local03
00c04     1C 00 90 AD |  if_e	jmp	#LR__0054
00c08     ED C2 01 F6 | 	mov	arg01, local02
00c0c     40 FD BF FD | 	call	#_libc_a_fflush
00c10     ED C2 01 F6 | 	mov	arg01, local02
00c14     EC C4 01 F6 | 	mov	arg02, local01
00c18     F0 C6 01 F6 | 	mov	arg03, local05
00c1c     A4 0C B0 FD | 	call	#_libc_a__vfsread
00c20                 | '     fflush(f);
00c20                 | '     r += _vfsread(f, ptr, size);
00c20                 | ' #line 44 "C:/Users/ryans/Documents/flexprop/include/libc/stdio/fwrite.c"
00c20                 | '     return r;
00c20     EE A6 01 F1 | 	add	result1, local03
00c24                 | LR__0054
00c24     A7 F0 03 F6 | 	mov	ptra, fp
00c28     B2 00 A0 FD | 	call	#popregs_
00c2c                 | _libc_a_fread_ret
00c2c     2D 00 64 FD | 	ret
00c30                 | 
00c30                 | _libc_a__openraw
00c30     15 4A 05 F6 | 	mov	COUNT_, #21
00c34     A8 00 A0 FD | 	call	#pushregs_
00c38     E1 D8 01 F6 | 	mov	local01, arg01
00c3c     E2 DA 01 F6 | 	mov	local02, arg02
00c40     E3 DC 01 F6 | 	mov	local03, arg03
00c44     E4 DE 01 F6 | 	mov	local04, arg04
00c48     04 E0 05 F6 | 	mov	local05, #4
00c4c     EC E2 01 F6 | 	mov	local06, local01
00c50     00 E4 05 F6 | 	mov	local07, #0
00c54     C9 E6 01 F6 | 	mov	local08, ptr___system__dat__
00c58     84 E7 05 F1 | 	add	local08, #388
00c5c     F3 C2 01 F6 | 	mov	arg01, local08
00c60     ED C4 01 F6 | 	mov	arg02, local02
00c64     00 C6 05 F6 | 	mov	arg03, #0
00c68     E8 DC B0 FD | 	call	#__system____getvfsforfile
00c6c     D3 E8 09 F6 | 	mov	local09, result1 wz
00c70     10 00 90 AD |  if_e	jmp	#LR__0060
00c74     20 E8 05 F1 | 	add	local09, #32
00c78     F4 A6 09 FB | 	rdlong	result1, local09 wz
00c7c     20 E8 85 F1 | 	sub	local09, #32
00c80     14 00 90 5D |  if_ne	jmp	#LR__0061
00c84                 | LR__0060
00c84                 | ' #line 121 "C:/Users/ryans/Documents/flexprop/include/libc/unix/posixio.c"
00c84                 | '         return _seterror( 16 );
00c84     20 92 05 F1 | 	add	ptr___system__dat__, #32
00c88     C9 20 68 FC | 	wrlong	#16, ptr___system__dat__
00c8c     20 92 85 F1 | 	sub	ptr___system__dat__, #32
00c90     01 A6 65 F6 | 	neg	result1, #1
00c94     88 02 90 FD | 	jmp	#LR__0074
00c98                 | LR__0061
00c98     F1 C2 01 F6 | 	mov	arg01, local06
00c9c     00 C4 05 F6 | 	mov	arg02, #0
00ca0     34 C6 05 F6 | 	mov	arg03, #52
00ca4     E1 EA 01 F6 | 	mov	local10, arg01
00ca8     98 00 A0 FD | 	call	#\builtin_bytefill_
00cac     20 E8 05 F1 | 	add	local09, #32
00cb0     F4 EC 01 FB | 	rdlong	local11, local09
00cb4     F6 EE 01 F6 | 	mov	local12, local11
00cb8     F6 F0 01 F6 | 	mov	local13, local11
00cbc     20 E8 85 F1 | 	sub	local09, #32
00cc0     F8 F2 01 F6 | 	mov	local14, local13
00cc4     13 EE 45 F7 | 	zerox	local12, #19
00cc8     14 F2 45 F0 | 	shr	local14, #20
00ccc     02 F2 65 F0 | 	shl	local14, #2
00cd0     C5 F2 01 F1 | 	add	local14, __methods__
00cd4     F9 F2 01 FB | 	rdlong	local14, local14
00cd8     F1 F4 01 F6 | 	mov	local15, local06
00cdc     F3 F6 01 F6 | 	mov	local16, local08
00ce0     EE F8 01 F6 | 	mov	local17, local03
00ce4     FA C2 01 F6 | 	mov	arg01, local15
00ce8     FB C4 01 F6 | 	mov	arg02, local16
00cec     FC C6 01 F6 | 	mov	arg03, local17
00cf0     C8 FA 01 F6 | 	mov	local18, objptr
00cf4     F7 90 01 F6 | 	mov	objptr, local12
00cf8     2D F2 61 FD | 	call	local14
00cfc     FD 90 01 F6 | 	mov	objptr, local18
00d00     D3 FC 09 F6 | 	mov	local19, result1 wz
00d04     04 DC CD 57 |  if_ne	test	local03, #4 wz
00d08     58 00 90 AD |  if_e	jmp	#LR__0062
00d0c     24 E8 05 F1 | 	add	local09, #36
00d10     F4 EC 01 FB | 	rdlong	local11, local09
00d14     F6 EE 01 F6 | 	mov	local12, local11
00d18     F6 F0 01 F6 | 	mov	local13, local11
00d1c     24 E8 85 F1 | 	sub	local09, #36
00d20     F8 F2 01 F6 | 	mov	local14, local13
00d24     13 EE 45 F7 | 	zerox	local12, #19
00d28     14 F2 45 F0 | 	shr	local14, #20
00d2c     02 F2 65 F0 | 	shl	local14, #2
00d30     C5 F2 01 F1 | 	add	local14, __methods__
00d34     F9 F2 01 FB | 	rdlong	local14, local14
00d38     F1 F4 01 F6 | 	mov	local15, local06
00d3c     F3 F6 01 F6 | 	mov	local16, local08
00d40     EF F8 01 F6 | 	mov	local17, local04
00d44     FA C2 01 F6 | 	mov	arg01, local15
00d48     FB C4 01 F6 | 	mov	arg02, local16
00d4c     FC C6 01 F6 | 	mov	arg03, local17
00d50     C8 FA 01 F6 | 	mov	local18, objptr
00d54     F7 90 01 F6 | 	mov	objptr, local12
00d58     2D F2 61 FD | 	call	local14
00d5c     FD 90 01 F6 | 	mov	objptr, local18
00d60     D3 FC 01 F6 | 	mov	local19, result1
00d64                 | LR__0062
00d64     00 FC 0D F2 | 	cmp	local19, #0 wz
00d68     88 01 90 5D |  if_ne	jmp	#LR__0072
00d6c     EE FE 01 F6 | 	mov	local20, local03
00d70     03 FE 0D F5 | 	and	local20, #3 wz
00d74     02 E0 45 55 |  if_ne	or	local05, #2
00d78     01 FE 0D F2 | 	cmp	local20, #1 wz
00d7c     01 E0 45 55 |  if_ne	or	local05, #1
00d80     20 DC CD F7 | 	test	local03, #32 wz
00d84     C0 E0 45 55 |  if_ne	or	local05, #192
00d88     08 E2 05 F1 | 	add	local06, #8
00d8c     F1 E0 61 FC | 	wrlong	local05, local06
00d90     0C E2 05 F1 | 	add	local06, #12
00d94     F1 00 0A FB | 	rdlong	local21, local06 wz
00d98     14 E2 85 F1 | 	sub	local06, #20
00d9c     18 00 90 5D |  if_ne	jmp	#LR__0063
00da0     04 E8 05 F1 | 	add	local09, #4
00da4     F4 00 02 FB | 	rdlong	local21, local09
00da8     04 E8 85 F1 | 	sub	local09, #4
00dac     14 E2 05 F1 | 	add	local06, #20
00db0     F1 00 62 FC | 	wrlong	local21, local06
00db4     14 E2 85 F1 | 	sub	local06, #20
00db8                 | LR__0063
00db8     18 E2 05 F1 | 	add	local06, #24
00dbc     F1 00 0A FB | 	rdlong	local21, local06 wz
00dc0     18 E2 85 F1 | 	sub	local06, #24
00dc4     18 00 90 5D |  if_ne	jmp	#LR__0064
00dc8     08 E8 05 F1 | 	add	local09, #8
00dcc     F4 00 02 FB | 	rdlong	local21, local09
00dd0     08 E8 85 F1 | 	sub	local09, #8
00dd4     18 E2 05 F1 | 	add	local06, #24
00dd8     F1 00 62 FC | 	wrlong	local21, local06
00ddc     18 E2 85 F1 | 	sub	local06, #24
00de0                 | LR__0064
00de0     24 E2 05 F1 | 	add	local06, #36
00de4     F1 00 0A FB | 	rdlong	local21, local06 wz
00de8     24 E2 85 F1 | 	sub	local06, #36
00dec     F4 00 02 AB |  if_e	rdlong	local21, local09
00df0     24 E2 05 A1 |  if_e	add	local06, #36
00df4     F1 00 62 AC |  if_e	wrlong	local21, local06
00df8     24 E2 85 A1 |  if_e	sub	local06, #36
00dfc     28 E2 05 F1 | 	add	local06, #40
00e00     F1 00 0A FB | 	rdlong	local21, local06 wz
00e04     28 E2 85 F1 | 	sub	local06, #40
00e08     18 00 90 5D |  if_ne	jmp	#LR__0065
00e0c     10 E8 05 F1 | 	add	local09, #16
00e10     F4 00 02 FB | 	rdlong	local21, local09
00e14     10 E8 85 F1 | 	sub	local09, #16
00e18     28 E2 05 F1 | 	add	local06, #40
00e1c     F1 00 62 FC | 	wrlong	local21, local06
00e20     28 E2 85 F1 | 	sub	local06, #40
00e24                 | LR__0065
00e24     30 E2 05 F1 | 	add	local06, #48
00e28     F1 00 0A FB | 	rdlong	local21, local06 wz
00e2c     30 E2 85 F1 | 	sub	local06, #48
00e30     18 00 90 5D |  if_ne	jmp	#LR__0066
00e34     0C E8 05 F1 | 	add	local09, #12
00e38     F4 00 02 FB | 	rdlong	local21, local09
00e3c     0C E8 85 F1 | 	sub	local09, #12
00e40     30 E2 05 F1 | 	add	local06, #48
00e44     F1 00 62 FC | 	wrlong	local21, local06
00e48     30 E2 85 F1 | 	sub	local06, #48
00e4c                 | LR__0066
00e4c     1C E2 05 F1 | 	add	local06, #28
00e50     F1 00 0A FB | 	rdlong	local21, local06 wz
00e54     1C E2 85 F1 | 	sub	local06, #28
00e58     1C 00 90 5D |  if_ne	jmp	#LR__0067
00e5c     01 E4 05 F6 | 	mov	local07, #1
00e60     C8 C2 01 F6 | 	mov	arg01, objptr
00e64     00 B8 00 FF 
00e68     00 C2 45 F5 | 	or	arg01, ##24117248
00e6c     1C E2 05 F1 | 	add	local06, #28
00e70     F1 C2 61 FC | 	wrlong	arg01, local06
00e74     1C E2 85 F1 | 	sub	local06, #28
00e78                 | LR__0067
00e78     20 E2 05 F1 | 	add	local06, #32
00e7c     F1 00 0A FB | 	rdlong	local21, local06 wz
00e80     20 E2 85 F1 | 	sub	local06, #32
00e84     18 00 90 5D |  if_ne	jmp	#LR__0068
00e88     01 E4 05 F6 | 	mov	local07, #1
00e8c     C8 C2 01 F6 | 	mov	arg01, objptr
00e90     37 C2 25 F4 | 	bith	arg01, #55
00e94     20 E2 05 F1 | 	add	local06, #32
00e98     F1 C2 61 FC | 	wrlong	arg01, local06
00e9c     20 E2 85 F1 | 	sub	local06, #32
00ea0                 | LR__0068
00ea0     2C E2 05 F1 | 	add	local06, #44
00ea4     F1 00 0A FB | 	rdlong	local21, local06 wz
00ea8     2C E2 85 F1 | 	sub	local06, #44
00eac     44 00 90 5D |  if_ne	jmp	#LR__0071
00eb0     14 E8 05 F1 | 	add	local09, #20
00eb4     F4 00 0A FB | 	rdlong	local21, local09 wz
00eb8     14 E8 85 F1 | 	sub	local09, #20
00ebc     18 00 90 AD |  if_e	jmp	#LR__0069
00ec0     14 E8 05 F1 | 	add	local09, #20
00ec4     F4 00 02 FB | 	rdlong	local21, local09
00ec8     2C E2 05 F1 | 	add	local06, #44
00ecc     F1 00 62 FC | 	wrlong	local21, local06
00ed0     2C E2 85 F1 | 	sub	local06, #44
00ed4     1C 00 90 FD | 	jmp	#LR__0070
00ed8                 | LR__0069
00ed8     01 E4 05 F6 | 	mov	local07, #1
00edc     C8 C2 01 F6 | 	mov	arg01, objptr
00ee0     00 C8 00 FF 
00ee4     00 C2 45 F5 | 	or	arg01, ##26214400
00ee8     2C E2 05 F1 | 	add	local06, #44
00eec     F1 C2 61 FC | 	wrlong	arg01, local06
00ef0     2C E2 85 F1 | 	sub	local06, #44
00ef4                 | LR__0070
00ef4                 | LR__0071
00ef4                 | LR__0072
00ef4     00 E4 0D F2 | 	cmp	local07, #0 wz
00ef8     F1 C2 01 56 |  if_ne	mov	arg01, local06
00efc     90 04 B0 5D |  if_ne	call	#_libc_a___default_buffer_init
00f00     00 FC 0D F2 | 	cmp	local19, #0 wz
00f04     00 C2 05 A6 |  if_e	mov	arg01, #0
00f08     10 00 90 5D |  if_ne	jmp	#LR__0073
00f0c     00 C2 4D F2 | 	cmps	arg01, #0 wz
00f10     20 92 05 F1 | 	add	ptr___system__dat__, #32
00f14     C9 C2 61 FC | 	wrlong	arg01, ptr___system__dat__
00f18     20 92 85 F1 | 	sub	ptr___system__dat__, #32
00f1c                 | LR__0073
00f1c                 | '     return r;
00f1c     FE A6 01 F6 | 	mov	result1, local19
00f20                 | LR__0074
00f20     A7 F0 03 F6 | 	mov	ptra, fp
00f24     B2 00 A0 FD | 	call	#popregs_
00f28                 | _libc_a__openraw_ret
00f28     2D 00 64 FD | 	ret
00f2c                 | 
00f2c                 | _libc_a__closeraw
00f2c     05 4A 05 F6 | 	mov	COUNT_, #5
00f30     A8 00 A0 FD | 	call	#pushregs_
00f34     E1 D8 01 F6 | 	mov	local01, arg01
00f38     00 DA 05 F6 | 	mov	local02, #0
00f3c     08 D8 05 F1 | 	add	local01, #8
00f40     EC A6 09 FB | 	rdlong	result1, local01 wz
00f44     08 D8 85 F1 | 	sub	local01, #8
00f48                 | '         return _seterror( 5 );
00f48     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
00f4c     C9 0A 68 AC |  if_e	wrlong	#5, ptr___system__dat__
00f50     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
00f54     01 A6 65 A6 |  if_e	neg	result1, #1
00f58     A8 00 90 AD |  if_e	jmp	#LR__0082
00f5c     2C D8 05 F1 | 	add	local01, #44
00f60     EC A6 09 FB | 	rdlong	result1, local01 wz
00f64     2C D8 85 F1 | 	sub	local01, #44
00f68     38 00 90 AD |  if_e	jmp	#LR__0080
00f6c     2C D8 05 F1 | 	add	local01, #44
00f70     EC DC 01 FB | 	rdlong	local03, local01
00f74     EE DE 01 F6 | 	mov	local04, local03
00f78     2C D8 85 F1 | 	sub	local01, #44
00f7c     13 DE 45 F7 | 	zerox	local04, #19
00f80     14 DC 45 F0 | 	shr	local03, #20
00f84     02 DC 65 F0 | 	shl	local03, #2
00f88     C5 DC 01 F1 | 	add	local03, __methods__
00f8c     EE DC 01 FB | 	rdlong	local03, local03
00f90     EC C2 01 F6 | 	mov	arg01, local01
00f94     C8 E0 01 F6 | 	mov	local05, objptr
00f98     EF 90 01 F6 | 	mov	objptr, local04
00f9c     2D DC 61 FD | 	call	local03
00fa0     F0 90 01 F6 | 	mov	objptr, local05
00fa4                 | LR__0080
00fa4     24 D8 05 F1 | 	add	local01, #36
00fa8     EC E0 09 FB | 	rdlong	local05, local01 wz
00fac     24 D8 85 F1 | 	sub	local01, #36
00fb0     3C 00 90 AD |  if_e	jmp	#LR__0081
00fb4     24 D8 05 F1 | 	add	local01, #36
00fb8     EC DC 01 FB | 	rdlong	local03, local01
00fbc     EE DE 01 F6 | 	mov	local04, local03
00fc0     24 D8 85 F1 | 	sub	local01, #36
00fc4     13 DE 45 F7 | 	zerox	local04, #19
00fc8     14 DC 45 F0 | 	shr	local03, #20
00fcc     02 DC 65 F0 | 	shl	local03, #2
00fd0     C5 DC 01 F1 | 	add	local03, __methods__
00fd4     EE DC 01 FB | 	rdlong	local03, local03
00fd8     EC C2 01 F6 | 	mov	arg01, local01
00fdc     C8 E0 01 F6 | 	mov	local05, objptr
00fe0     EF 90 01 F6 | 	mov	objptr, local04
00fe4     2D DC 61 FD | 	call	local03
00fe8     F0 90 01 F6 | 	mov	objptr, local05
00fec     D3 DA 01 F6 | 	mov	local02, result1
00ff0                 | LR__0081
00ff0     EC C2 01 F6 | 	mov	arg01, local01
00ff4     00 C4 05 F6 | 	mov	arg02, #0
00ff8     34 C6 05 F6 | 	mov	arg03, #52
00ffc     98 00 A0 FD | 	call	#\builtin_bytefill_
01000                 | '     return r;
01000     ED A6 01 F6 | 	mov	result1, local02
01004                 | LR__0082
01004     A7 F0 03 F6 | 	mov	ptra, fp
01008     B2 00 A0 FD | 	call	#popregs_
0100c                 | _libc_a__closeraw_ret
0100c     2D 00 64 FD | 	ret
01010                 | 
01010                 | _libc_a_lseek
01010     06 4A 05 F6 | 	mov	COUNT_, #6
01014     A8 00 A0 FD | 	call	#pushregs_
01018     0A C2 15 F2 | 	cmp	arg01, #10 wc
0101c                 | '         return _seterror( 5 );
0101c     20 92 05 31 |  if_ae	add	ptr___system__dat__, #32
01020     C9 0A 68 3C |  if_ae	wrlong	#5, ptr___system__dat__
01024     20 92 85 31 |  if_ae	sub	ptr___system__dat__, #32
01028     01 A6 65 36 |  if_ae	neg	result1, #1
0102c     BC 00 90 3D |  if_ae	jmp	#LR__0091
01030     34 C2 05 FD | 	qmul	arg01, #52
01034     CD C2 01 F6 | 	mov	arg01, ptr__libc_a_dat__
01038     04 C2 05 F1 | 	add	arg01, #4
0103c                 | '         return _seterror( 16 );
0103c     18 D8 61 FD | 	getqx	local01
01040     E1 D8 01 F1 | 	add	local01, arg01
01044     30 D8 05 F1 | 	add	local01, #48
01048     EC C2 09 FB | 	rdlong	arg01, local01 wz
0104c     30 D8 85 F1 | 	sub	local01, #48
01050     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
01054     C9 20 68 AC |  if_e	wrlong	#16, ptr___system__dat__
01058     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
0105c     01 A6 65 A6 |  if_e	neg	result1, #1
01060     88 00 90 AD |  if_e	jmp	#LR__0091
01064     08 D8 05 F1 | 	add	local01, #8
01068     EC DA 01 FB | 	rdlong	local02, local01
0106c     08 D8 85 F1 | 	sub	local01, #8
01070     40 DA CD F7 | 	test	local02, #64 wz
01074     08 D8 05 51 |  if_ne	add	local01, #8
01078     EC DA 01 5B |  if_ne	rdlong	local02, local01
0107c     80 DA 45 55 |  if_ne	or	local02, #128
01080     EC DA 61 5C |  if_ne	wrlong	local02, local01
01084     08 D8 85 51 |  if_ne	sub	local01, #8
01088     30 D8 05 F1 | 	add	local01, #48
0108c     EC DC 01 FB | 	rdlong	local03, local01
01090     EE DE 01 F6 | 	mov	local04, local03
01094     30 D8 85 F1 | 	sub	local01, #48
01098     13 DE 45 F7 | 	zerox	local04, #19
0109c     14 DC 45 F0 | 	shr	local03, #20
010a0     02 DC 65 F0 | 	shl	local03, #2
010a4     C5 DC 01 F1 | 	add	local03, __methods__
010a8     EE DC 01 FB | 	rdlong	local03, local03
010ac     EC C2 01 F6 | 	mov	arg01, local01
010b0     C8 E0 01 F6 | 	mov	local05, objptr
010b4     EF 90 01 F6 | 	mov	objptr, local04
010b8     2D DC 61 FD | 	call	local03
010bc     F0 90 01 F6 | 	mov	objptr, local05
010c0     D3 E2 01 F6 | 	mov	local06, result1
010c4     00 E2 55 F2 | 	cmps	local06, #0 wc
010c8     1C 00 90 3D |  if_ae	jmp	#LR__0090
010cc                 | '         return _seterror(-r);
010cc     F1 C2 69 F6 | 	neg	arg01, local06 wz
010d0     20 92 05 F1 | 	add	ptr___system__dat__, #32
010d4     C9 C2 61 FC | 	wrlong	arg01, ptr___system__dat__
010d8     20 92 85 F1 | 	sub	ptr___system__dat__, #32
010dc     01 A6 65 56 |  if_ne	neg	result1, #1
010e0     00 A6 05 A6 |  if_e	mov	result1, #0
010e4     04 00 90 FD | 	jmp	#LR__0091
010e8                 | LR__0090
010e8                 | '     }
010e8                 | '     return r;
010e8     F1 A6 01 F6 | 	mov	result1, local06
010ec                 | LR__0091
010ec     A7 F0 03 F6 | 	mov	ptra, fp
010f0     B2 00 A0 FD | 	call	#popregs_
010f4                 | _libc_a_lseek_ret
010f4     2D 00 64 FD | 	ret
010f8                 | 
010f8                 | _libc_a___default_getc
010f8     03 4A 05 F6 | 	mov	COUNT_, #3
010fc     A8 00 A0 FD | 	call	#pushregs_
01100     E1 D8 01 F6 | 	mov	local01, arg01
01104     EC DA 01 FB | 	rdlong	local02, local01
01108     08 DA 05 F1 | 	add	local02, #8
0110c     ED DC 01 FB | 	rdlong	local03, local02
01110     02 DC CD F7 | 	test	local03, #2 wz
01114     EC C2 01 56 |  if_ne	mov	arg01, local01
01118     00 01 B0 5D |  if_ne	call	#_libc_a___default_flush
0111c     ED DC 01 FB | 	rdlong	local03, local02
01120     01 DC 45 F5 | 	or	local03, #1
01124     ED DC 61 FC | 	wrlong	local03, local02
01128     08 DA 85 F1 | 	sub	local02, #8
0112c     ED DC 09 FB | 	rdlong	local03, local02 wz
01130     0C 00 90 5D |  if_ne	jmp	#LR__0100
01134     EC C2 01 F6 | 	mov	arg01, local01
01138     70 0A B0 FD | 	call	#_libc_a___default_filbuf
0113c     D3 DC 01 F6 | 	mov	local03, result1
01140                 | LR__0100
01140     01 DC 55 F2 | 	cmps	local03, #1 wc
01144                 | '         return -1;
01144     01 A6 65 C6 |  if_b	neg	result1, #1
01148     1C 00 90 CD |  if_b	jmp	#LR__0101
0114c     01 DC 85 F1 | 	sub	local03, #1
01150     ED DC 61 FC | 	wrlong	local03, local02
01154     04 DA 05 F1 | 	add	local02, #4
01158     ED DC 01 FB | 	rdlong	local03, local02
0115c     EE A6 C1 FA | 	rdbyte	result1, local03
01160     01 DC 05 F1 | 	add	local03, #1
01164     ED DC 61 FC | 	wrlong	local03, local02
01168                 | '     }
01168                 | '     b->cnt = i-1;
01168                 | '     ptr = b->ptr;
01168                 | '     i = *ptr++;
01168                 | '     b->ptr = ptr;
01168                 | '     return i;
01168                 | LR__0101
01168     A7 F0 03 F6 | 	mov	ptra, fp
0116c     B2 00 A0 FD | 	call	#popregs_
01170                 | _libc_a___default_getc_ret
01170     2D 00 64 FD | 	ret
01174                 | 
01174                 | _libc_a___default_putc
01174     06 4A 05 F6 | 	mov	COUNT_, #6
01178     A8 00 A0 FD | 	call	#pushregs_
0117c     E1 D8 01 F6 | 	mov	local01, arg01
01180     E2 DA 01 F6 | 	mov	local02, arg02
01184     ED DC 01 FB | 	rdlong	local03, local02
01188     08 DC 05 F1 | 	add	local03, #8
0118c     EE A6 01 FB | 	rdlong	result1, local03
01190     01 A6 CD F7 | 	test	result1, #1 wz
01194     ED C2 01 56 |  if_ne	mov	arg01, local02
01198     80 00 B0 5D |  if_ne	call	#_libc_a___default_flush
0119c     EE DE 01 FB | 	rdlong	local04, local03
011a0     02 DE 45 F5 | 	or	local04, #2
011a4     EE DE 61 FC | 	wrlong	local04, local03
011a8     08 DC 85 F1 | 	sub	local03, #8
011ac     EE E0 01 FB | 	rdlong	local05, local03
011b0     10 DC 05 F1 | 	add	local03, #16
011b4     EE C4 01 FB | 	rdlong	arg02, local03
011b8     10 DC 85 F1 | 	sub	local03, #16
011bc     F0 A6 01 F6 | 	mov	result1, local05
011c0     E2 A6 01 F1 | 	add	result1, arg02
011c4     D3 D8 41 FC | 	wrbyte	local01, result1
011c8     EC D8 E1 F8 | 	getbyte	local01, local01, #0
011cc     01 E0 05 F1 | 	add	local05, #1
011d0     EE E0 61 FC | 	wrlong	local05, local03
011d4     06 DA 05 F1 | 	add	local02, #6
011d8     ED E2 E9 FA | 	rdword	local06, local02 wz
011dc     06 DA 85 F1 | 	sub	local02, #6
011e0     0C DC 05 51 |  if_ne	add	local03, #12
011e4     EE DE 01 5B |  if_ne	rdlong	local04, local03
011e8     EF E0 09 52 |  if_ne	cmp	local05, local04 wz
011ec     0C 00 90 AD |  if_e	jmp	#LR__0110
011f0     0A D8 0D F2 | 	cmp	local01, #10 wz
011f4     01 E2 0D A2 |  if_e	cmp	local06, #1 wz
011f8     10 00 90 5D |  if_ne	jmp	#LR__0111
011fc                 | LR__0110
011fc     ED C2 01 F6 | 	mov	arg01, local02
01200     18 00 B0 FD | 	call	#_libc_a___default_flush
01204     00 A6 0D F2 | 	cmp	result1, #0 wz
01208     01 D8 65 56 |  if_ne	neg	local01, #1
0120c                 | LR__0111
0120c                 | '             c = -1;
0120c                 | '         }
0120c                 | '     }
0120c                 | '     return c;
0120c     EC A6 01 F6 | 	mov	result1, local01
01210     A7 F0 03 F6 | 	mov	ptra, fp
01214     B2 00 A0 FD | 	call	#popregs_
01218                 | _libc_a___default_putc_ret
01218     2D 00 64 FD | 	ret
0121c                 | 
0121c                 | _libc_a___default_flush
0121c     06 4A 05 F6 | 	mov	COUNT_, #6
01220     A8 00 A0 FD | 	call	#pushregs_
01224     E1 D8 01 F6 | 	mov	local01, arg01
01228     EC DA 01 FB | 	rdlong	local02, local01
0122c     ED DC 01 FB | 	rdlong	local03, local02
01230     08 DA 05 F1 | 	add	local02, #8
01234     ED A6 01 FB | 	rdlong	result1, local02
01238     08 DA 85 F1 | 	sub	local02, #8
0123c     02 A6 CD F7 | 	test	result1, #2 wz
01240     D0 00 90 AD |  if_e	jmp	#LR__0122
01244     01 DC 55 F2 | 	cmps	local03, #1 wc
01248     20 01 90 CD |  if_b	jmp	#LR__0124
0124c     08 D8 05 F1 | 	add	local01, #8
01250     EC A6 01 FB | 	rdlong	result1, local01
01254     08 D8 85 F1 | 	sub	local01, #8
01258     40 A6 CD F7 | 	test	result1, #64 wz
0125c     68 00 90 AD |  if_e	jmp	#LR__0121
01260     08 D8 05 F1 | 	add	local01, #8
01264     EC C6 01 FB | 	rdlong	arg03, local01
01268     08 D8 85 F1 | 	sub	local01, #8
0126c     80 C6 CD F7 | 	test	arg03, #128 wz
01270     54 00 90 AD |  if_e	jmp	#LR__0120
01274     30 D8 05 F1 | 	add	local01, #48
01278     EC DE 01 FB | 	rdlong	local04, local01
0127c     EF E0 01 F6 | 	mov	local05, local04
01280     30 D8 85 F1 | 	sub	local01, #48
01284     13 E0 45 F7 | 	zerox	local05, #19
01288     14 DE 45 F0 | 	shr	local04, #20
0128c     02 DE 65 F0 | 	shl	local04, #2
01290     C5 DE 01 F1 | 	add	local04, __methods__
01294     EF DE 01 FB | 	rdlong	local04, local04
01298     EC C2 01 F6 | 	mov	arg01, local01
0129c     00 C4 05 F6 | 	mov	arg02, #0
012a0     02 C6 05 F6 | 	mov	arg03, #2
012a4     C8 E2 01 F6 | 	mov	local06, objptr
012a8     F0 90 01 F6 | 	mov	objptr, local05
012ac     2D DE 61 FD | 	call	local04
012b0     F1 90 01 F6 | 	mov	objptr, local06
012b4     08 D8 05 F1 | 	add	local01, #8
012b8     EC E2 01 FB | 	rdlong	local06, local01
012bc     80 E2 25 F5 | 	andn	local06, #128
012c0     EC E2 61 FC | 	wrlong	local06, local01
012c4     08 D8 85 F1 | 	sub	local01, #8
012c8                 | LR__0120
012c8                 | LR__0121
012c8     18 D8 05 F1 | 	add	local01, #24
012cc     EC DE 01 FB | 	rdlong	local04, local01
012d0     EF E0 01 F6 | 	mov	local05, local04
012d4     18 D8 85 F1 | 	sub	local01, #24
012d8     13 E0 45 F7 | 	zerox	local05, #19
012dc     14 DE 45 F0 | 	shr	local04, #20
012e0     02 DE 65 F0 | 	shl	local04, #2
012e4     C5 DE 01 F1 | 	add	local04, __methods__
012e8     EF DE 01 FB | 	rdlong	local04, local04
012ec     10 DA 05 F1 | 	add	local02, #16
012f0     ED C4 01 FB | 	rdlong	arg02, local02
012f4     10 DA 85 F1 | 	sub	local02, #16
012f8     EC C2 01 F6 | 	mov	arg01, local01
012fc     EE C6 01 F6 | 	mov	arg03, local03
01300     C8 E2 01 F6 | 	mov	local06, objptr
01304     F0 90 01 F6 | 	mov	objptr, local05
01308     2D DE 61 FD | 	call	local04
0130c     F1 90 01 F6 | 	mov	objptr, local06
01310     58 00 90 FD | 	jmp	#LR__0124
01314                 | LR__0122
01314     08 DA 05 F1 | 	add	local02, #8
01318     ED E2 01 FB | 	rdlong	local06, local02
0131c     08 DA 85 F1 | 	sub	local02, #8
01320     01 E2 CD F7 | 	test	local06, #1 wz
01324     00 DC 0D 52 |  if_ne	cmp	local03, #0 wz
01328     40 00 90 AD |  if_e	jmp	#LR__0123
0132c     30 D8 05 F1 | 	add	local01, #48
01330     EC DE 01 FB | 	rdlong	local04, local01
01334     EF E0 01 F6 | 	mov	local05, local04
01338     30 D8 85 F1 | 	sub	local01, #48
0133c     13 E0 45 F7 | 	zerox	local05, #19
01340     14 DE 45 F0 | 	shr	local04, #20
01344     02 DE 65 F0 | 	shl	local04, #2
01348     C5 DE 01 F1 | 	add	local04, __methods__
0134c     EF DE 01 FB | 	rdlong	local04, local04
01350     EC C2 01 F6 | 	mov	arg01, local01
01354     EE C4 61 F6 | 	neg	arg02, local03
01358     01 C6 05 F6 | 	mov	arg03, #1
0135c     C8 E2 01 F6 | 	mov	local06, objptr
01360     F0 90 01 F6 | 	mov	objptr, local05
01364     2D DE 61 FD | 	call	local04
01368     F1 90 01 F6 | 	mov	objptr, local06
0136c                 | LR__0123
0136c                 | LR__0124
0136c     ED 00 68 FC | 	wrlong	#0, local02
01370     04 DA 05 F1 | 	add	local02, #4
01374     ED 00 68 FC | 	wrlong	#0, local02
01378     04 DA 05 F1 | 	add	local02, #4
0137c     ED 00 68 FC | 	wrlong	#0, local02
01380                 | '     }
01380                 | '     b->cnt = 0;
01380                 | '     b->ptr = 0;
01380                 | '     b->flags = 0;
01380                 | '     return 0;
01380     00 A6 05 F6 | 	mov	result1, #0
01384     A7 F0 03 F6 | 	mov	ptra, fp
01388     B2 00 A0 FD | 	call	#popregs_
0138c                 | _libc_a___default_flush_ret
0138c     2D 00 64 FD | 	ret
01390                 | 
01390                 | _libc_a___default_buffer_init
01390     02 4A 05 F6 | 	mov	COUNT_, #2
01394     A8 00 A0 FD | 	call	#pushregs_
01398     E1 D8 01 F6 | 	mov	local01, arg01
0139c     EC DA 01 FB | 	rdlong	local02, local01
013a0     EC C2 01 F6 | 	mov	arg01, local01
013a4     C8 00 B0 FD | 	call	#_libc_a__isatty
013a8     00 A6 0D F2 | 	cmp	result1, #0 wz
013ac     06 D8 05 51 |  if_ne	add	local01, #6
013b0     EC 0A 58 5C |  if_ne	wrword	#5, local01
013b4     06 D8 05 A1 |  if_e	add	local01, #6
013b8     EC 0C 58 AC |  if_e	wrword	#6, local01
013bc     14 DA 05 F1 | 	add	local02, #20
013c0     ED D8 01 F6 | 	mov	local01, local02
013c4     04 DA 85 F1 | 	sub	local02, #4
013c8     ED D8 61 FC | 	wrlong	local01, local02
013cc     04 DA 85 F1 | 	sub	local02, #4
013d0     02 00 80 FF 
013d4     ED 00 68 FC | 	wrlong	##1024, local02
013d8                 | '         f->bufmode =  (0x2)  |  (0x4) ;
013d8                 | '     }
013d8                 | '     b->bufptr = &b->bufdata[0];
013d8                 | '     b->bufsiz =  1024 ;
013d8                 | '     return 0;
013d8     00 A6 05 F6 | 	mov	result1, #0
013dc     A7 F0 03 F6 | 	mov	ptra, fp
013e0     B2 00 A0 FD | 	call	#popregs_
013e4                 | _libc_a___default_buffer_init_ret
013e4     2D 00 64 FD | 	ret
013e8                 | 
013e8                 | _libc_a__ioctl
013e8     03 4A 05 F6 | 	mov	COUNT_, #3
013ec     A8 00 A0 FD | 	call	#pushregs_
013f0     00 C2 4D F2 | 	cmps	arg01, #0 wz
013f4                 | '         return _seterror( 5 );
013f4     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
013f8     C9 0A 68 AC |  if_e	wrlong	#5, ptr___system__dat__
013fc     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
01400     01 A6 65 A6 |  if_e	neg	result1, #1
01404     5C 00 90 AD |  if_e	jmp	#LR__0131
01408     28 C2 05 F1 | 	add	arg01, #40
0140c     E1 D8 01 FB | 	rdlong	local01, arg01
01410     EC DA 01 F6 | 	mov	local02, local01
01414     28 C2 85 F1 | 	sub	arg01, #40
01418     13 DA 45 F7 | 	zerox	local02, #19
0141c     14 D8 45 F0 | 	shr	local01, #20
01420     02 D8 65 F0 | 	shl	local01, #2
01424     C5 D8 01 F1 | 	add	local01, __methods__
01428     EC D8 01 FB | 	rdlong	local01, local01
0142c     C8 DC 01 F6 | 	mov	local03, objptr
01430     ED 90 01 F6 | 	mov	objptr, local02
01434     2D D8 61 FD | 	call	local01
01438     EE 90 01 F6 | 	mov	objptr, local03
0143c     D3 C2 09 F6 | 	mov	arg01, result1 wz
01440     1C 00 90 AD |  if_e	jmp	#LR__0130
01444                 | '         return _seterror(r);
01444     00 C2 4D F2 | 	cmps	arg01, #0 wz
01448     20 92 05 F1 | 	add	ptr___system__dat__, #32
0144c     C9 C2 61 FC | 	wrlong	arg01, ptr___system__dat__
01450     20 92 85 F1 | 	sub	ptr___system__dat__, #32
01454     01 A6 65 56 |  if_ne	neg	result1, #1
01458     00 A6 05 A6 |  if_e	mov	result1, #0
0145c     04 00 90 FD | 	jmp	#LR__0131
01460                 | LR__0130
01460                 | '     }
01460                 | '     return 0;
01460     00 A6 05 F6 | 	mov	result1, #0
01464                 | LR__0131
01464     A7 F0 03 F6 | 	mov	ptra, fp
01468     B2 00 A0 FD | 	call	#popregs_
0146c                 | _libc_a__ioctl_ret
0146c     2D 00 64 FD | 	ret
01470                 | 
01470                 | _libc_a__isatty
01470     00 4A 05 F6 | 	mov	COUNT_, #0
01474     A8 00 A0 FD | 	call	#pushregs_
01478     0C F0 07 F1 | 	add	ptra, #12
0147c     04 4E 05 F1 | 	add	fp, #4
01480     A7 C2 61 FC | 	wrlong	arg01, fp
01484     04 4E 05 F1 | 	add	fp, #4
01488     A7 C6 01 F6 | 	mov	arg03, fp
0148c     08 4E 85 F1 | 	sub	fp, #8
01490     00 C5 05 F6 | 	mov	arg02, #256
01494     50 FF BF FD | 	call	#_libc_a__ioctl
01498     00 A6 0D F2 | 	cmp	result1, #0 wz
0149c                 | '         return 1;
0149c     01 A6 05 A6 |  if_e	mov	result1, #1
014a0                 | '     }
014a0                 | '     return 0;
014a0     00 A6 05 56 |  if_ne	mov	result1, #0
014a4     A7 F0 03 F6 | 	mov	ptra, fp
014a8     B2 00 A0 FD | 	call	#popregs_
014ac                 | _libc_a__isatty_ret
014ac     2D 00 64 FD | 	ret
014b0                 | 
014b0                 | _libc_a___getftab
014b0     0A C2 15 F2 | 	cmp	arg01, #10 wc
014b4     34 C2 05 CD |  if_b	qmul	arg01, #52
014b8                 | '         return 0;
014b8     00 A6 05 36 |  if_ae	mov	result1, #0
014bc                 | '     }
014bc                 | '     return &__filetab[i];
014bc     CD C2 01 C6 |  if_b	mov	arg01, ptr__libc_a_dat__
014c0     04 C2 05 C1 |  if_b	add	arg01, #4
014c4     18 A6 61 CD |  if_b	getqx	result1
014c8     E1 A6 01 C1 |  if_b	add	result1, arg01
014cc                 | _libc_a___getftab_ret
014cc     2D 00 64 FD | 	ret
014d0                 | 
014d0                 | _libc_a__fopenraw
014d0     0D 4A 05 F6 | 	mov	COUNT_, #13
014d4     A8 00 A0 FD | 	call	#pushregs_
014d8     E1 D8 01 F6 | 	mov	local01, arg01
014dc     E2 DA 01 F6 | 	mov	local02, arg02
014e0     E3 DC 01 F6 | 	mov	local03, arg03
014e4     00 DE 05 F6 | 	mov	local04, #0
014e8     00 E0 05 F6 | 	mov	local05, #0
014ec     00 E2 05 F6 | 	mov	local06, #0
014f0     00 E4 05 F6 | 	mov	local07, #0
014f4     00 E6 05 F6 | 	mov	local08, #0
014f8     00 E8 05 F6 | 	mov	local09, #0
014fc                 | ' 
014fc                 | '     while ((c = *mode++) != 0) {
014fc                 | LR__0140
014fc     ED EA C1 FA | 	rdbyte	local10, local02
01500     F5 EC 09 F6 | 	mov	local11, local10 wz
01504     01 DA 05 F1 | 	add	local02, #1
01508     A0 00 90 AD |  if_e	jmp	#LR__0147
0150c                 | '         switch (c) {
0150c     F6 EE 01 F6 | 	mov	local12, local11
01510     72 EE 0D F2 | 	cmp	local12, #114 wz
01514     24 00 90 AD |  if_e	jmp	#LR__0141
01518     77 EE 0D F2 | 	cmp	local12, #119 wz
0151c     24 00 90 AD |  if_e	jmp	#LR__0142
01520     61 EE 0D F2 | 	cmp	local12, #97 wz
01524     2C 00 90 AD |  if_e	jmp	#LR__0143
01528     62 EE 0D F2 | 	cmp	local12, #98 wz
0152c     34 00 90 AD |  if_e	jmp	#LR__0144
01530     2B EE 0D F2 | 	cmp	local12, #43 wz
01534     34 00 90 AD |  if_e	jmp	#LR__0145
01538     5C 00 90 FD | 	jmp	#LR__0146
0153c                 | LR__0141
0153c     01 DE 05 F6 | 	mov	local04, #1
01540                 | '             want_read = 1;
01540                 | '             break;
01540     B8 FF 9F FD | 	jmp	#LR__0140
01544                 | LR__0142
01544     01 E6 05 F6 | 	mov	local08, #1
01548     01 E8 05 F6 | 	mov	local09, #1
0154c     01 E0 05 F6 | 	mov	local05, #1
01550                 | '             want_create = 1;
01550                 | '             want_trunc = 1;
01550                 | '             want_write = 1;
01550                 | '             break;
01550     A8 FF 9F FD | 	jmp	#LR__0140
01554                 | LR__0143
01554     01 E0 05 F6 | 	mov	local05, #1
01558     01 E6 05 F6 | 	mov	local08, #1
0155c     01 E2 05 F6 | 	mov	local06, #1
01560                 | '             want_write = 1;
01560                 | '             want_create = 1;
01560                 | '             want_append = 1;
01560                 | '             break;
01560     98 FF 9F FD | 	jmp	#LR__0140
01564                 | LR__0144
01564     01 E4 05 F6 | 	mov	local07, #1
01568                 | '             want_binary = 1;
01568                 | '             break;
01568     90 FF 9F FD | 	jmp	#LR__0140
0156c                 | LR__0145
0156c     00 DE 0D F2 | 	cmp	local04, #0 wz
01570     01 E0 05 56 |  if_ne	mov	local05, #1
01574     84 FF 9F 5D |  if_ne	jmp	#LR__0140
01578     00 E0 0D F2 | 	cmp	local05, #0 wz
0157c     01 DE 05 56 |  if_ne	mov	local04, #1
01580                 | '                 want_read = 1;
01580                 | '                 break;
01580     78 FF 9F 5D |  if_ne	jmp	#LR__0140
01584     20 92 05 F1 | 	add	ptr___system__dat__, #32
01588     C9 14 68 FC | 	wrlong	#10, ptr___system__dat__
0158c     20 92 85 F1 | 	sub	ptr___system__dat__, #32
01590                 | '                 _seterror( 10 );
01590                 | '                 return 0;
01590     00 A6 05 F6 | 	mov	result1, #0
01594     A8 00 90 FD | 	jmp	#LR__0150
01598                 | '             }
01598                 | '             break;
01598                 | LR__0146
01598     20 92 05 F1 | 	add	ptr___system__dat__, #32
0159c     C9 14 68 FC | 	wrlong	#10, ptr___system__dat__
015a0     20 92 85 F1 | 	sub	ptr___system__dat__, #32
015a4                 | '             _seterror( 10 );
015a4                 | '             return 0;
015a4     00 A6 05 F6 | 	mov	result1, #0
015a8     94 00 90 FD | 	jmp	#LR__0150
015ac                 | LR__0147
015ac     00 DE 0D F2 | 	cmp	local04, #0 wz
015b0     14 00 90 AD |  if_e	jmp	#LR__0148
015b4     00 E0 0D F2 | 	cmp	local05, #0 wz
015b8     02 F0 05 56 |  if_ne	mov	local13, #2
015bc     24 00 90 5D |  if_ne	jmp	#LR__0149
015c0     00 F0 05 F6 | 	mov	local13, #0
015c4     1C 00 90 FD | 	jmp	#LR__0149
015c8                 | LR__0148
015c8     00 E0 0D F2 | 	cmp	local05, #0 wz
015cc     01 F0 05 56 |  if_ne	mov	local13, #1
015d0     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
015d4     C9 14 68 AC |  if_e	wrlong	#10, ptr___system__dat__
015d8     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
015dc                 | '         _seterror( 10 );
015dc                 | '         return 0;
015dc     00 A6 05 A6 |  if_e	mov	result1, #0
015e0     5C 00 90 AD |  if_e	jmp	#LR__0150
015e4                 | LR__0149
015e4     00 E2 0D F2 | 	cmp	local06, #0 wz
015e8     20 F0 45 55 |  if_ne	or	local13, #32
015ec     00 E6 0D F2 | 	cmp	local08, #0 wz
015f0     04 F0 45 55 |  if_ne	or	local13, #4
015f4     00 E8 0D F2 | 	cmp	local09, #0 wz
015f8     08 F0 45 55 |  if_ne	or	local13, #8
015fc     EC C4 01 F6 | 	mov	arg02, local01
01600     F8 C6 01 F6 | 	mov	arg03, local13
01604     EE C2 01 F6 | 	mov	arg01, local03
01608     B6 C9 05 F6 | 	mov	arg04, #438
0160c     20 F6 BF FD | 	call	#_libc_a__openraw
01610     00 A6 0D F2 | 	cmp	result1, #0 wz
01614                 | ' #line 80 "C:/Users/ryans/Documents/flexprop/include/libc/stdio/fopen.c"
01614                 | '         return 0;
01614     00 A6 05 56 |  if_ne	mov	result1, #0
01618     24 00 90 5D |  if_ne	jmp	#LR__0150
0161c     EE C2 01 F6 | 	mov	arg01, local03
01620     4C FE BF FD | 	call	#_libc_a__isatty
01624     00 A6 0D F2 | 	cmp	result1, #0 wz
01628     08 DC 05 51 |  if_ne	add	local03, #8
0162c     EE EA 01 5B |  if_ne	rdlong	local10, local03
01630     00 EB 45 55 |  if_ne	or	local10, #256
01634     EE EA 61 5C |  if_ne	wrlong	local10, local03
01638     08 DC 85 51 |  if_ne	sub	local03, #8
0163c                 | '         ftab->state |=  (0x100) ;
0163c                 | '     }
0163c                 | ' #line 88 "C:/Users/ryans/Documents/flexprop/include/libc/stdio/fopen.c"
0163c                 | '     return ftab;
0163c     EE A6 01 F6 | 	mov	result1, local03
01640                 | LR__0150
01640     A7 F0 03 F6 | 	mov	ptra, fp
01644     B2 00 A0 FD | 	call	#popregs_
01648                 | _libc_a__fopenraw_ret
01648     2D 00 64 FD | 	ret
0164c                 | 
0164c                 | _libc_a__rxtxioctl_0726
0164c                 | '     switch (req) {
0164c     00 C5 0D F2 | 	cmp	arg02, #256 wz
01650     0C 00 90 AD |  if_e	jmp	#LR__0160
01654     01 C5 0D F2 | 	cmp	arg02, #257 wz
01658     1C 00 90 AD |  if_e	jmp	#LR__0161
0165c     30 00 90 FD | 	jmp	#LR__0162
01660                 | LR__0160
01660     08 92 05 F1 | 	add	ptr___system__dat__, #8
01664     C9 A6 01 FB | 	rdlong	result1, ptr___system__dat__
01668     08 92 85 F1 | 	sub	ptr___system__dat__, #8
0166c     E3 A6 61 FC | 	wrlong	result1, arg03
01670                 | '         *argl = _getrxtxflags();
01670                 | '         return 0;
01670     00 A6 05 F6 | 	mov	result1, #0
01674     28 00 90 FD | 	jmp	#LR__0163
01678                 | LR__0161
01678     E3 C2 01 FB | 	rdlong	arg01, arg03
0167c     08 92 05 F1 | 	add	ptr___system__dat__, #8
01680     C9 C2 61 FC | 	wrlong	arg01, ptr___system__dat__
01684     08 92 85 F1 | 	sub	ptr___system__dat__, #8
01688                 | '         _setrxtxflags(*argl);
01688                 | '         return 0;
01688     00 A6 05 F6 | 	mov	result1, #0
0168c     10 00 90 FD | 	jmp	#LR__0163
01690                 | LR__0162
01690                 | '         return _seterror( 10 );
01690     20 92 05 F1 | 	add	ptr___system__dat__, #32
01694     C9 14 68 FC | 	wrlong	#10, ptr___system__dat__
01698     20 92 85 F1 | 	sub	ptr___system__dat__, #32
0169c     01 A6 65 F6 | 	neg	result1, #1
016a0                 | LR__0163
016a0                 | _libc_a__rxtxioctl_0726_ret
016a0     2D 00 64 FD | 	ret
016a4                 | 
016a4                 | _libc_a___dummy_flush_0727
016a4                 | ' {
016a4                 | '     return 0;
016a4     00 A6 05 F6 | 	mov	result1, #0
016a8                 | _libc_a___dummy_flush_0727_ret
016a8     2D 00 64 FD | 	ret
016ac                 | 
016ac                 | _libc_a__find_free_file
016ac     CD AA 01 F6 | 	mov	_var01, ptr__libc_a_dat__
016b0     04 AA 05 F1 | 	add	_var01, #4
016b4                 | ' 
016b4                 | '     for (fd = 0; fd <  10 ; fd++) {
016b4     00 AC 05 F6 | 	mov	_var02, #0
016b8     97 12 48 FB | 	callpa	#(@LR__0171-@LR__0170)>>2,fcache_load_ptr_
016bc                 | LR__0170
016bc     0A AC 55 F2 | 	cmps	_var02, #10 wc
016c0     1C 00 90 3D |  if_ae	jmp	#LR__0172
016c4     34 AC 05 FD | 	qmul	_var02, #52
016c8     18 A6 61 FD | 	getqx	result1
016cc     D5 A6 01 F1 | 	add	result1, _var01
016d0     08 A6 05 F1 | 	add	result1, #8
016d4     D3 A6 09 FB | 	rdlong	result1, result1 wz
016d8     01 AC 05 51 |  if_ne	add	_var02, #1
016dc     DC FF 9F 5D |  if_ne	jmp	#LR__0170
016e0                 | LR__0171
016e0                 | LR__0172
016e0     0A AC 0D F2 | 	cmp	_var02, #10 wz
016e4                 | '         return _seterror( 11 );
016e4     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
016e8     C9 16 68 AC |  if_e	wrlong	#11, ptr___system__dat__
016ec     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
016f0     01 A6 65 A6 |  if_e	neg	result1, #1
016f4                 | '     }
016f4                 | '     return fd;
016f4     D6 A6 01 56 |  if_ne	mov	result1, _var02
016f8                 | _libc_a__find_free_file_ret
016f8     2D 00 64 FD | 	ret
016fc                 | 
016fc                 | _libc_a__vfswrite
016fc     09 4A 05 F6 | 	mov	COUNT_, #9
01700     A8 00 A0 FD | 	call	#pushregs_
01704     E1 D8 01 F6 | 	mov	local01, arg01
01708     E2 DA 01 F6 | 	mov	local02, arg02
0170c     E3 DC 01 F6 | 	mov	local03, arg03
01710     ED DE 01 F6 | 	mov	local04, local02
01714     08 D8 05 F1 | 	add	local01, #8
01718     EC C2 01 FB | 	rdlong	arg01, local01
0171c     08 D8 85 F1 | 	sub	local01, #8
01720     02 C2 CD F7 | 	test	arg01, #2 wz
01724                 | '         return _seterror( 6 );
01724     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
01728     C9 0C 68 AC |  if_e	wrlong	#6, ptr___system__dat__
0172c     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
01730     01 A6 65 A6 |  if_e	neg	result1, #1
01734     80 01 90 AD |  if_e	jmp	#LR__0186
01738     08 D8 05 F1 | 	add	local01, #8
0173c     EC A6 01 FB | 	rdlong	result1, local01
01740     08 D8 85 F1 | 	sub	local01, #8
01744     40 A6 CD F7 | 	test	result1, #64 wz
01748     68 00 90 AD |  if_e	jmp	#LR__0181
0174c     08 D8 05 F1 | 	add	local01, #8
01750     EC C4 01 FB | 	rdlong	arg02, local01
01754     08 D8 85 F1 | 	sub	local01, #8
01758     80 C4 CD F7 | 	test	arg02, #128 wz
0175c     54 00 90 AD |  if_e	jmp	#LR__0180
01760     30 D8 05 F1 | 	add	local01, #48
01764     EC E0 01 FB | 	rdlong	local05, local01
01768     F0 E2 01 F6 | 	mov	local06, local05
0176c     30 D8 85 F1 | 	sub	local01, #48
01770     13 E2 45 F7 | 	zerox	local06, #19
01774     14 E0 45 F0 | 	shr	local05, #20
01778     02 E0 65 F0 | 	shl	local05, #2
0177c     C5 E0 01 F1 | 	add	local05, __methods__
01780     F0 E0 01 FB | 	rdlong	local05, local05
01784     EC C2 01 F6 | 	mov	arg01, local01
01788     00 C4 05 F6 | 	mov	arg02, #0
0178c     02 C6 05 F6 | 	mov	arg03, #2
01790     C8 E4 01 F6 | 	mov	local07, objptr
01794     F1 90 01 F6 | 	mov	objptr, local06
01798     2D E0 61 FD | 	call	local05
0179c     F2 90 01 F6 | 	mov	objptr, local07
017a0     08 D8 05 F1 | 	add	local01, #8
017a4     EC E4 01 FB | 	rdlong	local07, local01
017a8     80 E4 25 F5 | 	andn	local07, #128
017ac     EC E4 61 FC | 	wrlong	local07, local01
017b0     08 D8 85 F1 | 	sub	local01, #8
017b4                 | LR__0180
017b4                 | LR__0181
017b4     18 D8 05 F1 | 	add	local01, #24
017b8     EC E4 09 FB | 	rdlong	local07, local01 wz
017bc     18 D8 85 F1 | 	sub	local01, #24
017c0     80 00 90 AD |  if_e	jmp	#LR__0183
017c4     18 D8 05 F1 | 	add	local01, #24
017c8     EC E0 01 FB | 	rdlong	local05, local01
017cc     F0 E2 01 F6 | 	mov	local06, local05
017d0     18 D8 85 F1 | 	sub	local01, #24
017d4     13 E2 45 F7 | 	zerox	local06, #19
017d8     14 E0 45 F0 | 	shr	local05, #20
017dc     02 E0 65 F0 | 	shl	local05, #2
017e0     C5 E0 01 F1 | 	add	local05, __methods__
017e4     F0 E0 01 FB | 	rdlong	local05, local05
017e8     ED C4 01 F6 | 	mov	arg02, local02
017ec     EE C6 01 F6 | 	mov	arg03, local03
017f0     EC C2 01 F6 | 	mov	arg01, local01
017f4     C8 E4 01 F6 | 	mov	local07, objptr
017f8     F1 90 01 F6 | 	mov	objptr, local06
017fc     2D E0 61 FD | 	call	local05
01800     F2 90 01 F6 | 	mov	objptr, local07
01804     D3 E6 01 F6 | 	mov	local08, result1
01808     00 E6 55 F2 | 	cmps	local08, #0 wc
0180c     2C 00 90 3D |  if_ae	jmp	#LR__0182
01810     08 D8 05 F1 | 	add	local01, #8
01814     EC E4 01 FB | 	rdlong	local07, local01
01818     20 E4 45 F5 | 	or	local07, #32
0181c     EC E4 61 FC | 	wrlong	local07, local01
01820                 | '             f->state |=  (0x20) ;
01820                 | '             return _seterror(r);
01820     00 E6 4D F2 | 	cmps	local08, #0 wz
01824     20 92 05 F1 | 	add	ptr___system__dat__, #32
01828     C9 E6 61 FC | 	wrlong	local08, ptr___system__dat__
0182c     20 92 85 F1 | 	sub	ptr___system__dat__, #32
01830     01 A6 65 56 |  if_ne	neg	result1, #1
01834     00 A6 05 A6 |  if_e	mov	result1, #0
01838     7C 00 90 FD | 	jmp	#LR__0186
0183c                 | LR__0182
0183c                 | '         }
0183c                 | '         return r;
0183c     F3 A6 01 F6 | 	mov	result1, local08
01840     74 00 90 FD | 	jmp	#LR__0186
01844                 | LR__0183
01844     1C D8 05 F1 | 	add	local01, #28
01848     EC E8 09 FB | 	rdlong	local09, local01 wz
0184c     1C D8 85 F1 | 	sub	local01, #28
01850                 | '         return _seterror( 6 );
01850     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
01854     C9 0C 68 AC |  if_e	wrlong	#6, ptr___system__dat__
01858     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
0185c     01 A6 65 A6 |  if_e	neg	result1, #1
01860     54 00 90 AD |  if_e	jmp	#LR__0186
01864     00 E6 05 F6 | 	mov	local08, #0
01868                 | '     }
01868                 | '     r = 0;
01868                 | '     while (count > 0) {
01868                 | LR__0184
01868     01 DC 15 F2 | 	cmp	local03, #1 wc
0186c     44 00 90 CD |  if_b	jmp	#LR__0185
01870     F4 E0 01 F6 | 	mov	local05, local09
01874     F4 E4 01 F6 | 	mov	local07, local09
01878     13 E0 45 F7 | 	zerox	local05, #19
0187c     14 E4 45 F0 | 	shr	local07, #20
01880     02 E4 65 F0 | 	shl	local07, #2
01884     C5 E4 01 F1 | 	add	local07, __methods__
01888     F2 E4 01 FB | 	rdlong	local07, local07
0188c     EF C2 C1 FA | 	rdbyte	arg01, local04
01890     EC C4 01 F6 | 	mov	arg02, local01
01894     C8 E2 01 F6 | 	mov	local06, objptr
01898     F0 90 01 F6 | 	mov	objptr, local05
0189c     01 DE 05 F1 | 	add	local04, #1
018a0     2D E4 61 FD | 	call	local07
018a4     F1 90 01 F6 | 	mov	objptr, local06
018a8     D3 E6 01 F1 | 	add	local08, result1
018ac     01 DC 85 F1 | 	sub	local03, #1
018b0     B4 FF 9F FD | 	jmp	#LR__0184
018b4                 | LR__0185
018b4                 | '         r += (*tx)(*buf++, f);
018b4                 | '         --count;
018b4                 | '     }
018b4                 | '     return r;
018b4     F3 A6 01 F6 | 	mov	result1, local08
018b8                 | LR__0186
018b8     A7 F0 03 F6 | 	mov	ptra, fp
018bc     B2 00 A0 FD | 	call	#popregs_
018c0                 | _libc_a__vfswrite_ret
018c0     2D 00 64 FD | 	ret
018c4                 | 
018c4                 | _libc_a__vfsread
018c4     03 4A 05 F6 | 	mov	COUNT_, #3
018c8     A8 00 A0 FD | 	call	#pushregs_
018cc     28 F0 07 F1 | 	add	ptra, #40
018d0     04 4E 05 F1 | 	add	fp, #4
018d4     A7 C2 61 FC | 	wrlong	arg01, fp
018d8     04 4E 05 F1 | 	add	fp, #4
018dc     A7 C4 61 FC | 	wrlong	arg02, fp
018e0     04 4E 05 F1 | 	add	fp, #4
018e4     A7 C6 61 FC | 	wrlong	arg03, fp
018e8     04 4E 85 F1 | 	sub	fp, #4
018ec     A7 A6 01 FB | 	rdlong	result1, fp
018f0     14 4E 05 F1 | 	add	fp, #20
018f4     A7 A6 61 FC | 	wrlong	result1, fp
018f8     04 4E 05 F1 | 	add	fp, #4
018fc     A7 00 68 FC | 	wrlong	#0, fp
01900     1C 4E 85 F1 | 	sub	fp, #28
01904     A7 C2 01 FB | 	rdlong	arg01, fp
01908     04 4E 85 F1 | 	sub	fp, #4
0190c     08 C2 05 F1 | 	add	arg01, #8
01910     E1 A6 01 FB | 	rdlong	result1, arg01
01914     01 A6 CD F7 | 	test	result1, #1 wz
01918                 | ' #line 334 "C:/Users/ryans/Documents/flexprop/include/libc/unix/posixio.c"
01918                 | '         return _seterror( 6 );
01918     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
0191c     C9 0C 68 AC |  if_e	wrlong	#6, ptr___system__dat__
01920     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
01924     01 A6 65 A6 |  if_e	neg	result1, #1
01928     74 02 90 AD |  if_e	jmp	#LR__0196
0192c     04 4E 05 F1 | 	add	fp, #4
01930     A7 C2 01 FB | 	rdlong	arg01, fp
01934     04 4E 85 F1 | 	sub	fp, #4
01938     14 C2 05 F1 | 	add	arg01, #20
0193c     E1 A6 09 FB | 	rdlong	result1, arg01 wz
01940     B8 00 90 AD |  if_e	jmp	#LR__0191
01944     04 4E 05 F1 | 	add	fp, #4
01948     A7 C2 01 FB | 	rdlong	arg01, fp
0194c     E1 C6 01 F6 | 	mov	arg03, arg01
01950     14 C6 05 F1 | 	add	arg03, #20
01954     E3 D8 01 FB | 	rdlong	local01, arg03
01958     EC DA 01 F6 | 	mov	local02, local01
0195c     13 D8 45 F7 | 	zerox	local01, #19
01960     14 DA 45 F0 | 	shr	local02, #20
01964     02 DA 65 F0 | 	shl	local02, #2
01968     C5 DA 01 F1 | 	add	local02, __methods__
0196c     ED DA 01 FB | 	rdlong	local02, local02
01970     04 4E 05 F1 | 	add	fp, #4
01974     A7 C4 01 FB | 	rdlong	arg02, fp
01978     04 4E 05 F1 | 	add	fp, #4
0197c     A7 C6 01 FB | 	rdlong	arg03, fp
01980     0C 4E 85 F1 | 	sub	fp, #12
01984     C8 DC 01 F6 | 	mov	local03, objptr
01988     EC 90 01 F6 | 	mov	objptr, local01
0198c     2D DA 61 FD | 	call	local02
01990     EE 90 01 F6 | 	mov	objptr, local03
01994     10 4E 05 F1 | 	add	fp, #16
01998     A7 A6 61 FC | 	wrlong	result1, fp
0199c     10 4E 85 F1 | 	sub	fp, #16
019a0     00 A6 55 F2 | 	cmps	result1, #0 wc
019a4     44 00 90 3D |  if_ae	jmp	#LR__0190
019a8     04 4E 05 F1 | 	add	fp, #4
019ac     A7 DC 01 FB | 	rdlong	local03, fp
019b0     EE D8 01 F6 | 	mov	local01, local03
019b4     08 DC 05 F1 | 	add	local03, #8
019b8     EE DA 01 FB | 	rdlong	local02, local03
019bc     20 DA 45 F5 | 	or	local02, #32
019c0     08 D8 05 F1 | 	add	local01, #8
019c4     EC DA 61 FC | 	wrlong	local02, local01
019c8                 | '             f->state |=  (0x20) ;
019c8                 | '             return _seterror(r);
019c8     0C 4E 05 F1 | 	add	fp, #12
019cc     A7 C2 09 FB | 	rdlong	arg01, fp wz
019d0     10 4E 85 F1 | 	sub	fp, #16
019d4     20 92 05 F1 | 	add	ptr___system__dat__, #32
019d8     C9 C2 61 FC | 	wrlong	arg01, ptr___system__dat__
019dc     20 92 85 F1 | 	sub	ptr___system__dat__, #32
019e0     01 A6 65 56 |  if_ne	neg	result1, #1
019e4     00 A6 05 A6 |  if_e	mov	result1, #0
019e8     B4 01 90 FD | 	jmp	#LR__0196
019ec                 | LR__0190
019ec                 | '         }
019ec                 | '         return r;
019ec     10 4E 05 F1 | 	add	fp, #16
019f0     A7 A6 01 FB | 	rdlong	result1, fp
019f4     10 4E 85 F1 | 	sub	fp, #16
019f8     A4 01 90 FD | 	jmp	#LR__0196
019fc                 | LR__0191
019fc     04 4E 05 F1 | 	add	fp, #4
01a00     A7 C2 01 FB | 	rdlong	arg01, fp
01a04     20 C2 05 F1 | 	add	arg01, #32
01a08     E1 C2 09 FB | 	rdlong	arg01, arg01 wz
01a0c     14 4E 05 F1 | 	add	fp, #20
01a10     A7 C2 61 FC | 	wrlong	arg01, fp
01a14     18 4E 85 F1 | 	sub	fp, #24
01a18                 | '         return _seterror( 6 );
01a18     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
01a1c     C9 0C 68 AC |  if_e	wrlong	#6, ptr___system__dat__
01a20     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
01a24     01 A6 65 A6 |  if_e	neg	result1, #1
01a28     74 01 90 AD |  if_e	jmp	#LR__0196
01a2c     04 4E 05 F1 | 	add	fp, #4
01a30     A7 DC 01 FB | 	rdlong	local03, fp
01a34     04 4E 85 F1 | 	sub	fp, #4
01a38     28 DC 05 F1 | 	add	local03, #40
01a3c     EE DA 09 FB | 	rdlong	local02, local03 wz
01a40     7C 00 90 AD |  if_e	jmp	#LR__0193
01a44     04 4E 05 F1 | 	add	fp, #4
01a48     A7 C2 01 FB | 	rdlong	arg01, fp
01a4c     E1 DC 01 F6 | 	mov	local03, arg01
01a50     28 DC 05 F1 | 	add	local03, #40
01a54     EE D8 01 FB | 	rdlong	local01, local03
01a58     EC DA 01 F6 | 	mov	local02, local01
01a5c     13 D8 45 F7 | 	zerox	local01, #19
01a60     14 DA 45 F0 | 	shr	local02, #20
01a64     02 DA 65 F0 | 	shl	local02, #2
01a68     C5 DA 01 F1 | 	add	local02, __methods__
01a6c     ED DA 01 FB | 	rdlong	local02, local02
01a70     20 4E 05 F1 | 	add	fp, #32
01a74     A7 C6 01 F6 | 	mov	arg03, fp
01a78     24 4E 85 F1 | 	sub	fp, #36
01a7c     00 C5 05 F6 | 	mov	arg02, #256
01a80     C8 DC 01 F6 | 	mov	local03, objptr
01a84     EC 90 01 F6 | 	mov	objptr, local01
01a88     2D DA 61 FD | 	call	local02
01a8c     EE 90 01 F6 | 	mov	objptr, local03
01a90     10 4E 05 F1 | 	add	fp, #16
01a94     A7 A6 61 FC | 	wrlong	result1, fp
01a98     00 A6 4D F2 | 	cmps	result1, #0 wz
01a9c     10 4E 85 F1 | 	sub	fp, #16
01aa0     1C 00 90 5D |  if_ne	jmp	#LR__0192
01aa4     24 4E 05 F1 | 	add	fp, #36
01aa8     A7 DA 01 FB | 	rdlong	local02, fp
01aac     24 4E 85 F1 | 	sub	fp, #36
01ab0     02 DA CD F7 | 	test	local02, #2 wz
01ab4     20 4E 05 51 |  if_ne	add	fp, #32
01ab8     A7 02 68 5C |  if_ne	wrlong	#1, fp
01abc     20 4E 85 51 |  if_ne	sub	fp, #32
01ac0                 | LR__0192
01ac0                 | LR__0193
01ac0     10 4E 05 F1 | 	add	fp, #16
01ac4     A7 00 68 FC | 	wrlong	#0, fp
01ac8     10 4E 85 F1 | 	sub	fp, #16
01acc                 | '             break_on_nl = 1;
01acc                 | '         }
01acc                 | '     }
01acc                 | '     r = 0;
01acc                 | '     while (count > 0) {
01acc                 | LR__0194
01acc     0C 4E 05 F1 | 	add	fp, #12
01ad0     A7 DC 01 FB | 	rdlong	local03, fp
01ad4     0C 4E 85 F1 | 	sub	fp, #12
01ad8     01 DC 15 F2 | 	cmp	local03, #1 wc
01adc     B4 00 90 CD |  if_b	jmp	#LR__0195
01ae0     18 4E 05 F1 | 	add	fp, #24
01ae4     A7 DA 01 FB | 	rdlong	local02, fp
01ae8     ED DC 01 F6 | 	mov	local03, local02
01aec     13 DC 45 F7 | 	zerox	local03, #19
01af0     14 DA 45 F0 | 	shr	local02, #20
01af4     02 DA 65 F0 | 	shl	local02, #2
01af8     C5 DA 01 F1 | 	add	local02, __methods__
01afc     ED DA 01 FB | 	rdlong	local02, local02
01b00     14 4E 85 F1 | 	sub	fp, #20
01b04     A7 C2 01 FB | 	rdlong	arg01, fp
01b08     04 4E 85 F1 | 	sub	fp, #4
01b0c     C8 D8 01 F6 | 	mov	local01, objptr
01b10     EE 90 01 F6 | 	mov	objptr, local03
01b14     2D DA 61 FD | 	call	local02
01b18     EC 90 01 F6 | 	mov	objptr, local01
01b1c     14 4E 05 F1 | 	add	fp, #20
01b20     A7 A6 61 FC | 	wrlong	result1, fp
01b24     14 4E 85 F1 | 	sub	fp, #20
01b28     00 A6 55 F2 | 	cmps	result1, #0 wc
01b2c     64 00 90 CD |  if_b	jmp	#LR__0195
01b30     1C 4E 05 F1 | 	add	fp, #28
01b34     A7 DC 01 FB | 	rdlong	local03, fp
01b38     EE DA 01 F6 | 	mov	local02, local03
01b3c     01 DA 05 F1 | 	add	local02, #1
01b40     A7 DA 61 FC | 	wrlong	local02, fp
01b44     08 4E 85 F1 | 	sub	fp, #8
01b48     A7 DA 01 FB | 	rdlong	local02, fp
01b4c     EE DA 41 FC | 	wrbyte	local02, local03
01b50     04 4E 85 F1 | 	sub	fp, #4
01b54     A7 DC 01 FB | 	rdlong	local03, fp
01b58     01 DC 05 F1 | 	add	local03, #1
01b5c     A7 DC 61 FC | 	wrlong	local03, fp
01b60     04 4E 85 F1 | 	sub	fp, #4
01b64     A7 DC 01 FB | 	rdlong	local03, fp
01b68     01 DC 85 F1 | 	sub	local03, #1
01b6c     A7 DC 61 FC | 	wrlong	local03, fp
01b70     14 4E 05 F1 | 	add	fp, #20
01b74     A7 DC 09 FB | 	rdlong	local03, fp wz
01b78     20 4E 85 F1 | 	sub	fp, #32
01b7c     4C FF 9F AD |  if_e	jmp	#LR__0194
01b80     14 4E 05 F1 | 	add	fp, #20
01b84     A7 DA 01 FB | 	rdlong	local02, fp
01b88     14 4E 85 F1 | 	sub	fp, #20
01b8c     0A DA 0D F2 | 	cmp	local02, #10 wz
01b90                 | '             break;
01b90     38 FF 9F 5D |  if_ne	jmp	#LR__0194
01b94                 | LR__0195
01b94                 | '         }
01b94                 | '     }
01b94                 | '     return r;
01b94     10 4E 05 F1 | 	add	fp, #16
01b98     A7 A6 01 FB | 	rdlong	result1, fp
01b9c     10 4E 85 F1 | 	sub	fp, #16
01ba0                 | LR__0196
01ba0     A7 F0 03 F6 | 	mov	ptra, fp
01ba4     B2 00 A0 FD | 	call	#popregs_
01ba8                 | _libc_a__vfsread_ret
01ba8     2D 00 64 FD | 	ret
01bac                 | 
01bac                 | _libc_a___default_filbuf
01bac     04 4A 05 F6 | 	mov	COUNT_, #4
01bb0     A8 00 A0 FD | 	call	#pushregs_
01bb4     E1 D8 01 F6 | 	mov	local01, arg01
01bb8     EC DA 01 FB | 	rdlong	local02, local01
01bbc     0C DA 05 F1 | 	add	local02, #12
01bc0     ED A6 09 FB | 	rdlong	result1, local02 wz
01bc4     0C DA 85 F1 | 	sub	local02, #12
01bc8     20 00 90 5D |  if_ne	jmp	#LR__0200
01bcc     14 DA 05 F1 | 	add	local02, #20
01bd0     ED A6 01 F6 | 	mov	result1, local02
01bd4     04 DA 85 F1 | 	sub	local02, #4
01bd8     ED A6 61 FC | 	wrlong	result1, local02
01bdc     04 DA 85 F1 | 	sub	local02, #4
01be0     02 00 80 FF 
01be4     ED 00 68 FC | 	wrlong	##1024, local02
01be8     0C DA 85 F1 | 	sub	local02, #12
01bec                 | LR__0200
01bec     14 D8 05 F1 | 	add	local01, #20
01bf0     EC DC 01 FB | 	rdlong	local03, local01
01bf4     EE DE 01 F6 | 	mov	local04, local03
01bf8     14 D8 85 F1 | 	sub	local01, #20
01bfc     13 DE 45 F7 | 	zerox	local04, #19
01c00     14 DC 45 F0 | 	shr	local03, #20
01c04     02 DC 65 F0 | 	shl	local03, #2
01c08     C5 DC 01 F1 | 	add	local03, __methods__
01c0c     EE DC 01 FB | 	rdlong	local03, local03
01c10     10 DA 05 F1 | 	add	local02, #16
01c14     ED C4 01 FB | 	rdlong	arg02, local02
01c18     04 DA 85 F1 | 	sub	local02, #4
01c1c     ED C6 01 FB | 	rdlong	arg03, local02
01c20     0C DA 85 F1 | 	sub	local02, #12
01c24     EC C2 01 F6 | 	mov	arg01, local01
01c28     C8 D8 01 F6 | 	mov	local01, objptr
01c2c     EF 90 01 F6 | 	mov	objptr, local04
01c30     2D DC 61 FD | 	call	local03
01c34     EC 90 01 F6 | 	mov	objptr, local01
01c38     D3 DE 01 F6 | 	mov	local04, result1
01c3c     00 DE 55 F2 | 	cmps	local04, #0 wc
01c40                 | '         return -1;
01c40     01 A6 65 C6 |  if_b	neg	result1, #1
01c44     28 00 90 CD |  if_b	jmp	#LR__0201
01c48     ED DE 61 FC | 	wrlong	local04, local02
01c4c     10 DA 05 F1 | 	add	local02, #16
01c50     ED DC 01 FB | 	rdlong	local03, local02
01c54     0C DA 85 F1 | 	sub	local02, #12
01c58     ED DC 61 FC | 	wrlong	local03, local02
01c5c     04 DA 05 F1 | 	add	local02, #4
01c60     ED DC 01 FB | 	rdlong	local03, local02
01c64     01 DC 45 F5 | 	or	local03, #1
01c68     ED DC 61 FC | 	wrlong	local03, local02
01c6c                 | '     }
01c6c                 | '     b->cnt = r;
01c6c                 | '     b->ptr = &b->bufptr[0];
01c6c                 | '     b->flags |=  (0x01) ;
01c6c                 | '     return r;
01c6c     EF A6 01 F6 | 	mov	result1, local04
01c70                 | LR__0201
01c70     A7 F0 03 F6 | 	mov	ptra, fp
01c74     B2 00 A0 FD | 	call	#popregs_
01c78                 | _libc_a___default_filbuf_ret
01c78     2D 00 64 FD | 	ret
01c7c                 | 
01c7c                 | _fatfs_cc_memcmp
01c7c                 | ' 	for (n = size; n > 0; n--)
01c7c     00 C6 0D F2 | 	cmp	arg03, #0 wz
01c80     28 00 90 AD |  if_e	jmp	#LR__0211
01c84                 | LR__0210
01c84     E1 AA C1 FA | 	rdbyte	_var01, arg01
01c88     E2 AC C1 FA | 	rdbyte	_var02, arg02
01c8c     D6 AA 09 F2 | 	cmp	_var01, _var02 wz
01c90     01 C2 05 A1 |  if_e	add	arg01, #1
01c94     01 C4 05 A1 |  if_e	add	arg02, #1
01c98                 | ' 			return( ((unsigned char)(*scan1))  -  ((unsigned char)(*scan2)) );
01c98     E1 A6 C1 5A |  if_ne	rdbyte	result1, arg01
01c9c     E2 AC C1 5A |  if_ne	rdbyte	_var02, arg02
01ca0     D6 A6 81 51 |  if_ne	sub	result1, _var02
01ca4     08 00 90 5D |  if_ne	jmp	#_fatfs_cc_memcmp_ret
01ca8     F6 C7 6D FB | 	djnz	arg03, #LR__0210
01cac                 | LR__0211
01cac                 | ' 
01cac                 | ' 	return(0);
01cac     00 A6 05 F6 | 	mov	result1, #0
01cb0                 | _fatfs_cc_memcmp_ret
01cb0     2D 00 64 FD | 	ret
01cb4                 | 
01cb4                 | _fatfs_cc_strncmp
01cb4     E1 AA 09 F6 | 	mov	_var01, arg01 wz
01cb8     14 00 90 5D |  if_ne	jmp	#LR__0220
01cbc                 | ' 		return scan2 ? -1 : 0;
01cbc     00 C4 0D F2 | 	cmp	arg02, #0 wz
01cc0     01 AC 65 56 |  if_ne	neg	_var02, #1
01cc4     00 AC 05 A6 |  if_e	mov	_var02, #0
01cc8     D6 A6 01 F6 | 	mov	result1, _var02
01ccc     74 00 90 FD | 	jmp	#_fatfs_cc_strncmp_ret
01cd0                 | LR__0220
01cd0     00 C4 0D F2 | 	cmp	arg02, #0 wz
01cd4     01 A6 05 A6 |  if_e	mov	result1, #1
01cd8     68 00 90 AD |  if_e	jmp	#_fatfs_cc_strncmp_ret
01cdc     E3 AE 01 F6 | 	mov	_var03, arg03
01ce0     97 16 48 FB | 	callpa	#(@LR__0222-@LR__0221)>>2,fcache_load_ptr_
01ce4                 | ' 	count = n;
01ce4                 | ' 	do {
01ce4                 | LR__0221
01ce4     D5 B0 C1 FA | 	rdbyte	_var04, _var01
01ce8     E2 B2 01 F6 | 	mov	_var05, arg02
01cec     D9 B4 C1 FA | 	rdbyte	_var06, _var05
01cf0     01 AE 85 F1 | 	sub	_var03, #1
01cf4     00 AE 55 F2 | 	cmps	_var03, #0 wc
01cf8     01 AA 05 F1 | 	add	_var01, #1
01cfc     01 C4 05 F1 | 	add	arg02, #1
01d00     00 B0 0D 32 |  if_ae	cmp	_var04, #0 wz
01d04     08 00 90 2D |  if_nc_and_z	jmp	#LR__0223
01d08     DA B0 09 32 |  if_ae	cmp	_var04, _var06 wz
01d0c     D4 FF 9F 2D |  if_nc_and_z	jmp	#LR__0221
01d10                 | LR__0222
01d10                 | LR__0223
01d10     00 AE 55 F2 | 	cmps	_var03, #0 wc
01d14                 | ' 		return(0);
01d14     00 A6 05 C6 |  if_b	mov	result1, #0
01d18     28 00 90 CD |  if_b	jmp	#_fatfs_cc_strncmp_ret
01d1c     DA B0 09 F2 | 	cmp	_var04, _var06 wz
01d20                 | ' 		return(0);
01d20     00 A6 05 A6 |  if_e	mov	result1, #0
01d24     1C 00 90 AD |  if_e	jmp	#_fatfs_cc_strncmp_ret
01d28     00 B0 0D F2 | 	cmp	_var04, #0 wz
01d2c                 | ' 		return(-1);
01d2c     01 A6 65 A6 |  if_e	neg	result1, #1
01d30     10 00 90 AD |  if_e	jmp	#_fatfs_cc_strncmp_ret
01d34     00 B4 0D F2 | 	cmp	_var06, #0 wz
01d38                 | ' 		return(1);
01d38     01 A6 05 A6 |  if_e	mov	result1, #1
01d3c                 | ' 		return(c1 - c2);
01d3c     D8 A6 01 56 |  if_ne	mov	result1, _var04
01d40     DA A6 81 51 |  if_ne	sub	result1, _var06
01d44                 | _fatfs_cc_strncmp_ret
01d44     2D 00 64 FD | 	ret
01d48                 | 
01d48                 | _fatfs_cc_strchr
01d48                 | ' #line 16 "C:/Users/ryans/Documents/flexprop/include/libc/string/strchr.c"
01d48                 | ' 	while ((c = *s++) != (char) charwanted)
01d48                 | LR__0230
01d48     E1 AA 01 F6 | 	mov	_var01, arg01
01d4c     D5 AC C1 FA | 	rdbyte	_var02, _var01
01d50     D6 AE E1 F8 | 	getbyte	_var03, _var02, #0
01d54     E2 B0 E1 F8 | 	getbyte	_var04, arg02, #0
01d58     D8 AE 09 F2 | 	cmp	_var03, _var04 wz
01d5c     01 C2 05 F1 | 	add	arg01, #1
01d60     14 00 90 AD |  if_e	jmp	#LR__0231
01d64     D6 AE 01 F6 | 	mov	_var03, _var02
01d68     07 AE 4D F7 | 	zerox	_var03, #7 wz
01d6c     00 A6 05 A6 |  if_e	mov	result1, #0
01d70     0C 00 90 AD |  if_e	jmp	#_fatfs_cc_strchr_ret
01d74     D0 FF 9F FD | 	jmp	#LR__0230
01d78                 | LR__0231
01d78                 | ' 	return((char *)--s);
01d78     01 C2 85 F1 | 	sub	arg01, #1
01d7c     E1 A6 01 F6 | 	mov	result1, arg01
01d80                 | _fatfs_cc_strchr_ret
01d80     2D 00 64 FD | 	ret
01d84                 | 
01d84                 | _fatfs_cc_disk_initialize
01d84     0F 4A 05 F6 | 	mov	COUNT_, #15
01d88     A8 00 A0 FD | 	call	#pushregs_
01d8c     E1 D8 09 F6 | 	mov	local01, arg01 wz
01d90     F8 DB 01 F6 | 	mov	local02, ptra
01d94     10 90 05 F1 | 	add	objptr, #16
01d98     C8 DC 01 FB | 	rdlong	local03, objptr
01d9c     04 90 05 F1 | 	add	objptr, #4
01da0     C8 DE 01 FB | 	rdlong	local04, objptr
01da4     04 90 05 F1 | 	add	objptr, #4
01da8     C8 E0 01 FB | 	rdlong	local05, objptr
01dac     04 90 05 F1 | 	add	objptr, #4
01db0     C8 E2 01 FB | 	rdlong	local06, objptr
01db4     08 90 05 F1 | 	add	objptr, #8
01db8     C8 02 48 FC | 	wrbyte	#1, objptr
01dbc     24 90 85 F1 | 	sub	objptr, #36
01dc0                 | ' #line 538 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
01dc0                 | ' 		return RES_NOTRDY;
01dc0     0C F0 07 F1 | 	add	ptra, #12
01dc4     03 A6 05 56 |  if_ne	mov	result1, #3
01dc8     68 04 90 5D |  if_ne	jmp	#LR__0260
01dcc     13 00 00 FF 
01dd0     10 C3 05 F6 | 	mov	arg01, ##10000
01dd4     4C C8 B0 FD | 	call	#__system___waitus
01dd8     EE C8 01 F6 | 	mov	arg04, local03
01ddc     F0 C8 81 F1 | 	sub	arg04, local05
01de0     E4 C8 41 F6 | 	abs	arg04, arg04
01de4     04 C8 55 F2 | 	cmps	arg04, #4 wc
01de8     04 A6 05 36 |  if_ae	mov	result1, #4
01dec     44 04 90 3D |  if_ae	jmp	#LR__0260
01df0     EE E4 01 F6 | 	mov	local07, local03
01df4     F1 E4 81 F1 | 	sub	local07, local06
01df8     F2 E4 41 F6 | 	abs	local07, local07
01dfc     04 E4 55 F2 | 	cmps	local07, #4 wc
01e00     34 00 90 3D |  if_ae	jmp	#LR__0240
01e04     EE E6 01 F6 | 	mov	local08, local03
01e08     F1 E6 81 F1 | 	sub	local08, local06
01e0c     07 E6 05 F5 | 	and	local08, #7
01e10     18 E6 65 F0 | 	shl	local08, #24
01e14     29 00 00 FF 
01e18     7A E6 45 F5 | 	or	local08, ##21114
01e1c     F1 E8 01 F6 | 	mov	local09, local06
01e20     1C 90 05 F1 | 	add	objptr, #28
01e24     C8 E8 61 FC | 	wrlong	local09, objptr
01e28     04 90 05 F1 | 	add	objptr, #4
01e2c     C8 E8 61 FC | 	wrlong	local09, objptr
01e30     20 90 85 F1 | 	sub	objptr, #32
01e34     A4 00 90 FD | 	jmp	#LR__0243
01e38                 | LR__0240
01e38     F1 DC 59 F2 | 	cmps	local03, local06 wcz
01e3c     28 00 90 ED |  if_be	jmp	#LR__0241
01e40     EE E8 01 F6 | 	mov	local09, local03
01e44     03 E8 85 F1 | 	sub	local09, #3
01e48     F0 E8 09 F2 | 	cmp	local09, local05 wz
01e4c     EF E8 09 52 |  if_ne	cmp	local09, local04 wz
01e50     01 E8 05 A1 |  if_e	add	local09, #1
01e54     F0 E8 09 F2 | 	cmp	local09, local05 wz
01e58     EF E8 09 52 |  if_ne	cmp	local09, local04 wz
01e5c     28 00 90 5D |  if_ne	jmp	#LR__0242
01e60     01 E8 05 F1 | 	add	local09, #1
01e64     20 00 90 FD | 	jmp	#LR__0242
01e68                 | LR__0241
01e68     EE E8 01 F6 | 	mov	local09, local03
01e6c     03 E8 05 F1 | 	add	local09, #3
01e70     F0 E8 09 F2 | 	cmp	local09, local05 wz
01e74     EF E8 09 52 |  if_ne	cmp	local09, local04 wz
01e78     01 E8 85 A1 |  if_e	sub	local09, #1
01e7c     F0 E8 09 F2 | 	cmp	local09, local05 wz
01e80     EF E8 09 52 |  if_ne	cmp	local09, local04 wz
01e84     01 E8 85 A1 |  if_e	sub	local09, #1
01e88                 | LR__0242
01e88     F1 E4 01 F6 | 	mov	local07, local06
01e8c     F4 E4 81 F1 | 	sub	local07, local09
01e90     F2 E4 41 F6 | 	abs	local07, local07
01e94     04 E4 55 F2 | 	cmps	local07, #4 wc
01e98     04 A6 05 36 |  if_ae	mov	result1, #4
01e9c     94 03 90 3D |  if_ae	jmp	#LR__0260
01ea0     F1 E6 01 F6 | 	mov	local08, local06
01ea4     F4 E6 81 F1 | 	sub	local08, local09
01ea8     07 E6 05 F5 | 	and	local08, #7
01eac     1C E6 65 F0 | 	shl	local08, #28
01eb0     EE E4 01 F6 | 	mov	local07, local03
01eb4     F4 E4 81 F1 | 	sub	local07, local09
01eb8     07 E4 05 F5 | 	and	local07, #7
01ebc     18 E4 65 F0 | 	shl	local07, #24
01ec0     F2 E6 41 F5 | 	or	local08, local07
01ec4     3A E6 45 F5 | 	or	local08, #58
01ec8     20 90 05 F1 | 	add	objptr, #32
01ecc     C8 E2 61 FC | 	wrlong	local06, objptr
01ed0     04 90 85 F1 | 	sub	objptr, #4
01ed4     C8 E8 61 FC | 	wrlong	local09, objptr
01ed8     1C 90 85 F1 | 	sub	objptr, #28
01edc                 | LR__0243
01edc     EF 00 08 FC | 	wrpin	#0, local04
01ee0     59 DE 61 FD | 	drvh	local04
01ee4     00 08 00 FF 
01ee8     20 EA 05 F6 | 	mov	local10, ##1048608
01eec     40 DC 61 FD | 	dirl	local03
01ef0     A0 03 80 FF 
01ef4     EE 90 08 FC | 	wrpin	##475208, local03
01ef8     00 08 80 FF 
01efc     EE 40 18 FC | 	wxpin	##1048608, local03
01f00     EE 00 28 FC | 	wypin	#0, local03
01f04     41 DC 61 FD | 	dirh	local03
01f08     EE E4 01 F6 | 	mov	local07, local03
01f0c     F0 E4 81 F1 | 	sub	local07, local05
01f10     07 E4 05 F5 | 	and	local07, #7
01f14     18 E4 65 F0 | 	shl	local07, #24
01f18     78 EC 05 F6 | 	mov	local11, #120
01f1c     F2 EC 41 F5 | 	or	local11, local07
01f20     F6 C4 01 F6 | 	mov	arg02, local11
01f24     10 C4 25 F4 | 	bith	arg02, #16
01f28     40 E0 61 FD | 	dirl	local05
01f2c     F0 C4 01 FC | 	wrpin	arg02, local05
01f30     F0 3E 18 FC | 	wxpin	#31, local05
01f34     FF FF FF FF 
01f38     F0 FE 2B FC | 	wypin	##-1, local05
01f3c     41 E0 61 FD | 	dirh	local05
01f40     29 00 80 FF 
01f44     F1 00 08 FC | 	wrpin	##20992, local06
01f48     40 E8 61 FD | 	dirl	local09
01f4c     F4 E6 01 FC | 	wrpin	local08, local09
01f50     F4 4E 18 FC | 	wxpin	#39, local09
01f54     F4 00 28 FC | 	wypin	#0, local09
01f58     41 E8 61 FD | 	dirh	local09
01f5c     ED C2 01 F6 | 	mov	arg01, local02
01f60     0A C4 05 F6 | 	mov	arg02, #10
01f64     34 64 B0 FD | 	call	#_fatfs_cc_rcvr_mmc_0641
01f68     00 C2 05 F6 | 	mov	arg01, #0
01f6c     00 C4 05 F6 | 	mov	arg02, #0
01f70     B0 66 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
01f74     FC 64 B0 FD | 	call	#_fatfs_cc_deselect_0651
01f78     64 C2 05 F6 | 	mov	arg01, #100
01f7c     A4 C6 B0 FD | 	call	#__system___waitus
01f80     ED C2 01 F6 | 	mov	arg01, local02
01f84     0A C4 05 F6 | 	mov	arg02, #10
01f88     10 64 B0 FD | 	call	#_fatfs_cc_rcvr_mmc_0641
01f8c     00 EE 05 F6 | 	mov	local12, #0
01f90     00 C2 05 F6 | 	mov	arg01, #0
01f94     00 C4 05 F6 | 	mov	arg02, #0
01f98     88 66 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
01f9c     D3 E4 E1 F8 | 	getbyte	local07, result1, #0
01fa0     01 E4 0D F2 | 	cmp	local07, #1 wz
01fa4     5C 02 90 5D |  if_ne	jmp	#LR__0259
01fa8     08 C2 05 F6 | 	mov	arg01, #8
01fac     AA C5 05 F6 | 	mov	arg02, #426
01fb0     70 66 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
01fb4     D3 A6 E1 F8 | 	getbyte	result1, result1, #0
01fb8     01 A6 0D F2 | 	cmp	result1, #1 wz
01fbc     30 01 90 5D |  if_ne	jmp	#LR__0248
01fc0     ED C2 01 F6 | 	mov	arg01, local02
01fc4     04 C4 05 F6 | 	mov	arg02, #4
01fc8     D0 63 B0 FD | 	call	#_fatfs_cc_rcvr_mmc_0641
01fcc     02 DA 05 F1 | 	add	local02, #2
01fd0     ED E4 C1 FA | 	rdbyte	local07, local02
01fd4     02 DA 85 F1 | 	sub	local02, #2
01fd8     01 E4 0D F2 | 	cmp	local07, #1 wz
01fdc     03 DA 05 A1 |  if_e	add	local02, #3
01fe0     ED F0 C1 AA |  if_e	rdbyte	local13, local02
01fe4     03 DA 85 A1 |  if_e	sub	local02, #3
01fe8     AA F0 0D A2 |  if_e	cmp	local13, #170 wz
01fec     14 02 90 5D |  if_ne	jmp	#LR__0258
01ff0                 | ' 				for (tmr = 1000; tmr; tmr--) {
01ff0     01 00 00 FF 
01ff4     E8 F3 05 F6 | 	mov	local14, ##1000
01ff8                 | LR__0244
01ff8     A9 C2 05 F6 | 	mov	arg01, #169
01ffc     1E C4 C5 F9 | 	decod	arg02, #30
02000     20 66 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
02004     D3 E4 01 F6 | 	mov	local07, result1
02008     07 E4 4D F7 | 	zerox	local07, #7 wz
0200c     18 00 90 AD |  if_e	jmp	#LR__0245
02010     01 00 00 FF 
02014     E8 C3 05 F6 | 	mov	arg01, ##1000
02018     08 C6 B0 FD | 	call	#__system___waitus
0201c     F9 E4 01 F6 | 	mov	local07, local14
02020     01 F2 8D F1 | 	sub	local14, #1 wz
02024     D0 FF 9F 5D |  if_ne	jmp	#LR__0244
02028                 | LR__0245
02028     00 F2 0D F2 | 	cmp	local14, #0 wz
0202c     38 00 90 AD |  if_e	jmp	#LR__0246
02030     3A C2 05 F6 | 	mov	arg01, #58
02034     00 C4 05 F6 | 	mov	arg02, #0
02038     E8 65 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
0203c     D3 E4 01 F6 | 	mov	local07, result1
02040     07 E4 4D F7 | 	zerox	local07, #7 wz
02044     20 00 90 5D |  if_ne	jmp	#LR__0246
02048     ED C2 01 F6 | 	mov	arg01, local02
0204c     04 C4 05 F6 | 	mov	arg02, #4
02050     48 63 B0 FD | 	call	#_fatfs_cc_rcvr_mmc_0641
02054     ED F2 C1 FA | 	rdbyte	local14, local02
02058     40 F2 CD F7 | 	test	local14, #64 wz
0205c     0C E4 05 56 |  if_ne	mov	local07, #12
02060     04 E4 05 A6 |  if_e	mov	local07, #4
02064     F2 EE 01 F6 | 	mov	local12, local07
02068                 | LR__0246
02068     14 F2 05 FB | 	rdlong	local14, #20
0206c     F0 FA 02 FF 
02070     01 F3 15 F2 | 	cmp	local14, ##100000001 wc
02074     F6 E4 01 C6 |  if_b	mov	local07, local11
02078     1B E4 25 C4 |  if_b	bith	local07, #27
0207c     F2 EC 01 C6 |  if_b	mov	local11, local07
02080     10 00 90 CD |  if_b	jmp	#LR__0247
02084     E1 F5 05 FF 
02088     01 F2 15 F2 | 	cmp	local14, ##200000001 wc
0208c     80 00 04 CF 
02090     00 EC 45 C5 |  if_b	or	local11, ##134283264
02094                 | LR__0247
02094     F0 FA 02 FF 
02098     01 F3 15 F2 | 	cmp	local14, ##100000001 wc
0209c     00 01 00 CF 
020a0     04 EA 05 C6 |  if_b	mov	local10, ##131076
020a4     5C 01 90 CD |  if_b	jmp	#LR__0258
020a8     68 78 04 FF 
020ac     81 F3 15 F2 | 	cmp	local14, ##150000001 wc
020b0     80 01 00 CF 
020b4     06 EA 05 C6 |  if_b	mov	local10, ##196614
020b8     48 01 90 CD |  if_b	jmp	#LR__0258
020bc     E1 F5 05 FF 
020c0     01 F2 15 F2 | 	cmp	local14, ##200000001 wc
020c4     00 02 00 CF 
020c8     08 EA 05 C6 |  if_b	mov	local10, ##262152
020cc     34 01 90 CD |  if_b	jmp	#LR__0258
020d0     59 73 07 FF 
020d4     81 F2 15 F2 | 	cmp	local14, ##250000001 wc
020d8     80 02 00 CF 
020dc     0A EA 05 C6 |  if_b	mov	local10, ##327690
020e0     20 01 90 CD |  if_b	jmp	#LR__0258
020e4     00 03 00 FF 
020e8     0C EA 05 F6 | 	mov	local10, ##393228
020ec     14 01 90 FD | 	jmp	#LR__0258
020f0                 | LR__0248
020f0     A9 C2 05 F6 | 	mov	arg01, #169
020f4     00 C4 05 F6 | 	mov	arg02, #0
020f8     28 65 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
020fc     D3 E4 E1 F8 | 	getbyte	local07, result1, #0
02100     02 E4 15 F2 | 	cmp	local07, #2 wc
02104     02 EE 05 C6 |  if_b	mov	local12, #2
02108     A9 F4 05 C6 |  if_b	mov	local15, #169
0210c     01 EE 05 36 |  if_ae	mov	local12, #1
02110     01 F4 05 36 |  if_ae	mov	local15, #1
02114                 | ' 				ty =  0x01 ; cmd =  (1) ;
02114                 | ' 			}
02114                 | ' 			for (tmr = 1000; tmr; tmr--) {
02114     01 00 00 FF 
02118     E8 F3 05 F6 | 	mov	local14, ##1000
0211c                 | LR__0249
0211c     FA C2 01 F6 | 	mov	arg01, local15
02120     00 C4 05 F6 | 	mov	arg02, #0
02124     FC 64 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
02128     D3 E4 01 F6 | 	mov	local07, result1
0212c     07 E4 4D F7 | 	zerox	local07, #7 wz
02130     18 00 90 AD |  if_e	jmp	#LR__0250
02134     01 00 00 FF 
02138     E8 C3 05 F6 | 	mov	arg01, ##1000
0213c     E4 C4 B0 FD | 	call	#__system___waitus
02140     F9 E4 01 F6 | 	mov	local07, local14
02144     01 F2 8D F1 | 	sub	local14, #1 wz
02148     D0 FF 9F 5D |  if_ne	jmp	#LR__0249
0214c                 | LR__0250
0214c     00 F2 0D F2 | 	cmp	local14, #0 wz
02150     18 00 90 AD |  if_e	jmp	#LR__0251
02154     10 C2 05 F6 | 	mov	arg01, #16
02158     09 C4 C5 F9 | 	decod	arg02, #9
0215c     C4 64 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
02160     D3 E4 01 F6 | 	mov	local07, result1
02164     07 E4 4D F7 | 	zerox	local07, #7 wz
02168     04 00 90 AD |  if_e	jmp	#LR__0252
0216c                 | LR__0251
0216c     00 EE 05 F6 | 	mov	local12, #0
02170                 | LR__0252
02170     14 F2 05 FB | 	rdlong	local14, #20
02174     F0 FA 02 FF 
02178     01 F3 15 F2 | 	cmp	local14, ##100000001 wc
0217c     F6 E4 01 C6 |  if_b	mov	local07, local11
02180     1B E4 25 C4 |  if_b	bith	local07, #27
02184     F2 EC 01 C6 |  if_b	mov	local11, local07
02188     10 00 90 CD |  if_b	jmp	#LR__0253
0218c     E1 F5 05 FF 
02190     01 F2 15 F2 | 	cmp	local14, ##200000001 wc
02194     80 00 04 CF 
02198     00 EC 45 C5 |  if_b	or	local11, ##134283264
0219c                 | LR__0253
0219c     F0 FA 02 FF 
021a0     01 F3 15 F2 | 	cmp	local14, ##100000001 wc
021a4     00 01 00 CF 
021a8     04 EA 05 C6 |  if_b	mov	local10, ##131076
021ac     54 00 90 CD |  if_b	jmp	#LR__0257
021b0     68 78 04 FF 
021b4     81 F3 15 F2 | 	cmp	local14, ##150000001 wc
021b8     80 01 00 CF 
021bc     06 EA 05 C6 |  if_b	mov	local10, ##196614
021c0     40 00 90 CD |  if_b	jmp	#LR__0256
021c4     E1 F5 05 FF 
021c8     01 F2 15 F2 | 	cmp	local14, ##200000001 wc
021cc     00 02 00 CF 
021d0     08 EA 05 C6 |  if_b	mov	local10, ##262152
021d4     2C 00 90 CD |  if_b	jmp	#LR__0255
021d8     59 73 07 FF 
021dc     81 F2 15 F2 | 	cmp	local14, ##250000001 wc
021e0     80 02 00 CF 
021e4     0A EA 05 C6 |  if_b	mov	local10, ##327690
021e8     18 00 90 CD |  if_b	jmp	#LR__0254
021ec     D1 F0 08 FF 
021f0     01 F3 15 F2 | 	cmp	local14, ##300000001 wc
021f4     00 03 00 CF 
021f8     0C EA 05 C6 |  if_b	mov	local10, ##393228
021fc     80 03 00 3F 
02200     0E EA 05 36 |  if_ae	mov	local10, ##458766
02204                 | LR__0254
02204                 | LR__0255
02204                 | LR__0256
02204                 | LR__0257
02204                 | LR__0258
02204                 | LR__0259
02204     25 90 05 F1 | 	add	objptr, #37
02208     C8 EE 41 FC | 	wrbyte	local12, objptr
0220c     00 EE 0D F2 | 	cmp	local12, #0 wz
02210     00 E4 05 56 |  if_ne	mov	local07, #0
02214     01 E4 05 A6 |  if_e	mov	local07, #1
02218     01 90 85 F1 | 	sub	objptr, #1
0221c     C8 E4 41 FC | 	wrbyte	local07, objptr
02220     24 90 85 F1 | 	sub	objptr, #36
02224     4C 62 B0 FD | 	call	#_fatfs_cc_deselect_0651
02228     EE EA 11 FC | 	wxpin	local10, local03
0222c     F0 EC 01 FC | 	wrpin	local11, local05
02230                 | ' #line 681 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
02230                 | ' 		}
02230                 | ' 	}
02230                 | ' #line 686 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
02230                 | ' 	CardType = ty;
02230                 | ' 	s = ty ? 0 :  0x01 ;
02230                 | ' 	Stat = s;
02230                 | ' 
02230                 | ' 	deselect();
02230                 | ' 
02230                 | ' 
02230                 | ' 	_wxpin( PIN_CLK, ck_div );
02230                 | ' 	_wrpin( PIN_DI, spm_tx );
02230                 | ' #line 699 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
02230                 | ' 	return s;
02230     F2 A6 01 F6 | 	mov	result1, local07
02234                 | LR__0260
02234     A7 F0 03 F6 | 	mov	ptra, fp
02238     B2 00 A0 FD | 	call	#popregs_
0223c                 | _fatfs_cc_disk_initialize_ret
0223c     2D 00 64 FD | 	ret
02240                 | 
02240                 | _fatfs_cc_disk_read
02240     05 4A 05 F6 | 	mov	COUNT_, #5
02244     A8 00 A0 FD | 	call	#pushregs_
02248     E2 D8 01 F6 | 	mov	local01, arg02
0224c     E3 DA 01 F6 | 	mov	local02, arg03
02250     E4 DC 01 F6 | 	mov	local03, arg04
02254     00 C2 0D F2 | 	cmp	arg01, #0 wz
02258     01 A6 05 56 |  if_ne	mov	result1, #1
0225c                 | ' 
0225c                 | ' 	return Stat;
0225c     24 90 05 A1 |  if_e	add	objptr, #36
02260     C8 A6 C1 AA |  if_e	rdbyte	result1, objptr
02264     24 90 85 A1 |  if_e	sub	objptr, #36
02268     D3 A6 E1 F8 | 	getbyte	result1, result1, #0
0226c     01 A6 CD F7 | 	test	result1, #1 wz
02270     03 A6 05 56 |  if_ne	mov	result1, #3
02274     7C 00 90 5D |  if_ne	jmp	#LR__0272
02278     25 90 05 F1 | 	add	objptr, #37
0227c     C8 DE C1 FA | 	rdbyte	local04, objptr
02280     25 90 85 F1 | 	sub	objptr, #37
02284     08 DE CD F7 | 	test	local04, #8 wz
02288     09 DA 65 A0 |  if_e	shl	local02, #9
0228c     02 DC 15 F2 | 	cmp	local03, #2 wc
02290     12 DE 05 36 |  if_ae	mov	local04, #18
02294     11 DE 05 C6 |  if_b	mov	local04, #17
02298     ED C4 01 F6 | 	mov	arg02, local02
0229c     EF C2 01 F6 | 	mov	arg01, local04
022a0     80 63 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
022a4     D3 E0 01 F6 | 	mov	local05, result1
022a8     07 E0 4D F7 | 	zerox	local05, #7 wz
022ac     30 00 90 5D |  if_ne	jmp	#LR__0271
022b0                 | ' 		do {
022b0                 | LR__0270
022b0     EC C2 01 F6 | 	mov	arg01, local01
022b4     09 C4 C5 F9 | 	decod	arg02, #9
022b8     58 62 B0 FD | 	call	#_fatfs_cc_rcvr_datablock_0659
022bc     00 A6 0D F2 | 	cmp	result1, #0 wz
022c0     01 00 00 5F 
022c4     00 D8 05 51 |  if_ne	add	local01, ##512
022c8     F9 DD 6D 5B |  if_ne	djnz	local03, #LR__0270
022cc     EF DE E1 F8 | 	getbyte	local04, local04, #0
022d0     12 DE 0D F2 | 	cmp	local04, #18 wz
022d4     0C C2 05 A6 |  if_e	mov	arg01, #12
022d8     00 C4 05 A6 |  if_e	mov	arg02, #0
022dc     44 63 B0 AD |  if_e	call	#_fatfs_cc_send_cmd_0664
022e0                 | LR__0271
022e0     90 61 B0 FD | 	call	#_fatfs_cc_deselect_0651
022e4                 | ' 	}
022e4                 | ' 	deselect();
022e4                 | ' 
022e4                 | ' 	return count ? RES_ERROR : RES_OK;
022e4     00 DC 0D F2 | 	cmp	local03, #0 wz
022e8     01 E0 05 56 |  if_ne	mov	local05, #1
022ec     00 E0 05 A6 |  if_e	mov	local05, #0
022f0     F0 A6 01 F6 | 	mov	result1, local05
022f4                 | LR__0272
022f4     A7 F0 03 F6 | 	mov	ptra, fp
022f8     B2 00 A0 FD | 	call	#popregs_
022fc                 | _fatfs_cc_disk_read_ret
022fc     2D 00 64 FD | 	ret
02300                 | 
02300                 | _fatfs_cc_disk_write
02300     04 4A 05 F6 | 	mov	COUNT_, #4
02304     A8 00 A0 FD | 	call	#pushregs_
02308     E2 D8 01 F6 | 	mov	local01, arg02
0230c     E4 DA 01 F6 | 	mov	local02, arg04
02310     E3 DC 01 F6 | 	mov	local03, arg03
02314     00 C2 0D F2 | 	cmp	arg01, #0 wz
02318     01 A6 05 56 |  if_ne	mov	result1, #1
0231c                 | ' 
0231c                 | ' 	return Stat;
0231c     24 90 05 A1 |  if_e	add	objptr, #36
02320     C8 A6 C1 AA |  if_e	rdbyte	result1, objptr
02324     24 90 85 A1 |  if_e	sub	objptr, #36
02328     D3 A6 E1 F8 | 	getbyte	result1, result1, #0
0232c     01 A6 CD F7 | 	test	result1, #1 wz
02330     03 A6 05 56 |  if_ne	mov	result1, #3
02334     C4 00 90 5D |  if_ne	jmp	#LR__0284
02338     25 90 05 F1 | 	add	objptr, #37
0233c     C8 C6 C1 FA | 	rdbyte	arg03, objptr
02340     25 90 85 F1 | 	sub	objptr, #37
02344     08 C6 CD F7 | 	test	arg03, #8 wz
02348     09 DC 65 A0 |  if_e	shl	local03, #9
0234c     01 DA 0D F2 | 	cmp	local02, #1 wz
02350     30 00 90 5D |  if_ne	jmp	#LR__0280
02354     18 C2 05 F6 | 	mov	arg01, #24
02358     EE C4 01 F6 | 	mov	arg02, local03
0235c     C4 62 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
02360     D3 DE 01 F6 | 	mov	local04, result1
02364     07 DE 4D F7 | 	zerox	local04, #7 wz
02368     7C 00 90 5D |  if_ne	jmp	#LR__0283
0236c     EC C2 01 F6 | 	mov	arg01, local01
02370     FE C4 05 F6 | 	mov	arg02, #254
02374     20 62 B0 FD | 	call	#_fatfs_cc_xmit_datablock_0661
02378     00 A6 0D F2 | 	cmp	result1, #0 wz
0237c     00 DA 05 56 |  if_ne	mov	local02, #0
02380     64 00 90 FD | 	jmp	#LR__0283
02384                 | LR__0280
02384     25 90 05 F1 | 	add	objptr, #37
02388     C8 DE C1 FA | 	rdbyte	local04, objptr
0238c     25 90 85 F1 | 	sub	objptr, #37
02390     06 DE CD F7 | 	test	local04, #6 wz
02394     97 C2 05 56 |  if_ne	mov	arg01, #151
02398     ED C4 01 56 |  if_ne	mov	arg02, local02
0239c     84 62 B0 5D |  if_ne	call	#_fatfs_cc_send_cmd_0664
023a0     EE C4 01 F6 | 	mov	arg02, local03
023a4     19 C2 05 F6 | 	mov	arg01, #25
023a8     78 62 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
023ac     D3 DE 01 F6 | 	mov	local04, result1
023b0     07 DE 4D F7 | 	zerox	local04, #7 wz
023b4     30 00 90 5D |  if_ne	jmp	#LR__0282
023b8                 | ' 			do {
023b8                 | LR__0281
023b8     EC C2 01 F6 | 	mov	arg01, local01
023bc     FC C4 05 F6 | 	mov	arg02, #252
023c0     D4 61 B0 FD | 	call	#_fatfs_cc_xmit_datablock_0661
023c4     00 A6 0D F2 | 	cmp	result1, #0 wz
023c8     01 00 00 5F 
023cc     00 D8 05 51 |  if_ne	add	local01, ##512
023d0     F9 DB 6D 5B |  if_ne	djnz	local02, #LR__0281
023d4     00 C2 05 F6 | 	mov	arg01, #0
023d8     FD C4 05 F6 | 	mov	arg02, #253
023dc     B8 61 B0 FD | 	call	#_fatfs_cc_xmit_datablock_0661
023e0     00 A6 0D F2 | 	cmp	result1, #0 wz
023e4     01 DA 05 A6 |  if_e	mov	local02, #1
023e8                 | LR__0282
023e8                 | LR__0283
023e8     88 60 B0 FD | 	call	#_fatfs_cc_deselect_0651
023ec                 | ' 				count = 1;
023ec                 | ' 		}
023ec                 | ' 	}
023ec                 | ' 	deselect();
023ec                 | ' 
023ec                 | ' 	return count ? RES_ERROR : RES_OK;
023ec     00 DA 0D F2 | 	cmp	local02, #0 wz
023f0     01 DE 05 56 |  if_ne	mov	local04, #1
023f4     00 DE 05 A6 |  if_e	mov	local04, #0
023f8     EF A6 01 F6 | 	mov	result1, local04
023fc                 | LR__0284
023fc     A7 F0 03 F6 | 	mov	ptra, fp
02400     B2 00 A0 FD | 	call	#popregs_
02404                 | _fatfs_cc_disk_write_ret
02404     2D 00 64 FD | 	ret
02408                 | 
02408                 | _fatfs_cc_disk_ioctl
02408     01 4A 05 F6 | 	mov	COUNT_, #1
0240c     A8 00 A0 FD | 	call	#pushregs_
02410     30 F0 07 F1 | 	add	ptra, #48
02414     04 4E 05 F1 | 	add	fp, #4
02418     A7 C2 41 FC | 	wrbyte	arg01, fp
0241c     04 4E 05 F1 | 	add	fp, #4
02420     A7 C4 41 FC | 	wrbyte	arg02, fp
02424     04 4E 05 F1 | 	add	fp, #4
02428     A7 C6 61 FC | 	wrlong	arg03, fp
0242c     08 4E 85 F1 | 	sub	fp, #8
02430     A7 C2 C9 FA | 	rdbyte	arg01, fp wz
02434     04 4E 85 F1 | 	sub	fp, #4
02438     01 A6 05 56 |  if_ne	mov	result1, #1
0243c                 | ' 
0243c                 | ' 	return Stat;
0243c     24 90 05 A1 |  if_e	add	objptr, #36
02440     C8 A6 C1 AA |  if_e	rdbyte	result1, objptr
02444     24 90 85 A1 |  if_e	sub	objptr, #36
02448     D3 A6 E1 F8 | 	getbyte	result1, result1, #0
0244c     01 A6 CD F7 | 	test	result1, #1 wz
02450     03 A6 05 56 |  if_ne	mov	result1, #3
02454     E0 01 90 5D |  if_ne	jmp	#LR__0298
02458     10 4E 05 F1 | 	add	fp, #16
0245c     A7 02 68 FC | 	wrlong	#1, fp
02460                 | ' 
02460                 | ' 	res = RES_ERROR;
02460                 | ' 	switch (ctrl) {
02460     08 4E 85 F1 | 	sub	fp, #8
02464     A7 D8 C1 FA | 	rdbyte	local01, fp
02468     08 4E 85 F1 | 	sub	fp, #8
0246c     04 D8 25 F3 | 	fle	local01, #4
02470     30 D8 61 FD | 	jmprel	local01
02474                 | LR__0290
02474     10 00 90 FD | 	jmp	#LR__0291
02478     24 00 90 FD | 	jmp	#LR__0292
0247c     9C 01 90 FD | 	jmp	#LR__0296
02480     7C 01 90 FD | 	jmp	#LR__0295
02484     94 01 90 FD | 	jmp	#LR__0296
02488                 | LR__0291
02488     24 60 B0 FD | 	call	#_fatfs_cc_select_0655
0248c     00 A6 0D F2 | 	cmp	result1, #0 wz
02490     10 4E 05 51 |  if_ne	add	fp, #16
02494     A7 00 68 5C |  if_ne	wrlong	#0, fp
02498     10 4E 85 51 |  if_ne	sub	fp, #16
0249c                 | ' 			break;
0249c     88 01 90 FD | 	jmp	#LR__0297
024a0                 | LR__0292
024a0     09 C2 05 F6 | 	mov	arg01, #9
024a4     00 C4 05 F6 | 	mov	arg02, #0
024a8     78 61 B0 FD | 	call	#_fatfs_cc_send_cmd_0664
024ac     D3 D8 01 F6 | 	mov	local01, result1
024b0     07 D8 4D F7 | 	zerox	local01, #7 wz
024b4     70 01 90 5D |  if_ne	jmp	#LR__0297
024b8     A7 C2 01 F6 | 	mov	arg01, fp
024bc     18 C2 05 F1 | 	add	arg01, #24
024c0     10 C4 05 F6 | 	mov	arg02, #16
024c4     4C 60 B0 FD | 	call	#_fatfs_cc_rcvr_datablock_0659
024c8     00 A6 0D F2 | 	cmp	result1, #0 wz
024cc     58 01 90 AD |  if_e	jmp	#LR__0297
024d0     18 4E 05 F1 | 	add	fp, #24
024d4     A7 D8 C1 FA | 	rdbyte	local01, fp
024d8     18 4E 85 F1 | 	sub	fp, #24
024dc     06 D8 45 F0 | 	shr	local01, #6
024e0     01 D8 0D F2 | 	cmp	local01, #1 wz
024e4     5C 00 90 5D |  if_ne	jmp	#LR__0293
024e8     21 4E 05 F1 | 	add	fp, #33
024ec     A7 D8 C1 FA | 	rdbyte	local01, fp
024f0     01 4E 85 F1 | 	sub	fp, #1
024f4     A7 A6 C1 FA | 	rdbyte	result1, fp
024f8     D3 A6 31 F9 | 	getword	result1, result1, #0
024fc     08 A6 65 F0 | 	shl	result1, #8
02500     D3 D8 01 F1 | 	add	local01, result1
02504     01 4E 85 F1 | 	sub	fp, #1
02508     A7 A6 C1 FA | 	rdbyte	result1, fp
0250c     3F A6 05 F5 | 	and	result1, #63
02510     10 A6 65 F0 | 	shl	result1, #16
02514     D3 D8 01 F1 | 	add	local01, result1
02518     01 D8 05 F1 | 	add	local01, #1
0251c     09 4E 05 F1 | 	add	fp, #9
02520     A7 D8 61 FC | 	wrlong	local01, fp
02524     1C 4E 85 F1 | 	sub	fp, #28
02528     A7 D8 01 FB | 	rdlong	local01, fp
0252c     1C 4E 05 F1 | 	add	fp, #28
02530     A7 A6 01 FB | 	rdlong	result1, fp
02534     28 4E 85 F1 | 	sub	fp, #40
02538     0A A6 65 F0 | 	shl	result1, #10
0253c     EC A6 61 FC | 	wrlong	result1, local01
02540     AC 00 90 FD | 	jmp	#LR__0294
02544                 | LR__0293
02544     1D 4E 05 F1 | 	add	fp, #29
02548     A7 D8 C1 FA | 	rdbyte	local01, fp
0254c     EC D8 41 F8 | 	getnib	local01, local01, #0
02550     05 4E 05 F1 | 	add	fp, #5
02554     A7 A6 C1 FA | 	rdbyte	result1, fp
02558     80 A6 05 F5 | 	and	result1, #128
0255c     07 A6 C5 F0 | 	sar	result1, #7
02560     D3 D8 01 F1 | 	add	local01, result1
02564     01 4E 85 F1 | 	sub	fp, #1
02568     A7 A6 C1 FA | 	rdbyte	result1, fp
0256c     03 A6 05 F5 | 	and	result1, #3
02570     01 A6 65 F0 | 	shl	result1, #1
02574     D3 D8 01 F1 | 	add	local01, result1
02578     02 D8 05 F1 | 	add	local01, #2
0257c     0D 4E 85 F1 | 	sub	fp, #13
02580     A7 D8 41 FC | 	wrbyte	local01, fp
02584     0C 4E 05 F1 | 	add	fp, #12
02588     A7 D8 C1 FA | 	rdbyte	local01, fp
0258c     06 D8 45 F0 | 	shr	local01, #6
02590     01 4E 85 F1 | 	sub	fp, #1
02594     A7 A6 C1 FA | 	rdbyte	result1, fp
02598     D3 A6 31 F9 | 	getword	result1, result1, #0
0259c     02 A6 65 F0 | 	shl	result1, #2
025a0     D3 D8 01 F1 | 	add	local01, result1
025a4     01 4E 85 F1 | 	sub	fp, #1
025a8     A7 A6 C1 FA | 	rdbyte	result1, fp
025ac     03 A6 05 F5 | 	and	result1, #3
025b0     D3 A6 31 F9 | 	getword	result1, result1, #0
025b4     0A A6 65 F0 | 	shl	result1, #10
025b8     D3 D8 01 F1 | 	add	local01, result1
025bc     01 D8 05 F1 | 	add	local01, #1
025c0     0A 4E 05 F1 | 	add	fp, #10
025c4     A7 D8 61 FC | 	wrlong	local01, fp
025c8     1C 4E 85 F1 | 	sub	fp, #28
025cc     A7 D8 01 FB | 	rdlong	local01, fp
025d0     1C 4E 05 F1 | 	add	fp, #28
025d4     A7 A6 01 FB | 	rdlong	result1, fp
025d8     14 4E 85 F1 | 	sub	fp, #20
025dc     A7 C6 C1 FA | 	rdbyte	arg03, fp
025e0     14 4E 85 F1 | 	sub	fp, #20
025e4     09 C6 85 F1 | 	sub	arg03, #9
025e8     E3 A6 61 F0 | 	shl	result1, arg03
025ec     EC A6 61 FC | 	wrlong	result1, local01
025f0                 | LR__0294
025f0     10 4E 05 F1 | 	add	fp, #16
025f4     A7 00 68 FC | 	wrlong	#0, fp
025f8     10 4E 85 F1 | 	sub	fp, #16
025fc                 | ' 					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
025fc                 | ' 					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
025fc                 | ' 					*(LBA_t*)buff = cs << (n - 9);
025fc                 | ' 				}
025fc                 | ' 				res = RES_OK;
025fc                 | ' 			}
025fc                 | ' 			break;
025fc     28 00 90 FD | 	jmp	#LR__0297
02600                 | LR__0295
02600     0C 4E 05 F1 | 	add	fp, #12
02604     A7 D8 01 FB | 	rdlong	local01, fp
02608     EC 00 69 FC | 	wrlong	#128, local01
0260c     04 4E 05 F1 | 	add	fp, #4
02610     A7 00 68 FC | 	wrlong	#0, fp
02614     10 4E 85 F1 | 	sub	fp, #16
02618                 | ' 			*(DWORD*)buff = 128;
02618                 | ' 			res = RES_OK;
02618                 | ' 			break;
02618     0C 00 90 FD | 	jmp	#LR__0297
0261c                 | LR__0296
0261c     10 4E 05 F1 | 	add	fp, #16
02620     A7 08 68 FC | 	wrlong	#4, fp
02624     10 4E 85 F1 | 	sub	fp, #16
02628                 | LR__0297
02628     48 5E B0 FD | 	call	#_fatfs_cc_deselect_0651
0262c                 | ' 			res = RES_PARERR;
0262c                 | ' 	}
0262c                 | ' 
0262c                 | ' 	deselect();
0262c                 | ' 
0262c                 | ' 	return res;
0262c     10 4E 05 F1 | 	add	fp, #16
02630     A7 A6 01 FB | 	rdlong	result1, fp
02634     10 4E 85 F1 | 	sub	fp, #16
02638                 | LR__0298
02638     A7 F0 03 F6 | 	mov	ptra, fp
0263c     B2 00 A0 FD | 	call	#popregs_
02640                 | _fatfs_cc_disk_ioctl_ret
02640     2D 00 64 FD | 	ret
02644                 | 
02644                 | _fatfs_cc_disk_setpins
02644     00 C2 0D F2 | 	cmp	arg01, #0 wz
02648     01 A6 65 56 |  if_ne	neg	result1, #1
0264c     28 00 90 5D |  if_ne	jmp	#_fatfs_cc_disk_setpins_ret
02650     10 90 05 F1 | 	add	objptr, #16
02654     C8 C4 61 FC | 	wrlong	arg02, objptr
02658     04 90 05 F1 | 	add	objptr, #4
0265c     C8 C6 61 FC | 	wrlong	arg03, objptr
02660     04 90 05 F1 | 	add	objptr, #4
02664     C8 C8 61 FC | 	wrlong	arg04, objptr
02668     04 90 05 F1 | 	add	objptr, #4
0266c     C8 CA 61 FC | 	wrlong	arg05, objptr
02670     1C 90 85 F1 | 	sub	objptr, #28
02674     00 A6 05 F6 | 	mov	result1, #0
02678                 | _fatfs_cc_disk_setpins_ret
02678     2D 00 64 FD | 	ret
0267c                 | 
0267c                 | _fatfs_cc_sync_window
0267c     02 4A 05 F6 | 	mov	COUNT_, #2
02680     A8 00 A0 FD | 	call	#pushregs_
02684     E1 D8 01 F6 | 	mov	local01, arg01
02688     00 DA 05 F6 | 	mov	local02, #0
0268c     03 D8 05 F1 | 	add	local01, #3
02690     EC A6 C9 FA | 	rdbyte	result1, local01 wz
02694     03 D8 85 F1 | 	sub	local01, #3
02698     A4 00 90 AD |  if_e	jmp	#LR__0302
0269c     01 D8 05 F1 | 	add	local01, #1
026a0     EC C2 C1 FA | 	rdbyte	arg01, local01
026a4     2F D8 05 F1 | 	add	local01, #47
026a8     EC C4 01 F6 | 	mov	arg02, local01
026ac     04 D8 85 F1 | 	sub	local01, #4
026b0     EC C6 01 FB | 	rdlong	arg03, local01
026b4     2C D8 85 F1 | 	sub	local01, #44
026b8     01 C8 05 F6 | 	mov	arg04, #1
026bc     40 FC BF FD | 	call	#_fatfs_cc_disk_write
026c0     00 A6 0D F2 | 	cmp	result1, #0 wz
026c4     74 00 90 5D |  if_ne	jmp	#LR__0300
026c8     03 D8 05 F1 | 	add	local01, #3
026cc     EC 00 48 FC | 	wrbyte	#0, local01
026d0     29 D8 05 F1 | 	add	local01, #41
026d4     EC A6 01 FB | 	rdlong	result1, local01
026d8     0C D8 85 F1 | 	sub	local01, #12
026dc     EC C8 01 FB | 	rdlong	arg04, local01
026e0     E4 A6 81 F1 | 	sub	result1, arg04
026e4     08 D8 85 F1 | 	sub	local01, #8
026e8     EC C8 01 FB | 	rdlong	arg04, local01
026ec     18 D8 85 F1 | 	sub	local01, #24
026f0     E4 A6 11 F2 | 	cmp	result1, arg04 wc
026f4     48 00 90 3D |  if_ae	jmp	#LR__0301
026f8     02 D8 05 F1 | 	add	local01, #2
026fc     EC C8 C1 FA | 	rdbyte	arg04, local01
02700     02 D8 85 F1 | 	sub	local01, #2
02704     02 C8 0D F2 | 	cmp	arg04, #2 wz
02708     34 00 90 5D |  if_ne	jmp	#LR__0301
0270c     01 D8 05 F1 | 	add	local01, #1
02710     EC C2 C1 FA | 	rdbyte	arg01, local01
02714     2F D8 05 F1 | 	add	local01, #47
02718     EC C4 01 F6 | 	mov	arg02, local01
0271c     04 D8 85 F1 | 	sub	local01, #4
02720     EC C6 01 FB | 	rdlong	arg03, local01
02724     14 D8 85 F1 | 	sub	local01, #20
02728     EC D8 01 FB | 	rdlong	local01, local01
0272c     EC C6 01 F1 | 	add	arg03, local01
02730     01 C8 05 F6 | 	mov	arg04, #1
02734     C8 FB BF FD | 	call	#_fatfs_cc_disk_write
02738     04 00 90 FD | 	jmp	#LR__0301
0273c                 | LR__0300
0273c     01 DA 05 F6 | 	mov	local02, #1
02740                 | LR__0301
02740                 | LR__0302
02740                 | ' 			res = FR_DISK_ERR;
02740                 | ' 		}
02740                 | ' 	}
02740                 | ' 	return res;
02740     ED A6 01 F6 | 	mov	result1, local02
02744     A7 F0 03 F6 | 	mov	ptra, fp
02748     B2 00 A0 FD | 	call	#popregs_
0274c                 | _fatfs_cc_sync_window_ret
0274c     2D 00 64 FD | 	ret
02750                 | 
02750                 | _fatfs_cc_move_window
02750     03 4A 05 F6 | 	mov	COUNT_, #3
02754     A8 00 A0 FD | 	call	#pushregs_
02758     E1 D8 01 F6 | 	mov	local01, arg01
0275c     E2 DA 01 F6 | 	mov	local02, arg02
02760     00 DC 05 F6 | 	mov	local03, #0
02764     2C D8 05 F1 | 	add	local01, #44
02768     EC C8 01 FB | 	rdlong	arg04, local01
0276c     2C D8 85 F1 | 	sub	local01, #44
02770     E4 DA 09 F2 | 	cmp	local02, arg04 wz
02774     40 00 90 AD |  if_e	jmp	#LR__0311
02778     EC C2 01 F6 | 	mov	arg01, local01
0277c     FC FE BF FD | 	call	#_fatfs_cc_sync_window
02780     D3 DC 09 F6 | 	mov	local03, result1 wz
02784     30 00 90 5D |  if_ne	jmp	#LR__0310
02788     01 D8 05 F1 | 	add	local01, #1
0278c     EC C2 C1 FA | 	rdbyte	arg01, local01
02790     2F D8 05 F1 | 	add	local01, #47
02794     EC C4 01 F6 | 	mov	arg02, local01
02798     ED C6 01 F6 | 	mov	arg03, local02
0279c     01 C8 05 F6 | 	mov	arg04, #1
027a0     9C FA BF FD | 	call	#_fatfs_cc_disk_read
027a4     00 A6 0D F2 | 	cmp	result1, #0 wz
027a8     01 DA 65 56 |  if_ne	neg	local02, #1
027ac     01 DC 05 56 |  if_ne	mov	local03, #1
027b0     04 D8 85 F1 | 	sub	local01, #4
027b4     EC DA 61 FC | 	wrlong	local02, local01
027b8                 | LR__0310
027b8                 | LR__0311
027b8                 | ' 				sect = (LBA_t)0 - 1;
027b8                 | ' 				res = FR_DISK_ERR;
027b8                 | ' 			}
027b8                 | ' 			fs->winsect = sect;
027b8                 | ' 		}
027b8                 | ' 	}
027b8                 | ' 	return res;
027b8     EE A6 01 F6 | 	mov	result1, local03
027bc     A7 F0 03 F6 | 	mov	ptra, fp
027c0     B2 00 A0 FD | 	call	#popregs_
027c4                 | _fatfs_cc_move_window_ret
027c4     2D 00 64 FD | 	ret
027c8                 | 
027c8                 | _fatfs_cc_sync_fs
027c8     02 4A 05 F6 | 	mov	COUNT_, #2
027cc     A8 00 A0 FD | 	call	#pushregs_
027d0     E1 D8 01 F6 | 	mov	local01, arg01
027d4     A4 FE BF FD | 	call	#_fatfs_cc_sync_window
027d8     D3 DA 09 F6 | 	mov	local02, result1 wz
027dc     D8 00 90 5D |  if_ne	jmp	#LR__0321
027e0     EC C8 C1 FA | 	rdbyte	arg04, local01
027e4     03 C8 0D F2 | 	cmp	arg04, #3 wz
027e8     04 D8 05 A1 |  if_e	add	local01, #4
027ec     EC C8 C1 AA |  if_e	rdbyte	arg04, local01
027f0     04 D8 85 A1 |  if_e	sub	local01, #4
027f4     01 C8 0D A2 |  if_e	cmp	arg04, #1 wz
027f8     A0 00 90 5D |  if_ne	jmp	#LR__0320
027fc     30 D8 05 F1 | 	add	local01, #48
02800     EC C2 01 F6 | 	mov	arg01, local01
02804     00 C4 05 F6 | 	mov	arg02, #0
02808     09 C6 C5 F9 | 	decod	arg03, #9
0280c     98 00 A0 FD | 	call	#\builtin_bytefill_
02810     EC C2 01 F6 | 	mov	arg01, local01
02814     FE C3 05 F1 | 	add	arg01, #510
02818     55 00 80 FF 
0281c     E1 AA 58 FC | 	wrword	##43605, arg01
02820     A9 B0 A0 FF 
02824     EC A4 68 FC | 	wrlong	##1096897106, local01
02828     EC C2 01 F6 | 	mov	arg01, local01
0282c     E4 C3 05 F1 | 	add	arg01, #484
02830     B9 A0 B0 FF 
02834     E1 E4 68 FC | 	wrlong	##1631679090, arg01
02838     EC C2 01 F6 | 	mov	arg01, local01
0283c     E8 C3 05 F1 | 	add	arg01, #488
02840     20 D8 85 F1 | 	sub	local01, #32
02844     EC C4 01 FB | 	rdlong	arg02, local01
02848     E1 C4 61 FC | 	wrlong	arg02, arg01
0284c     20 D8 05 F1 | 	add	local01, #32
02850     EC C2 01 F6 | 	mov	arg01, local01
02854     EC C3 05 F1 | 	add	arg01, #492
02858     24 D8 85 F1 | 	sub	local01, #36
0285c     EC C4 01 FB | 	rdlong	arg02, local01
02860     E1 C4 61 FC | 	wrlong	arg02, arg01
02864     10 D8 05 F1 | 	add	local01, #16
02868     EC C6 01 FB | 	rdlong	arg03, local01
0286c     01 C6 05 F1 | 	add	arg03, #1
02870     10 D8 05 F1 | 	add	local01, #16
02874     EC C6 61 FC | 	wrlong	arg03, local01
02878     2B D8 85 F1 | 	sub	local01, #43
0287c     EC C2 C1 FA | 	rdbyte	arg01, local01
02880     2F D8 05 F1 | 	add	local01, #47
02884     EC C4 01 F6 | 	mov	arg02, local01
02888     01 C8 05 F6 | 	mov	arg04, #1
0288c     70 FA BF FD | 	call	#_fatfs_cc_disk_write
02890     2C D8 85 F1 | 	sub	local01, #44
02894     EC 00 48 FC | 	wrbyte	#0, local01
02898     04 D8 85 F1 | 	sub	local01, #4
0289c                 | LR__0320
0289c     01 D8 05 F1 | 	add	local01, #1
028a0     EC C2 C1 FA | 	rdbyte	arg01, local01
028a4     00 C4 05 F6 | 	mov	arg02, #0
028a8     00 C6 05 F6 | 	mov	arg03, #0
028ac     58 FB BF FD | 	call	#_fatfs_cc_disk_ioctl
028b0     00 A6 0D F2 | 	cmp	result1, #0 wz
028b4     01 DA 05 56 |  if_ne	mov	local02, #1
028b8                 | LR__0321
028b8                 | ' 	}
028b8                 | ' 
028b8                 | ' 	return res;
028b8     ED A6 01 F6 | 	mov	result1, local02
028bc     A7 F0 03 F6 | 	mov	ptra, fp
028c0     B2 00 A0 FD | 	call	#popregs_
028c4                 | _fatfs_cc_sync_fs_ret
028c4     2D 00 64 FD | 	ret
028c8                 | 
028c8                 | _fatfs_cc_clst2sect
028c8     02 C4 85 F1 | 	sub	arg02, #2
028cc     14 C2 05 F1 | 	add	arg01, #20
028d0     E1 AA 01 FB | 	rdlong	_var01, arg01
028d4     14 C2 85 F1 | 	sub	arg01, #20
028d8     02 AA 85 F1 | 	sub	_var01, #2
028dc     D5 C4 11 F2 | 	cmp	arg02, _var01 wc
028e0     00 A6 05 36 |  if_ae	mov	result1, #0
028e4     1C 00 90 3D |  if_ae	jmp	#_fatfs_cc_clst2sect_ret
028e8     0A C2 05 F1 | 	add	arg01, #10
028ec     E1 AA E1 FA | 	rdword	_var01, arg01
028f0     E2 AA 01 FD | 	qmul	_var01, arg02
028f4                 | ' 	return fs->database + (LBA_t)fs->csize * clst;
028f4     1E C2 05 F1 | 	add	arg01, #30
028f8     E1 A6 01 FB | 	rdlong	result1, arg01
028fc     18 AA 61 FD | 	getqx	_var01
02900     D5 A6 01 F1 | 	add	result1, _var01
02904                 | _fatfs_cc_clst2sect_ret
02904     2D 00 64 FD | 	ret
02908                 | 
02908                 | _fatfs_cc_get_fat
02908     07 4A 05 F6 | 	mov	COUNT_, #7
0290c     A8 00 A0 FD | 	call	#pushregs_
02910     E2 D8 01 F6 | 	mov	local01, arg02
02914     E1 DA 01 FB | 	rdlong	local02, arg01
02918     02 D8 15 F2 | 	cmp	local01, #2 wc
0291c     14 00 90 CD |  if_b	jmp	#LR__0330
02920     14 DA 05 F1 | 	add	local02, #20
02924     ED DC 01 FB | 	rdlong	local03, local02
02928     14 DA 85 F1 | 	sub	local02, #20
0292c     EE D8 11 F2 | 	cmp	local01, local03 wc
02930     08 00 90 CD |  if_b	jmp	#LR__0331
02934                 | LR__0330
02934     01 DE 05 F6 | 	mov	local04, #1
02938     60 01 90 FD | 	jmp	#LR__0338
0293c                 | LR__0331
0293c     01 DE 65 F6 | 	neg	local04, #1
02940                 | ' 		val = 0xFFFFFFFF;
02940                 | ' 
02940                 | ' 		switch (fs->fs_type) {
02940     ED E0 C1 FA | 	rdbyte	local05, local02
02944     01 E0 85 F1 | 	sub	local05, #1
02948     03 E0 25 F3 | 	fle	local05, #3
0294c     30 E0 61 FD | 	jmprel	local05
02950                 | LR__0332
02950     0C 00 90 FD | 	jmp	#LR__0333
02954     B8 00 90 FD | 	jmp	#LR__0334
02958     F8 00 90 FD | 	jmp	#LR__0335
0295c     38 01 90 FD | 	jmp	#LR__0336
02960                 | LR__0333
02960     EC E0 01 F6 | 	mov	local05, local01
02964     EC C2 01 F6 | 	mov	arg01, local01
02968     01 C2 45 F0 | 	shr	arg01, #1
0296c     E1 E0 01 F1 | 	add	local05, arg01
02970     ED C2 01 F6 | 	mov	arg01, local02
02974     F0 E2 01 F6 | 	mov	local06, local05
02978     09 E2 45 F0 | 	shr	local06, #9
0297c     20 DA 05 F1 | 	add	local02, #32
02980     ED C4 01 FB | 	rdlong	arg02, local02
02984     20 DA 85 F1 | 	sub	local02, #32
02988     F1 C4 01 F1 | 	add	arg02, local06
0298c     C0 FD BF FD | 	call	#_fatfs_cc_move_window
02990     00 A6 0D F2 | 	cmp	result1, #0 wz
02994     04 01 90 5D |  if_ne	jmp	#LR__0337
02998     F0 E2 01 F6 | 	mov	local06, local05
0299c     FF E3 05 F5 | 	and	local06, #511
029a0     ED C2 01 F6 | 	mov	arg01, local02
029a4     30 C2 05 F1 | 	add	arg01, #48
029a8     E1 E2 01 F1 | 	add	local06, arg01
029ac     F1 E4 C1 FA | 	rdbyte	local07, local06
029b0     ED C2 01 F6 | 	mov	arg01, local02
029b4     01 E0 05 F1 | 	add	local05, #1
029b8     F0 E2 01 F6 | 	mov	local06, local05
029bc     09 E2 45 F0 | 	shr	local06, #9
029c0     20 DA 05 F1 | 	add	local02, #32
029c4     ED C4 01 FB | 	rdlong	arg02, local02
029c8     20 DA 85 F1 | 	sub	local02, #32
029cc     F1 C4 01 F1 | 	add	arg02, local06
029d0     7C FD BF FD | 	call	#_fatfs_cc_move_window
029d4     00 A6 0D F2 | 	cmp	result1, #0 wz
029d8     C0 00 90 5D |  if_ne	jmp	#LR__0337
029dc     FF E1 05 F5 | 	and	local05, #511
029e0     30 DA 05 F1 | 	add	local02, #48
029e4     ED E0 01 F1 | 	add	local05, local02
029e8     F0 E2 C1 FA | 	rdbyte	local06, local05
029ec     08 E2 65 F0 | 	shl	local06, #8
029f0     F1 E4 41 F5 | 	or	local07, local06
029f4     01 D8 CD F7 | 	test	local01, #1 wz
029f8     04 E4 45 50 |  if_ne	shr	local07, #4
029fc     F2 DC 01 56 |  if_ne	mov	local03, local07
02a00     0B E4 45 A7 |  if_e	zerox	local07, #11
02a04     F2 DC 01 A6 |  if_e	mov	local03, local07
02a08     EE DE 01 F6 | 	mov	local04, local03
02a0c                 | ' 			wc |= fs->win[bc %  ((UINT) 512 ) ] << 8;
02a0c                 | ' 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
02a0c                 | ' 			break;
02a0c     8C 00 90 FD | 	jmp	#LR__0337
02a10                 | LR__0334
02a10     ED C2 01 F6 | 	mov	arg01, local02
02a14     EC E2 01 F6 | 	mov	local06, local01
02a18     08 E2 45 F0 | 	shr	local06, #8
02a1c     20 DA 05 F1 | 	add	local02, #32
02a20     ED C4 01 FB | 	rdlong	arg02, local02
02a24     20 DA 85 F1 | 	sub	local02, #32
02a28     F1 C4 01 F1 | 	add	arg02, local06
02a2c     20 FD BF FD | 	call	#_fatfs_cc_move_window
02a30     00 A6 0D F2 | 	cmp	result1, #0 wz
02a34     64 00 90 5D |  if_ne	jmp	#LR__0337
02a38     30 DA 05 F1 | 	add	local02, #48
02a3c     01 D8 65 F0 | 	shl	local01, #1
02a40     FF D9 05 F5 | 	and	local01, #511
02a44     EC DA 01 F1 | 	add	local02, local01
02a48                 | ' {
02a48                 | ' 
02a48                 | ' 	return *((WORD*)ptr);
02a48     ED A6 E1 FA | 	rdword	result1, local02
02a4c     D3 DE 31 F9 | 	getword	local04, result1, #0
02a50                 | ' 			val = ld_word(fs->win + clst * 2 %  ((UINT) 512 ) );
02a50                 | ' 			break;
02a50     48 00 90 FD | 	jmp	#LR__0337
02a54                 | LR__0335
02a54     ED C2 01 F6 | 	mov	arg01, local02
02a58     EC E2 01 F6 | 	mov	local06, local01
02a5c     07 E2 45 F0 | 	shr	local06, #7
02a60     20 DA 05 F1 | 	add	local02, #32
02a64     ED C4 01 FB | 	rdlong	arg02, local02
02a68     20 DA 85 F1 | 	sub	local02, #32
02a6c     F1 C4 01 F1 | 	add	arg02, local06
02a70     DC FC BF FD | 	call	#_fatfs_cc_move_window
02a74     00 A6 0D F2 | 	cmp	result1, #0 wz
02a78     20 00 90 5D |  if_ne	jmp	#LR__0337
02a7c     30 DA 05 F1 | 	add	local02, #48
02a80     02 D8 65 F0 | 	shl	local01, #2
02a84     FF D9 05 F5 | 	and	local01, #511
02a88     EC DA 01 F1 | 	add	local02, local01
02a8c                 | ' {
02a8c                 | ' 
02a8c                 | ' 	return *((DWORD*)ptr);
02a8c     ED DE 01 FB | 	rdlong	local04, local02
02a90     7C DE 05 F4 | 	bitl	local04, #124
02a94                 | ' 			val = ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0x0FFFFFFF;
02a94                 | ' 			break;
02a94     04 00 90 FD | 	jmp	#LR__0337
02a98                 | LR__0336
02a98     01 DE 05 F6 | 	mov	local04, #1
02a9c                 | LR__0337
02a9c                 | LR__0338
02a9c                 | ' 			val = 1;
02a9c                 | ' 		}
02a9c                 | ' 	}
02a9c                 | ' 
02a9c                 | ' 	return val;
02a9c     EF A6 01 F6 | 	mov	result1, local04
02aa0     A7 F0 03 F6 | 	mov	ptra, fp
02aa4     B2 00 A0 FD | 	call	#popregs_
02aa8                 | _fatfs_cc_get_fat_ret
02aa8     2D 00 64 FD | 	ret
02aac                 | 
02aac                 | _fatfs_cc_put_fat
02aac     08 4A 05 F6 | 	mov	COUNT_, #8
02ab0     A8 00 A0 FD | 	call	#pushregs_
02ab4     E1 D8 01 F6 | 	mov	local01, arg01
02ab8     E2 DA 01 F6 | 	mov	local02, arg02
02abc     E3 DC 01 F6 | 	mov	local03, arg03
02ac0     02 DE 05 F6 | 	mov	local04, #2
02ac4     02 DA 15 F2 | 	cmp	local02, #2 wc
02ac8     E0 01 90 CD |  if_b	jmp	#LR__0347
02acc     14 D8 05 F1 | 	add	local01, #20
02ad0     EC E0 01 FB | 	rdlong	local05, local01
02ad4     14 D8 85 F1 | 	sub	local01, #20
02ad8     F0 DA 11 F2 | 	cmp	local02, local05 wc
02adc     CC 01 90 3D |  if_ae	jmp	#LR__0347
02ae0                 | ' 		switch (fs->fs_type) {
02ae0     EC E2 C1 FA | 	rdbyte	local06, local01
02ae4     01 E2 85 F1 | 	sub	local06, #1
02ae8     03 E2 25 F3 | 	fle	local06, #3
02aec     30 E2 61 FD | 	jmprel	local06
02af0                 | LR__0340
02af0     0C 00 90 FD | 	jmp	#LR__0341
02af4     F4 00 90 FD | 	jmp	#LR__0344
02af8     3C 01 90 FD | 	jmp	#LR__0345
02afc     AC 01 90 FD | 	jmp	#LR__0346
02b00                 | LR__0341
02b00     ED E4 01 F6 | 	mov	local07, local02
02b04     ED E0 01 F6 | 	mov	local05, local02
02b08     01 E0 45 F0 | 	shr	local05, #1
02b0c     F0 E4 01 F1 | 	add	local07, local05
02b10     EC C2 01 F6 | 	mov	arg01, local01
02b14     F2 E2 01 F6 | 	mov	local06, local07
02b18     09 E2 45 F0 | 	shr	local06, #9
02b1c     20 D8 05 F1 | 	add	local01, #32
02b20     EC C4 01 FB | 	rdlong	arg02, local01
02b24     20 D8 85 F1 | 	sub	local01, #32
02b28     F1 C4 01 F1 | 	add	arg02, local06
02b2c     20 FC BF FD | 	call	#_fatfs_cc_move_window
02b30     D3 DE 09 F6 | 	mov	local04, result1 wz
02b34     74 01 90 5D |  if_ne	jmp	#LR__0346
02b38     EC E6 01 F6 | 	mov	local08, local01
02b3c     30 E6 05 F1 | 	add	local08, #48
02b40     F2 E0 01 F6 | 	mov	local05, local07
02b44     FF E1 05 F5 | 	and	local05, #511
02b48     F0 E6 01 F1 | 	add	local08, local05
02b4c     01 DA CD F7 | 	test	local02, #1 wz
02b50     01 E4 05 F1 | 	add	local07, #1
02b54     18 00 90 AD |  if_e	jmp	#LR__0342
02b58     F3 E0 C1 FA | 	rdbyte	local05, local08
02b5c     F0 E0 41 F8 | 	getnib	local05, local05, #0
02b60     EE E2 E1 F8 | 	getbyte	local06, local03, #0
02b64     04 E2 65 F0 | 	shl	local06, #4
02b68     F1 E0 41 F5 | 	or	local05, local06
02b6c     04 00 90 FD | 	jmp	#LR__0343
02b70                 | LR__0342
02b70     EE E0 01 F6 | 	mov	local05, local03
02b74                 | LR__0343
02b74     F3 E0 41 FC | 	wrbyte	local05, local08
02b78     03 D8 05 F1 | 	add	local01, #3
02b7c     EC 02 48 FC | 	wrbyte	#1, local01
02b80     03 D8 85 F1 | 	sub	local01, #3
02b84     EC C2 01 F6 | 	mov	arg01, local01
02b88     F2 E6 01 F6 | 	mov	local08, local07
02b8c     09 E6 45 F0 | 	shr	local08, #9
02b90     20 D8 05 F1 | 	add	local01, #32
02b94     EC C4 01 FB | 	rdlong	arg02, local01
02b98     20 D8 85 F1 | 	sub	local01, #32
02b9c     F3 C4 01 F1 | 	add	arg02, local08
02ba0     AC FB BF FD | 	call	#_fatfs_cc_move_window
02ba4     D3 DE 09 F6 | 	mov	local04, result1 wz
02ba8     00 01 90 5D |  if_ne	jmp	#LR__0346
02bac     EC E6 01 F6 | 	mov	local08, local01
02bb0     30 E6 05 F1 | 	add	local08, #48
02bb4     FF E5 05 F5 | 	and	local07, #511
02bb8     F2 E6 01 F1 | 	add	local08, local07
02bbc     01 DA CD F7 | 	test	local02, #1 wz
02bc0     04 DC 45 50 |  if_ne	shr	local03, #4
02bc4     EE E0 01 56 |  if_ne	mov	local05, local03
02bc8     F3 E0 C1 AA |  if_e	rdbyte	local05, local08
02bcc     F0 E0 05 A5 |  if_e	and	local05, #240
02bd0     EE DC E9 A8 |  if_e	getbyte	local03, local03, #1
02bd4     EE DC 41 A8 |  if_e	getnib	local03, local03, #0
02bd8     EE E0 41 A5 |  if_e	or	local05, local03
02bdc     F3 E0 41 FC | 	wrbyte	local05, local08
02be0     03 D8 05 F1 | 	add	local01, #3
02be4     EC 02 48 FC | 	wrbyte	#1, local01
02be8                 | ' 			p = fs->win + bc %  ((UINT) 512 ) ;
02be8                 | ' 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
02be8                 | ' 			fs->wflag = 1;
02be8                 | ' 			break;
02be8     C0 00 90 FD | 	jmp	#LR__0346
02bec                 | LR__0344
02bec     EC C2 01 F6 | 	mov	arg01, local01
02bf0     ED E6 01 F6 | 	mov	local08, local02
02bf4     08 E6 45 F0 | 	shr	local08, #8
02bf8     20 D8 05 F1 | 	add	local01, #32
02bfc     EC C4 01 FB | 	rdlong	arg02, local01
02c00     20 D8 85 F1 | 	sub	local01, #32
02c04     F3 C4 01 F1 | 	add	arg02, local08
02c08     44 FB BF FD | 	call	#_fatfs_cc_move_window
02c0c     D3 DE 09 F6 | 	mov	local04, result1 wz
02c10     98 00 90 5D |  if_ne	jmp	#LR__0346
02c14     30 D8 05 F1 | 	add	local01, #48
02c18     EC C2 01 F6 | 	mov	arg01, local01
02c1c     01 DA 65 F0 | 	shl	local02, #1
02c20     FF DB 05 F5 | 	and	local02, #511
02c24     ED C2 01 F1 | 	add	arg01, local02
02c28     E1 DC 51 FC | 	wrword	local03, arg01
02c2c     2D D8 85 F1 | 	sub	local01, #45
02c30     EC 02 48 FC | 	wrbyte	#1, local01
02c34                 | ' 			st_word(fs->win + clst * 2 %  ((UINT) 512 ) , (WORD)val);
02c34                 | ' 			fs->wflag = 1;
02c34                 | ' 			break;
02c34     74 00 90 FD | 	jmp	#LR__0346
02c38                 | LR__0345
02c38     EC C2 01 F6 | 	mov	arg01, local01
02c3c     ED E6 01 F6 | 	mov	local08, local02
02c40     07 E6 45 F0 | 	shr	local08, #7
02c44     20 D8 05 F1 | 	add	local01, #32
02c48     EC C4 01 FB | 	rdlong	arg02, local01
02c4c     20 D8 85 F1 | 	sub	local01, #32
02c50     F3 C4 01 F1 | 	add	arg02, local08
02c54     F8 FA BF FD | 	call	#_fatfs_cc_move_window
02c58     D3 DE 09 F6 | 	mov	local04, result1 wz
02c5c     4C 00 90 5D |  if_ne	jmp	#LR__0346
02c60     7C DC 05 F4 | 	bitl	local03, #124
02c64     EC C2 01 F6 | 	mov	arg01, local01
02c68     30 C2 05 F1 | 	add	arg01, #48
02c6c     ED E6 01 F6 | 	mov	local08, local02
02c70     02 E6 65 F0 | 	shl	local08, #2
02c74     FF E7 05 F5 | 	and	local08, #511
02c78     F3 C2 01 F1 | 	add	arg01, local08
02c7c                 | ' {
02c7c                 | ' 
02c7c                 | ' 	return *((DWORD*)ptr);
02c7c     E1 E6 01 FB | 	rdlong	local08, arg01
02c80     00 00 78 FF 
02c84     00 E6 05 F5 | 	and	local08, ##-268435456
02c88     F3 DC 41 F5 | 	or	local03, local08
02c8c     30 D8 05 F1 | 	add	local01, #48
02c90     EC C2 01 F6 | 	mov	arg01, local01
02c94     02 DA 65 F0 | 	shl	local02, #2
02c98     FF DB 05 F5 | 	and	local02, #511
02c9c     ED C2 01 F1 | 	add	arg01, local02
02ca0     E1 DC 61 FC | 	wrlong	local03, arg01
02ca4     2D D8 85 F1 | 	sub	local01, #45
02ca8     EC 02 48 FC | 	wrbyte	#1, local01
02cac                 | ' 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0xF0000000);
02cac                 | ' 			}
02cac                 | ' 			st_dword(fs->win + clst * 4 %  ((UINT) 512 ) , val);
02cac                 | ' 			fs->wflag = 1;
02cac                 | ' 			break;
02cac                 | LR__0346
02cac                 | LR__0347
02cac                 | ' 		}
02cac                 | ' 	}
02cac                 | ' 	return res;
02cac     EF A6 01 F6 | 	mov	result1, local04
02cb0     A7 F0 03 F6 | 	mov	ptra, fp
02cb4     B2 00 A0 FD | 	call	#popregs_
02cb8                 | _fatfs_cc_put_fat_ret
02cb8     2D 00 64 FD | 	ret
02cbc                 | 
02cbc                 | _fatfs_cc_remove_chain
02cbc     05 4A 05 F6 | 	mov	COUNT_, #5
02cc0     A8 00 A0 FD | 	call	#pushregs_
02cc4     E1 D8 01 F6 | 	mov	local01, arg01
02cc8     E2 DA 01 F6 | 	mov	local02, arg02
02ccc     E3 DC 01 F6 | 	mov	local03, arg03
02cd0     EC DE 01 FB | 	rdlong	local04, local01
02cd4     02 DA 15 F2 | 	cmp	local02, #2 wc
02cd8     14 00 90 CD |  if_b	jmp	#LR__0350
02cdc     14 DE 05 F1 | 	add	local04, #20
02ce0     EF A6 01 FB | 	rdlong	result1, local04
02ce4     14 DE 85 F1 | 	sub	local04, #20
02ce8     D3 DA 11 F2 | 	cmp	local02, result1 wc
02cec     08 00 90 CD |  if_b	jmp	#LR__0351
02cf0                 | LR__0350
02cf0     02 A6 05 F6 | 	mov	result1, #2
02cf4     CC 00 90 FD | 	jmp	#LR__0356
02cf8                 | LR__0351
02cf8     00 DC 0D F2 | 	cmp	local03, #0 wz
02cfc     18 00 90 AD |  if_e	jmp	#LR__0352
02d00     EE C4 01 F6 | 	mov	arg02, local03
02d04     EF C2 01 F6 | 	mov	arg01, local04
02d08     01 C6 65 F6 | 	neg	arg03, #1
02d0c     9C FD BF FD | 	call	#_fatfs_cc_put_fat
02d10     00 A6 0D F2 | 	cmp	result1, #0 wz
02d14     AC 00 90 5D |  if_ne	jmp	#LR__0356
02d18                 | LR__0352
02d18                 | ' 	}
02d18                 | ' 
02d18                 | ' 
02d18                 | ' 	do {
02d18                 | LR__0353
02d18     ED C4 01 F6 | 	mov	arg02, local02
02d1c     EC C2 01 F6 | 	mov	arg01, local01
02d20     E4 FB BF FD | 	call	#_fatfs_cc_get_fat
02d24     D3 E0 09 F6 | 	mov	local05, result1 wz
02d28     94 00 90 AD |  if_e	jmp	#LR__0355
02d2c     01 E0 0D F2 | 	cmp	local05, #1 wz
02d30     02 A6 05 A6 |  if_e	mov	result1, #2
02d34     8C 00 90 AD |  if_e	jmp	#LR__0356
02d38     FF FF 7F FF 
02d3c     FF E1 0D F2 | 	cmp	local05, ##-1 wz
02d40     01 A6 05 A6 |  if_e	mov	result1, #1
02d44     7C 00 90 AD |  if_e	jmp	#LR__0356
02d48     ED C4 01 F6 | 	mov	arg02, local02
02d4c     EF C2 01 F6 | 	mov	arg01, local04
02d50     00 C6 05 F6 | 	mov	arg03, #0
02d54     54 FD BF FD | 	call	#_fatfs_cc_put_fat
02d58     D3 DC 09 F6 | 	mov	local03, result1 wz
02d5c     EE A6 01 56 |  if_ne	mov	result1, local03
02d60     60 00 90 5D |  if_ne	jmp	#LR__0356
02d64     14 DE 05 F1 | 	add	local04, #20
02d68     EF DC 01 FB | 	rdlong	local03, local04
02d6c     02 DC 85 F1 | 	sub	local03, #2
02d70     04 DE 85 F1 | 	sub	local04, #4
02d74     EF DA 01 FB | 	rdlong	local02, local04
02d78     10 DE 85 F1 | 	sub	local04, #16
02d7c     EE DA 11 F2 | 	cmp	local02, local03 wc
02d80     24 00 90 3D |  if_ae	jmp	#LR__0354
02d84     10 DE 05 F1 | 	add	local04, #16
02d88     EF DC 01 FB | 	rdlong	local03, local04
02d8c     01 DC 05 F1 | 	add	local03, #1
02d90     EF DC 61 FC | 	wrlong	local03, local04
02d94     0C DE 85 F1 | 	sub	local04, #12
02d98     EF DC C1 FA | 	rdbyte	local03, local04
02d9c     01 DC 45 F5 | 	or	local03, #1
02da0     EF DC 41 FC | 	wrbyte	local03, local04
02da4     04 DE 85 F1 | 	sub	local04, #4
02da8                 | LR__0354
02da8     F0 DA 01 F6 | 	mov	local02, local05
02dac     14 DE 05 F1 | 	add	local04, #20
02db0     EF E0 01 FB | 	rdlong	local05, local04
02db4     14 DE 85 F1 | 	sub	local04, #20
02db8     F0 DA 11 F2 | 	cmp	local02, local05 wc
02dbc     58 FF 9F CD |  if_b	jmp	#LR__0353
02dc0                 | LR__0355
02dc0                 | ' #line 1500 "ff.c"
02dc0                 | ' 	return FR_OK;
02dc0     00 A6 05 F6 | 	mov	result1, #0
02dc4                 | LR__0356
02dc4     A7 F0 03 F6 | 	mov	ptra, fp
02dc8     B2 00 A0 FD | 	call	#popregs_
02dcc                 | _fatfs_cc_remove_chain_ret
02dcc     2D 00 64 FD | 	ret
02dd0                 | 
02dd0                 | _fatfs_cc_create_chain
02dd0     09 4A 05 F6 | 	mov	COUNT_, #9
02dd4     A8 00 A0 FD | 	call	#pushregs_
02dd8     E1 D8 01 F6 | 	mov	local01, arg01
02ddc     E2 DA 09 F6 | 	mov	local02, arg02 wz
02de0     EC DC 01 FB | 	rdlong	local03, local01
02de4     28 00 90 5D |  if_ne	jmp	#LR__0360
02de8     0C DC 05 F1 | 	add	local03, #12
02dec     EE DE 09 FB | 	rdlong	local04, local03 wz
02df0     0C DC 85 F1 | 	sub	local03, #12
02df4     14 DC 05 51 |  if_ne	add	local03, #20
02df8     EE E0 01 5B |  if_ne	rdlong	local05, local03
02dfc     14 DC 85 51 |  if_ne	sub	local03, #20
02e00     F0 DE 11 52 |  if_ne	cmp	local04, local05 wc
02e04     50 00 90 4D |  if_c_and_nz	jmp	#LR__0361
02e08     01 DE 05 F6 | 	mov	local04, #1
02e0c     48 00 90 FD | 	jmp	#LR__0361
02e10                 | LR__0360
02e10     ED C4 01 F6 | 	mov	arg02, local02
02e14     EC C2 01 F6 | 	mov	arg01, local01
02e18     EC FA BF FD | 	call	#_fatfs_cc_get_fat
02e1c     D3 DE 01 F6 | 	mov	local04, result1
02e20     02 DE 15 F2 | 	cmp	local04, #2 wc
02e24     01 A6 05 C6 |  if_b	mov	result1, #1
02e28     BC 01 90 CD |  if_b	jmp	#LR__0371
02e2c     FF FF 7F FF 
02e30     FF DF 0D F2 | 	cmp	local04, ##-1 wz
02e34     EF A6 01 A6 |  if_e	mov	result1, local04
02e38     AC 01 90 AD |  if_e	jmp	#LR__0371
02e3c     14 DC 05 F1 | 	add	local03, #20
02e40     EE E0 01 FB | 	rdlong	local05, local03
02e44     14 DC 85 F1 | 	sub	local03, #20
02e48     F0 DE 11 F2 | 	cmp	local04, local05 wc
02e4c     EF A6 01 C6 |  if_b	mov	result1, local04
02e50     94 01 90 CD |  if_b	jmp	#LR__0371
02e54     ED DE 01 F6 | 	mov	local04, local02
02e58                 | LR__0361
02e58     10 DC 05 F1 | 	add	local03, #16
02e5c     EE E0 09 FB | 	rdlong	local05, local03 wz
02e60     10 DC 85 F1 | 	sub	local03, #16
02e64     00 A6 05 A6 |  if_e	mov	result1, #0
02e68     7C 01 90 AD |  if_e	jmp	#LR__0371
02e6c     00 E2 05 F6 | 	mov	local06, #0
02e70     ED DE 09 F2 | 	cmp	local04, local02 wz
02e74     74 00 90 5D |  if_ne	jmp	#LR__0364
02e78     EF E2 01 F6 | 	mov	local06, local04
02e7c     01 E2 05 F1 | 	add	local06, #1
02e80     14 DC 05 F1 | 	add	local03, #20
02e84     EE E0 01 FB | 	rdlong	local05, local03
02e88     14 DC 85 F1 | 	sub	local03, #20
02e8c     F0 E2 11 F2 | 	cmp	local06, local05 wc
02e90     02 E2 05 36 |  if_ae	mov	local06, #2
02e94     F1 C4 01 F6 | 	mov	arg02, local06
02e98     EC C2 01 F6 | 	mov	arg01, local01
02e9c     68 FA BF FD | 	call	#_fatfs_cc_get_fat
02ea0     D3 E0 01 F6 | 	mov	local05, result1
02ea4     01 E0 0D F2 | 	cmp	local05, #1 wz
02ea8     FF FF 7F 5F 
02eac     FF E1 0D 52 |  if_ne	cmp	local05, ##-1 wz
02eb0     F0 A6 01 A6 |  if_e	mov	result1, local05
02eb4     30 01 90 AD |  if_e	jmp	#LR__0371
02eb8     00 E0 0D F2 | 	cmp	local05, #0 wz
02ebc     2C 00 90 AD |  if_e	jmp	#LR__0363
02ec0     0C DC 05 F1 | 	add	local03, #12
02ec4     EE E4 01 FB | 	rdlong	local07, local03
02ec8     0C DC 85 F1 | 	sub	local03, #12
02ecc     02 E4 15 F2 | 	cmp	local07, #2 wc
02ed0     14 00 90 CD |  if_b	jmp	#LR__0362
02ed4     14 DC 05 F1 | 	add	local03, #20
02ed8     EE E0 01 FB | 	rdlong	local05, local03
02edc     14 DC 85 F1 | 	sub	local03, #20
02ee0     F0 E4 11 F2 | 	cmp	local07, local05 wc
02ee4     F2 DE 01 C6 |  if_b	mov	local04, local07
02ee8                 | LR__0362
02ee8     00 E2 05 F6 | 	mov	local06, #0
02eec                 | LR__0363
02eec                 | LR__0364
02eec     00 E2 0D F2 | 	cmp	local06, #0 wz
02ef0     60 00 90 5D |  if_ne	jmp	#LR__0367
02ef4     EF E2 01 F6 | 	mov	local06, local04
02ef8                 | ' 			ncl = scl;
02ef8                 | ' 			for (;;) {
02ef8                 | LR__0365
02ef8     01 E2 05 F1 | 	add	local06, #1
02efc     14 DC 05 F1 | 	add	local03, #20
02f00     EE E0 01 FB | 	rdlong	local05, local03
02f04     14 DC 85 F1 | 	sub	local03, #20
02f08     F0 E2 11 F2 | 	cmp	local06, local05 wc
02f0c     02 E2 05 36 |  if_ae	mov	local06, #2
02f10     EF E2 19 32 |  if_ae	cmp	local06, local04 wcz
02f14     00 A6 05 16 |  if_a	mov	result1, #0
02f18     CC 00 90 1D |  if_a	jmp	#LR__0371
02f1c     F1 C4 01 F6 | 	mov	arg02, local06
02f20     EC C2 01 F6 | 	mov	arg01, local01
02f24     E0 F9 BF FD | 	call	#_fatfs_cc_get_fat
02f28     D3 E4 09 F6 | 	mov	local07, result1 wz
02f2c     24 00 90 AD |  if_e	jmp	#LR__0366
02f30     01 E4 0D F2 | 	cmp	local07, #1 wz
02f34     FF FF 7F 5F 
02f38     FF E5 0D 52 |  if_ne	cmp	local07, ##-1 wz
02f3c     F2 A6 01 A6 |  if_e	mov	result1, local07
02f40     A4 00 90 AD |  if_e	jmp	#LR__0371
02f44     EF E2 09 F2 | 	cmp	local06, local04 wz
02f48     00 A6 05 A6 |  if_e	mov	result1, #0
02f4c     98 00 90 AD |  if_e	jmp	#LR__0371
02f50     A4 FF 9F FD | 	jmp	#LR__0365
02f54                 | LR__0366
02f54                 | LR__0367
02f54     EE C2 01 F6 | 	mov	arg01, local03
02f58     F1 C4 01 F6 | 	mov	arg02, local06
02f5c     01 C6 65 F6 | 	neg	arg03, #1
02f60     48 FB BF FD | 	call	#_fatfs_cc_put_fat
02f64     D3 E6 09 F6 | 	mov	local08, result1 wz
02f68     1C 00 90 5D |  if_ne	jmp	#LR__0368
02f6c     00 DA 0D F2 | 	cmp	local02, #0 wz
02f70     14 00 90 AD |  if_e	jmp	#LR__0368
02f74     EE C2 01 F6 | 	mov	arg01, local03
02f78     ED C4 01 F6 | 	mov	arg02, local02
02f7c     F1 C6 01 F6 | 	mov	arg03, local06
02f80     28 FB BF FD | 	call	#_fatfs_cc_put_fat
02f84     D3 E6 01 F6 | 	mov	local08, result1
02f88                 | LR__0368
02f88     00 E6 0D F2 | 	cmp	local08, #0 wz
02f8c     4C 00 90 5D |  if_ne	jmp	#LR__0369
02f90     0C DC 05 F1 | 	add	local03, #12
02f94     EE E2 61 FC | 	wrlong	local06, local03
02f98     08 DC 05 F1 | 	add	local03, #8
02f9c     EE E0 01 FB | 	rdlong	local05, local03
02fa0     02 E0 85 F1 | 	sub	local05, #2
02fa4     04 DC 85 F1 | 	sub	local03, #4
02fa8     EE E8 01 FB | 	rdlong	local09, local03
02fac     10 DC 85 F1 | 	sub	local03, #16
02fb0     F0 E8 19 F2 | 	cmp	local09, local05 wcz
02fb4     10 DC 05 E1 |  if_be	add	local03, #16
02fb8     EE E8 01 EB |  if_be	rdlong	local09, local03
02fbc     01 E8 85 E1 |  if_be	sub	local09, #1
02fc0     EE E8 61 EC |  if_be	wrlong	local09, local03
02fc4     10 DC 85 E1 |  if_be	sub	local03, #16
02fc8     04 DC 05 F1 | 	add	local03, #4
02fcc     EE E0 C1 FA | 	rdbyte	local05, local03
02fd0     01 E0 45 F5 | 	or	local05, #1
02fd4     EE E0 41 FC | 	wrbyte	local05, local03
02fd8     08 00 90 FD | 	jmp	#LR__0370
02fdc                 | LR__0369
02fdc     01 E6 0D F2 | 	cmp	local08, #1 wz
02fe0     01 E2 C5 F6 | 	negz	local06, #1
02fe4                 | LR__0370
02fe4                 | ' 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
02fe4                 | ' 	}
02fe4                 | ' 
02fe4                 | ' 	return ncl;
02fe4     F1 A6 01 F6 | 	mov	result1, local06
02fe8                 | LR__0371
02fe8     A7 F0 03 F6 | 	mov	ptra, fp
02fec     B2 00 A0 FD | 	call	#popregs_
02ff0                 | _fatfs_cc_create_chain_ret
02ff0     2D 00 64 FD | 	ret
02ff4                 | 
02ff4                 | _fatfs_cc_dir_clear
02ff4     06 4A 05 F6 | 	mov	COUNT_, #6
02ff8     A8 00 A0 FD | 	call	#pushregs_
02ffc     E1 D8 01 F6 | 	mov	local01, arg01
03000     E2 DA 01 F6 | 	mov	local02, arg02
03004     EC C2 01 F6 | 	mov	arg01, local01
03008     70 F6 BF FD | 	call	#_fatfs_cc_sync_window
0300c     00 A6 0D F2 | 	cmp	result1, #0 wz
03010     01 A6 05 56 |  if_ne	mov	result1, #1
03014     90 00 90 5D |  if_ne	jmp	#LR__0382
03018     EC C2 01 F6 | 	mov	arg01, local01
0301c     ED C4 01 F6 | 	mov	arg02, local02
03020     A4 F8 BF FD | 	call	#_fatfs_cc_clst2sect
03024     D3 DC 01 F6 | 	mov	local03, result1
03028     2C D8 05 F1 | 	add	local01, #44
0302c     EC DC 61 FC | 	wrlong	local03, local01
03030     04 D8 05 F1 | 	add	local01, #4
03034     EC C2 01 F6 | 	mov	arg01, local01
03038     00 C4 05 F6 | 	mov	arg02, #0
0303c     09 C6 C5 F9 | 	decod	arg03, #9
03040     98 00 A0 FD | 	call	#\builtin_bytefill_
03044     EC DE 01 F6 | 	mov	local04, local01
03048                 | ' #line 1667 "ff.c"
03048                 | ' 	{
03048                 | ' 		ibuf = fs->win; szb = 1;
03048                 | ' 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
03048     00 E0 05 F6 | 	mov	local05, #0
0304c     30 D8 85 F1 | 	sub	local01, #48
03050                 | LR__0380
03050     0A D8 05 F1 | 	add	local01, #10
03054     EC E2 E1 FA | 	rdword	local06, local01
03058     0A D8 85 F1 | 	sub	local01, #10
0305c     F1 E0 11 F2 | 	cmp	local05, local06 wc
03060     2C 00 90 3D |  if_ae	jmp	#LR__0381
03064     01 D8 05 F1 | 	add	local01, #1
03068     EC C2 C1 FA | 	rdbyte	arg01, local01
0306c     01 D8 85 F1 | 	sub	local01, #1
03070     EF C4 01 F6 | 	mov	arg02, local04
03074     EE C6 01 F6 | 	mov	arg03, local03
03078     F0 C6 01 F1 | 	add	arg03, local05
0307c     01 C8 05 F6 | 	mov	arg04, #1
03080     7C F2 BF FD | 	call	#_fatfs_cc_disk_write
03084     00 A6 0D F2 | 	cmp	result1, #0 wz
03088     01 E0 05 A1 |  if_e	add	local05, #1
0308c     C0 FF 9F AD |  if_e	jmp	#LR__0380
03090                 | LR__0381
03090                 | ' 	}
03090                 | ' 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
03090     0A D8 05 F1 | 	add	local01, #10
03094     EC DE E1 FA | 	rdword	local04, local01
03098     EF E0 09 F2 | 	cmp	local05, local04 wz
0309c     00 E2 05 A6 |  if_e	mov	local06, #0
030a0     01 E2 05 56 |  if_ne	mov	local06, #1
030a4     F1 A6 01 F6 | 	mov	result1, local06
030a8                 | LR__0382
030a8     A7 F0 03 F6 | 	mov	ptra, fp
030ac     B2 00 A0 FD | 	call	#popregs_
030b0                 | _fatfs_cc_dir_clear_ret
030b0     2D 00 64 FD | 	ret
030b4                 | 
030b4                 | _fatfs_cc_dir_sdi
030b4     06 4A 05 F6 | 	mov	COUNT_, #6
030b8     A8 00 A0 FD | 	call	#pushregs_
030bc     E1 D8 01 F6 | 	mov	local01, arg01
030c0     E2 DA 01 F6 | 	mov	local02, arg02
030c4     EC DC 01 FB | 	rdlong	local03, local01
030c8     00 10 00 FF 
030cc     00 DA 15 F2 | 	cmp	local02, ##2097152 wc
030d0     1F DA CD C7 |  if_b	test	local02, #31 wz
030d4                 | ' 		return FR_INT_ERR;
030d4     02 A6 05 76 |  if_nc_or_nz	mov	result1, #2
030d8     34 01 90 7D |  if_nc_or_nz	jmp	#LR__0396
030dc     10 D8 05 F1 | 	add	local01, #16
030e0     EC DA 61 FC | 	wrlong	local02, local01
030e4     08 D8 85 F1 | 	sub	local01, #8
030e8     EC DE 09 FB | 	rdlong	local04, local01 wz
030ec     08 D8 85 F1 | 	sub	local01, #8
030f0     EE E0 C1 AA |  if_e	rdbyte	local05, local03
030f4     03 E0 15 A2 |  if_e	cmp	local05, #3 wc
030f8     24 DC 05 21 |  if_nc_and_z	add	local03, #36
030fc     EE DE 01 2B |  if_nc_and_z	rdlong	local04, local03
03100     24 DC 85 21 |  if_nc_and_z	sub	local03, #36
03104     00 DE 0D F2 | 	cmp	local04, #0 wz
03108     3C 00 90 5D |  if_ne	jmp	#LR__0390
0310c     ED E0 01 F6 | 	mov	local05, local02
03110     05 E0 45 F0 | 	shr	local05, #5
03114     08 DC 05 F1 | 	add	local03, #8
03118     EE C4 E1 FA | 	rdword	arg02, local03
0311c     08 DC 85 F1 | 	sub	local03, #8
03120     E2 E0 11 F2 | 	cmp	local05, arg02 wc
03124     02 A6 05 36 |  if_ae	mov	result1, #2
03128     E4 00 90 3D |  if_ae	jmp	#LR__0396
0312c     24 DC 05 F1 | 	add	local03, #36
03130     EE E0 01 FB | 	rdlong	local05, local03
03134     24 DC 85 F1 | 	sub	local03, #36
03138     18 D8 05 F1 | 	add	local01, #24
0313c     EC E0 61 FC | 	wrlong	local05, local01
03140     18 D8 85 F1 | 	sub	local01, #24
03144     7C 00 90 FD | 	jmp	#LR__0395
03148                 | LR__0390
03148     0A DC 05 F1 | 	add	local03, #10
0314c     EE E2 E1 FA | 	rdword	local06, local03
03150     0A DC 85 F1 | 	sub	local03, #10
03154     09 E2 65 F0 | 	shl	local06, #9
03158                 | ' 		csz = (DWORD)fs->csize *  ((UINT) 512 ) ;
03158                 | ' 		while (ofs >= csz) {
03158                 | LR__0391
03158     F1 DA 11 F2 | 	cmp	local02, local06 wc
0315c     4C 00 90 CD |  if_b	jmp	#LR__0394
03160     EC C2 01 F6 | 	mov	arg01, local01
03164     EF C4 01 F6 | 	mov	arg02, local04
03168     9C F7 BF FD | 	call	#_fatfs_cc_get_fat
0316c     D3 DE 01 F6 | 	mov	local04, result1
03170     FF FF 7F FF 
03174     FF DF 0D F2 | 	cmp	local04, ##-1 wz
03178     01 A6 05 A6 |  if_e	mov	result1, #1
0317c     90 00 90 AD |  if_e	jmp	#LR__0396
03180     02 DE 15 F2 | 	cmp	local04, #2 wc
03184     14 00 90 CD |  if_b	jmp	#LR__0392
03188     14 DC 05 F1 | 	add	local03, #20
0318c     EE E0 01 FB | 	rdlong	local05, local03
03190     14 DC 85 F1 | 	sub	local03, #20
03194     F0 DE 11 F2 | 	cmp	local04, local05 wc
03198     08 00 90 CD |  if_b	jmp	#LR__0393
0319c                 | LR__0392
0319c     02 A6 05 F6 | 	mov	result1, #2
031a0     6C 00 90 FD | 	jmp	#LR__0396
031a4                 | LR__0393
031a4     F1 DA 81 F1 | 	sub	local02, local06
031a8     AC FF 9F FD | 	jmp	#LR__0391
031ac                 | LR__0394
031ac     EE C2 01 F6 | 	mov	arg01, local03
031b0     EF C4 01 F6 | 	mov	arg02, local04
031b4     10 F7 BF FD | 	call	#_fatfs_cc_clst2sect
031b8     18 D8 05 F1 | 	add	local01, #24
031bc     EC A6 61 FC | 	wrlong	result1, local01
031c0     18 D8 85 F1 | 	sub	local01, #24
031c4                 | LR__0395
031c4     14 D8 05 F1 | 	add	local01, #20
031c8     EC DE 61 FC | 	wrlong	local04, local01
031cc     04 D8 05 F1 | 	add	local01, #4
031d0     EC E0 09 FB | 	rdlong	local05, local01 wz
031d4     18 D8 85 F1 | 	sub	local01, #24
031d8     02 A6 05 A6 |  if_e	mov	result1, #2
031dc     30 00 90 AD |  if_e	jmp	#LR__0396
031e0     ED E2 01 F6 | 	mov	local06, local02
031e4     09 E2 45 F0 | 	shr	local06, #9
031e8     18 D8 05 F1 | 	add	local01, #24
031ec     EC E0 01 FB | 	rdlong	local05, local01
031f0     F1 E0 01 F1 | 	add	local05, local06
031f4     EC E0 61 FC | 	wrlong	local05, local01
031f8     30 DC 05 F1 | 	add	local03, #48
031fc     FF DB 05 F5 | 	and	local02, #511
03200     ED DC 01 F1 | 	add	local03, local02
03204     04 D8 05 F1 | 	add	local01, #4
03208     EC DC 61 FC | 	wrlong	local03, local01
0320c                 | ' 	dp->sect += ofs /  ((UINT) 512 ) ;
0320c                 | ' 	dp->dir = fs->win + (ofs %  ((UINT) 512 ) );
0320c                 | ' 
0320c                 | ' 	return FR_OK;
0320c     00 A6 05 F6 | 	mov	result1, #0
03210                 | LR__0396
03210     A7 F0 03 F6 | 	mov	ptra, fp
03214     B2 00 A0 FD | 	call	#popregs_
03218                 | _fatfs_cc_dir_sdi_ret
03218     2D 00 64 FD | 	ret
0321c                 | 
0321c                 | _fatfs_cc_dir_next
0321c     05 4A 05 F6 | 	mov	COUNT_, #5
03220     A8 00 A0 FD | 	call	#pushregs_
03224     E1 D8 01 F6 | 	mov	local01, arg01
03228     E2 DA 01 F6 | 	mov	local02, arg02
0322c     EC DC 01 FB | 	rdlong	local03, local01
03230     10 D8 05 F1 | 	add	local01, #16
03234     EC DE 01 FB | 	rdlong	local04, local01
03238     10 D8 85 F1 | 	sub	local01, #16
0323c     20 DE 05 F1 | 	add	local04, #32
03240     00 10 00 FF 
03244     00 DE 15 F2 | 	cmp	local04, ##2097152 wc
03248     18 D8 05 31 |  if_ae	add	local01, #24
0324c     EC 00 68 3C |  if_ae	wrlong	#0, local01
03250     18 D8 85 31 |  if_ae	sub	local01, #24
03254     18 D8 05 F1 | 	add	local01, #24
03258     EC C4 09 FB | 	rdlong	arg02, local01 wz
0325c     18 D8 85 F1 | 	sub	local01, #24
03260     04 A6 05 A6 |  if_e	mov	result1, #4
03264     64 01 90 AD |  if_e	jmp	#LR__0405
03268     FF DF CD F7 | 	test	local04, #511 wz
0326c     3C 01 90 5D |  if_ne	jmp	#LR__0404
03270     18 D8 05 F1 | 	add	local01, #24
03274     EC C4 01 FB | 	rdlong	arg02, local01
03278     01 C4 05 F1 | 	add	arg02, #1
0327c     EC C4 61 FC | 	wrlong	arg02, local01
03280     04 D8 85 F1 | 	sub	local01, #4
03284     EC C4 09 FB | 	rdlong	arg02, local01 wz
03288     14 D8 85 F1 | 	sub	local01, #20
0328c     2C 00 90 5D |  if_ne	jmp	#LR__0400
03290     EF C4 01 F6 | 	mov	arg02, local04
03294     05 C4 45 F0 | 	shr	arg02, #5
03298     08 DC 05 F1 | 	add	local03, #8
0329c     EE DA E1 FA | 	rdword	local02, local03
032a0     08 DC 85 F1 | 	sub	local03, #8
032a4     ED C4 11 F2 | 	cmp	arg02, local02 wc
032a8     18 D8 05 31 |  if_ae	add	local01, #24
032ac     EC 00 68 3C |  if_ae	wrlong	#0, local01
032b0                 | ' 				dp->sect = 0; return FR_NO_FILE;
032b0     04 A6 05 36 |  if_ae	mov	result1, #4
032b4     14 01 90 3D |  if_ae	jmp	#LR__0405
032b8     F0 00 90 FD | 	jmp	#LR__0403
032bc                 | LR__0400
032bc     EF C2 01 F6 | 	mov	arg01, local04
032c0     09 C2 45 F0 | 	shr	arg01, #9
032c4     0A DC 05 F1 | 	add	local03, #10
032c8     EE C4 E1 FA | 	rdword	arg02, local03
032cc     0A DC 85 F1 | 	sub	local03, #10
032d0     01 C4 85 F1 | 	sub	arg02, #1
032d4     E2 C2 C9 F7 | 	test	arg01, arg02 wz
032d8     D0 00 90 5D |  if_ne	jmp	#LR__0402
032dc     EC C2 01 F6 | 	mov	arg01, local01
032e0     14 D8 05 F1 | 	add	local01, #20
032e4     EC C4 01 FB | 	rdlong	arg02, local01
032e8     14 D8 85 F1 | 	sub	local01, #20
032ec     18 F6 BF FD | 	call	#_fatfs_cc_get_fat
032f0     D3 E0 01 F6 | 	mov	local05, result1
032f4     02 E0 15 F2 | 	cmp	local05, #2 wc
032f8     02 A6 05 C6 |  if_b	mov	result1, #2
032fc     CC 00 90 CD |  if_b	jmp	#LR__0405
03300     FF FF 7F FF 
03304     FF E1 0D F2 | 	cmp	local05, ##-1 wz
03308     01 A6 05 A6 |  if_e	mov	result1, #1
0330c     BC 00 90 AD |  if_e	jmp	#LR__0405
03310     14 DC 05 F1 | 	add	local03, #20
03314     EE C4 01 FB | 	rdlong	arg02, local03
03318     14 DC 85 F1 | 	sub	local03, #20
0331c     E2 E0 11 F2 | 	cmp	local05, arg02 wc
03320     68 00 90 CD |  if_b	jmp	#LR__0401
03324     00 DA 0D F2 | 	cmp	local02, #0 wz
03328     18 D8 05 A1 |  if_e	add	local01, #24
0332c     EC 00 68 AC |  if_e	wrlong	#0, local01
03330                 | ' 						dp->sect = 0; return FR_NO_FILE;
03330     04 A6 05 A6 |  if_e	mov	result1, #4
03334     94 00 90 AD |  if_e	jmp	#LR__0405
03338     EC C2 01 F6 | 	mov	arg01, local01
0333c     14 D8 05 F1 | 	add	local01, #20
03340     EC C4 01 FB | 	rdlong	arg02, local01
03344     14 D8 85 F1 | 	sub	local01, #20
03348     84 FA BF FD | 	call	#_fatfs_cc_create_chain
0334c     D3 E0 09 F6 | 	mov	local05, result1 wz
03350     07 A6 05 A6 |  if_e	mov	result1, #7
03354     74 00 90 AD |  if_e	jmp	#LR__0405
03358     01 E0 0D F2 | 	cmp	local05, #1 wz
0335c     02 A6 05 A6 |  if_e	mov	result1, #2
03360     68 00 90 AD |  if_e	jmp	#LR__0405
03364     FF FF 7F FF 
03368     FF E1 0D F2 | 	cmp	local05, ##-1 wz
0336c     01 A6 05 A6 |  if_e	mov	result1, #1
03370     58 00 90 AD |  if_e	jmp	#LR__0405
03374     F0 C4 01 F6 | 	mov	arg02, local05
03378     EE C2 01 F6 | 	mov	arg01, local03
0337c     74 FC BF FD | 	call	#_fatfs_cc_dir_clear
03380     00 A6 0D F2 | 	cmp	result1, #0 wz
03384     01 A6 05 56 |  if_ne	mov	result1, #1
03388     40 00 90 5D |  if_ne	jmp	#LR__0405
0338c                 | LR__0401
0338c     14 D8 05 F1 | 	add	local01, #20
03390     EC E0 61 FC | 	wrlong	local05, local01
03394     EE C2 01 F6 | 	mov	arg01, local03
03398     F0 C4 01 F6 | 	mov	arg02, local05
0339c     28 F5 BF FD | 	call	#_fatfs_cc_clst2sect
033a0     04 D8 05 F1 | 	add	local01, #4
033a4     EC A6 61 FC | 	wrlong	result1, local01
033a8     18 D8 85 F1 | 	sub	local01, #24
033ac                 | LR__0402
033ac                 | LR__0403
033ac                 | LR__0404
033ac     10 D8 05 F1 | 	add	local01, #16
033b0     EC DE 61 FC | 	wrlong	local04, local01
033b4     30 DC 05 F1 | 	add	local03, #48
033b8     FF DF 05 F5 | 	and	local04, #511
033bc     EF DC 01 F1 | 	add	local03, local04
033c0     0C D8 05 F1 | 	add	local01, #12
033c4     EC DC 61 FC | 	wrlong	local03, local01
033c8                 | ' #line 1771 "ff.c"
033c8                 | ' 				}
033c8                 | ' 				dp->clust = clst;
033c8                 | ' 				dp->sect = clst2sect(fs, clst);
033c8                 | ' 			}
033c8                 | ' 		}
033c8                 | ' 	}
033c8                 | ' 	dp->dptr = ofs;
033c8                 | ' 	dp->dir = fs->win + ofs %  ((UINT) 512 ) ;
033c8                 | ' 
033c8                 | ' 	return FR_OK;
033c8     00 A6 05 F6 | 	mov	result1, #0
033cc                 | LR__0405
033cc     A7 F0 03 F6 | 	mov	ptra, fp
033d0     B2 00 A0 FD | 	call	#popregs_
033d4                 | _fatfs_cc_dir_next_ret
033d4     2D 00 64 FD | 	ret
033d8                 | 
033d8                 | _fatfs_cc_dir_alloc
033d8     08 4A 05 F6 | 	mov	COUNT_, #8
033dc     A8 00 A0 FD | 	call	#pushregs_
033e0     E1 D8 01 F6 | 	mov	local01, arg01
033e4     E2 DA 01 F6 | 	mov	local02, arg02
033e8     EC DC 01 FB | 	rdlong	local03, local01
033ec     EC C2 01 F6 | 	mov	arg01, local01
033f0     00 C4 05 F6 | 	mov	arg02, #0
033f4     BC FC BF FD | 	call	#_fatfs_cc_dir_sdi
033f8     D3 DE 09 F6 | 	mov	local04, result1 wz
033fc     70 00 90 5D |  if_ne	jmp	#LR__0414
03400     00 E0 05 F6 | 	mov	local05, #0
03404                 | ' 		n = 0;
03404                 | ' 		do {
03404                 | LR__0410
03404     18 D8 05 F1 | 	add	local01, #24
03408     EC C4 01 FB | 	rdlong	arg02, local01
0340c     18 D8 85 F1 | 	sub	local01, #24
03410     EE C2 01 F6 | 	mov	arg01, local03
03414     38 F3 BF FD | 	call	#_fatfs_cc_move_window
03418     D3 DE 09 F6 | 	mov	local04, result1 wz
0341c     50 00 90 5D |  if_ne	jmp	#LR__0413
03420     1C D8 05 F1 | 	add	local01, #28
03424     EC E2 01 FB | 	rdlong	local06, local01
03428     1C D8 85 F1 | 	sub	local01, #28
0342c     F1 E2 C1 FA | 	rdbyte	local06, local06
03430     E5 E2 0D F2 | 	cmp	local06, #229 wz
03434     1C D8 05 51 |  if_ne	add	local01, #28
03438     EC E4 01 5B |  if_ne	rdlong	local07, local01
0343c     1C D8 85 51 |  if_ne	sub	local01, #28
03440     F2 E6 C9 5A |  if_ne	rdbyte	local08, local07 wz
03444     10 00 90 5D |  if_ne	jmp	#LR__0411
03448     01 E0 05 F1 | 	add	local05, #1
0344c     ED E0 09 F2 | 	cmp	local05, local02 wz
03450     1C 00 90 AD |  if_e	jmp	#LR__0413
03454     04 00 90 FD | 	jmp	#LR__0412
03458                 | LR__0411
03458     00 E0 05 F6 | 	mov	local05, #0
0345c                 | LR__0412
0345c     EC C2 01 F6 | 	mov	arg01, local01
03460     01 C4 05 F6 | 	mov	arg02, #1
03464     B4 FD BF FD | 	call	#_fatfs_cc_dir_next
03468     D3 DE 09 F6 | 	mov	local04, result1 wz
0346c     94 FF 9F AD |  if_e	jmp	#LR__0410
03470                 | LR__0413
03470                 | LR__0414
03470     04 DE 0D F2 | 	cmp	local04, #4 wz
03474     07 DE 05 A6 |  if_e	mov	local04, #7
03478                 | ' 	return res;
03478     EF A6 01 F6 | 	mov	result1, local04
0347c     A7 F0 03 F6 | 	mov	ptra, fp
03480     B2 00 A0 FD | 	call	#popregs_
03484                 | _fatfs_cc_dir_alloc_ret
03484     2D 00 64 FD | 	ret
03488                 | 
03488                 | _fatfs_cc_ld_clust
03488     E1 AA 01 F6 | 	mov	_var01, arg01
0348c     E2 C2 01 F6 | 	mov	arg01, arg02
03490     1A C2 05 F1 | 	add	arg01, #26
03494                 | ' {
03494                 | ' 
03494                 | ' 	return *((WORD*)ptr);
03494     E1 A6 E1 FA | 	rdword	result1, arg01
03498     D3 C2 31 F9 | 	getword	arg01, result1, #0
0349c     D5 AA C1 FA | 	rdbyte	_var01, _var01
034a0     03 AA 0D F2 | 	cmp	_var01, #3 wz
034a4     14 C4 05 A1 |  if_e	add	arg02, #20
034a8                 | ' {
034a8                 | ' 
034a8                 | ' 	return *((WORD*)ptr);
034a8     E2 A6 E1 AA |  if_e	rdword	result1, arg02
034ac     10 A6 65 A0 |  if_e	shl	result1, #16
034b0     D3 C2 41 A5 |  if_e	or	arg01, result1
034b4                 | ' 		cl |= (DWORD)ld_word(dir +  20 ) << 16;
034b4                 | ' 	}
034b4                 | ' 
034b4                 | ' 	return cl;
034b4     E1 A6 01 F6 | 	mov	result1, arg01
034b8                 | _fatfs_cc_ld_clust_ret
034b8     2D 00 64 FD | 	ret
034bc                 | 
034bc                 | _fatfs_cc_st_clust
034bc     E1 AA 01 F6 | 	mov	_var01, arg01
034c0     E2 C2 01 F6 | 	mov	arg01, arg02
034c4     1A C2 05 F1 | 	add	arg01, #26
034c8     E1 C6 51 FC | 	wrword	arg03, arg01
034cc     D5 AA C1 FA | 	rdbyte	_var01, _var01
034d0     03 AA 0D F2 | 	cmp	_var01, #3 wz
034d4     14 C4 05 A1 |  if_e	add	arg02, #20
034d8     10 C6 45 A0 |  if_e	shr	arg03, #16
034dc     E2 C6 51 AC |  if_e	wrword	arg03, arg02
034e0                 | _fatfs_cc_st_clust_ret
034e0     2D 00 64 FD | 	ret
034e4                 | 
034e4                 | _fatfs_cc_dir_read
034e4     09 4A 05 F6 | 	mov	COUNT_, #9
034e8     A8 00 A0 FD | 	call	#pushregs_
034ec     E1 D8 01 F6 | 	mov	local01, arg01
034f0     E2 DA 01 F6 | 	mov	local02, arg02
034f4     04 DC 05 F6 | 	mov	local03, #4
034f8     EC DE 01 FB | 	rdlong	local04, local01
034fc                 | ' )
034fc                 | ' {
034fc                 | ' 	FRESULT res = FR_NO_FILE;
034fc                 | ' 	FATFS *fs = dp->obj.fs;
034fc                 | ' 	BYTE attr, b;
034fc                 | ' #line 2303 "ff.c"
034fc                 | ' 	while (dp->sect) {
034fc                 | LR__0420
034fc     18 D8 05 F1 | 	add	local01, #24
03500     EC A6 09 FB | 	rdlong	result1, local01 wz
03504     18 D8 85 F1 | 	sub	local01, #24
03508     B0 00 90 AD |  if_e	jmp	#LR__0422
0350c     18 D8 05 F1 | 	add	local01, #24
03510     EC C4 01 FB | 	rdlong	arg02, local01
03514     18 D8 85 F1 | 	sub	local01, #24
03518     EF C2 01 F6 | 	mov	arg01, local04
0351c     30 F2 BF FD | 	call	#_fatfs_cc_move_window
03520     D3 DC 09 F6 | 	mov	local03, result1 wz
03524     94 00 90 5D |  if_ne	jmp	#LR__0422
03528     1C D8 05 F1 | 	add	local01, #28
0352c     EC A6 01 FB | 	rdlong	result1, local01
03530     1C D8 85 F1 | 	sub	local01, #28
03534     D3 E0 C1 FA | 	rdbyte	local05, result1
03538     F0 A6 01 F6 | 	mov	result1, local05
0353c     07 A6 4D F7 | 	zerox	result1, #7 wz
03540     04 DC 05 A6 |  if_e	mov	local03, #4
03544                 | ' 			res = FR_NO_FILE; break;
03544     74 00 90 AD |  if_e	jmp	#LR__0422
03548     1C D8 05 F1 | 	add	local01, #28
0354c     EC E2 01 FB | 	rdlong	local06, local01
03550     0B E2 05 F1 | 	add	local06, #11
03554     F1 E4 C1 FA | 	rdbyte	local07, local06
03558     3F E4 05 F5 | 	and	local07, #63
0355c     16 D8 85 F1 | 	sub	local01, #22
03560     EC E4 41 FC | 	wrbyte	local07, local01
03564     06 D8 85 F1 | 	sub	local01, #6
03568     F0 A6 E1 F8 | 	getbyte	result1, local05, #0
0356c     E5 A6 0D F2 | 	cmp	result1, #229 wz
03570     F0 E2 01 56 |  if_ne	mov	local06, local05
03574     F1 E2 E1 58 |  if_ne	getbyte	local06, local06, #0
03578     2E E2 0D 52 |  if_ne	cmp	local06, #46 wz
0357c     F2 E6 01 56 |  if_ne	mov	local08, local07
03580     F3 E6 E1 58 |  if_ne	getbyte	local08, local08, #0
03584     0F E6 0D 52 |  if_ne	cmp	local08, #15 wz
03588     1C 00 90 AD |  if_e	jmp	#LR__0421
0358c     00 E8 05 F6 | 	mov	local09, #0
03590     F2 E4 E1 F8 | 	getbyte	local07, local07, #0
03594     20 E4 25 F5 | 	andn	local07, #32
03598     08 E4 0D F2 | 	cmp	local07, #8 wz
0359c     01 E8 05 A6 |  if_e	mov	local09, #1
035a0     ED E8 09 F2 | 	cmp	local09, local02 wz
035a4                 | ' 				break;
035a4     14 00 90 AD |  if_e	jmp	#LR__0422
035a8                 | LR__0421
035a8     EC C2 01 F6 | 	mov	arg01, local01
035ac     00 C4 05 F6 | 	mov	arg02, #0
035b0     68 FC BF FD | 	call	#_fatfs_cc_dir_next
035b4     D3 DC 09 F6 | 	mov	local03, result1 wz
035b8     40 FF 9F AD |  if_e	jmp	#LR__0420
035bc                 | LR__0422
035bc     00 DC 0D F2 | 	cmp	local03, #0 wz
035c0     18 D8 05 51 |  if_ne	add	local01, #24
035c4     EC 00 68 5C |  if_ne	wrlong	#0, local01
035c8                 | ' 	return res;
035c8     EE A6 01 F6 | 	mov	result1, local03
035cc     A7 F0 03 F6 | 	mov	ptra, fp
035d0     B2 00 A0 FD | 	call	#popregs_
035d4                 | _fatfs_cc_dir_read_ret
035d4     2D 00 64 FD | 	ret
035d8                 | 
035d8                 | _fatfs_cc_dir_find
035d8     03 4A 05 F6 | 	mov	COUNT_, #3
035dc     A8 00 A0 FD | 	call	#pushregs_
035e0     E1 D8 01 F6 | 	mov	local01, arg01
035e4     EC DA 01 FB | 	rdlong	local02, local01
035e8     EC C2 01 F6 | 	mov	arg01, local01
035ec     00 C4 05 F6 | 	mov	arg02, #0
035f0     C0 FA BF FD | 	call	#_fatfs_cc_dir_sdi
035f4     00 A6 0D F2 | 	cmp	result1, #0 wz
035f8     A8 00 90 5D |  if_ne	jmp	#LR__0433
035fc                 | ' #line 2406 "ff.c"
035fc                 | ' 	do {
035fc                 | LR__0430
035fc     18 D8 05 F1 | 	add	local01, #24
03600     EC C4 01 FB | 	rdlong	arg02, local01
03604     18 D8 85 F1 | 	sub	local01, #24
03608     ED C2 01 F6 | 	mov	arg01, local02
0360c     40 F1 BF FD | 	call	#_fatfs_cc_move_window
03610     D3 DC 09 F6 | 	mov	local03, result1 wz
03614     88 00 90 5D |  if_ne	jmp	#LR__0432
03618     1C D8 05 F1 | 	add	local01, #28
0361c     EC C6 01 FB | 	rdlong	arg03, local01
03620     1C D8 85 F1 | 	sub	local01, #28
03624     E3 C6 C9 FA | 	rdbyte	arg03, arg03 wz
03628     04 DC 05 A6 |  if_e	mov	local03, #4
0362c     70 00 90 AD |  if_e	jmp	#LR__0432
03630     1C D8 05 F1 | 	add	local01, #28
03634     EC C6 01 FB | 	rdlong	arg03, local01
03638     0B C6 05 F1 | 	add	arg03, #11
0363c     E3 C6 C1 FA | 	rdbyte	arg03, arg03
03640     3F C6 05 F5 | 	and	arg03, #63
03644     16 D8 85 F1 | 	sub	local01, #22
03648     EC C6 41 FC | 	wrbyte	arg03, local01
0364c     16 D8 05 F1 | 	add	local01, #22
03650     EC C6 01 FB | 	rdlong	arg03, local01
03654     1C D8 85 F1 | 	sub	local01, #28
03658     0B C6 05 F1 | 	add	arg03, #11
0365c     E3 C6 C1 FA | 	rdbyte	arg03, arg03
03660     08 C6 CD F7 | 	test	arg03, #8 wz
03664     24 00 90 5D |  if_ne	jmp	#LR__0431
03668     1C D8 05 F1 | 	add	local01, #28
0366c     EC C2 01 FB | 	rdlong	arg01, local01
03670     04 D8 05 F1 | 	add	local01, #4
03674     EC C4 01 F6 | 	mov	arg02, local01
03678     20 D8 85 F1 | 	sub	local01, #32
0367c     0B C6 05 F6 | 	mov	arg03, #11
03680     F8 E5 BF FD | 	call	#_fatfs_cc_memcmp
03684     00 A6 0D F2 | 	cmp	result1, #0 wz
03688     14 00 90 AD |  if_e	jmp	#LR__0432
0368c                 | LR__0431
0368c     EC C2 01 F6 | 	mov	arg01, local01
03690     00 C4 05 F6 | 	mov	arg02, #0
03694     84 FB BF FD | 	call	#_fatfs_cc_dir_next
03698     D3 DC 09 F6 | 	mov	local03, result1 wz
0369c     5C FF 9F AD |  if_e	jmp	#LR__0430
036a0                 | LR__0432
036a0                 | ' 
036a0                 | ' 	return res;
036a0     EE A6 01 F6 | 	mov	result1, local03
036a4                 | LR__0433
036a4     A7 F0 03 F6 | 	mov	ptra, fp
036a8     B2 00 A0 FD | 	call	#popregs_
036ac                 | _fatfs_cc_dir_find_ret
036ac     2D 00 64 FD | 	ret
036b0                 | 
036b0                 | _fatfs_cc_dir_register
036b0     03 4A 05 F6 | 	mov	COUNT_, #3
036b4     A8 00 A0 FD | 	call	#pushregs_
036b8     E1 D8 01 F6 | 	mov	local01, arg01
036bc     EC DA 01 FB | 	rdlong	local02, local01
036c0     EC C2 01 F6 | 	mov	arg01, local01
036c4     01 C4 05 F6 | 	mov	arg02, #1
036c8     0C FD BF FD | 	call	#_fatfs_cc_dir_alloc
036cc     D3 DC 09 F6 | 	mov	local03, result1 wz
036d0     4C 00 90 5D |  if_ne	jmp	#LR__0441
036d4     18 D8 05 F1 | 	add	local01, #24
036d8     EC C4 01 FB | 	rdlong	arg02, local01
036dc     18 D8 85 F1 | 	sub	local01, #24
036e0     ED C2 01 F6 | 	mov	arg01, local02
036e4     68 F0 BF FD | 	call	#_fatfs_cc_move_window
036e8     D3 DC 09 F6 | 	mov	local03, result1 wz
036ec     30 00 90 5D |  if_ne	jmp	#LR__0440
036f0     1C D8 05 F1 | 	add	local01, #28
036f4     EC C2 01 FB | 	rdlong	arg01, local01
036f8     00 C4 05 F6 | 	mov	arg02, #0
036fc     20 C6 05 F6 | 	mov	arg03, #32
03700     98 00 A0 FD | 	call	#\builtin_bytefill_
03704     EC C2 01 FB | 	rdlong	arg01, local01
03708     04 D8 05 F1 | 	add	local01, #4
0370c     EC C4 01 F6 | 	mov	arg02, local01
03710     0B C6 05 F6 | 	mov	arg03, #11
03714     40 AC B0 FD | 	call	#__system____builtin_memmove
03718     03 DA 05 F1 | 	add	local02, #3
0371c     ED 02 48 FC | 	wrbyte	#1, local02
03720                 | LR__0440
03720                 | LR__0441
03720                 | ' 			__builtin_memset(dp->dir, 0, 32 ) ;
03720                 | ' 			__builtin_memcpy(dp->dir + 0 , dp->fn, 11) ;
03720                 | ' #line 2540 "ff.c"
03720                 | ' 			fs->wflag = 1;
03720                 | ' 		}
03720                 | ' 	}
03720                 | ' 
03720                 | ' 	return res;
03720     EE A6 01 F6 | 	mov	result1, local03
03724     A7 F0 03 F6 | 	mov	ptra, fp
03728     B2 00 A0 FD | 	call	#popregs_
0372c                 | _fatfs_cc_dir_register_ret
0372c     2D 00 64 FD | 	ret
03730                 | 
03730                 | _fatfs_cc_dir_remove
03730     02 4A 05 F6 | 	mov	COUNT_, #2
03734     A8 00 A0 FD | 	call	#pushregs_
03738     E1 D8 01 F6 | 	mov	local01, arg01
0373c     EC DA 01 FB | 	rdlong	local02, local01
03740     18 D8 05 F1 | 	add	local01, #24
03744     EC C4 01 FB | 	rdlong	arg02, local01
03748     18 D8 85 F1 | 	sub	local01, #24
0374c     ED C2 01 F6 | 	mov	arg01, local02
03750     FC EF BF FD | 	call	#_fatfs_cc_move_window
03754     00 A6 4D F2 | 	cmps	result1, #0 wz
03758     1C D8 05 A1 |  if_e	add	local01, #28
0375c     EC D8 01 AB |  if_e	rdlong	local01, local01
03760     EC CA 49 AC |  if_e	wrbyte	#229, local01
03764     03 DA 05 A1 |  if_e	add	local02, #3
03768     ED 02 48 AC |  if_e	wrbyte	#1, local02
0376c                 | ' 		dp->dir[ 0 ] =  0xE5 ;
0376c                 | ' 		fs->wflag = 1;
0376c                 | ' 	}
0376c                 | ' 
0376c                 | ' 
0376c                 | ' 	return res;
0376c     A7 F0 03 F6 | 	mov	ptra, fp
03770     B2 00 A0 FD | 	call	#popregs_
03774                 | _fatfs_cc_dir_remove_ret
03774     2D 00 64 FD | 	ret
03778                 | 
03778                 | _fatfs_cc_get_fileinfo
03778     E1 AA 01 F6 | 	mov	_var01, arg01
0377c     0C C4 05 F1 | 	add	arg02, #12
03780     E2 00 48 FC | 	wrbyte	#0, arg02
03784     0C C4 85 F1 | 	sub	arg02, #12
03788     18 AA 05 F1 | 	add	_var01, #24
0378c     D5 A6 09 FB | 	rdlong	result1, _var01 wz
03790     18 AA 85 F1 | 	sub	_var01, #24
03794     E4 00 90 AD |  if_e	jmp	#LR__0453
03798     00 AC 05 F6 | 	mov	_var02, #0
0379c     00 AE 05 F6 | 	mov	_var03, #0
037a0                 | ' #line 2708 "ff.c"
037a0                 | ' 	si = di = 0;
037a0                 | ' 	while (si < 11) {
037a0                 | LR__0450
037a0     0B AE 15 F2 | 	cmp	_var03, #11 wc
037a4     70 00 90 3D |  if_ae	jmp	#LR__0452
037a8     1C AA 05 F1 | 	add	_var01, #28
037ac     D5 A6 01 FB | 	rdlong	result1, _var01
037b0     1C AA 85 F1 | 	sub	_var01, #28
037b4     D7 C2 01 F6 | 	mov	arg01, _var03
037b8     D3 C2 01 F1 | 	add	arg01, result1
037bc     E1 B0 C1 FA | 	rdbyte	_var04, arg01
037c0     D8 A6 E1 F8 | 	getbyte	result1, _var04, #0
037c4     20 A6 0D F2 | 	cmp	result1, #32 wz
037c8     01 AE 05 F1 | 	add	_var03, #1
037cc     D0 FF 9F AD |  if_e	jmp	#LR__0450
037d0     D8 A6 E1 F8 | 	getbyte	result1, _var04, #0
037d4     05 A6 0D F2 | 	cmp	result1, #5 wz
037d8     E5 B0 05 A6 |  if_e	mov	_var04, #229
037dc     09 AE 0D F2 | 	cmp	_var03, #9 wz
037e0     18 00 90 5D |  if_ne	jmp	#LR__0451
037e4     D6 A6 01 F6 | 	mov	result1, _var02
037e8     E2 C2 01 F6 | 	mov	arg01, arg02
037ec     0C C2 05 F1 | 	add	arg01, #12
037f0     E1 A6 01 F1 | 	add	result1, arg01
037f4     D3 5C 48 FC | 	wrbyte	#46, result1
037f8     01 AC 05 F1 | 	add	_var02, #1
037fc                 | LR__0451
037fc     D6 A6 01 F6 | 	mov	result1, _var02
03800     E2 C2 01 F6 | 	mov	arg01, arg02
03804     0C C2 05 F1 | 	add	arg01, #12
03808     E1 A6 01 F1 | 	add	result1, arg01
0380c     D3 B0 41 FC | 	wrbyte	_var04, result1
03810     01 AC 05 F1 | 	add	_var02, #1
03814     88 FF 9F FD | 	jmp	#LR__0450
03818                 | LR__0452
03818     0C C4 05 F1 | 	add	arg02, #12
0381c     E2 AC 01 F1 | 	add	_var02, arg02
03820     D6 00 48 FC | 	wrbyte	#0, _var02
03824     1C AA 05 F1 | 	add	_var01, #28
03828     D5 B0 01 FB | 	rdlong	_var04, _var01
0382c     0B B0 05 F1 | 	add	_var04, #11
03830     D8 B0 C1 FA | 	rdbyte	_var04, _var04
03834     3F B0 05 F5 | 	and	_var04, #63
03838     04 C4 85 F1 | 	sub	arg02, #4
0383c     E2 B0 41 FC | 	wrbyte	_var04, arg02
03840     08 C4 85 F1 | 	sub	arg02, #8
03844     D5 C2 01 FB | 	rdlong	arg01, _var01
03848     1C C2 05 F1 | 	add	arg01, #28
0384c                 | ' {
0384c                 | ' 
0384c                 | ' 	return *((DWORD*)ptr);
0384c     E1 A6 01 FB | 	rdlong	result1, arg01
03850     E2 A6 61 FC | 	wrlong	result1, arg02
03854     D5 C2 01 FB | 	rdlong	arg01, _var01
03858     16 C2 05 F1 | 	add	arg01, #22
0385c                 | ' {
0385c                 | ' 
0385c                 | ' 	return *((WORD*)ptr);
0385c     E1 A6 E1 FA | 	rdword	result1, arg01
03860     06 C4 05 F1 | 	add	arg02, #6
03864     E2 A6 51 FC | 	wrword	result1, arg02
03868     D5 C2 01 FB | 	rdlong	arg01, _var01
0386c     18 C2 05 F1 | 	add	arg01, #24
03870                 | ' {
03870                 | ' 
03870                 | ' 	return *((WORD*)ptr);
03870     E1 A6 E1 FA | 	rdword	result1, arg01
03874     02 C4 85 F1 | 	sub	arg02, #2
03878     E2 A6 51 FC | 	wrword	result1, arg02
0387c                 | LR__0453
0387c                 | _fatfs_cc_get_fileinfo_ret
0387c     2D 00 64 FD | 	ret
03880                 | 
03880                 | _fatfs_cc_create_name
03880     0E 4A 05 F6 | 	mov	COUNT_, #14
03884     A8 00 A0 FD | 	call	#pushregs_
03888     E2 D8 01 F6 | 	mov	local01, arg02
0388c     EC DA 01 FB | 	rdlong	local02, local01
03890     E1 DC 01 F6 | 	mov	local03, arg01
03894     20 DC 05 F1 | 	add	local03, #32
03898     EE C2 01 F6 | 	mov	arg01, local03
0389c     20 C4 05 F6 | 	mov	arg02, #32
038a0     0B C6 05 F6 | 	mov	arg03, #11
038a4     E1 DE 01 F6 | 	mov	local04, arg01
038a8     98 00 A0 FD | 	call	#\builtin_bytefill_
038ac     EF A6 01 F6 | 	mov	result1, local04
038b0     00 E0 05 F6 | 	mov	local05, #0
038b4     00 E2 05 F6 | 	mov	local06, #0
038b8     08 E4 05 F6 | 	mov	local07, #8
038bc                 | ' 
038bc                 | ' 
038bc                 | ' 	p = *path; sfn = dp->fn;
038bc                 | ' 	__builtin_memset(sfn, ' ', 11) ;
038bc                 | ' 	si = i = 0; ni = 8;
038bc                 | ' #line 2970 "ff.c"
038bc                 | ' 	for (;;) {
038bc                 | LR__0460
038bc     F1 E6 01 F6 | 	mov	local08, local06
038c0     ED E8 01 F6 | 	mov	local09, local02
038c4     ED E6 01 F1 | 	add	local08, local02
038c8     F3 E6 C1 FA | 	rdbyte	local08, local08
038cc     F3 C6 E1 F8 | 	getbyte	arg03, local08, #0
038d0     21 C6 15 F2 | 	cmp	arg03, #33 wc
038d4     01 E2 05 F1 | 	add	local06, #1
038d8     54 01 90 CD |  if_b	jmp	#LR__0468
038dc     F3 C6 E1 F8 | 	getbyte	arg03, local08, #0
038e0     2F C6 0D F2 | 	cmp	arg03, #47 wz
038e4     F3 EA 01 56 |  if_ne	mov	local10, local08
038e8     F5 EA E1 58 |  if_ne	getbyte	local10, local10, #0
038ec     5C EA 0D 52 |  if_ne	cmp	local10, #92 wz
038f0     2C 00 90 5D |  if_ne	jmp	#LR__0462
038f4                 | ' 			while ( ((p[si]) == '/' || (p[si]) == '\\') ) si++;
038f4                 | LR__0461
038f4     F1 EA 01 F6 | 	mov	local10, local06
038f8     ED EA 01 F1 | 	add	local10, local02
038fc     F5 EA C1 FA | 	rdbyte	local10, local10
03900     2F EA 0D F2 | 	cmp	local10, #47 wz
03904     F1 EC 01 56 |  if_ne	mov	local11, local06
03908     ED EC 01 51 |  if_ne	add	local11, local02
0390c     F6 E8 C1 5A |  if_ne	rdbyte	local09, local11
03910     5C E8 0D 52 |  if_ne	cmp	local09, #92 wz
03914     18 01 90 5D |  if_ne	jmp	#LR__0468
03918     01 E2 05 F1 | 	add	local06, #1
0391c     D4 FF 9F FD | 	jmp	#LR__0461
03920                 | ' 			break;
03920                 | LR__0462
03920     F3 E8 E1 F8 | 	getbyte	local09, local08, #0
03924     2E E8 0D F2 | 	cmp	local09, #46 wz
03928     F2 E0 11 52 |  if_ne	cmp	local05, local07 wc
0392c     28 00 90 4D |  if_c_and_nz	jmp	#LR__0465
03930     0B E4 0D F2 | 	cmp	local07, #11 wz
03934     0C 00 90 AD |  if_e	jmp	#LR__0463
03938     F3 E6 E1 F8 | 	getbyte	local08, local08, #0
0393c     2E E6 0D F2 | 	cmp	local08, #46 wz
03940     08 00 90 AD |  if_e	jmp	#LR__0464
03944                 | LR__0463
03944     06 A6 05 F6 | 	mov	result1, #6
03948     30 01 90 FD | 	jmp	#LR__0469
0394c                 | LR__0464
0394c     08 E0 05 F6 | 	mov	local05, #8
03950     0B E4 05 F6 | 	mov	local07, #11
03954                 | ' 			i = 8; ni = 11;
03954                 | ' 			continue;
03954     64 FF 9F FD | 	jmp	#LR__0460
03958                 | LR__0465
03958     F3 E8 E1 F8 | 	getbyte	local09, local08, #0
0395c     80 E8 15 F2 | 	cmp	local09, #128 wc
03960     F3 E6 E1 38 |  if_ae	getbyte	local08, local08, #0
03964     7F E6 05 35 |  if_ae	and	local08, #127
03968     CB E6 01 31 |  if_ae	add	local08, ptr__fatfs_cc_dat__
0396c     F3 E6 C1 3A |  if_ae	rdbyte	local08, local08
03970     F3 C2 01 F6 | 	mov	arg01, local08
03974     07 C2 4D F7 | 	zerox	arg01, #7 wz
03978     00 A6 05 56 |  if_ne	mov	result1, #0
0397c                 | ' 
0397c                 | ' 	return 0;
0397c     00 A6 05 A6 |  if_e	mov	result1, #0
03980     00 A6 0D F2 | 	cmp	result1, #0 wz
03984     5C 00 90 AD |  if_e	jmp	#LR__0466
03988     F1 E8 01 F6 | 	mov	local09, local06
0398c     ED E8 01 F1 | 	add	local09, local02
03990     F4 EE C1 FA | 	rdbyte	local12, local09
03994     F7 C2 01 F6 | 	mov	arg01, local12
03998     01 E2 05 F1 | 	add	local06, #1
0399c     07 C2 4D F7 | 	zerox	arg01, #7 wz
039a0     00 A6 05 56 |  if_ne	mov	result1, #0
039a4                 | ' 
039a4                 | ' 	return 0;
039a4     00 A6 05 A6 |  if_e	mov	result1, #0
039a8     00 A6 0D F2 | 	cmp	result1, #0 wz
039ac     F2 EA 01 56 |  if_ne	mov	local10, local07
039b0     01 EA 85 51 |  if_ne	sub	local10, #1
039b4     F5 E0 11 52 |  if_ne	cmp	local05, local10 wc
039b8     06 A6 05 B6 |  if_nc_or_z	mov	result1, #6
039bc     BC 00 90 BD |  if_nc_or_z	jmp	#LR__0469
039c0     F0 E8 01 F6 | 	mov	local09, local05
039c4     EE E8 01 F1 | 	add	local09, local03
039c8     F4 E6 41 FC | 	wrbyte	local08, local09
039cc     01 E0 05 F1 | 	add	local05, #1
039d0     F0 E8 01 F6 | 	mov	local09, local05
039d4     EE E8 01 F1 | 	add	local09, local03
039d8     F4 EE 41 FC | 	wrbyte	local12, local09
039dc     01 E0 05 F1 | 	add	local05, #1
039e0     D8 FE 9F FD | 	jmp	#LR__0460
039e4                 | LR__0466
039e4     7C 00 00 FF 
039e8     4E C3 05 F6 | 	mov	arg01, ##@LR__2096
039ec     F3 C4 E1 F8 | 	getbyte	arg02, local08, #0
039f0     54 E3 BF FD | 	call	#_fatfs_cc_strchr
039f4     00 A6 0D F2 | 	cmp	result1, #0 wz
039f8     06 A6 05 56 |  if_ne	mov	result1, #6
039fc     7C 00 90 5D |  if_ne	jmp	#LR__0469
03a00     F3 E8 E1 F8 | 	getbyte	local09, local08, #0
03a04     61 E8 15 F2 | 	cmp	local09, #97 wc
03a08     10 00 90 CD |  if_b	jmp	#LR__0467
03a0c     F3 EA E1 F8 | 	getbyte	local10, local08, #0
03a10     7B EA 15 F2 | 	cmp	local10, #123 wc
03a14     F3 E6 E1 C8 |  if_b	getbyte	local08, local08, #0
03a18     20 E6 85 C1 |  if_b	sub	local08, #32
03a1c                 | LR__0467
03a1c     F0 E8 01 F6 | 	mov	local09, local05
03a20     EE E8 01 F1 | 	add	local09, local03
03a24     F4 E6 41 FC | 	wrbyte	local08, local09
03a28     01 E0 05 F1 | 	add	local05, #1
03a2c     8C FE 9F FD | 	jmp	#LR__0460
03a30                 | LR__0468
03a30     F1 F0 01 F6 | 	mov	local13, local06
03a34     ED F0 01 F1 | 	add	local13, local02
03a38     EC F0 61 FC | 	wrlong	local13, local01
03a3c     00 E0 0D F2 | 	cmp	local05, #0 wz
03a40     06 A6 05 A6 |  if_e	mov	result1, #6
03a44     34 00 90 AD |  if_e	jmp	#LR__0469
03a48     EE F2 C1 FA | 	rdbyte	local14, local03
03a4c     E5 F2 0D F2 | 	cmp	local14, #229 wz
03a50     EE 0A 48 AC |  if_e	wrbyte	#5, local03
03a54     F3 EA E1 F8 | 	getbyte	local10, local08, #0
03a58     21 EA 15 F2 | 	cmp	local10, #33 wc
03a5c     ED E2 01 31 |  if_ae	add	local06, local02
03a60     F1 F0 C1 3A |  if_ae	rdbyte	local13, local06
03a64     21 F0 15 32 |  if_ae	cmp	local13, #33 wc
03a68     04 F2 05 C6 |  if_b	mov	local14, #4
03a6c     00 F2 05 36 |  if_ae	mov	local14, #0
03a70     0B DC 05 F1 | 	add	local03, #11
03a74     EE F2 41 FC | 	wrbyte	local14, local03
03a78                 | ' 	sfn[ 11 ] = (c <= ' ' || p[si] <= ' ') ?  0x04  : 0;
03a78                 | ' 
03a78                 | ' 	return FR_OK;
03a78     00 A6 05 F6 | 	mov	result1, #0
03a7c                 | LR__0469
03a7c     A7 F0 03 F6 | 	mov	ptra, fp
03a80     B2 00 A0 FD | 	call	#popregs_
03a84                 | _fatfs_cc_create_name_ret
03a84     2D 00 64 FD | 	ret
03a88                 | 
03a88                 | _fatfs_cc_follow_path
03a88     02 4A 05 F6 | 	mov	COUNT_, #2
03a8c     A8 00 A0 FD | 	call	#pushregs_
03a90     18 F0 07 F1 | 	add	ptra, #24
03a94     04 4E 05 F1 | 	add	fp, #4
03a98     A7 C2 61 FC | 	wrlong	arg01, fp
03a9c     04 4E 05 F1 | 	add	fp, #4
03aa0     A7 C4 61 FC | 	wrlong	arg02, fp
03aa4     04 4E 85 F1 | 	sub	fp, #4
03aa8     A7 A6 01 FB | 	rdlong	result1, fp
03aac     D3 D8 01 FB | 	rdlong	local01, result1
03ab0     10 4E 05 F1 | 	add	fp, #16
03ab4     A7 D8 61 FC | 	wrlong	local01, fp
03ab8     14 4E 85 F1 | 	sub	fp, #20
03abc     97 24 48 FB | 	callpa	#(@LR__0472-@LR__0470)>>2,fcache_load_ptr_
03ac0                 | ' )
03ac0                 | ' {
03ac0                 | ' 	FRESULT res;
03ac0                 | ' 	BYTE ns;
03ac0                 | ' 	FATFS *fs = dp->obj.fs;
03ac0                 | ' #line 3034 "ff.c"
03ac0                 | ' 	{
03ac0                 | ' 		while ( ((*path) == '/' || (*path) == '\\') ) path++;
03ac0                 | LR__0470
03ac0     08 4E 05 F1 | 	add	fp, #8
03ac4     A7 D8 01 FB | 	rdlong	local01, fp
03ac8     08 4E 85 F1 | 	sub	fp, #8
03acc     EC D8 C1 FA | 	rdbyte	local01, local01
03ad0     2F D8 0D F2 | 	cmp	local01, #47 wz
03ad4     18 00 90 AD |  if_e	jmp	#LR__0471
03ad8     08 4E 05 F1 | 	add	fp, #8
03adc     A7 D8 01 FB | 	rdlong	local01, fp
03ae0     08 4E 85 F1 | 	sub	fp, #8
03ae4     EC D8 C1 FA | 	rdbyte	local01, local01
03ae8     5C D8 0D F2 | 	cmp	local01, #92 wz
03aec     18 00 90 5D |  if_ne	jmp	#LR__0473
03af0                 | LR__0471
03af0     08 4E 05 F1 | 	add	fp, #8
03af4     A7 D8 01 FB | 	rdlong	local01, fp
03af8     01 D8 05 F1 | 	add	local01, #1
03afc     A7 D8 61 FC | 	wrlong	local01, fp
03b00     08 4E 85 F1 | 	sub	fp, #8
03b04     B8 FF 9F FD | 	jmp	#LR__0470
03b08                 | LR__0472
03b08                 | LR__0473
03b08     04 4E 05 F1 | 	add	fp, #4
03b0c     A7 D8 01 FB | 	rdlong	local01, fp
03b10     08 D8 05 F1 | 	add	local01, #8
03b14     EC 00 68 FC | 	wrlong	#0, local01
03b18     04 4E 05 F1 | 	add	fp, #4
03b1c     A7 D8 01 FB | 	rdlong	local01, fp
03b20     08 4E 85 F1 | 	sub	fp, #8
03b24     EC D8 C1 FA | 	rdbyte	local01, local01
03b28     20 D8 15 F2 | 	cmp	local01, #32 wc
03b2c     30 00 90 3D |  if_ae	jmp	#LR__0474
03b30     04 4E 05 F1 | 	add	fp, #4
03b34     A7 D8 01 FB | 	rdlong	local01, fp
03b38     2B D8 05 F1 | 	add	local01, #43
03b3c     EC 00 49 FC | 	wrbyte	#128, local01
03b40     A7 C2 01 FB | 	rdlong	arg01, fp
03b44     04 4E 85 F1 | 	sub	fp, #4
03b48     00 C4 05 F6 | 	mov	arg02, #0
03b4c     64 F5 BF FD | 	call	#_fatfs_cc_dir_sdi
03b50     0C 4E 05 F1 | 	add	fp, #12
03b54     A7 A6 61 FC | 	wrlong	result1, fp
03b58     0C 4E 85 F1 | 	sub	fp, #12
03b5c     1C 01 90 FD | 	jmp	#LR__0478
03b60                 | LR__0474
03b60                 | ' 		for (;;) {
03b60                 | LR__0475
03b60     04 4E 05 F1 | 	add	fp, #4
03b64     A7 C2 01 FB | 	rdlong	arg01, fp
03b68     04 4E 05 F1 | 	add	fp, #4
03b6c     A7 C4 01 F6 | 	mov	arg02, fp
03b70     08 4E 85 F1 | 	sub	fp, #8
03b74     08 FD BF FD | 	call	#_fatfs_cc_create_name
03b78     0C 4E 05 F1 | 	add	fp, #12
03b7c     A7 A6 61 FC | 	wrlong	result1, fp
03b80     00 A6 4D F2 | 	cmps	result1, #0 wz
03b84     0C 4E 85 F1 | 	sub	fp, #12
03b88     F0 00 90 5D |  if_ne	jmp	#LR__0477
03b8c     04 4E 05 F1 | 	add	fp, #4
03b90     A7 C2 01 FB | 	rdlong	arg01, fp
03b94     04 4E 85 F1 | 	sub	fp, #4
03b98     3C FA BF FD | 	call	#_fatfs_cc_dir_find
03b9c     0C 4E 05 F1 | 	add	fp, #12
03ba0     A7 A6 61 FC | 	wrlong	result1, fp
03ba4     08 4E 85 F1 | 	sub	fp, #8
03ba8     A7 D8 01 FB | 	rdlong	local01, fp
03bac     2B D8 05 F1 | 	add	local01, #43
03bb0     EC D8 C1 FA | 	rdbyte	local01, local01
03bb4     0C 4E 05 F1 | 	add	fp, #12
03bb8     A7 D8 41 FC | 	wrbyte	local01, fp
03bbc     04 4E 85 F1 | 	sub	fp, #4
03bc0     A7 D8 09 FB | 	rdlong	local01, fp wz
03bc4     0C 4E 85 F1 | 	sub	fp, #12
03bc8     34 00 90 AD |  if_e	jmp	#LR__0476
03bcc     0C 4E 05 F1 | 	add	fp, #12
03bd0     A7 D8 01 FB | 	rdlong	local01, fp
03bd4     0C 4E 85 F1 | 	sub	fp, #12
03bd8     04 D8 0D F2 | 	cmp	local01, #4 wz
03bdc     9C 00 90 5D |  if_ne	jmp	#LR__0477
03be0     10 4E 05 F1 | 	add	fp, #16
03be4     A7 D8 C1 FA | 	rdbyte	local01, fp
03be8     10 4E 85 F1 | 	sub	fp, #16
03bec     04 D8 CD F7 | 	test	local01, #4 wz
03bf0     0C 4E 05 A1 |  if_e	add	fp, #12
03bf4     A7 0A 68 AC |  if_e	wrlong	#5, fp
03bf8     0C 4E 85 A1 |  if_e	sub	fp, #12
03bfc                 | ' 					}
03bfc                 | ' 				}
03bfc                 | ' 				break;
03bfc     7C 00 90 FD | 	jmp	#LR__0477
03c00                 | LR__0476
03c00     10 4E 05 F1 | 	add	fp, #16
03c04     A7 D8 C1 FA | 	rdbyte	local01, fp
03c08     10 4E 85 F1 | 	sub	fp, #16
03c0c     04 D8 CD F7 | 	test	local01, #4 wz
03c10     68 00 90 5D |  if_ne	jmp	#LR__0477
03c14     04 4E 05 F1 | 	add	fp, #4
03c18     A7 D8 01 FB | 	rdlong	local01, fp
03c1c     04 4E 85 F1 | 	sub	fp, #4
03c20     06 D8 05 F1 | 	add	local01, #6
03c24     EC D8 C1 FA | 	rdbyte	local01, local01
03c28     10 D8 CD F7 | 	test	local01, #16 wz
03c2c     0C 4E 05 A1 |  if_e	add	fp, #12
03c30     A7 0A 68 AC |  if_e	wrlong	#5, fp
03c34     0C 4E 85 A1 |  if_e	sub	fp, #12
03c38                 | ' 				res = FR_NO_PATH; break;
03c38     40 00 90 AD |  if_e	jmp	#LR__0477
03c3c     04 4E 05 F1 | 	add	fp, #4
03c40     A7 DA 01 FB | 	rdlong	local02, fp
03c44     ED D8 01 F6 | 	mov	local01, local02
03c48     10 4E 05 F1 | 	add	fp, #16
03c4c     A7 C4 01 FB | 	rdlong	arg02, fp
03c50     E2 C2 01 F6 | 	mov	arg01, arg02
03c54     30 C4 05 F1 | 	add	arg02, #48
03c58     14 4E 85 F1 | 	sub	fp, #20
03c5c     10 DA 05 F1 | 	add	local02, #16
03c60     ED DA 01 FB | 	rdlong	local02, local02
03c64     FF DB 05 F5 | 	and	local02, #511
03c68     ED C4 01 F1 | 	add	arg02, local02
03c6c     18 F8 BF FD | 	call	#_fatfs_cc_ld_clust
03c70     08 D8 05 F1 | 	add	local01, #8
03c74     EC A6 61 FC | 	wrlong	result1, local01
03c78     E4 FE 9F FD | 	jmp	#LR__0475
03c7c                 | LR__0477
03c7c                 | LR__0478
03c7c                 | ' 			}
03c7c                 | ' #line 3090 "ff.c"
03c7c                 | ' 			{
03c7c                 | ' 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr %  ((UINT) 512 ) );
03c7c                 | ' 			}
03c7c                 | ' 		}
03c7c                 | ' 	}
03c7c                 | ' 
03c7c                 | ' 	return res;
03c7c     0C 4E 05 F1 | 	add	fp, #12
03c80     A7 A6 01 FB | 	rdlong	result1, fp
03c84     0C 4E 85 F1 | 	sub	fp, #12
03c88     A7 F0 03 F6 | 	mov	ptra, fp
03c8c     B2 00 A0 FD | 	call	#popregs_
03c90                 | _fatfs_cc_follow_path_ret
03c90     2D 00 64 FD | 	ret
03c94                 | 
03c94                 | _fatfs_cc_get_ldnumber
03c94     01 AA 65 F6 | 	neg	_var01, #1
03c98     E1 AC 09 FB | 	rdlong	_var02, arg01 wz
03c9c     D6 AE 01 F6 | 	mov	_var03, _var02
03ca0     01 A6 65 A6 |  if_e	neg	result1, #1
03ca4     74 00 90 AD |  if_e	jmp	#_fatfs_cc_get_ldnumber_ret
03ca8     97 10 48 FB | 	callpa	#(@LR__0481-@LR__0480)>>2,fcache_load_ptr_
03cac                 | ' 	do tc = *tt++; while (! ((UINT)(tc) < ( 0 ? ' ' : '!'))  && tc != ':');
03cac                 | LR__0480
03cac     D7 B0 C1 FA | 	rdbyte	_var04, _var03
03cb0     D8 A6 E1 F8 | 	getbyte	result1, _var04, #0
03cb4     21 A6 15 F2 | 	cmp	result1, #33 wc
03cb8     01 AE 05 F1 | 	add	_var03, #1
03cbc     D8 B2 01 36 |  if_ae	mov	_var05, _var04
03cc0     D9 B2 E1 38 |  if_ae	getbyte	_var05, _var05, #0
03cc4     3A B2 0D 32 |  if_ae	cmp	_var05, #58 wz
03cc8     E0 FF 9F 1D |  if_a	jmp	#LR__0480
03ccc                 | LR__0481
03ccc     D8 B0 E1 F8 | 	getbyte	_var04, _var04, #0
03cd0     3A B0 0D F2 | 	cmp	_var04, #58 wz
03cd4     40 00 90 5D |  if_ne	jmp	#LR__0483
03cd8     01 B4 05 F6 | 	mov	_var06, #1
03cdc     D6 B2 C1 FA | 	rdbyte	_var05, _var02
03ce0     30 B2 15 F2 | 	cmp	_var05, #48 wc
03ce4     1C 00 90 CD |  if_b	jmp	#LR__0482
03ce8     D6 B2 C1 FA | 	rdbyte	_var05, _var02
03cec     3A B2 15 F2 | 	cmp	_var05, #58 wc
03cf0     D6 B6 01 C6 |  if_b	mov	_var07, _var02
03cf4     02 B6 05 C1 |  if_b	add	_var07, #2
03cf8     D7 B6 09 C2 |  if_b	cmp	_var07, _var03 wz
03cfc     D9 B4 01 86 |  if_c_and_z	mov	_var06, _var05
03d00     30 B4 85 81 |  if_c_and_z	sub	_var06, #48
03d04                 | LR__0482
03d04     01 B4 55 F2 | 	cmps	_var06, #1 wc
03d08     DA AA 01 C6 |  if_b	mov	_var01, _var06
03d0c     E1 AE 61 CC |  if_b	wrlong	_var03, arg01
03d10                 | ' 			vol = i;
03d10                 | ' 			*path = tt;
03d10                 | ' 		}
03d10                 | ' 		return vol;
03d10     D5 A6 01 F6 | 	mov	result1, _var01
03d14     04 00 90 FD | 	jmp	#_fatfs_cc_get_ldnumber_ret
03d18                 | LR__0483
03d18                 | ' 	}
03d18                 | ' #line 3170 "ff.c"
03d18                 | ' 	vol = 0;
03d18                 | ' 
03d18                 | ' 	return vol;
03d18     00 A6 05 F6 | 	mov	result1, #0
03d1c                 | _fatfs_cc_get_ldnumber_ret
03d1c     2D 00 64 FD | 	ret
03d20                 | 
03d20                 | _fatfs_cc_check_fs
03d20     04 4A 05 F6 | 	mov	COUNT_, #4
03d24     A8 00 A0 FD | 	call	#pushregs_
03d28     E1 D8 01 F6 | 	mov	local01, arg01
03d2c     03 D8 05 F1 | 	add	local01, #3
03d30     EC 00 48 FC | 	wrbyte	#0, local01
03d34     29 D8 05 F1 | 	add	local01, #41
03d38     FF FF FF FF 
03d3c     EC FE 6B FC | 	wrlong	##-1, local01
03d40     2C D8 85 F1 | 	sub	local01, #44
03d44     EC C2 01 F6 | 	mov	arg01, local01
03d48     04 EA BF FD | 	call	#_fatfs_cc_move_window
03d4c     00 A6 0D F2 | 	cmp	result1, #0 wz
03d50     04 A6 05 56 |  if_ne	mov	result1, #4
03d54     64 01 90 5D |  if_ne	jmp	#LR__0493
03d58     30 D8 05 F1 | 	add	local01, #48
03d5c     EC C2 01 F6 | 	mov	arg01, local01
03d60     FE C3 05 F1 | 	add	arg01, #510
03d64                 | ' {
03d64                 | ' 
03d64                 | ' 	return *((WORD*)ptr);
03d64     E1 DA E1 FA | 	rdword	local02, arg01
03d68     EC DC C1 FA | 	rdbyte	local03, local01
03d6c     30 D8 85 F1 | 	sub	local01, #48
03d70     EE DE E1 F8 | 	getbyte	local04, local03, #0
03d74     EB DE 0D F2 | 	cmp	local04, #235 wz
03d78     EE C6 01 56 |  if_ne	mov	arg03, local03
03d7c     E3 C6 E1 58 |  if_ne	getbyte	arg03, arg03, #0
03d80     E9 C6 0D 52 |  if_ne	cmp	arg03, #233 wz
03d84     EE DC E1 58 |  if_ne	getbyte	local03, local03, #0
03d88     E8 DC 0D 52 |  if_ne	cmp	local03, #232 wz
03d8c     14 01 90 5D |  if_ne	jmp	#LR__0492
03d90     ED DE 31 F9 | 	getword	local04, local02, #0
03d94     55 00 00 FF 
03d98     55 DE 0D F2 | 	cmp	local04, ##43605 wz
03d9c     24 00 90 5D |  if_ne	jmp	#LR__0490
03da0     EC C2 01 F6 | 	mov	arg01, local01
03da4     82 C2 05 F1 | 	add	arg01, #130
03da8     7C 00 00 FF 
03dac     5D C5 05 F6 | 	mov	arg02, ##@LR__2097
03db0     08 C6 05 F6 | 	mov	arg03, #8
03db4     C4 DE BF FD | 	call	#_fatfs_cc_memcmp
03db8     00 A6 0D F2 | 	cmp	result1, #0 wz
03dbc                 | ' 			return 0;
03dbc     00 A6 05 A6 |  if_e	mov	result1, #0
03dc0     F8 00 90 AD |  if_e	jmp	#LR__0493
03dc4                 | LR__0490
03dc4     30 D8 05 F1 | 	add	local01, #48
03dc8     EC C2 01 F6 | 	mov	arg01, local01
03dcc     0B C2 05 F1 | 	add	arg01, #11
03dd0                 | ' {
03dd0                 | ' 
03dd0                 | ' 	return *((WORD*)ptr);
03dd0     E1 A6 E1 FA | 	rdword	result1, arg01
03dd4     0D D8 05 F1 | 	add	local01, #13
03dd8     EC DC C1 FA | 	rdbyte	local03, local01
03ddc     3D D8 85 F1 | 	sub	local01, #61
03de0     D3 DE 31 F9 | 	getword	local04, result1, #0
03de4     D3 C4 31 F9 | 	getword	arg02, result1, #0
03de8     01 C4 85 F1 | 	sub	arg02, #1
03dec     E2 DE C9 F7 | 	test	local04, arg02 wz
03df0     B0 00 90 5D |  if_ne	jmp	#LR__0491
03df4     D3 C4 31 F9 | 	getword	arg02, result1, #0
03df8     01 00 00 FF 
03dfc     00 C4 15 F2 | 	cmp	arg02, ##512 wc
03e00     A0 00 90 CD |  if_b	jmp	#LR__0491
03e04     D3 C4 31 F9 | 	getword	arg02, result1, #0
03e08     01 00 00 FF 
03e0c     01 C4 15 F2 | 	cmp	arg02, ##513 wc
03e10     90 00 90 3D |  if_ae	jmp	#LR__0491
03e14     EE C2 01 F6 | 	mov	arg01, local03
03e18     07 C2 4D F7 | 	zerox	arg01, #7 wz
03e1c     84 00 90 AD |  if_e	jmp	#LR__0491
03e20     EE C2 E1 F8 | 	getbyte	arg01, local03, #0
03e24     EE DC E1 F8 | 	getbyte	local03, local03, #0
03e28     01 DC 85 F1 | 	sub	local03, #1
03e2c     EE C2 C9 F7 | 	test	arg01, local03 wz
03e30     70 00 90 5D |  if_ne	jmp	#LR__0491
03e34     EC C2 01 F6 | 	mov	arg01, local01
03e38     3E C2 05 F1 | 	add	arg01, #62
03e3c                 | ' {
03e3c                 | ' 
03e3c                 | ' 	return *((WORD*)ptr);
03e3c     E1 A6 E9 FA | 	rdword	result1, arg01 wz
03e40     60 00 90 AD |  if_e	jmp	#LR__0491
03e44     40 D8 05 F1 | 	add	local01, #64
03e48     EC C2 C1 FA | 	rdbyte	arg01, local01
03e4c     40 D8 85 F1 | 	sub	local01, #64
03e50     01 C2 85 F1 | 	sub	arg01, #1
03e54     02 C2 15 F2 | 	cmp	arg01, #2 wc
03e58     48 00 90 3D |  if_ae	jmp	#LR__0491
03e5c     EC C2 01 F6 | 	mov	arg01, local01
03e60     41 C2 05 F1 | 	add	arg01, #65
03e64                 | ' {
03e64                 | ' 
03e64                 | ' 	return *((WORD*)ptr);
03e64     E1 A6 E9 FA | 	rdword	result1, arg01 wz
03e68     38 00 90 AD |  if_e	jmp	#LR__0491
03e6c     EC C2 01 F6 | 	mov	arg01, local01
03e70     43 C2 05 F1 | 	add	arg01, #67
03e74                 | ' {
03e74                 | ' 
03e74                 | ' 	return *((WORD*)ptr);
03e74     E1 A6 E1 FA | 	rdword	result1, arg01
03e78     D3 DC 31 F9 | 	getword	local03, result1, #0
03e7c     80 DC 15 F2 | 	cmp	local03, #128 wc
03e80     EC C2 01 C6 |  if_b	mov	arg01, local01
03e84     50 C2 05 C1 |  if_b	add	arg01, #80
03e88                 | ' {
03e88                 | ' 
03e88                 | ' 	return *((DWORD*)ptr);
03e88     E1 A6 01 CB |  if_b	rdlong	result1, arg01
03e8c     80 00 00 CF 
03e90     00 A6 15 C2 |  if_b	cmp	result1, ##65536 wc
03e94     46 D8 05 31 |  if_ae	add	local01, #70
03e98                 | ' {
03e98                 | ' 
03e98                 | ' 	return *((WORD*)ptr);
03e98     EC A6 E9 3A |  if_ae	rdword	result1, local01 wz
03e9c                 | ' 			&& b != 0 && (b & (b - 1)) == 0
03e9c                 | ' 			&& ld_word(fs->win +  14 ) != 0
03e9c                 | ' 			&& (UINT)fs->win[ 16 ] - 1 <= 1
03e9c                 | ' 			&& ld_word(fs->win +  17 ) != 0
03e9c                 | ' 			&& (ld_word(fs->win +  19 ) >= 128 || ld_dword(fs->win +  32 ) >= 0x10000)
03e9c                 | ' 			&& ld_word(fs->win +  22 ) != 0) {
03e9c                 | ' 				return 0;
03e9c     00 A6 05 16 |  if_a	mov	result1, #0
03ea0     18 00 90 1D |  if_a	jmp	#LR__0493
03ea4                 | LR__0491
03ea4                 | LR__0492
03ea4                 | ' 		}
03ea4                 | ' 	}
03ea4                 | ' 	return sign == 0xAA55 ? 2 : 3;
03ea4     ED DC 31 F9 | 	getword	local03, local02, #0
03ea8     55 00 00 FF 
03eac     55 DC 0D F2 | 	cmp	local03, ##43605 wz
03eb0     02 DE 05 A6 |  if_e	mov	local04, #2
03eb4     03 DE 05 56 |  if_ne	mov	local04, #3
03eb8     EF A6 01 F6 | 	mov	result1, local04
03ebc                 | LR__0493
03ebc     A7 F0 03 F6 | 	mov	ptra, fp
03ec0     B2 00 A0 FD | 	call	#popregs_
03ec4                 | _fatfs_cc_check_fs_ret
03ec4     2D 00 64 FD | 	ret
03ec8                 | 
03ec8                 | _fatfs_cc_find_volume
03ec8     05 4A 05 F6 | 	mov	COUNT_, #5
03ecc     A8 00 A0 FD | 	call	#pushregs_
03ed0     24 F0 07 F1 | 	add	ptra, #36
03ed4     E1 D8 01 F6 | 	mov	local01, arg01
03ed8     E2 DA 01 F6 | 	mov	local02, arg02
03edc     EC C2 01 F6 | 	mov	arg01, local01
03ee0     00 C4 05 F6 | 	mov	arg02, #0
03ee4     38 FE BF FD | 	call	#_fatfs_cc_check_fs
03ee8     02 A6 0D F2 | 	cmp	result1, #2 wz
03eec     0C 00 90 AD |  if_e	jmp	#LR__0500
03ef0     03 A6 15 F2 | 	cmp	result1, #3 wc
03ef4     00 DA 0D C2 |  if_b	cmp	local02, #0 wz
03ef8     C8 00 90 BD |  if_nc_or_z	jmp	#LR__0508
03efc                 | LR__0500
03efc                 | ' 	for (i = 0; i < 4; i++) {
03efc     00 DC 05 F6 | 	mov	local03, #0
03f00     97 22 48 FB | 	callpa	#(@LR__0502-@LR__0501)>>2,fcache_load_ptr_
03f04                 | LR__0501
03f04     04 DC 15 F2 | 	cmp	local03, #4 wc
03f08     3C 00 90 3D |  if_ae	jmp	#LR__0503
03f0c     EE DE 01 F6 | 	mov	local04, local03
03f10     02 DE 65 F0 | 	shl	local04, #2
03f14     A7 C4 01 F6 | 	mov	arg02, fp
03f18     14 C4 05 F1 | 	add	arg02, #20
03f1c     E2 DE 01 F1 | 	add	local04, arg02
03f20     EC C2 01 F6 | 	mov	arg01, local01
03f24     EE C3 05 F1 | 	add	arg01, #494
03f28     EE C4 01 F6 | 	mov	arg02, local03
03f2c     04 C4 65 F0 | 	shl	arg02, #4
03f30     E2 C2 01 F1 | 	add	arg01, arg02
03f34     08 C2 05 F1 | 	add	arg01, #8
03f38                 | ' {
03f38                 | ' 
03f38                 | ' 	return *((DWORD*)ptr);
03f38     E1 A6 01 FB | 	rdlong	result1, arg01
03f3c     EF A6 61 FC | 	wrlong	result1, local04
03f40     01 DC 05 F1 | 	add	local03, #1
03f44     BC FF 9F FD | 	jmp	#LR__0501
03f48                 | LR__0502
03f48                 | LR__0503
03f48     00 DA 0D F2 | 	cmp	local02, #0 wz
03f4c     ED DE 01 56 |  if_ne	mov	local04, local02
03f50     01 DE 85 51 |  if_ne	sub	local04, #1
03f54     00 DE 05 A6 |  if_e	mov	local04, #0
03f58     EF DC 01 F6 | 	mov	local03, local04
03f5c                 | ' 		mbr_pt[i] = ld_dword(fs->win +  446  + i *  16  +  8 );
03f5c                 | ' 	}
03f5c                 | ' 	i = part ? part - 1 : 0;
03f5c                 | ' 	do {
03f5c                 | LR__0504
03f5c     EE DE 01 F6 | 	mov	local04, local03
03f60     02 DE 65 F0 | 	shl	local04, #2
03f64     A7 C4 01 F6 | 	mov	arg02, fp
03f68     14 C4 05 F1 | 	add	arg02, #20
03f6c     E2 DE 01 F1 | 	add	local04, arg02
03f70     EF DE 09 FB | 	rdlong	local04, local04 wz
03f74     28 00 90 AD |  if_e	jmp	#LR__0505
03f78     EE DE 01 F6 | 	mov	local04, local03
03f7c     02 DE 65 F0 | 	shl	local04, #2
03f80     A7 C4 01 F6 | 	mov	arg02, fp
03f84     14 C4 05 F1 | 	add	arg02, #20
03f88     E2 DE 01 F1 | 	add	local04, arg02
03f8c     EF C4 01 FB | 	rdlong	arg02, local04
03f90     EC C2 01 F6 | 	mov	arg01, local01
03f94     88 FD BF FD | 	call	#_fatfs_cc_check_fs
03f98     D3 DE 01 F6 | 	mov	local04, result1
03f9c     04 00 90 FD | 	jmp	#LR__0506
03fa0                 | LR__0505
03fa0     03 DE 05 F6 | 	mov	local04, #3
03fa4                 | LR__0506
03fa4     EF E0 01 F6 | 	mov	local05, local04
03fa8     00 DA 0D F2 | 	cmp	local02, #0 wz
03fac     02 E0 15 A2 |  if_e	cmp	local05, #2 wc
03fb0     0C 00 90 8D |  if_c_and_z	jmp	#LR__0507
03fb4     01 DC 05 A1 |  if_e	add	local03, #1
03fb8     04 DC 15 A2 |  if_e	cmp	local03, #4 wc
03fbc     9C FF 9F 8D |  if_c_and_z	jmp	#LR__0504
03fc0                 | LR__0507
03fc0                 | ' 	return fmt;
03fc0     F0 A6 01 F6 | 	mov	result1, local05
03fc4                 | LR__0508
03fc4     A7 F0 03 F6 | 	mov	ptra, fp
03fc8     B2 00 A0 FD | 	call	#popregs_
03fcc                 | _fatfs_cc_find_volume_ret
03fcc     2D 00 64 FD | 	ret
03fd0                 | 
03fd0                 | _fatfs_cc_mount_volume
03fd0     0B 4A 05 F6 | 	mov	COUNT_, #11
03fd4     A8 00 A0 FD | 	call	#pushregs_
03fd8     E2 D8 01 F6 | 	mov	local01, arg02
03fdc     E3 DA 01 F6 | 	mov	local02, arg03
03fe0     EC 00 68 FC | 	wrlong	#0, local01
03fe4     AC FC BF FD | 	call	#_fatfs_cc_get_ldnumber
03fe8     D3 DC 01 F6 | 	mov	local03, result1
03fec     00 DC 55 F2 | 	cmps	local03, #0 wc
03ff0     0B A6 05 C6 |  if_b	mov	result1, #11
03ff4     E0 04 90 CD |  if_b	jmp	#LR__0519
03ff8     EE C6 01 F6 | 	mov	arg03, local03
03ffc     02 C6 65 F0 | 	shl	arg03, #2
04000     C8 C6 01 F1 | 	add	arg03, objptr
04004     E3 DE 09 FB | 	rdlong	local04, arg03 wz
04008     0C A6 05 A6 |  if_e	mov	result1, #12
0400c     C8 04 90 AD |  if_e	jmp	#LR__0519
04010     EC DE 61 FC | 	wrlong	local04, local01
04014     ED DA E1 F8 | 	getbyte	local02, local02, #0
04018     FE DA 05 F5 | 	and	local02, #254
0401c     EF C6 C9 FA | 	rdbyte	arg03, local04 wz
04020     44 00 90 AD |  if_e	jmp	#LR__0511
04024     01 DE 05 F1 | 	add	local04, #1
04028     EF C2 C9 FA | 	rdbyte	arg01, local04 wz
0402c     01 DE 85 F1 | 	sub	local04, #1
04030     01 A6 05 56 |  if_ne	mov	result1, #1
04034                 | ' 
04034                 | ' 	return Stat;
04034     24 90 05 A1 |  if_e	add	objptr, #36
04038     C8 A6 C1 AA |  if_e	rdbyte	result1, objptr
0403c     24 90 85 A1 |  if_e	sub	objptr, #36
04040     D3 C6 E1 F8 | 	getbyte	arg03, result1, #0
04044     01 C6 CD F7 | 	test	arg03, #1 wz
04048     1C 00 90 5D |  if_ne	jmp	#LR__0510
0404c     00 DA 0D F2 | 	cmp	local02, #0 wz
04050     D3 A6 E1 58 |  if_ne	getbyte	result1, result1, #0
04054     04 A6 CD 57 |  if_ne	test	result1, #4 wz
04058                 | ' 				return FR_WRITE_PROTECTED;
04058     0A A6 05 56 |  if_ne	mov	result1, #10
0405c     78 04 90 5D |  if_ne	jmp	#LR__0519
04060                 | ' 			}
04060                 | ' 			return FR_OK;
04060     00 A6 05 F6 | 	mov	result1, #0
04064     70 04 90 FD | 	jmp	#LR__0519
04068                 | LR__0510
04068                 | LR__0511
04068     EF 00 48 FC | 	wrbyte	#0, local04
0406c     01 DE 05 F1 | 	add	local04, #1
04070     EF DC 41 FC | 	wrbyte	local03, local04
04074     EE C2 E1 F8 | 	getbyte	arg01, local03, #0
04078     01 DE 85 F1 | 	sub	local04, #1
0407c     04 DD BF FD | 	call	#_fatfs_cc_disk_initialize
04080     D3 C6 01 F6 | 	mov	arg03, result1
04084     E3 E0 E1 F8 | 	getbyte	local05, arg03, #0
04088     01 E0 CD F7 | 	test	local05, #1 wz
0408c                 | ' 		return FR_NOT_READY;
0408c     03 A6 05 56 |  if_ne	mov	result1, #3
04090     44 04 90 5D |  if_ne	jmp	#LR__0519
04094     00 DA 0D F2 | 	cmp	local02, #0 wz
04098     E3 E0 01 56 |  if_ne	mov	local05, arg03
0409c     F0 E0 E1 58 |  if_ne	getbyte	local05, local05, #0
040a0     04 E0 CD 57 |  if_ne	test	local05, #4 wz
040a4                 | ' 		return FR_WRITE_PROTECTED;
040a4     0A A6 05 56 |  if_ne	mov	result1, #10
040a8     2C 04 90 5D |  if_ne	jmp	#LR__0519
040ac     EF C2 01 F6 | 	mov	arg01, local04
040b0     00 C4 05 F6 | 	mov	arg02, #0
040b4     10 FE BF FD | 	call	#_fatfs_cc_find_volume
040b8     D3 C2 01 F6 | 	mov	arg01, result1
040bc     04 C2 0D F2 | 	cmp	arg01, #4 wz
040c0     01 A6 05 A6 |  if_e	mov	result1, #1
040c4     10 04 90 AD |  if_e	jmp	#LR__0519
040c8     02 C2 15 F2 | 	cmp	arg01, #2 wc
040cc     0D A6 05 36 |  if_ae	mov	result1, #13
040d0     04 04 90 3D |  if_ae	jmp	#LR__0519
040d4     2C DE 05 F1 | 	add	local04, #44
040d8     EF E2 01 FB | 	rdlong	local06, local04
040dc     04 DE 05 F1 | 	add	local04, #4
040e0     EF C2 01 F6 | 	mov	arg01, local04
040e4     30 DE 85 F1 | 	sub	local04, #48
040e8     0B C2 05 F1 | 	add	arg01, #11
040ec                 | ' {
040ec                 | ' 
040ec                 | ' 	return *((WORD*)ptr);
040ec     E1 A6 E1 FA | 	rdword	result1, arg01
040f0     01 00 00 FF 
040f4     00 A6 0D F2 | 	cmp	result1, ##512 wz
040f8     0D A6 05 56 |  if_ne	mov	result1, #13
040fc     D8 03 90 5D |  if_ne	jmp	#LR__0519
04100     EF C2 01 F6 | 	mov	arg01, local04
04104     46 C2 05 F1 | 	add	arg01, #70
04108                 | ' {
04108                 | ' 
04108                 | ' 	return *((WORD*)ptr);
04108     E1 A6 E1 FA | 	rdword	result1, arg01
0410c     D3 E4 09 F6 | 	mov	local07, result1 wz
04110     EF C2 01 A6 |  if_e	mov	arg01, local04
04114     54 C2 05 A1 |  if_e	add	arg01, #84
04118                 | ' {
04118                 | ' 
04118                 | ' 	return *((DWORD*)ptr);
04118     E1 A6 01 AB |  if_e	rdlong	result1, arg01
0411c     D3 E4 01 A6 |  if_e	mov	local07, result1
04120     18 DE 05 F1 | 	add	local04, #24
04124     EF E4 61 FC | 	wrlong	local07, local04
04128     28 DE 05 F1 | 	add	local04, #40
0412c     EF E0 C1 FA | 	rdbyte	local05, local04
04130     3E DE 85 F1 | 	sub	local04, #62
04134     EF E0 41 FC | 	wrbyte	local05, local04
04138     F0 E0 E1 F8 | 	getbyte	local05, local05, #0
0413c     02 DE 85 F1 | 	sub	local04, #2
04140     01 E0 0D F2 | 	cmp	local05, #1 wz
04144     02 DE 05 51 |  if_ne	add	local04, #2
04148     EF E0 C1 5A |  if_ne	rdbyte	local05, local04
0414c     02 DE 85 51 |  if_ne	sub	local04, #2
04150     02 E0 0D 52 |  if_ne	cmp	local05, #2 wz
04154     0D A6 05 56 |  if_ne	mov	result1, #13
04158     7C 03 90 5D |  if_ne	jmp	#LR__0519
0415c     02 DE 05 F1 | 	add	local04, #2
04160     EF E0 C1 FA | 	rdbyte	local05, local04
04164     F0 E4 01 FD | 	qmul	local07, local05
04168     3B DE 05 F1 | 	add	local04, #59
0416c     EF E0 C1 FA | 	rdbyte	local05, local04
04170     33 DE 85 F1 | 	sub	local04, #51
04174     EF E0 51 FC | 	wrword	local05, local04
04178     F0 E0 31 F9 | 	getword	local05, local05, #0
0417c     0A DE 85 F1 | 	sub	local04, #10
04180     0F E0 4D F7 | 	zerox	local05, #15 wz
04184     18 E4 61 FD | 	getqx	local07
04188     20 00 90 AD |  if_e	jmp	#LR__0512
0418c     0A DE 05 F1 | 	add	local04, #10
04190     EF E0 E1 FA | 	rdword	local05, local04
04194     F0 DC 31 F9 | 	getword	local03, local05, #0
04198     0A DE 85 F1 | 	sub	local04, #10
0419c     F0 E0 31 F9 | 	getword	local05, local05, #0
041a0     01 E0 85 F1 | 	sub	local05, #1
041a4     F0 DC C9 F7 | 	test	local03, local05 wz
041a8     08 00 90 AD |  if_e	jmp	#LR__0513
041ac                 | LR__0512
041ac     0D A6 05 F6 | 	mov	result1, #13
041b0     24 03 90 FD | 	jmp	#LR__0519
041b4                 | LR__0513
041b4     30 DE 05 F1 | 	add	local04, #48
041b8     EF C2 01 F6 | 	mov	arg01, local04
041bc     11 C2 05 F1 | 	add	arg01, #17
041c0                 | ' {
041c0                 | ' 
041c0                 | ' 	return *((WORD*)ptr);
041c0     E1 A6 E1 FA | 	rdword	result1, arg01
041c4     28 DE 85 F1 | 	sub	local04, #40
041c8     EF A6 51 FC | 	wrword	result1, local04
041cc     D3 E0 31 F9 | 	getword	local05, result1, #0
041d0     08 DE 85 F1 | 	sub	local04, #8
041d4     F0 C2 51 F6 | 	abs	arg01, local05 wc
041d8     E1 C2 41 F8 | 	getnib	arg01, arg01, #0
041dc     E1 C2 89 F6 | 	negc	arg01, arg01 wz
041e0     0D A6 05 56 |  if_ne	mov	result1, #13
041e4     F0 02 90 5D |  if_ne	jmp	#LR__0519
041e8     EF C2 01 F6 | 	mov	arg01, local04
041ec     43 C2 05 F1 | 	add	arg01, #67
041f0                 | ' {
041f0                 | ' 
041f0                 | ' 	return *((WORD*)ptr);
041f0     E1 A6 E1 FA | 	rdword	result1, arg01
041f4     D3 E6 09 F6 | 	mov	local08, result1 wz
041f8     EF C2 01 A6 |  if_e	mov	arg01, local04
041fc     50 C2 05 A1 |  if_e	add	arg01, #80
04200                 | ' {
04200                 | ' 
04200                 | ' 	return *((DWORD*)ptr);
04200     E1 E6 01 AB |  if_e	rdlong	local08, arg01
04204     EF C2 01 F6 | 	mov	arg01, local04
04208     3E C2 05 F1 | 	add	arg01, #62
0420c                 | ' {
0420c                 | ' 
0420c                 | ' 	return *((WORD*)ptr);
0420c     E1 A6 E1 FA | 	rdword	result1, arg01
04210     D3 C2 01 F6 | 	mov	arg01, result1
04214     E1 E0 01 F6 | 	mov	local05, arg01
04218     0F E0 4D F7 | 	zerox	local05, #15 wz
0421c     0D A6 05 A6 |  if_e	mov	result1, #13
04220     B4 02 90 AD |  if_e	jmp	#LR__0519
04224     E1 E8 31 F9 | 	getword	local09, arg01, #0
04228     F2 E8 01 F1 | 	add	local09, local07
0422c     08 DE 05 F1 | 	add	local04, #8
04230     EF E0 E1 FA | 	rdword	local05, local04
04234     08 DE 85 F1 | 	sub	local04, #8
04238     F0 E0 51 F6 | 	abs	local05, local05 wc
0423c     04 E0 45 F0 | 	shr	local05, #4
04240     F0 E8 81 F3 | 	sumc	local09, local05
04244     F4 E6 11 F2 | 	cmp	local08, local09 wc
04248     0D A6 05 C6 |  if_b	mov	result1, #13
0424c     88 02 90 CD |  if_b	jmp	#LR__0519
04250     F4 E6 81 F1 | 	sub	local08, local09
04254     0A DE 05 F1 | 	add	local04, #10
04258     EF E0 E1 FA | 	rdword	local05, local04
0425c     F0 E6 11 FD | 	qdiv	local08, local05
04260     0A DE 85 F1 | 	sub	local04, #10
04264     18 E0 61 FD | 	getqx	local05
04268     00 E0 0D F2 | 	cmp	local05, #0 wz
0426c     0D A6 05 A6 |  if_e	mov	result1, #13
04270     64 02 90 AD |  if_e	jmp	#LR__0519
04274     00 EA 05 F6 | 	mov	local10, #0
04278     FF FF 07 FF 
0427c     F6 E1 15 F2 | 	cmp	local05, ##268435446 wc
04280     03 EA 05 C6 |  if_b	mov	local10, #3
04284     7F 00 00 FF 
04288     F6 E1 15 F2 | 	cmp	local05, ##65526 wc
0428c     02 EA 05 C6 |  if_b	mov	local10, #2
04290     07 00 00 FF 
04294     F6 E1 15 F2 | 	cmp	local05, ##4086 wc
04298     01 EA 05 C6 |  if_b	mov	local10, #1
0429c     00 EA 0D F2 | 	cmp	local10, #0 wz
042a0     0D A6 05 A6 |  if_e	mov	result1, #13
042a4     30 02 90 AD |  if_e	jmp	#LR__0519
042a8     02 E0 05 F1 | 	add	local05, #2
042ac     14 DE 05 F1 | 	add	local04, #20
042b0     EF E0 61 FC | 	wrlong	local05, local04
042b4     08 DE 05 F1 | 	add	local04, #8
042b8     EF E2 61 FC | 	wrlong	local06, local04
042bc     F1 E0 01 F6 | 	mov	local05, local06
042c0     E1 C2 31 F9 | 	getword	arg01, arg01, #0
042c4     E1 E0 01 F1 | 	add	local05, arg01
042c8     04 DE 05 F1 | 	add	local04, #4
042cc     EF E0 61 FC | 	wrlong	local05, local04
042d0     F1 E0 01 F6 | 	mov	local05, local06
042d4     F4 E0 01 F1 | 	add	local05, local09
042d8     08 DE 05 F1 | 	add	local04, #8
042dc     EF E0 61 FC | 	wrlong	local05, local04
042e0     28 DE 85 F1 | 	sub	local04, #40
042e4     03 EA 0D F2 | 	cmp	local10, #3 wz
042e8     54 00 90 5D |  if_ne	jmp	#LR__0514
042ec     EF C2 01 F6 | 	mov	arg01, local04
042f0     5A C2 05 F1 | 	add	arg01, #90
042f4                 | ' {
042f4                 | ' 
042f4                 | ' 	return *((WORD*)ptr);
042f4     E1 A6 E9 FA | 	rdword	result1, arg01 wz
042f8     0D A6 05 56 |  if_ne	mov	result1, #13
042fc     D8 01 90 5D |  if_ne	jmp	#LR__0519
04300     08 DE 05 F1 | 	add	local04, #8
04304     EF E0 E9 FA | 	rdword	local05, local04 wz
04308     08 DE 85 F1 | 	sub	local04, #8
0430c     0D A6 05 56 |  if_ne	mov	result1, #13
04310     C4 01 90 5D |  if_ne	jmp	#LR__0519
04314     30 DE 05 F1 | 	add	local04, #48
04318     EF C2 01 F6 | 	mov	arg01, local04
0431c     2C C2 05 F1 | 	add	arg01, #44
04320                 | ' {
04320                 | ' 
04320                 | ' 	return *((DWORD*)ptr);
04320     E1 A6 01 FB | 	rdlong	result1, arg01
04324     0C DE 85 F1 | 	sub	local04, #12
04328     EF A6 61 FC | 	wrlong	result1, local04
0432c     10 DE 85 F1 | 	sub	local04, #16
04330     EF EC 01 FB | 	rdlong	local11, local04
04334     14 DE 85 F1 | 	sub	local04, #20
04338     02 EC 65 F0 | 	shl	local11, #2
0433c     6C 00 90 FD | 	jmp	#LR__0516
04340                 | LR__0514
04340     08 DE 05 F1 | 	add	local04, #8
04344     EF E0 E9 FA | 	rdword	local05, local04 wz
04348     08 DE 85 F1 | 	sub	local04, #8
0434c     0D A6 05 A6 |  if_e	mov	result1, #13
04350     84 01 90 AD |  if_e	jmp	#LR__0519
04354     20 DE 05 F1 | 	add	local04, #32
04358     EF E0 01 FB | 	rdlong	local05, local04
0435c     F2 E0 01 F1 | 	add	local05, local07
04360     04 DE 05 F1 | 	add	local04, #4
04364     EF E0 61 FC | 	wrlong	local05, local04
04368     24 DE 85 F1 | 	sub	local04, #36
0436c     02 EA 0D F2 | 	cmp	local10, #2 wz
04370     14 DE 05 A1 |  if_e	add	local04, #20
04374     EF E0 01 AB |  if_e	rdlong	local05, local04
04378     14 DE 85 A1 |  if_e	sub	local04, #20
0437c     01 E0 65 A0 |  if_e	shl	local05, #1
04380     24 00 90 AD |  if_e	jmp	#LR__0515
04384     14 DE 05 F1 | 	add	local04, #20
04388     EF EC 01 FB | 	rdlong	local11, local04
0438c     F6 E0 01 F6 | 	mov	local05, local11
04390     01 E0 65 F0 | 	shl	local05, #1
04394     F6 E0 01 F1 | 	add	local05, local11
04398     01 E0 45 F0 | 	shr	local05, #1
0439c     14 DE 85 F1 | 	sub	local04, #20
043a0     01 EC 05 F5 | 	and	local11, #1
043a4     F6 E0 01 F1 | 	add	local05, local11
043a8                 | LR__0515
043a8     F0 EC 01 F6 | 	mov	local11, local05
043ac                 | LR__0516
043ac     FF ED 05 F1 | 	add	local11, #511
043b0     09 EC 45 F0 | 	shr	local11, #9
043b4     18 DE 05 F1 | 	add	local04, #24
043b8     EF C6 01 FB | 	rdlong	arg03, local04
043bc     18 DE 85 F1 | 	sub	local04, #24
043c0     F6 C6 11 F2 | 	cmp	arg03, local11 wc
043c4     0D A6 05 C6 |  if_b	mov	result1, #13
043c8     0C 01 90 CD |  if_b	jmp	#LR__0519
043cc     10 DE 05 F1 | 	add	local04, #16
043d0     FF FF FF FF 
043d4     EF FE 6B FC | 	wrlong	##-1, local04
043d8     04 DE 85 F1 | 	sub	local04, #4
043dc     FF FF FF FF 
043e0     EF FE 6B FC | 	wrlong	##-1, local04
043e4     08 DE 85 F1 | 	sub	local04, #8
043e8     EF 00 49 FC | 	wrbyte	#128, local04
043ec     04 DE 85 F1 | 	sub	local04, #4
043f0     03 EA 0D F2 | 	cmp	local10, #3 wz
043f4     EF C2 01 A6 |  if_e	mov	arg01, local04
043f8     60 C2 05 A1 |  if_e	add	arg01, #96
043fc                 | ' {
043fc                 | ' 
043fc                 | ' 	return *((WORD*)ptr);
043fc     E1 A6 E1 AA |  if_e	rdword	result1, arg01
04400     D3 E0 31 A9 |  if_e	getword	local05, result1, #0
04404     01 E0 0D A2 |  if_e	cmp	local05, #1 wz
04408     A4 00 90 5D |  if_ne	jmp	#LR__0518
0440c     01 E2 05 F1 | 	add	local06, #1
04410     EF C2 01 F6 | 	mov	arg01, local04
04414     F1 C4 01 F6 | 	mov	arg02, local06
04418     34 E3 BF FD | 	call	#_fatfs_cc_move_window
0441c     00 A6 0D F2 | 	cmp	result1, #0 wz
04420     8C 00 90 5D |  if_ne	jmp	#LR__0518
04424     04 DE 05 F1 | 	add	local04, #4
04428     EF 00 48 FC | 	wrbyte	#0, local04
0442c     2C DE 05 F1 | 	add	local04, #44
04430     EF C2 01 F6 | 	mov	arg01, local04
04434     30 DE 85 F1 | 	sub	local04, #48
04438     FE C3 05 F1 | 	add	arg01, #510
0443c                 | ' {
0443c                 | ' 
0443c                 | ' 	return *((WORD*)ptr);
0443c     E1 A6 E1 FA | 	rdword	result1, arg01
04440     D3 E0 31 F9 | 	getword	local05, result1, #0
04444     55 00 00 FF 
04448     55 E0 0D F2 | 	cmp	local05, ##43605 wz
0444c     EF C2 01 A6 |  if_e	mov	arg01, local04
04450     30 C2 05 A1 |  if_e	add	arg01, #48
04454                 | ' {
04454                 | ' 
04454                 | ' 	return *((DWORD*)ptr);
04454     E1 A6 01 AB |  if_e	rdlong	result1, arg01
04458     A9 B0 20 AF 
0445c     52 A6 0D A2 |  if_e	cmp	result1, ##1096897106 wz
04460     EF C2 01 A6 |  if_e	mov	arg01, local04
04464     01 00 00 AF 
04468     14 C2 05 A1 |  if_e	add	arg01, ##532
0446c                 | ' {
0446c                 | ' 
0446c                 | ' 	return *((DWORD*)ptr);
0446c     E1 A6 01 AB |  if_e	rdlong	result1, arg01
04470     B9 A0 30 AF 
04474     72 A6 0D A2 |  if_e	cmp	result1, ##1631679090 wz
04478     34 00 90 5D |  if_ne	jmp	#LR__0517
0447c     30 DE 05 F1 | 	add	local04, #48
04480     EF C2 01 F6 | 	mov	arg01, local04
04484     E8 C3 05 F1 | 	add	arg01, #488
04488                 | ' {
04488                 | ' 
04488                 | ' 	return *((DWORD*)ptr);
04488     E1 A6 01 FB | 	rdlong	result1, arg01
0448c     20 DE 85 F1 | 	sub	local04, #32
04490     EF A6 61 FC | 	wrlong	result1, local04
04494     20 DE 05 F1 | 	add	local04, #32
04498     EF C2 01 F6 | 	mov	arg01, local04
0449c     EC C3 05 F1 | 	add	arg01, #492
044a0                 | ' {
044a0                 | ' 
044a0                 | ' 	return *((DWORD*)ptr);
044a0     E1 A6 01 FB | 	rdlong	result1, arg01
044a4     24 DE 85 F1 | 	sub	local04, #36
044a8     EF A6 61 FC | 	wrlong	result1, local04
044ac     0C DE 85 F1 | 	sub	local04, #12
044b0                 | LR__0517
044b0                 | LR__0518
044b0     EF EA 41 FC | 	wrbyte	local10, local04
044b4     04 90 05 F1 | 	add	objptr, #4
044b8     C8 E0 E1 FA | 	rdword	local05, objptr
044bc     01 E0 05 F1 | 	add	local05, #1
044c0     C8 E0 51 FC | 	wrword	local05, objptr
044c4     F0 EC 31 F9 | 	getword	local11, local05, #0
044c8     04 90 85 F1 | 	sub	objptr, #4
044cc     06 DE 05 F1 | 	add	local04, #6
044d0     EF EC 51 FC | 	wrword	local11, local04
044d4                 | ' 				&& ld_dword(fs->win +  0 ) == 0x41615252
044d4                 | ' 				&& ld_dword(fs->win +  484 ) == 0x61417272)
044d4                 | ' 			{
044d4                 | ' 
044d4                 | ' 				fs->free_clst = ld_dword(fs->win +  488 );
044d4                 | ' 
044d4                 | ' 
044d4                 | ' 				fs->last_clst = ld_dword(fs->win +  492 );
044d4                 | ' 
044d4                 | ' 			}
044d4                 | ' 		}
044d4                 | ' 
044d4                 | ' 
044d4                 | ' 	}
044d4                 | ' 
044d4                 | ' 	fs->fs_type = (BYTE)fmt;
044d4                 | ' 	fs->id = ++Fsid;
044d4                 | ' #line 3567 "ff.c"
044d4                 | ' 	return FR_OK;
044d4     00 A6 05 F6 | 	mov	result1, #0
044d8                 | LR__0519
044d8     A7 F0 03 F6 | 	mov	ptra, fp
044dc     B2 00 A0 FD | 	call	#popregs_
044e0                 | _fatfs_cc_mount_volume_ret
044e0     2D 00 64 FD | 	ret
044e4                 | 
044e4                 | _fatfs_cc_validate
044e4     E1 AA 09 F6 | 	mov	_var01, arg01 wz
044e8     09 AC 05 F6 | 	mov	_var02, #9
044ec     D5 AE 09 5B |  if_ne	rdlong	_var03, _var01 wz
044f0     D7 B0 C9 5A |  if_ne	rdbyte	_var04, _var03 wz
044f4     48 00 90 AD |  if_e	jmp	#LR__0520
044f8     04 AA 05 F1 | 	add	_var01, #4
044fc     D5 B0 E1 FA | 	rdword	_var04, _var01
04500     04 AA 85 F1 | 	sub	_var01, #4
04504     D5 C2 01 FB | 	rdlong	arg01, _var01
04508     06 C2 05 F1 | 	add	arg01, #6
0450c     E1 A6 E1 FA | 	rdword	result1, arg01
04510     D3 B0 09 F2 | 	cmp	_var04, result1 wz
04514     28 00 90 5D |  if_ne	jmp	#LR__0520
04518     D5 B0 01 FB | 	rdlong	_var04, _var01
0451c     01 B0 05 F1 | 	add	_var04, #1
04520     D8 C2 C9 FA | 	rdbyte	arg01, _var04 wz
04524     01 A6 05 56 |  if_ne	mov	result1, #1
04528                 | ' 
04528                 | ' 	return Stat;
04528     24 90 05 A1 |  if_e	add	objptr, #36
0452c     C8 A6 C1 AA |  if_e	rdbyte	result1, objptr
04530     24 90 85 A1 |  if_e	sub	objptr, #36
04534     D3 AE E1 F8 | 	getbyte	_var03, result1, #0
04538     01 AE CD F7 | 	test	_var03, #1 wz
0453c     00 AC 05 A6 |  if_e	mov	_var02, #0
04540                 | LR__0520
04540     00 AC 0D F2 | 	cmp	_var02, #0 wz
04544     D5 AE 01 AB |  if_e	rdlong	_var03, _var01
04548     00 AE 05 56 |  if_ne	mov	_var03, #0
0454c     E2 AE 61 FC | 	wrlong	_var03, arg02
04550                 | ' 			res = FR_OK;
04550                 | ' 		}
04550                 | ' 
04550                 | ' 	}
04550                 | ' 	*rfs = (res == FR_OK) ? obj->fs : 0;
04550                 | ' 	return res;
04550     D6 A6 01 F6 | 	mov	result1, _var02
04554                 | _fatfs_cc_validate_ret
04554     2D 00 64 FD | 	ret
04558                 | 
04558                 | _fatfs_cc_f_mount
04558     01 4A 05 F6 | 	mov	COUNT_, #1
0455c     A8 00 A0 FD | 	call	#pushregs_
04560     20 F0 07 F1 | 	add	ptra, #32
04564     04 4E 05 F1 | 	add	fp, #4
04568     A7 C2 61 FC | 	wrlong	arg01, fp
0456c     04 4E 05 F1 | 	add	fp, #4
04570     A7 C4 61 FC | 	wrlong	arg02, fp
04574     04 4E 05 F1 | 	add	fp, #4
04578     A7 C6 41 FC | 	wrbyte	arg03, fp
0457c     04 4E 85 F1 | 	sub	fp, #4
04580     A7 C6 01 FB | 	rdlong	arg03, fp
04584     14 4E 05 F1 | 	add	fp, #20
04588     A7 C6 61 FC | 	wrlong	arg03, fp
0458c     A7 C2 01 F6 | 	mov	arg01, fp
04590     1C 4E 85 F1 | 	sub	fp, #28
04594     FC F6 BF FD | 	call	#_fatfs_cc_get_ldnumber
04598     14 4E 05 F1 | 	add	fp, #20
0459c     A7 A6 61 FC | 	wrlong	result1, fp
045a0     14 4E 85 F1 | 	sub	fp, #20
045a4     00 A6 55 F2 | 	cmps	result1, #0 wc
045a8     0B A6 05 C6 |  if_b	mov	result1, #11
045ac     C0 00 90 CD |  if_b	jmp	#LR__0531
045b0     14 4E 05 F1 | 	add	fp, #20
045b4     A7 C6 01 FB | 	rdlong	arg03, fp
045b8     02 C6 65 F0 | 	shl	arg03, #2
045bc     C8 C6 01 F1 | 	add	arg03, objptr
045c0     E3 C6 09 FB | 	rdlong	arg03, arg03 wz
045c4     04 4E 85 F1 | 	sub	fp, #4
045c8     A7 C6 61 FC | 	wrlong	arg03, fp
045cc     10 4E 85 F1 | 	sub	fp, #16
045d0     28 00 90 AD |  if_e	jmp	#LR__0530
045d4     10 4E 05 F1 | 	add	fp, #16
045d8     A7 C6 01 FB | 	rdlong	arg03, fp
045dc     10 4E 85 F1 | 	sub	fp, #16
045e0     01 C6 05 F1 | 	add	arg03, #1
045e4     E3 C2 C1 FA | 	rdbyte	arg01, arg03
045e8     44 41 B0 FD | 	call	#_fatfs_cc_disk_deinitialize
045ec     10 4E 05 F1 | 	add	fp, #16
045f0     A7 C6 01 FB | 	rdlong	arg03, fp
045f4     10 4E 85 F1 | 	sub	fp, #16
045f8     E3 00 48 FC | 	wrbyte	#0, arg03
045fc                 | LR__0530
045fc     04 4E 05 F1 | 	add	fp, #4
04600     A7 D8 09 FB | 	rdlong	local01, fp wz
04604     04 4E 85 F1 | 	sub	fp, #4
04608     04 4E 05 51 |  if_ne	add	fp, #4
0460c     A7 D8 01 5B |  if_ne	rdlong	local01, fp
04610     04 4E 85 51 |  if_ne	sub	fp, #4
04614     EC 00 48 5C |  if_ne	wrbyte	#0, local01
04618     14 4E 05 F1 | 	add	fp, #20
0461c     A7 D8 01 FB | 	rdlong	local01, fp
04620     02 D8 65 F0 | 	shl	local01, #2
04624     C8 D8 01 F1 | 	add	local01, objptr
04628     10 4E 85 F1 | 	sub	fp, #16
0462c     A7 C6 01 FB | 	rdlong	arg03, fp
04630     EC C6 61 FC | 	wrlong	arg03, local01
04634     08 4E 05 F1 | 	add	fp, #8
04638     A7 D8 C9 FA | 	rdbyte	local01, fp wz
0463c     0C 4E 85 F1 | 	sub	fp, #12
04640     00 A6 05 A6 |  if_e	mov	result1, #0
04644     28 00 90 AD |  if_e	jmp	#LR__0531
04648     08 4E 05 F1 | 	add	fp, #8
0464c     A7 C2 01 F6 | 	mov	arg01, fp
04650     04 4E 85 F1 | 	sub	fp, #4
04654     A7 C4 01 F6 | 	mov	arg02, fp
04658     04 4E 85 F1 | 	sub	fp, #4
0465c     00 C6 05 F6 | 	mov	arg03, #0
04660     6C F9 BF FD | 	call	#_fatfs_cc_mount_volume
04664     18 4E 05 F1 | 	add	fp, #24
04668     A7 A6 61 FC | 	wrlong	result1, fp
0466c                 | ' 
0466c                 | ' 	res = mount_volume(&path, &fs, 0);
0466c                 | ' 	return res ;
0466c     18 4E 85 F1 | 	sub	fp, #24
04670                 | LR__0531
04670     A7 F0 03 F6 | 	mov	ptra, fp
04674     B2 00 A0 FD | 	call	#popregs_
04678                 | _fatfs_cc_f_mount_ret
04678     2D 00 64 FD | 	ret
0467c                 | 
0467c                 | _fatfs_cc_f_open
0467c     02 4A 05 F6 | 	mov	COUNT_, #2
04680     A8 00 A0 FD | 	call	#pushregs_
04684     5C F0 07 F1 | 	add	ptra, #92
04688     04 4E 05 F1 | 	add	fp, #4
0468c     A7 C2 61 FC | 	wrlong	arg01, fp
04690     04 4E 05 F1 | 	add	fp, #4
04694     A7 C4 61 FC | 	wrlong	arg02, fp
04698     04 4E 05 F1 | 	add	fp, #4
0469c     A7 C6 41 FC | 	wrbyte	arg03, fp
046a0     08 4E 85 F1 | 	sub	fp, #8
046a4     A7 C8 09 FB | 	rdlong	arg04, fp wz
046a8     04 4E 85 F1 | 	sub	fp, #4
046ac     09 A6 05 A6 |  if_e	mov	result1, #9
046b0     90 06 90 AD |  if_e	jmp	#LR__0557
046b4     0C 4E 05 F1 | 	add	fp, #12
046b8     A7 C8 C1 FA | 	rdbyte	arg04, fp
046bc     3F C8 05 F5 | 	and	arg04, #63
046c0     A7 C8 41 FC | 	wrbyte	arg04, fp
046c4     04 4E 85 F1 | 	sub	fp, #4
046c8     A7 C2 01 F6 | 	mov	arg01, fp
046cc     38 4E 05 F1 | 	add	fp, #56
046d0     A7 C4 01 F6 | 	mov	arg02, fp
046d4     E4 C6 E1 F8 | 	getbyte	arg03, arg04, #0
046d8     40 4E 85 F1 | 	sub	fp, #64
046dc     F0 F8 BF FD | 	call	#_fatfs_cc_mount_volume
046e0     10 4E 05 F1 | 	add	fp, #16
046e4     A7 A6 61 FC | 	wrlong	result1, fp
046e8     10 4E 85 F1 | 	sub	fp, #16
046ec     00 A6 0D F2 | 	cmp	result1, #0 wz
046f0     28 06 90 5D |  if_ne	jmp	#LR__0556
046f4     40 4E 05 F1 | 	add	fp, #64
046f8     A7 C8 01 FB | 	rdlong	arg04, fp
046fc     2C 4E 85 F1 | 	sub	fp, #44
04700     A7 C8 61 FC | 	wrlong	arg04, fp
04704     A7 C2 01 F6 | 	mov	arg01, fp
04708     0C 4E 85 F1 | 	sub	fp, #12
0470c     A7 D8 01 FB | 	rdlong	local01, fp
04710     08 4E 85 F1 | 	sub	fp, #8
04714     EC C4 01 F6 | 	mov	arg02, local01
04718     6C F3 BF FD | 	call	#_fatfs_cc_follow_path
0471c     10 4E 05 F1 | 	add	fp, #16
04720     A7 A6 61 FC | 	wrlong	result1, fp
04724     10 4E 85 F1 | 	sub	fp, #16
04728     00 A6 0D F2 | 	cmp	result1, #0 wz
0472c     1C 00 90 5D |  if_ne	jmp	#LR__0540
04730     3F 4E 05 F1 | 	add	fp, #63
04734     A7 C8 C1 FA | 	rdbyte	arg04, fp
04738     3F 4E 85 F1 | 	sub	fp, #63
0473c     80 C8 CD F7 | 	test	arg04, #128 wz
04740     10 4E 05 51 |  if_ne	add	fp, #16
04744     A7 0C 68 5C |  if_ne	wrlong	#6, fp
04748     10 4E 85 51 |  if_ne	sub	fp, #16
0474c                 | LR__0540
0474c     0C 4E 05 F1 | 	add	fp, #12
04750     A7 C8 C1 FA | 	rdbyte	arg04, fp
04754     0C 4E 85 F1 | 	sub	fp, #12
04758     1C C8 CD F7 | 	test	arg04, #28 wz
0475c     EC 01 90 AD |  if_e	jmp	#LR__0545
04760     10 4E 05 F1 | 	add	fp, #16
04764     A7 D8 09 FB | 	rdlong	local01, fp wz
04768     10 4E 85 F1 | 	sub	fp, #16
0476c     44 00 90 AD |  if_e	jmp	#LR__0542
04770     10 4E 05 F1 | 	add	fp, #16
04774     A7 C8 01 FB | 	rdlong	arg04, fp
04778     10 4E 85 F1 | 	sub	fp, #16
0477c     04 C8 0D F2 | 	cmp	arg04, #4 wz
04780     18 00 90 5D |  if_ne	jmp	#LR__0541
04784     A7 C2 01 F6 | 	mov	arg01, fp
04788     14 C2 05 F1 | 	add	arg01, #20
0478c     20 EF BF FD | 	call	#_fatfs_cc_dir_register
04790     10 4E 05 F1 | 	add	fp, #16
04794     A7 A6 61 FC | 	wrlong	result1, fp
04798     10 4E 85 F1 | 	sub	fp, #16
0479c                 | LR__0541
0479c     0C 4E 05 F1 | 	add	fp, #12
047a0     A7 D8 C1 FA | 	rdbyte	local01, fp
047a4     08 D8 45 F5 | 	or	local01, #8
047a8     A7 D8 41 FC | 	wrbyte	local01, fp
047ac     0C 4E 85 F1 | 	sub	fp, #12
047b0     3C 00 90 FD | 	jmp	#LR__0544
047b4                 | LR__0542
047b4     1A 4E 05 F1 | 	add	fp, #26
047b8     A7 D8 C1 FA | 	rdbyte	local01, fp
047bc     1A 4E 85 F1 | 	sub	fp, #26
047c0     11 D8 CD F7 | 	test	local01, #17 wz
047c4     10 4E 05 51 |  if_ne	add	fp, #16
047c8     A7 0E 68 5C |  if_ne	wrlong	#7, fp
047cc     10 4E 85 51 |  if_ne	sub	fp, #16
047d0     1C 00 90 5D |  if_ne	jmp	#LR__0543
047d4     0C 4E 05 F1 | 	add	fp, #12
047d8     A7 D8 C1 FA | 	rdbyte	local01, fp
047dc     0C 4E 85 F1 | 	sub	fp, #12
047e0     04 D8 CD F7 | 	test	local01, #4 wz
047e4     10 4E 05 51 |  if_ne	add	fp, #16
047e8     A7 10 68 5C |  if_ne	wrlong	#8, fp
047ec     10 4E 85 51 |  if_ne	sub	fp, #16
047f0                 | LR__0543
047f0                 | LR__0544
047f0     10 4E 05 F1 | 	add	fp, #16
047f4     A7 D8 09 FB | 	rdlong	local01, fp wz
047f8     10 4E 85 F1 | 	sub	fp, #16
047fc     A8 01 90 5D |  if_ne	jmp	#LR__0548
04800     0C 4E 05 F1 | 	add	fp, #12
04804     A7 D8 C1 FA | 	rdbyte	local01, fp
04808     0C 4E 85 F1 | 	sub	fp, #12
0480c     08 D8 CD F7 | 	test	local01, #8 wz
04810     94 01 90 AD |  if_e	jmp	#LR__0548
04814     98 2E B0 FD | 	call	#_fatfs_cc__get_fattime
04818     50 4E 05 F1 | 	add	fp, #80
0481c     A7 A6 61 FC | 	wrlong	result1, fp
04820     20 4E 85 F1 | 	sub	fp, #32
04824     A7 C2 01 FB | 	rdlong	arg01, fp
04828     0E C2 05 F1 | 	add	arg01, #14
0482c     E1 A6 61 FC | 	wrlong	result1, arg01
04830     A7 C2 01 FB | 	rdlong	arg01, fp
04834     16 C2 05 F1 | 	add	arg01, #22
04838     20 4E 05 F1 | 	add	fp, #32
0483c     A7 C4 01 FB | 	rdlong	arg02, fp
04840     E1 C4 61 FC | 	wrlong	arg02, arg01
04844     10 4E 85 F1 | 	sub	fp, #16
04848     A7 C2 01 FB | 	rdlong	arg01, fp
0484c     10 4E 85 F1 | 	sub	fp, #16
04850     A7 C4 01 FB | 	rdlong	arg02, fp
04854     30 4E 85 F1 | 	sub	fp, #48
04858     2C EC BF FD | 	call	#_fatfs_cc_ld_clust
0485c     44 4E 05 F1 | 	add	fp, #68
04860     A7 A6 61 FC | 	wrlong	result1, fp
04864     14 4E 85 F1 | 	sub	fp, #20
04868     A7 D8 01 FB | 	rdlong	local01, fp
0486c     0B D8 05 F1 | 	add	local01, #11
04870     EC 40 48 FC | 	wrbyte	#32, local01
04874     10 4E 05 F1 | 	add	fp, #16
04878     A7 C2 01 FB | 	rdlong	arg01, fp
0487c     10 4E 85 F1 | 	sub	fp, #16
04880     A7 C4 01 FB | 	rdlong	arg02, fp
04884     30 4E 85 F1 | 	sub	fp, #48
04888     00 C6 05 F6 | 	mov	arg03, #0
0488c     2C EC BF FD | 	call	#_fatfs_cc_st_clust
04890     30 4E 05 F1 | 	add	fp, #48
04894     A7 C2 01 FB | 	rdlong	arg01, fp
04898     1C C2 05 F1 | 	add	arg01, #28
0489c     E1 00 68 FC | 	wrlong	#0, arg01
048a0     10 4E 05 F1 | 	add	fp, #16
048a4     A7 D8 01 FB | 	rdlong	local01, fp
048a8     03 D8 05 F1 | 	add	local01, #3
048ac     EC 02 48 FC | 	wrbyte	#1, local01
048b0     04 4E 05 F1 | 	add	fp, #4
048b4     A7 D8 09 FB | 	rdlong	local01, fp wz
048b8     44 4E 85 F1 | 	sub	fp, #68
048bc     E8 00 90 AD |  if_e	jmp	#LR__0548
048c0     40 4E 05 F1 | 	add	fp, #64
048c4     A7 D8 01 FB | 	rdlong	local01, fp
048c8     2C D8 05 F1 | 	add	local01, #44
048cc     EC D8 01 FB | 	rdlong	local01, local01
048d0     14 4E 05 F1 | 	add	fp, #20
048d4     A7 D8 61 FC | 	wrlong	local01, fp
048d8     40 4E 85 F1 | 	sub	fp, #64
048dc     A7 C2 01 F6 | 	mov	arg01, fp
048e0     30 4E 05 F1 | 	add	fp, #48
048e4     A7 C4 01 FB | 	rdlong	arg02, fp
048e8     44 4E 85 F1 | 	sub	fp, #68
048ec     00 C6 05 F6 | 	mov	arg03, #0
048f0     C8 E3 BF FD | 	call	#_fatfs_cc_remove_chain
048f4     10 4E 05 F1 | 	add	fp, #16
048f8     A7 A6 61 FC | 	wrlong	result1, fp
048fc     10 4E 85 F1 | 	sub	fp, #16
04900     00 A6 0D F2 | 	cmp	result1, #0 wz
04904     A0 00 90 5D |  if_ne	jmp	#LR__0548
04908     40 4E 05 F1 | 	add	fp, #64
0490c     A7 C2 01 FB | 	rdlong	arg01, fp
04910     14 4E 05 F1 | 	add	fp, #20
04914     A7 C4 01 FB | 	rdlong	arg02, fp
04918     54 4E 85 F1 | 	sub	fp, #84
0491c     30 DE BF FD | 	call	#_fatfs_cc_move_window
04920     10 4E 05 F1 | 	add	fp, #16
04924     A7 A6 61 FC | 	wrlong	result1, fp
04928     30 4E 05 F1 | 	add	fp, #48
0492c     A7 C8 01 FB | 	rdlong	arg04, fp
04930     04 4E 05 F1 | 	add	fp, #4
04934     A7 D8 01 FB | 	rdlong	local01, fp
04938     44 4E 85 F1 | 	sub	fp, #68
0493c     01 D8 85 F1 | 	sub	local01, #1
04940     0C C8 05 F1 | 	add	arg04, #12
04944     E4 D8 61 FC | 	wrlong	local01, arg04
04948     5C 00 90 FD | 	jmp	#LR__0548
0494c                 | LR__0545
0494c     10 4E 05 F1 | 	add	fp, #16
04950     A7 C8 09 FB | 	rdlong	arg04, fp wz
04954     10 4E 85 F1 | 	sub	fp, #16
04958     4C 00 90 5D |  if_ne	jmp	#LR__0547
0495c     1A 4E 05 F1 | 	add	fp, #26
04960     A7 C8 C1 FA | 	rdbyte	arg04, fp
04964     1A 4E 85 F1 | 	sub	fp, #26
04968     10 C8 CD F7 | 	test	arg04, #16 wz
0496c     10 4E 05 51 |  if_ne	add	fp, #16
04970     A7 08 68 5C |  if_ne	wrlong	#4, fp
04974     10 4E 85 51 |  if_ne	sub	fp, #16
04978     2C 00 90 5D |  if_ne	jmp	#LR__0546
0497c     0C 4E 05 F1 | 	add	fp, #12
04980     A7 C8 C1 FA | 	rdbyte	arg04, fp
04984     0C 4E 85 F1 | 	sub	fp, #12
04988     02 C8 CD F7 | 	test	arg04, #2 wz
0498c     1A 4E 05 51 |  if_ne	add	fp, #26
04990     A7 D8 C1 5A |  if_ne	rdbyte	local01, fp
04994     1A 4E 85 51 |  if_ne	sub	fp, #26
04998     01 D8 CD 57 |  if_ne	test	local01, #1 wz
0499c     10 4E 05 51 |  if_ne	add	fp, #16
049a0     A7 0E 68 5C |  if_ne	wrlong	#7, fp
049a4     10 4E 85 51 |  if_ne	sub	fp, #16
049a8                 | LR__0546
049a8                 | LR__0547
049a8                 | LR__0548
049a8     10 4E 05 F1 | 	add	fp, #16
049ac     A7 D8 09 FB | 	rdlong	local01, fp wz
049b0     10 4E 85 F1 | 	sub	fp, #16
049b4     60 00 90 5D |  if_ne	jmp	#LR__0549
049b8     0C 4E 05 F1 | 	add	fp, #12
049bc     A7 DA C1 FA | 	rdbyte	local02, fp
049c0     0C 4E 85 F1 | 	sub	fp, #12
049c4     08 DA CD F7 | 	test	local02, #8 wz
049c8     0C 4E 05 51 |  if_ne	add	fp, #12
049cc     A7 DA C1 5A |  if_ne	rdbyte	local02, fp
049d0     40 DA 45 55 |  if_ne	or	local02, #64
049d4     A7 DA 41 5C |  if_ne	wrbyte	local02, fp
049d8     0C 4E 85 51 |  if_ne	sub	fp, #12
049dc     04 4E 05 F1 | 	add	fp, #4
049e0     A7 DA 01 FB | 	rdlong	local02, fp
049e4     3C 4E 05 F1 | 	add	fp, #60
049e8     A7 D8 01 FB | 	rdlong	local01, fp
049ec     2C D8 05 F1 | 	add	local01, #44
049f0     EC D8 01 FB | 	rdlong	local01, local01
049f4     20 DA 05 F1 | 	add	local02, #32
049f8     ED D8 61 FC | 	wrlong	local01, local02
049fc     3C 4E 85 F1 | 	sub	fp, #60
04a00     A7 DA 01 FB | 	rdlong	local02, fp
04a04     2C 4E 05 F1 | 	add	fp, #44
04a08     A7 D8 01 FB | 	rdlong	local01, fp
04a0c     30 4E 85 F1 | 	sub	fp, #48
04a10     24 DA 05 F1 | 	add	local02, #36
04a14     ED D8 61 FC | 	wrlong	local01, local02
04a18                 | LR__0549
04a18     10 4E 05 F1 | 	add	fp, #16
04a1c     A7 DA 09 FB | 	rdlong	local02, fp wz
04a20     10 4E 85 F1 | 	sub	fp, #16
04a24     F4 02 90 5D |  if_ne	jmp	#LR__0555
04a28     04 4E 05 F1 | 	add	fp, #4
04a2c     A7 DA 01 FB | 	rdlong	local02, fp
04a30     3C 4E 05 F1 | 	add	fp, #60
04a34     A7 C2 01 FB | 	rdlong	arg01, fp
04a38     10 4E 85 F1 | 	sub	fp, #16
04a3c     A7 C4 01 FB | 	rdlong	arg02, fp
04a40     30 4E 85 F1 | 	sub	fp, #48
04a44     40 EA BF FD | 	call	#_fatfs_cc_ld_clust
04a48     08 DA 05 F1 | 	add	local02, #8
04a4c     ED A6 61 FC | 	wrlong	result1, local02
04a50     04 4E 05 F1 | 	add	fp, #4
04a54     A7 DA 01 FB | 	rdlong	local02, fp
04a58     2C 4E 05 F1 | 	add	fp, #44
04a5c     A7 C2 01 FB | 	rdlong	arg01, fp
04a60     1C C2 05 F1 | 	add	arg01, #28
04a64                 | ' {
04a64                 | ' 
04a64                 | ' 	return *((DWORD*)ptr);
04a64     E1 A6 01 FB | 	rdlong	result1, arg01
04a68     0C DA 05 F1 | 	add	local02, #12
04a6c     ED A6 61 FC | 	wrlong	result1, local02
04a70     2C 4E 85 F1 | 	sub	fp, #44
04a74     A7 DA 01 FB | 	rdlong	local02, fp
04a78     3C 4E 05 F1 | 	add	fp, #60
04a7c     A7 D8 01 FB | 	rdlong	local01, fp
04a80     ED D8 61 FC | 	wrlong	local01, local02
04a84     3C 4E 85 F1 | 	sub	fp, #60
04a88     A7 DA 01 FB | 	rdlong	local02, fp
04a8c     3C 4E 05 F1 | 	add	fp, #60
04a90     A7 D8 01 FB | 	rdlong	local01, fp
04a94     06 D8 05 F1 | 	add	local01, #6
04a98     EC D8 E1 FA | 	rdword	local01, local01
04a9c     04 DA 05 F1 | 	add	local02, #4
04aa0     ED D8 51 FC | 	wrword	local01, local02
04aa4     3C 4E 85 F1 | 	sub	fp, #60
04aa8     A7 DA 01 FB | 	rdlong	local02, fp
04aac     08 4E 05 F1 | 	add	fp, #8
04ab0     A7 D8 C1 FA | 	rdbyte	local01, fp
04ab4     10 DA 05 F1 | 	add	local02, #16
04ab8     ED D8 41 FC | 	wrbyte	local01, local02
04abc     08 4E 85 F1 | 	sub	fp, #8
04ac0     A7 DA 01 FB | 	rdlong	local02, fp
04ac4     11 DA 05 F1 | 	add	local02, #17
04ac8     ED 00 48 FC | 	wrbyte	#0, local02
04acc     A7 DA 01 FB | 	rdlong	local02, fp
04ad0     1C DA 05 F1 | 	add	local02, #28
04ad4     ED 00 68 FC | 	wrlong	#0, local02
04ad8     A7 DA 01 FB | 	rdlong	local02, fp
04adc     14 DA 05 F1 | 	add	local02, #20
04ae0     ED 00 68 FC | 	wrlong	#0, local02
04ae4     A7 C2 01 FB | 	rdlong	arg01, fp
04ae8     04 4E 85 F1 | 	sub	fp, #4
04aec     28 C2 05 F1 | 	add	arg01, #40
04af0     00 C4 05 F6 | 	mov	arg02, #0
04af4     09 C6 C5 F9 | 	decod	arg03, #9
04af8     98 00 A0 FD | 	call	#\builtin_bytefill_
04afc     0C 4E 05 F1 | 	add	fp, #12
04b00     A7 DA C1 FA | 	rdbyte	local02, fp
04b04     0C 4E 85 F1 | 	sub	fp, #12
04b08     20 DA CD F7 | 	test	local02, #32 wz
04b0c     0C 02 90 AD |  if_e	jmp	#LR__0554
04b10     04 4E 05 F1 | 	add	fp, #4
04b14     A7 D8 01 FB | 	rdlong	local01, fp
04b18     04 4E 85 F1 | 	sub	fp, #4
04b1c     0C D8 05 F1 | 	add	local01, #12
04b20     EC DA 01 FB | 	rdlong	local02, local01
04b24     01 DA 15 F2 | 	cmp	local02, #1 wc
04b28     F0 01 90 CD |  if_b	jmp	#LR__0554
04b2c     04 4E 05 F1 | 	add	fp, #4
04b30     A7 D8 01 FB | 	rdlong	local01, fp
04b34     EC DA 01 F6 | 	mov	local02, local01
04b38     0C D8 05 F1 | 	add	local01, #12
04b3c     EC D8 01 FB | 	rdlong	local01, local01
04b40     14 DA 05 F1 | 	add	local02, #20
04b44     ED D8 61 FC | 	wrlong	local01, local02
04b48     3C 4E 05 F1 | 	add	fp, #60
04b4c     A7 DA 01 FB | 	rdlong	local02, fp
04b50     0A DA 05 F1 | 	add	local02, #10
04b54     ED DA E1 FA | 	rdword	local02, local02
04b58     09 DA 65 F0 | 	shl	local02, #9
04b5c     08 4E 05 F1 | 	add	fp, #8
04b60     A7 DA 61 FC | 	wrlong	local02, fp
04b64     44 4E 85 F1 | 	sub	fp, #68
04b68     A7 DA 01 FB | 	rdlong	local02, fp
04b6c     08 DA 05 F1 | 	add	local02, #8
04b70     ED D8 01 FB | 	rdlong	local01, local02
04b74     48 4E 05 F1 | 	add	fp, #72
04b78     A7 D8 61 FC | 	wrlong	local01, fp
04b7c                 | ' 				fp->fptr = fp->obj.objsize;
04b7c                 | ' 				bcs = (DWORD)fs->csize *  ((UINT) 512 ) ;
04b7c                 | ' 				clst = fp->obj.sclust;
04b7c                 | ' 				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
04b7c     48 4E 85 F1 | 	sub	fp, #72
04b80     A7 DA 01 FB | 	rdlong	local02, fp
04b84     0C DA 05 F1 | 	add	local02, #12
04b88     ED D8 01 FB | 	rdlong	local01, local02
04b8c     54 4E 05 F1 | 	add	fp, #84
04b90     A7 D8 61 FC | 	wrlong	local01, fp
04b94     58 4E 85 F1 | 	sub	fp, #88
04b98                 | LR__0550
04b98     10 4E 05 F1 | 	add	fp, #16
04b9c     A7 DA 09 FB | 	rdlong	local02, fp wz
04ba0     10 4E 85 F1 | 	sub	fp, #16
04ba4     94 00 90 5D |  if_ne	jmp	#LR__0551
04ba8     58 4E 05 F1 | 	add	fp, #88
04bac     A7 DA 01 FB | 	rdlong	local02, fp
04bb0     10 4E 85 F1 | 	sub	fp, #16
04bb4     A7 D8 01 FB | 	rdlong	local01, fp
04bb8     48 4E 85 F1 | 	sub	fp, #72
04bbc     EC DA 19 F2 | 	cmp	local02, local01 wcz
04bc0     78 00 90 ED |  if_be	jmp	#LR__0551
04bc4     04 4E 05 F1 | 	add	fp, #4
04bc8     A7 C2 01 FB | 	rdlong	arg01, fp
04bcc     48 4E 05 F1 | 	add	fp, #72
04bd0     A7 C4 01 FB | 	rdlong	arg02, fp
04bd4     4C 4E 85 F1 | 	sub	fp, #76
04bd8     2C DD BF FD | 	call	#_fatfs_cc_get_fat
04bdc     4C 4E 05 F1 | 	add	fp, #76
04be0     A7 A6 61 FC | 	wrlong	result1, fp
04be4     4C 4E 85 F1 | 	sub	fp, #76
04be8     02 A6 15 F2 | 	cmp	result1, #2 wc
04bec     10 4E 05 C1 |  if_b	add	fp, #16
04bf0     A7 04 68 CC |  if_b	wrlong	#2, fp
04bf4     10 4E 85 C1 |  if_b	sub	fp, #16
04bf8     4C 4E 05 F1 | 	add	fp, #76
04bfc     A7 DA 01 FB | 	rdlong	local02, fp
04c00     4C 4E 85 F1 | 	sub	fp, #76
04c04     FF FF 7F FF 
04c08     FF DB 0D F2 | 	cmp	local02, ##-1 wz
04c0c     10 4E 05 A1 |  if_e	add	fp, #16
04c10     A7 02 68 AC |  if_e	wrlong	#1, fp
04c14     10 4E 85 A1 |  if_e	sub	fp, #16
04c18     58 4E 05 F1 | 	add	fp, #88
04c1c     A7 DA 01 FB | 	rdlong	local02, fp
04c20     10 4E 85 F1 | 	sub	fp, #16
04c24     A7 D8 01 FB | 	rdlong	local01, fp
04c28     EC DA 81 F1 | 	sub	local02, local01
04c2c     10 4E 05 F1 | 	add	fp, #16
04c30     A7 DA 61 FC | 	wrlong	local02, fp
04c34     58 4E 85 F1 | 	sub	fp, #88
04c38     5C FF 9F FD | 	jmp	#LR__0550
04c3c                 | LR__0551
04c3c     04 4E 05 F1 | 	add	fp, #4
04c40     A7 DA 01 FB | 	rdlong	local02, fp
04c44     48 4E 05 F1 | 	add	fp, #72
04c48     A7 D8 01 FB | 	rdlong	local01, fp
04c4c     18 DA 05 F1 | 	add	local02, #24
04c50     ED D8 61 FC | 	wrlong	local01, local02
04c54     3C 4E 85 F1 | 	sub	fp, #60
04c58     A7 DA 09 FB | 	rdlong	local02, fp wz
04c5c     10 4E 85 F1 | 	sub	fp, #16
04c60     B8 00 90 5D |  if_ne	jmp	#LR__0553
04c64     58 4E 05 F1 | 	add	fp, #88
04c68     A7 D8 01 FB | 	rdlong	local01, fp
04c6c     58 4E 85 F1 | 	sub	fp, #88
04c70     FF D9 CD F7 | 	test	local01, #511 wz
04c74     A4 00 90 AD |  if_e	jmp	#LR__0553
04c78     40 4E 05 F1 | 	add	fp, #64
04c7c     A7 C2 01 FB | 	rdlong	arg01, fp
04c80     0C 4E 05 F1 | 	add	fp, #12
04c84     A7 C4 01 FB | 	rdlong	arg02, fp
04c88     4C 4E 85 F1 | 	sub	fp, #76
04c8c     38 DC BF FD | 	call	#_fatfs_cc_clst2sect
04c90     54 4E 05 F1 | 	add	fp, #84
04c94     A7 A6 61 FC | 	wrlong	result1, fp
04c98     00 A6 4D F2 | 	cmps	result1, #0 wz
04c9c     54 4E 85 F1 | 	sub	fp, #84
04ca0     10 4E 05 A1 |  if_e	add	fp, #16
04ca4     A7 04 68 AC |  if_e	wrlong	#2, fp
04ca8     10 4E 85 A1 |  if_e	sub	fp, #16
04cac     6C 00 90 AD |  if_e	jmp	#LR__0552
04cb0     04 4E 05 F1 | 	add	fp, #4
04cb4     A7 DA 01 FB | 	rdlong	local02, fp
04cb8     50 4E 05 F1 | 	add	fp, #80
04cbc     A7 D8 01 FB | 	rdlong	local01, fp
04cc0     04 4E 05 F1 | 	add	fp, #4
04cc4     A7 C8 01 FB | 	rdlong	arg04, fp
04cc8     09 C8 45 F0 | 	shr	arg04, #9
04ccc     E4 D8 01 F1 | 	add	local01, arg04
04cd0     1C DA 05 F1 | 	add	local02, #28
04cd4     ED D8 61 FC | 	wrlong	local01, local02
04cd8     18 4E 85 F1 | 	sub	fp, #24
04cdc     A7 DA 01 FB | 	rdlong	local02, fp
04ce0     01 DA 05 F1 | 	add	local02, #1
04ce4     ED C2 C1 FA | 	rdbyte	arg01, local02
04ce8     3C 4E 85 F1 | 	sub	fp, #60
04cec     A7 DA 01 FB | 	rdlong	local02, fp
04cf0     ED C4 01 F6 | 	mov	arg02, local02
04cf4     28 C4 05 F1 | 	add	arg02, #40
04cf8     04 4E 85 F1 | 	sub	fp, #4
04cfc     1C DA 05 F1 | 	add	local02, #28
04d00     ED C6 01 FB | 	rdlong	arg03, local02
04d04     01 C8 05 F6 | 	mov	arg04, #1
04d08     34 D5 BF FD | 	call	#_fatfs_cc_disk_read
04d0c     00 A6 0D F2 | 	cmp	result1, #0 wz
04d10     10 4E 05 51 |  if_ne	add	fp, #16
04d14     A7 02 68 5C |  if_ne	wrlong	#1, fp
04d18     10 4E 85 51 |  if_ne	sub	fp, #16
04d1c                 | LR__0552
04d1c                 | LR__0553
04d1c                 | LR__0554
04d1c                 | LR__0555
04d1c                 | LR__0556
04d1c     10 4E 05 F1 | 	add	fp, #16
04d20     A7 DA 09 FB | 	rdlong	local02, fp wz
04d24     10 4E 85 F1 | 	sub	fp, #16
04d28     04 4E 05 51 |  if_ne	add	fp, #4
04d2c     A7 DA 01 5B |  if_ne	rdlong	local02, fp
04d30     04 4E 85 51 |  if_ne	sub	fp, #4
04d34     ED 00 68 5C |  if_ne	wrlong	#0, local02
04d38                 | ' 
04d38                 | ' 	return res ;
04d38     10 4E 05 F1 | 	add	fp, #16
04d3c     A7 A6 01 FB | 	rdlong	result1, fp
04d40     10 4E 85 F1 | 	sub	fp, #16
04d44                 | LR__0557
04d44     A7 F0 03 F6 | 	mov	ptra, fp
04d48     B2 00 A0 FD | 	call	#popregs_
04d4c                 | _fatfs_cc_f_open_ret
04d4c     2D 00 64 FD | 	ret
04d50                 | 
04d50                 | _fatfs_cc_f_read
04d50     0E 4A 05 F6 | 	mov	COUNT_, #14
04d54     A8 00 A0 FD | 	call	#pushregs_
04d58     38 F0 07 F1 | 	add	ptra, #56
04d5c     04 4E 05 F1 | 	add	fp, #4
04d60     A7 C2 61 FC | 	wrlong	arg01, fp
04d64     04 4E 05 F1 | 	add	fp, #4
04d68     A7 C4 61 FC | 	wrlong	arg02, fp
04d6c     04 4E 05 F1 | 	add	fp, #4
04d70     A7 C6 61 FC | 	wrlong	arg03, fp
04d74     04 4E 05 F1 | 	add	fp, #4
04d78     A7 C8 61 FC | 	wrlong	arg04, fp
04d7c     08 4E 85 F1 | 	sub	fp, #8
04d80     A7 A6 01 FB | 	rdlong	result1, fp
04d84     2C 4E 05 F1 | 	add	fp, #44
04d88     A7 A6 61 FC | 	wrlong	result1, fp
04d8c     24 4E 85 F1 | 	sub	fp, #36
04d90     A7 A6 01 FB | 	rdlong	result1, fp
04d94     D3 00 68 FC | 	wrlong	#0, result1
04d98     0C 4E 85 F1 | 	sub	fp, #12
04d9c     A7 C2 01 FB | 	rdlong	arg01, fp
04da0     14 4E 05 F1 | 	add	fp, #20
04da4     A7 C4 01 F6 | 	mov	arg02, fp
04da8     18 4E 85 F1 | 	sub	fp, #24
04dac     34 F7 BF FD | 	call	#_fatfs_cc_validate
04db0     14 4E 05 F1 | 	add	fp, #20
04db4     A7 A6 61 FC | 	wrlong	result1, fp
04db8     00 A6 4D F2 | 	cmps	result1, #0 wz
04dbc     14 4E 85 F1 | 	sub	fp, #20
04dc0     20 00 90 5D |  if_ne	jmp	#LR__0560
04dc4     04 4E 05 F1 | 	add	fp, #4
04dc8     A7 C4 01 FB | 	rdlong	arg02, fp
04dcc     11 C4 05 F1 | 	add	arg02, #17
04dd0     E2 C4 C9 FA | 	rdbyte	arg02, arg02 wz
04dd4     10 4E 05 F1 | 	add	fp, #16
04dd8     A7 C4 61 FC | 	wrlong	arg02, fp
04ddc     14 4E 85 F1 | 	sub	fp, #20
04de0     10 00 90 AD |  if_e	jmp	#LR__0561
04de4                 | LR__0560
04de4     14 4E 05 F1 | 	add	fp, #20
04de8     A7 A6 01 FB | 	rdlong	result1, fp
04dec     14 4E 85 F1 | 	sub	fp, #20
04df0     EC 05 90 FD | 	jmp	#LR__0580
04df4                 | LR__0561
04df4     04 4E 05 F1 | 	add	fp, #4
04df8     A7 C8 01 FB | 	rdlong	arg04, fp
04dfc     04 4E 85 F1 | 	sub	fp, #4
04e00     10 C8 05 F1 | 	add	arg04, #16
04e04     E4 C8 C1 FA | 	rdbyte	arg04, arg04
04e08     01 C8 CD F7 | 	test	arg04, #1 wz
04e0c     07 A6 05 A6 |  if_e	mov	result1, #7
04e10     CC 05 90 AD |  if_e	jmp	#LR__0580
04e14     04 4E 05 F1 | 	add	fp, #4
04e18     A7 D8 01 FB | 	rdlong	local01, fp
04e1c     EC DA 01 F6 | 	mov	local02, local01
04e20     0C DA 05 F1 | 	add	local02, #12
04e24     ED DC 01 FB | 	rdlong	local03, local02
04e28     14 D8 05 F1 | 	add	local01, #20
04e2c     EC D8 01 FB | 	rdlong	local01, local01
04e30     EC DC 81 F1 | 	sub	local03, local01
04e34     20 4E 05 F1 | 	add	fp, #32
04e38     A7 DC 61 FC | 	wrlong	local03, fp
04e3c     18 4E 85 F1 | 	sub	fp, #24
04e40     A7 DE 01 FB | 	rdlong	local04, fp
04e44     0C 4E 85 F1 | 	sub	fp, #12
04e48     EE DE 19 F2 | 	cmp	local04, local03 wcz
04e4c     24 4E 05 11 |  if_a	add	fp, #36
04e50     A7 DE 01 1B |  if_a	rdlong	local04, fp
04e54     18 4E 85 11 |  if_a	sub	fp, #24
04e58     A7 DE 61 1C |  if_a	wrlong	local04, fp
04e5c     0C 4E 85 11 |  if_a	sub	fp, #12
04e60                 | ' 
04e60                 | ' 	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
04e60                 | LR__0562
04e60     0C 4E 05 F1 | 	add	fp, #12
04e64     A7 DA 01 FB | 	rdlong	local02, fp
04e68     0C 4E 85 F1 | 	sub	fp, #12
04e6c     ED DE 01 F6 | 	mov	local04, local02
04e70     01 DE 15 F2 | 	cmp	local04, #1 wc
04e74     64 05 90 CD |  if_b	jmp	#LR__0579
04e78     04 4E 05 F1 | 	add	fp, #4
04e7c     A7 DC 01 FB | 	rdlong	local03, fp
04e80     04 4E 85 F1 | 	sub	fp, #4
04e84     14 DC 05 F1 | 	add	local03, #20
04e88     EE DC 01 FB | 	rdlong	local03, local03
04e8c     FF DD CD F7 | 	test	local03, #511 wz
04e90     3C 04 90 5D |  if_ne	jmp	#LR__0577
04e94     04 4E 05 F1 | 	add	fp, #4
04e98     A7 D8 01 FB | 	rdlong	local01, fp
04e9c     14 D8 05 F1 | 	add	local01, #20
04ea0     EC DC 01 FB | 	rdlong	local03, local01
04ea4     09 DC 45 F0 | 	shr	local03, #9
04ea8     14 4E 05 F1 | 	add	fp, #20
04eac     A7 E0 01 FB | 	rdlong	local05, fp
04eb0     F0 E2 01 F6 | 	mov	local06, local05
04eb4     0A E2 05 F1 | 	add	local06, #10
04eb8     F1 E4 E1 FA | 	rdword	local07, local06
04ebc     0A E2 85 F1 | 	sub	local06, #10
04ec0     F2 E6 31 F9 | 	getword	local08, local07, #0
04ec4     01 E6 85 F1 | 	sub	local08, #1
04ec8     F3 DC 09 F5 | 	and	local03, local08 wz
04ecc     18 4E 05 F1 | 	add	fp, #24
04ed0     A7 DC 61 FC | 	wrlong	local03, fp
04ed4     30 4E 85 F1 | 	sub	fp, #48
04ed8     E0 00 90 5D |  if_ne	jmp	#LR__0567
04edc     04 4E 05 F1 | 	add	fp, #4
04ee0     A7 DC 01 FB | 	rdlong	local03, fp
04ee4     04 4E 85 F1 | 	sub	fp, #4
04ee8     14 DC 05 F1 | 	add	local03, #20
04eec     EE DC 09 FB | 	rdlong	local03, local03 wz
04ef0     20 00 90 5D |  if_ne	jmp	#LR__0563
04ef4     04 4E 05 F1 | 	add	fp, #4
04ef8     A7 DC 01 FB | 	rdlong	local03, fp
04efc     08 DC 05 F1 | 	add	local03, #8
04f00     EE DC 01 FB | 	rdlong	local03, local03
04f04     18 4E 05 F1 | 	add	fp, #24
04f08     A7 DC 61 FC | 	wrlong	local03, fp
04f0c     1C 4E 85 F1 | 	sub	fp, #28
04f10     28 00 90 FD | 	jmp	#LR__0564
04f14                 | LR__0563
04f14     04 4E 05 F1 | 	add	fp, #4
04f18     A7 E6 01 FB | 	rdlong	local08, fp
04f1c     F3 C2 01 F6 | 	mov	arg01, local08
04f20     04 4E 85 F1 | 	sub	fp, #4
04f24     18 E6 05 F1 | 	add	local08, #24
04f28     F3 C4 01 FB | 	rdlong	arg02, local08
04f2c     D8 D9 BF FD | 	call	#_fatfs_cc_get_fat
04f30     1C 4E 05 F1 | 	add	fp, #28
04f34     A7 A6 61 FC | 	wrlong	result1, fp
04f38     1C 4E 85 F1 | 	sub	fp, #28
04f3c                 | LR__0564
04f3c     1C 4E 05 F1 | 	add	fp, #28
04f40     A7 DC 01 FB | 	rdlong	local03, fp
04f44     1C 4E 85 F1 | 	sub	fp, #28
04f48     02 DC 15 F2 | 	cmp	local03, #2 wc
04f4c     1C 00 90 3D |  if_ae	jmp	#LR__0565
04f50     04 4E 05 F1 | 	add	fp, #4
04f54     A7 DC 01 FB | 	rdlong	local03, fp
04f58     04 4E 85 F1 | 	sub	fp, #4
04f5c     11 DC 05 F1 | 	add	local03, #17
04f60     EE 04 48 FC | 	wrbyte	#2, local03
04f64     02 A6 05 F6 | 	mov	result1, #2
04f68     74 04 90 FD | 	jmp	#LR__0580
04f6c                 | LR__0565
04f6c     1C 4E 05 F1 | 	add	fp, #28
04f70     A7 DC 01 FB | 	rdlong	local03, fp
04f74     1C 4E 85 F1 | 	sub	fp, #28
04f78     FF FF 7F FF 
04f7c     FF DD 0D F2 | 	cmp	local03, ##-1 wz
04f80     1C 00 90 5D |  if_ne	jmp	#LR__0566
04f84     04 4E 05 F1 | 	add	fp, #4
04f88     A7 DC 01 FB | 	rdlong	local03, fp
04f8c     04 4E 85 F1 | 	sub	fp, #4
04f90     11 DC 05 F1 | 	add	local03, #17
04f94     EE 02 48 FC | 	wrbyte	#1, local03
04f98     01 A6 05 F6 | 	mov	result1, #1
04f9c     40 04 90 FD | 	jmp	#LR__0580
04fa0                 | LR__0566
04fa0     04 4E 05 F1 | 	add	fp, #4
04fa4     A7 DC 01 FB | 	rdlong	local03, fp
04fa8     18 4E 05 F1 | 	add	fp, #24
04fac     A7 E6 01 FB | 	rdlong	local08, fp
04fb0     1C 4E 85 F1 | 	sub	fp, #28
04fb4     18 DC 05 F1 | 	add	local03, #24
04fb8     EE E6 61 FC | 	wrlong	local08, local03
04fbc                 | LR__0567
04fbc     18 4E 05 F1 | 	add	fp, #24
04fc0     A7 C2 01 FB | 	rdlong	arg01, fp
04fc4     14 4E 85 F1 | 	sub	fp, #20
04fc8     A7 DC 01 FB | 	rdlong	local03, fp
04fcc     04 4E 85 F1 | 	sub	fp, #4
04fd0     18 DC 05 F1 | 	add	local03, #24
04fd4     EE C4 01 FB | 	rdlong	arg02, local03
04fd8     EC D8 BF FD | 	call	#_fatfs_cc_clst2sect
04fdc     20 4E 05 F1 | 	add	fp, #32
04fe0     A7 A6 61 FC | 	wrlong	result1, fp
04fe4     20 4E 85 F1 | 	sub	fp, #32
04fe8     00 A6 0D F2 | 	cmp	result1, #0 wz
04fec     1C 00 90 5D |  if_ne	jmp	#LR__0568
04ff0     04 4E 05 F1 | 	add	fp, #4
04ff4     A7 DC 01 FB | 	rdlong	local03, fp
04ff8     04 4E 85 F1 | 	sub	fp, #4
04ffc     11 DC 05 F1 | 	add	local03, #17
05000     EE 04 48 FC | 	wrbyte	#2, local03
05004     02 A6 05 F6 | 	mov	result1, #2
05008     D4 03 90 FD | 	jmp	#LR__0580
0500c                 | LR__0568
0500c     20 4E 05 F1 | 	add	fp, #32
05010     A7 DC 01 FB | 	rdlong	local03, fp
05014     10 4E 05 F1 | 	add	fp, #16
05018     A7 E6 01 FB | 	rdlong	local08, fp
0501c     F3 DC 01 F1 | 	add	local03, local08
05020     10 4E 85 F1 | 	sub	fp, #16
05024     A7 DC 61 FC | 	wrlong	local03, fp
05028     14 4E 85 F1 | 	sub	fp, #20
0502c     A7 DC 01 FB | 	rdlong	local03, fp
05030     09 DC 45 F0 | 	shr	local03, #9
05034     20 4E 05 F1 | 	add	fp, #32
05038     A7 DC 61 FC | 	wrlong	local03, fp
0503c     2C 4E 85 F1 | 	sub	fp, #44
05040     01 DC 15 F2 | 	cmp	local03, #1 wc
05044     5C 01 90 CD |  if_b	jmp	#LR__0572
05048     30 4E 05 F1 | 	add	fp, #48
0504c     A7 DC 01 FB | 	rdlong	local03, fp
05050     04 4E 85 F1 | 	sub	fp, #4
05054     A7 E6 01 FB | 	rdlong	local08, fp
05058     F3 DC 01 F1 | 	add	local03, local08
0505c     14 4E 85 F1 | 	sub	fp, #20
05060     A7 E6 01 FB | 	rdlong	local08, fp
05064     18 4E 85 F1 | 	sub	fp, #24
05068     0A E6 05 F1 | 	add	local08, #10
0506c     F3 E6 E1 FA | 	rdword	local08, local08
05070     F3 DC 19 F2 | 	cmp	local03, local08 wcz
05074     28 00 90 ED |  if_be	jmp	#LR__0569
05078     18 4E 05 F1 | 	add	fp, #24
0507c     A7 D8 01 FB | 	rdlong	local01, fp
05080     0A D8 05 F1 | 	add	local01, #10
05084     EC DC E1 FA | 	rdword	local03, local01
05088     18 4E 05 F1 | 	add	fp, #24
0508c     A7 E6 01 FB | 	rdlong	local08, fp
05090     F3 DC 81 F1 | 	sub	local03, local08
05094     04 4E 85 F1 | 	sub	fp, #4
05098     A7 DC 61 FC | 	wrlong	local03, fp
0509c     2C 4E 85 F1 | 	sub	fp, #44
050a0                 | LR__0569
050a0     18 4E 05 F1 | 	add	fp, #24
050a4     A7 D8 01 FB | 	rdlong	local01, fp
050a8     01 D8 05 F1 | 	add	local01, #1
050ac     EC C2 C1 FA | 	rdbyte	arg01, local01
050b0     1C 4E 05 F1 | 	add	fp, #28
050b4     A7 C4 01 FB | 	rdlong	arg02, fp
050b8     14 4E 85 F1 | 	sub	fp, #20
050bc     A7 C6 01 FB | 	rdlong	arg03, fp
050c0     0C 4E 05 F1 | 	add	fp, #12
050c4     A7 C8 01 FB | 	rdlong	arg04, fp
050c8     2C 4E 85 F1 | 	sub	fp, #44
050cc     70 D1 BF FD | 	call	#_fatfs_cc_disk_read
050d0     00 A6 0D F2 | 	cmp	result1, #0 wz
050d4     1C 00 90 AD |  if_e	jmp	#LR__0570
050d8     04 4E 05 F1 | 	add	fp, #4
050dc     A7 DC 01 FB | 	rdlong	local03, fp
050e0     04 4E 85 F1 | 	sub	fp, #4
050e4     11 DC 05 F1 | 	add	local03, #17
050e8     EE 02 48 FC | 	wrbyte	#1, local03
050ec     01 A6 05 F6 | 	mov	result1, #1
050f0     EC 02 90 FD | 	jmp	#LR__0580
050f4                 | LR__0570
050f4     04 4E 05 F1 | 	add	fp, #4
050f8     A7 D8 01 FB | 	rdlong	local01, fp
050fc     04 4E 85 F1 | 	sub	fp, #4
05100     10 D8 05 F1 | 	add	local01, #16
05104     EC DC C1 FA | 	rdbyte	local03, local01
05108     80 DC CD F7 | 	test	local03, #128 wz
0510c     78 00 90 AD |  if_e	jmp	#LR__0571
05110     04 4E 05 F1 | 	add	fp, #4
05114     A7 E6 01 FB | 	rdlong	local08, fp
05118     1C E6 05 F1 | 	add	local08, #28
0511c     F3 E6 01 FB | 	rdlong	local08, local08
05120     1C 4E 05 F1 | 	add	fp, #28
05124     A7 E8 01 FB | 	rdlong	local09, fp
05128     F4 E6 81 F1 | 	sub	local08, local09
0512c     0C 4E 05 F1 | 	add	fp, #12
05130     A7 EA 01 FB | 	rdlong	local10, fp
05134     2C 4E 85 F1 | 	sub	fp, #44
05138     F5 EC 01 F6 | 	mov	local11, local10
0513c     F6 E6 11 F2 | 	cmp	local08, local11 wc
05140     44 00 90 3D |  if_ae	jmp	#LR__0571
05144     34 4E 05 F1 | 	add	fp, #52
05148     A7 C2 01 FB | 	rdlong	arg01, fp
0514c     30 4E 85 F1 | 	sub	fp, #48
05150     A7 C4 01 FB | 	rdlong	arg02, fp
05154     E2 EC 01 F6 | 	mov	local11, arg02
05158     1C EC 05 F1 | 	add	local11, #28
0515c     F6 E8 01 FB | 	rdlong	local09, local11
05160     1C 4E 05 F1 | 	add	fp, #28
05164     A7 E0 01 FB | 	rdlong	local05, fp
05168     F0 E8 81 F1 | 	sub	local09, local05
0516c     09 E8 65 F0 | 	shl	local09, #9
05170     F4 EC 01 F6 | 	mov	local11, local09
05174     F4 C2 01 F1 | 	add	arg01, local09
05178     20 4E 85 F1 | 	sub	fp, #32
0517c     28 C4 05 F1 | 	add	arg02, #40
05180     09 C6 C5 F9 | 	decod	arg03, #9
05184     D0 91 B0 FD | 	call	#__system____builtin_memmove
05188                 | LR__0571
05188     2C 4E 05 F1 | 	add	fp, #44
0518c     A7 DC 01 FB | 	rdlong	local03, fp
05190     09 DC 65 F0 | 	shl	local03, #9
05194     04 4E 85 F1 | 	sub	fp, #4
05198     A7 DC 61 FC | 	wrlong	local03, fp
0519c     28 4E 85 F1 | 	sub	fp, #40
051a0                 | ' 					__builtin_memcpy(rbuff + ((fp->sect - sect) * ((UINT) 512 ) ), fp->buf, ((UINT) 512 ) ) ;
051a0                 | ' 				}
051a0                 | ' 
051a0                 | ' 
051a0                 | ' 				rcnt =  ((UINT) 512 )  * cc;
051a0                 | ' 				continue;
051a0     B4 01 90 FD | 	jmp	#LR__0578
051a4                 | LR__0572
051a4     04 4E 05 F1 | 	add	fp, #4
051a8     A7 DC 01 FB | 	rdlong	local03, fp
051ac     1C DC 05 F1 | 	add	local03, #28
051b0     EE DC 01 FB | 	rdlong	local03, local03
051b4     1C 4E 05 F1 | 	add	fp, #28
051b8     A7 D8 01 FB | 	rdlong	local01, fp
051bc     20 4E 85 F1 | 	sub	fp, #32
051c0     EC DC 09 F2 | 	cmp	local03, local01 wz
051c4     EC 00 90 AD |  if_e	jmp	#LR__0576
051c8     04 4E 05 F1 | 	add	fp, #4
051cc     A7 D8 01 FB | 	rdlong	local01, fp
051d0     04 4E 85 F1 | 	sub	fp, #4
051d4     10 D8 05 F1 | 	add	local01, #16
051d8     EC DC C1 FA | 	rdbyte	local03, local01
051dc     80 DC CD F7 | 	test	local03, #128 wz
051e0     7C 00 90 AD |  if_e	jmp	#LR__0574
051e4     18 4E 05 F1 | 	add	fp, #24
051e8     A7 D8 01 FB | 	rdlong	local01, fp
051ec     01 D8 05 F1 | 	add	local01, #1
051f0     EC C2 C1 FA | 	rdbyte	arg01, local01
051f4     14 4E 85 F1 | 	sub	fp, #20
051f8     A7 DC 01 FB | 	rdlong	local03, fp
051fc     EE C4 01 F6 | 	mov	arg02, local03
05200     28 C4 05 F1 | 	add	arg02, #40
05204     04 4E 85 F1 | 	sub	fp, #4
05208     1C DC 05 F1 | 	add	local03, #28
0520c     EE C6 01 FB | 	rdlong	arg03, local03
05210     01 C8 05 F6 | 	mov	arg04, #1
05214     E8 D0 BF FD | 	call	#_fatfs_cc_disk_write
05218     00 A6 0D F2 | 	cmp	result1, #0 wz
0521c     1C 00 90 AD |  if_e	jmp	#LR__0573
05220     04 4E 05 F1 | 	add	fp, #4
05224     A7 DC 01 FB | 	rdlong	local03, fp
05228     04 4E 85 F1 | 	sub	fp, #4
0522c     11 DC 05 F1 | 	add	local03, #17
05230     EE 02 48 FC | 	wrbyte	#1, local03
05234     01 A6 05 F6 | 	mov	result1, #1
05238     A4 01 90 FD | 	jmp	#LR__0580
0523c                 | LR__0573
0523c     04 4E 05 F1 | 	add	fp, #4
05240     A7 EC 01 FB | 	rdlong	local11, fp
05244     F6 DC 01 F6 | 	mov	local03, local11
05248     04 4E 85 F1 | 	sub	fp, #4
0524c     10 EC 05 F1 | 	add	local11, #16
05250     F6 EC C1 FA | 	rdbyte	local11, local11
05254     7F EC 05 F5 | 	and	local11, #127
05258     10 DC 05 F1 | 	add	local03, #16
0525c     EE EC 41 FC | 	wrbyte	local11, local03
05260                 | LR__0574
05260     18 4E 05 F1 | 	add	fp, #24
05264     A7 D8 01 FB | 	rdlong	local01, fp
05268     01 D8 05 F1 | 	add	local01, #1
0526c     EC C2 C1 FA | 	rdbyte	arg01, local01
05270     14 4E 85 F1 | 	sub	fp, #20
05274     A7 C4 01 FB | 	rdlong	arg02, fp
05278     28 C4 05 F1 | 	add	arg02, #40
0527c     1C 4E 05 F1 | 	add	fp, #28
05280     A7 C6 01 FB | 	rdlong	arg03, fp
05284     20 4E 85 F1 | 	sub	fp, #32
05288     01 C8 05 F6 | 	mov	arg04, #1
0528c     B0 CF BF FD | 	call	#_fatfs_cc_disk_read
05290     00 A6 0D F2 | 	cmp	result1, #0 wz
05294     1C 00 90 AD |  if_e	jmp	#LR__0575
05298     04 4E 05 F1 | 	add	fp, #4
0529c     A7 DC 01 FB | 	rdlong	local03, fp
052a0     04 4E 85 F1 | 	sub	fp, #4
052a4     11 DC 05 F1 | 	add	local03, #17
052a8     EE 02 48 FC | 	wrbyte	#1, local03
052ac     01 A6 05 F6 | 	mov	result1, #1
052b0     2C 01 90 FD | 	jmp	#LR__0580
052b4                 | LR__0575
052b4                 | LR__0576
052b4     04 4E 05 F1 | 	add	fp, #4
052b8     A7 DC 01 FB | 	rdlong	local03, fp
052bc     1C 4E 05 F1 | 	add	fp, #28
052c0     A7 EC 01 FB | 	rdlong	local11, fp
052c4     20 4E 85 F1 | 	sub	fp, #32
052c8     1C DC 05 F1 | 	add	local03, #28
052cc     EE EC 61 FC | 	wrlong	local11, local03
052d0                 | LR__0577
052d0     04 4E 05 F1 | 	add	fp, #4
052d4     A7 D8 01 FB | 	rdlong	local01, fp
052d8     14 D8 05 F1 | 	add	local01, #20
052dc     EC EC 01 FB | 	rdlong	local11, local01
052e0     FF ED 05 F5 | 	and	local11, #511
052e4     09 DC C5 F9 | 	decod	local03, #9
052e8     F6 DC 81 F1 | 	sub	local03, local11
052ec     24 4E 05 F1 | 	add	fp, #36
052f0     A7 DC 61 FC | 	wrlong	local03, fp
052f4     1C 4E 85 F1 | 	sub	fp, #28
052f8     A7 EC 01 FB | 	rdlong	local11, fp
052fc     0C 4E 85 F1 | 	sub	fp, #12
05300     F6 DC 19 F2 | 	cmp	local03, local11 wcz
05304     0C 4E 05 11 |  if_a	add	fp, #12
05308     A7 DC 01 1B |  if_a	rdlong	local03, fp
0530c     1C 4E 05 11 |  if_a	add	fp, #28
05310     A7 DC 61 1C |  if_a	wrlong	local03, fp
05314     28 4E 85 11 |  if_a	sub	fp, #40
05318     34 4E 05 F1 | 	add	fp, #52
0531c     A7 C2 01 FB | 	rdlong	arg01, fp
05320     30 4E 85 F1 | 	sub	fp, #48
05324     A7 E2 01 FB | 	rdlong	local06, fp
05328     F1 C4 01 F6 | 	mov	arg02, local06
0532c     28 C4 05 F1 | 	add	arg02, #40
05330     14 E2 05 F1 | 	add	local06, #20
05334     F1 EC 01 FB | 	rdlong	local11, local06
05338     F6 E8 01 F6 | 	mov	local09, local11
0533c     F4 EA 01 F6 | 	mov	local10, local09
05340     FF EB 05 F5 | 	and	local10, #511
05344     F5 C4 01 F1 | 	add	arg02, local10
05348     24 4E 05 F1 | 	add	fp, #36
0534c     A7 C6 01 FB | 	rdlong	arg03, fp
05350     28 4E 85 F1 | 	sub	fp, #40
05354     00 90 B0 FD | 	call	#__system____builtin_memmove
05358                 | LR__0578
05358     0C 4E 05 F1 | 	add	fp, #12
0535c     A7 DC 01 FB | 	rdlong	local03, fp
05360     1C 4E 05 F1 | 	add	fp, #28
05364     A7 E6 01 FB | 	rdlong	local08, fp
05368     F3 DC 81 F1 | 	sub	local03, local08
0536c     1C 4E 85 F1 | 	sub	fp, #28
05370     A7 DC 61 FC | 	wrlong	local03, fp
05374     04 4E 05 F1 | 	add	fp, #4
05378     A7 D8 01 FB | 	rdlong	local01, fp
0537c     EC E4 01 FB | 	rdlong	local07, local01
05380     18 4E 05 F1 | 	add	fp, #24
05384     A7 E6 01 FB | 	rdlong	local08, fp
05388     F3 E4 01 F1 | 	add	local07, local08
0538c     EC E4 61 FC | 	wrlong	local07, local01
05390     0C 4E 05 F1 | 	add	fp, #12
05394     A7 DC 01 FB | 	rdlong	local03, fp
05398     0C 4E 85 F1 | 	sub	fp, #12
0539c     A7 EE 01 FB | 	rdlong	local12, fp
053a0     F7 DC 01 F1 | 	add	local03, local12
053a4     0C 4E 05 F1 | 	add	fp, #12
053a8     A7 DC 61 FC | 	wrlong	local03, fp
053ac     30 4E 85 F1 | 	sub	fp, #48
053b0     A7 F0 01 FB | 	rdlong	local13, fp
053b4     F8 DC 01 F6 | 	mov	local03, local13
053b8     14 F0 05 F1 | 	add	local13, #20
053bc     F8 F2 01 FB | 	rdlong	local14, local13
053c0     24 4E 05 F1 | 	add	fp, #36
053c4     A7 E2 01 FB | 	rdlong	local06, fp
053c8     28 4E 85 F1 | 	sub	fp, #40
053cc     F1 F2 01 F1 | 	add	local14, local06
053d0     14 DC 05 F1 | 	add	local03, #20
053d4     EE F2 61 FC | 	wrlong	local14, local03
053d8     84 FA 9F FD | 	jmp	#LR__0562
053dc                 | LR__0579
053dc                 | ' 
053dc                 | ' 
053dc                 | ' 
053dc                 | ' 
053dc                 | ' 		__builtin_memcpy(rbuff, fp->buf + fp->fptr % ((UINT) 512 ) , rcnt) ;
053dc                 | ' 
053dc                 | ' 	}
053dc                 | ' 
053dc                 | ' 	return FR_OK ;
053dc     00 A6 05 F6 | 	mov	result1, #0
053e0                 | LR__0580
053e0     A7 F0 03 F6 | 	mov	ptra, fp
053e4     B2 00 A0 FD | 	call	#popregs_
053e8                 | _fatfs_cc_f_read_ret
053e8     2D 00 64 FD | 	ret
053ec                 | 
053ec                 | _fatfs_cc_f_write
053ec     15 4A 05 F6 | 	mov	COUNT_, #21
053f0     A8 00 A0 FD | 	call	#pushregs_
053f4     34 F0 07 F1 | 	add	ptra, #52
053f8     04 4E 05 F1 | 	add	fp, #4
053fc     A7 C2 61 FC | 	wrlong	arg01, fp
05400     04 4E 05 F1 | 	add	fp, #4
05404     A7 C4 61 FC | 	wrlong	arg02, fp
05408     04 4E 05 F1 | 	add	fp, #4
0540c     A7 C6 61 FC | 	wrlong	arg03, fp
05410     04 4E 05 F1 | 	add	fp, #4
05414     A7 C8 61 FC | 	wrlong	arg04, fp
05418     08 4E 85 F1 | 	sub	fp, #8
0541c     A7 A6 01 FB | 	rdlong	result1, fp
05420     28 4E 05 F1 | 	add	fp, #40
05424     A7 A6 61 FC | 	wrlong	result1, fp
05428     20 4E 85 F1 | 	sub	fp, #32
0542c     A7 A6 01 FB | 	rdlong	result1, fp
05430     D3 00 68 FC | 	wrlong	#0, result1
05434     0C 4E 85 F1 | 	sub	fp, #12
05438     A7 C2 01 FB | 	rdlong	arg01, fp
0543c     14 4E 05 F1 | 	add	fp, #20
05440     A7 C4 01 F6 | 	mov	arg02, fp
05444     18 4E 85 F1 | 	sub	fp, #24
05448     98 F0 BF FD | 	call	#_fatfs_cc_validate
0544c     14 4E 05 F1 | 	add	fp, #20
05450     A7 A6 61 FC | 	wrlong	result1, fp
05454     00 A6 4D F2 | 	cmps	result1, #0 wz
05458     14 4E 85 F1 | 	sub	fp, #20
0545c     20 00 90 5D |  if_ne	jmp	#LR__0590
05460     04 4E 05 F1 | 	add	fp, #4
05464     A7 C4 01 FB | 	rdlong	arg02, fp
05468     11 C4 05 F1 | 	add	arg02, #17
0546c     E2 C4 C9 FA | 	rdbyte	arg02, arg02 wz
05470     10 4E 05 F1 | 	add	fp, #16
05474     A7 C4 61 FC | 	wrlong	arg02, fp
05478     14 4E 85 F1 | 	sub	fp, #20
0547c     10 00 90 AD |  if_e	jmp	#LR__0591
05480                 | LR__0590
05480     14 4E 05 F1 | 	add	fp, #20
05484     A7 A6 01 FB | 	rdlong	result1, fp
05488     14 4E 85 F1 | 	sub	fp, #20
0548c     44 07 90 FD | 	jmp	#LR__0613
05490                 | LR__0591
05490     04 4E 05 F1 | 	add	fp, #4
05494     A7 C4 01 FB | 	rdlong	arg02, fp
05498     04 4E 85 F1 | 	sub	fp, #4
0549c     10 C4 05 F1 | 	add	arg02, #16
054a0     E2 C4 C1 FA | 	rdbyte	arg02, arg02
054a4     02 C4 CD F7 | 	test	arg02, #2 wz
054a8     07 A6 05 A6 |  if_e	mov	result1, #7
054ac     24 07 90 AD |  if_e	jmp	#LR__0613
054b0     04 4E 05 F1 | 	add	fp, #4
054b4     A7 C4 01 FB | 	rdlong	arg02, fp
054b8     E2 C2 01 F6 | 	mov	arg01, arg02
054bc     14 C2 05 F1 | 	add	arg01, #20
054c0     E1 C2 01 FB | 	rdlong	arg01, arg01
054c4     08 4E 05 F1 | 	add	fp, #8
054c8     A7 A6 01 FB | 	rdlong	result1, fp
054cc     D3 C2 01 F1 | 	add	arg01, result1
054d0     0C 4E 85 F1 | 	sub	fp, #12
054d4     14 C4 05 F1 | 	add	arg02, #20
054d8     E2 A6 01 FB | 	rdlong	result1, arg02
054dc     D3 C2 11 F2 | 	cmp	arg01, result1 wc
054e0     24 00 90 3D |  if_ae	jmp	#LR__0592
054e4     04 4E 05 F1 | 	add	fp, #4
054e8     A7 C4 01 FB | 	rdlong	arg02, fp
054ec     01 A6 65 F6 | 	neg	result1, #1
054f0     14 C4 05 F1 | 	add	arg02, #20
054f4     E2 C4 01 FB | 	rdlong	arg02, arg02
054f8     E2 A6 81 F1 | 	sub	result1, arg02
054fc     08 4E 05 F1 | 	add	fp, #8
05500     A7 A6 61 FC | 	wrlong	result1, fp
05504     0C 4E 85 F1 | 	sub	fp, #12
05508                 | LR__0592
05508                 | ' 		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
05508                 | ' 	}
05508                 | ' 
05508                 | ' 	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
05508                 | LR__0593
05508     0C 4E 05 F1 | 	add	fp, #12
0550c     A7 A6 01 FB | 	rdlong	result1, fp
05510     0C 4E 85 F1 | 	sub	fp, #12
05514     01 A6 15 F2 | 	cmp	result1, #1 wc
05518     90 06 90 CD |  if_b	jmp	#LR__0612
0551c     04 4E 05 F1 | 	add	fp, #4
05520     A7 A6 01 FB | 	rdlong	result1, fp
05524     04 4E 85 F1 | 	sub	fp, #4
05528     14 A6 05 F1 | 	add	result1, #20
0552c     D3 A6 01 FB | 	rdlong	result1, result1
05530     FF A7 CD F7 | 	test	result1, #511 wz
05534     D8 04 90 5D |  if_ne	jmp	#LR__0608
05538     04 4E 05 F1 | 	add	fp, #4
0553c     A7 A6 01 FB | 	rdlong	result1, fp
05540     14 A6 05 F1 | 	add	result1, #20
05544     D3 A6 01 FB | 	rdlong	result1, result1
05548     09 A6 45 F0 | 	shr	result1, #9
0554c     14 4E 05 F1 | 	add	fp, #20
05550     A7 C4 01 FB | 	rdlong	arg02, fp
05554     0A C4 05 F1 | 	add	arg02, #10
05558     E2 C8 E1 FA | 	rdword	arg04, arg02
0555c     E4 C4 31 F9 | 	getword	arg02, arg04, #0
05560     01 C4 85 F1 | 	sub	arg02, #1
05564     E2 A6 09 F5 | 	and	result1, arg02 wz
05568     14 4E 05 F1 | 	add	fp, #20
0556c     A7 A6 61 FC | 	wrlong	result1, fp
05570     2C 4E 85 F1 | 	sub	fp, #44
05574     44 01 90 5D |  if_ne	jmp	#LR__0599
05578     04 4E 05 F1 | 	add	fp, #4
0557c     A7 A6 01 FB | 	rdlong	result1, fp
05580     04 4E 85 F1 | 	sub	fp, #4
05584     14 A6 05 F1 | 	add	result1, #20
05588     D3 C4 09 FB | 	rdlong	arg02, result1 wz
0558c     44 00 90 5D |  if_ne	jmp	#LR__0594
05590     04 4E 05 F1 | 	add	fp, #4
05594     A7 C4 01 FB | 	rdlong	arg02, fp
05598     08 C4 05 F1 | 	add	arg02, #8
0559c     E2 C4 09 FB | 	rdlong	arg02, arg02 wz
055a0     18 4E 05 F1 | 	add	fp, #24
055a4     A7 C4 61 FC | 	wrlong	arg02, fp
055a8     1C 4E 85 F1 | 	sub	fp, #28
055ac     4C 00 90 5D |  if_ne	jmp	#LR__0595
055b0     04 4E 05 F1 | 	add	fp, #4
055b4     A7 C2 01 FB | 	rdlong	arg01, fp
055b8     04 4E 85 F1 | 	sub	fp, #4
055bc     00 C4 05 F6 | 	mov	arg02, #0
055c0     0C D8 BF FD | 	call	#_fatfs_cc_create_chain
055c4     1C 4E 05 F1 | 	add	fp, #28
055c8     A7 A6 61 FC | 	wrlong	result1, fp
055cc     1C 4E 85 F1 | 	sub	fp, #28
055d0     28 00 90 FD | 	jmp	#LR__0595
055d4                 | LR__0594
055d4     04 4E 05 F1 | 	add	fp, #4
055d8     A7 C8 01 FB | 	rdlong	arg04, fp
055dc     E4 C2 01 F6 | 	mov	arg01, arg04
055e0     04 4E 85 F1 | 	sub	fp, #4
055e4     18 C8 05 F1 | 	add	arg04, #24
055e8     E4 C4 01 FB | 	rdlong	arg02, arg04
055ec     E0 D7 BF FD | 	call	#_fatfs_cc_create_chain
055f0     1C 4E 05 F1 | 	add	fp, #28
055f4     A7 A6 61 FC | 	wrlong	result1, fp
055f8     1C 4E 85 F1 | 	sub	fp, #28
055fc                 | LR__0595
055fc     1C 4E 05 F1 | 	add	fp, #28
05600     A7 A6 09 FB | 	rdlong	result1, fp wz
05604     1C 4E 85 F1 | 	sub	fp, #28
05608     A0 05 90 AD |  if_e	jmp	#LR__0612
0560c     1C 4E 05 F1 | 	add	fp, #28
05610     A7 A6 01 FB | 	rdlong	result1, fp
05614     1C 4E 85 F1 | 	sub	fp, #28
05618     01 A6 0D F2 | 	cmp	result1, #1 wz
0561c     1C 00 90 5D |  if_ne	jmp	#LR__0596
05620     04 4E 05 F1 | 	add	fp, #4
05624     A7 A6 01 FB | 	rdlong	result1, fp
05628     04 4E 85 F1 | 	sub	fp, #4
0562c     11 A6 05 F1 | 	add	result1, #17
05630     D3 04 48 FC | 	wrbyte	#2, result1
05634     02 A6 05 F6 | 	mov	result1, #2
05638     98 05 90 FD | 	jmp	#LR__0613
0563c                 | LR__0596
0563c     1C 4E 05 F1 | 	add	fp, #28
05640     A7 A6 01 FB | 	rdlong	result1, fp
05644     1C 4E 85 F1 | 	sub	fp, #28
05648     FF FF 7F FF 
0564c     FF A7 0D F2 | 	cmp	result1, ##-1 wz
05650     1C 00 90 5D |  if_ne	jmp	#LR__0597
05654     04 4E 05 F1 | 	add	fp, #4
05658     A7 A6 01 FB | 	rdlong	result1, fp
0565c     04 4E 85 F1 | 	sub	fp, #4
05660     11 A6 05 F1 | 	add	result1, #17
05664     D3 02 48 FC | 	wrbyte	#1, result1
05668     01 A6 05 F6 | 	mov	result1, #1
0566c     64 05 90 FD | 	jmp	#LR__0613
05670                 | LR__0597
05670     04 4E 05 F1 | 	add	fp, #4
05674     A7 A6 01 FB | 	rdlong	result1, fp
05678     18 4E 05 F1 | 	add	fp, #24
0567c     A7 C8 01 FB | 	rdlong	arg04, fp
05680     18 A6 05 F1 | 	add	result1, #24
05684     D3 C8 61 FC | 	wrlong	arg04, result1
05688     18 4E 85 F1 | 	sub	fp, #24
0568c     A7 A6 01 FB | 	rdlong	result1, fp
05690     04 4E 85 F1 | 	sub	fp, #4
05694     08 A6 05 F1 | 	add	result1, #8
05698     D3 A6 09 FB | 	rdlong	result1, result1 wz
0569c     1C 00 90 5D |  if_ne	jmp	#LR__0598
056a0     04 4E 05 F1 | 	add	fp, #4
056a4     A7 C8 01 FB | 	rdlong	arg04, fp
056a8     18 4E 05 F1 | 	add	fp, #24
056ac     A7 A6 01 FB | 	rdlong	result1, fp
056b0     1C 4E 85 F1 | 	sub	fp, #28
056b4     08 C8 05 F1 | 	add	arg04, #8
056b8     E4 A6 61 FC | 	wrlong	result1, arg04
056bc                 | LR__0598
056bc                 | LR__0599
056bc     04 4E 05 F1 | 	add	fp, #4
056c0     A7 C8 01 FB | 	rdlong	arg04, fp
056c4     04 4E 85 F1 | 	sub	fp, #4
056c8     10 C8 05 F1 | 	add	arg04, #16
056cc     E4 C8 C1 FA | 	rdbyte	arg04, arg04
056d0     80 C8 CD F7 | 	test	arg04, #128 wz
056d4     7C 00 90 AD |  if_e	jmp	#LR__0601
056d8     18 4E 05 F1 | 	add	fp, #24
056dc     A7 C8 01 FB | 	rdlong	arg04, fp
056e0     01 C8 05 F1 | 	add	arg04, #1
056e4     E4 C2 C1 FA | 	rdbyte	arg01, arg04
056e8     14 4E 85 F1 | 	sub	fp, #20
056ec     A7 C8 01 FB | 	rdlong	arg04, fp
056f0     E4 C4 01 F6 | 	mov	arg02, arg04
056f4     28 C4 05 F1 | 	add	arg02, #40
056f8     04 4E 85 F1 | 	sub	fp, #4
056fc     1C C8 05 F1 | 	add	arg04, #28
05700     E4 C6 01 FB | 	rdlong	arg03, arg04
05704     01 C8 05 F6 | 	mov	arg04, #1
05708     F4 CB BF FD | 	call	#_fatfs_cc_disk_write
0570c     00 A6 0D F2 | 	cmp	result1, #0 wz
05710     1C 00 90 AD |  if_e	jmp	#LR__0600
05714     04 4E 05 F1 | 	add	fp, #4
05718     A7 A6 01 FB | 	rdlong	result1, fp
0571c     04 4E 85 F1 | 	sub	fp, #4
05720     11 A6 05 F1 | 	add	result1, #17
05724     D3 02 48 FC | 	wrbyte	#1, result1
05728     01 A6 05 F6 | 	mov	result1, #1
0572c     A4 04 90 FD | 	jmp	#LR__0613
05730                 | LR__0600
05730     04 4E 05 F1 | 	add	fp, #4
05734     A7 C8 01 FB | 	rdlong	arg04, fp
05738     E4 A6 01 F6 | 	mov	result1, arg04
0573c     04 4E 85 F1 | 	sub	fp, #4
05740     10 C8 05 F1 | 	add	arg04, #16
05744     E4 C8 C1 FA | 	rdbyte	arg04, arg04
05748     7F C8 05 F5 | 	and	arg04, #127
0574c     10 A6 05 F1 | 	add	result1, #16
05750     D3 C8 41 FC | 	wrbyte	arg04, result1
05754                 | LR__0601
05754     18 4E 05 F1 | 	add	fp, #24
05758     A7 C2 01 FB | 	rdlong	arg01, fp
0575c     14 4E 85 F1 | 	sub	fp, #20
05760     A7 C4 01 FB | 	rdlong	arg02, fp
05764     04 4E 85 F1 | 	sub	fp, #4
05768     18 C4 05 F1 | 	add	arg02, #24
0576c     E2 C4 01 FB | 	rdlong	arg02, arg02
05770     54 D1 BF FD | 	call	#_fatfs_cc_clst2sect
05774     20 4E 05 F1 | 	add	fp, #32
05778     A7 A6 61 FC | 	wrlong	result1, fp
0577c     20 4E 85 F1 | 	sub	fp, #32
05780     00 A6 0D F2 | 	cmp	result1, #0 wz
05784     1C 00 90 5D |  if_ne	jmp	#LR__0602
05788     04 4E 05 F1 | 	add	fp, #4
0578c     A7 A6 01 FB | 	rdlong	result1, fp
05790     04 4E 85 F1 | 	sub	fp, #4
05794     11 A6 05 F1 | 	add	result1, #17
05798     D3 04 48 FC | 	wrbyte	#2, result1
0579c     02 A6 05 F6 | 	mov	result1, #2
057a0     30 04 90 FD | 	jmp	#LR__0613
057a4                 | LR__0602
057a4     20 4E 05 F1 | 	add	fp, #32
057a8     A7 A6 01 FB | 	rdlong	result1, fp
057ac     0C 4E 05 F1 | 	add	fp, #12
057b0     A7 D8 01 FB | 	rdlong	local01, fp
057b4     EC A6 01 F1 | 	add	result1, local01
057b8     0C 4E 85 F1 | 	sub	fp, #12
057bc     A7 A6 61 FC | 	wrlong	result1, fp
057c0     14 4E 85 F1 | 	sub	fp, #20
057c4     A7 A6 01 FB | 	rdlong	result1, fp
057c8     09 A6 45 F0 | 	shr	result1, #9
057cc     1C 4E 05 F1 | 	add	fp, #28
057d0     A7 A6 61 FC | 	wrlong	result1, fp
057d4     28 4E 85 F1 | 	sub	fp, #40
057d8     01 A6 15 F2 | 	cmp	result1, #1 wc
057dc     60 01 90 CD |  if_b	jmp	#LR__0606
057e0     2C 4E 05 F1 | 	add	fp, #44
057e4     A7 A6 01 FB | 	rdlong	result1, fp
057e8     04 4E 85 F1 | 	sub	fp, #4
057ec     A7 C8 01 FB | 	rdlong	arg04, fp
057f0     E4 A6 01 F1 | 	add	result1, arg04
057f4     10 4E 85 F1 | 	sub	fp, #16
057f8     A7 C8 01 FB | 	rdlong	arg04, fp
057fc     18 4E 85 F1 | 	sub	fp, #24
05800     0A C8 05 F1 | 	add	arg04, #10
05804     E4 C8 E1 FA | 	rdword	arg04, arg04
05808     E4 A6 19 F2 | 	cmp	result1, arg04 wcz
0580c     28 00 90 ED |  if_be	jmp	#LR__0603
05810     18 4E 05 F1 | 	add	fp, #24
05814     A7 A6 01 FB | 	rdlong	result1, fp
05818     0A A6 05 F1 | 	add	result1, #10
0581c     D3 A6 E1 FA | 	rdword	result1, result1
05820     14 4E 05 F1 | 	add	fp, #20
05824     A7 C8 01 FB | 	rdlong	arg04, fp
05828     E4 A6 81 F1 | 	sub	result1, arg04
0582c     04 4E 85 F1 | 	sub	fp, #4
05830     A7 A6 61 FC | 	wrlong	result1, fp
05834     28 4E 85 F1 | 	sub	fp, #40
05838                 | LR__0603
05838     18 4E 05 F1 | 	add	fp, #24
0583c     A7 C8 01 FB | 	rdlong	arg04, fp
05840     01 C8 05 F1 | 	add	arg04, #1
05844     E4 C2 C1 FA | 	rdbyte	arg01, arg04
05848     18 4E 05 F1 | 	add	fp, #24
0584c     A7 C4 01 FB | 	rdlong	arg02, fp
05850     10 4E 85 F1 | 	sub	fp, #16
05854     A7 C6 01 FB | 	rdlong	arg03, fp
05858     08 4E 05 F1 | 	add	fp, #8
0585c     A7 C8 01 FB | 	rdlong	arg04, fp
05860     28 4E 85 F1 | 	sub	fp, #40
05864     98 CA BF FD | 	call	#_fatfs_cc_disk_write
05868     00 A6 0D F2 | 	cmp	result1, #0 wz
0586c     1C 00 90 AD |  if_e	jmp	#LR__0604
05870     04 4E 05 F1 | 	add	fp, #4
05874     A7 D8 01 FB | 	rdlong	local01, fp
05878     04 4E 85 F1 | 	sub	fp, #4
0587c     11 D8 05 F1 | 	add	local01, #17
05880     EC 02 48 FC | 	wrbyte	#1, local01
05884     01 A6 05 F6 | 	mov	result1, #1
05888     48 03 90 FD | 	jmp	#LR__0613
0588c                 | LR__0604
0588c     04 4E 05 F1 | 	add	fp, #4
05890     A7 A6 01 FB | 	rdlong	result1, fp
05894     1C A6 05 F1 | 	add	result1, #28
05898     D3 A6 01 FB | 	rdlong	result1, result1
0589c     1C 4E 05 F1 | 	add	fp, #28
058a0     A7 DA 01 FB | 	rdlong	local02, fp
058a4     ED A6 81 F1 | 	sub	result1, local02
058a8     08 4E 05 F1 | 	add	fp, #8
058ac     A7 C8 01 FB | 	rdlong	arg04, fp
058b0     28 4E 85 F1 | 	sub	fp, #40
058b4     E4 A6 11 F2 | 	cmp	result1, arg04 wc
058b8     68 00 90 3D |  if_ae	jmp	#LR__0605
058bc     04 4E 05 F1 | 	add	fp, #4
058c0     A7 C2 01 FB | 	rdlong	arg01, fp
058c4     28 C2 05 F1 | 	add	arg01, #40
058c8     2C 4E 05 F1 | 	add	fp, #44
058cc     A7 C4 01 FB | 	rdlong	arg02, fp
058d0     2C 4E 85 F1 | 	sub	fp, #44
058d4     A7 A6 01 FB | 	rdlong	result1, fp
058d8     1C A6 05 F1 | 	add	result1, #28
058dc     D3 DC 01 FB | 	rdlong	local03, result1
058e0     1C 4E 05 F1 | 	add	fp, #28
058e4     A7 C8 01 FB | 	rdlong	arg04, fp
058e8     20 4E 85 F1 | 	sub	fp, #32
058ec     E4 DC 81 F1 | 	sub	local03, arg04
058f0     09 DC 65 F0 | 	shl	local03, #9
058f4     EE C4 01 F1 | 	add	arg02, local03
058f8     09 C6 C5 F9 | 	decod	arg03, #9
058fc     58 8A B0 FD | 	call	#__system____builtin_memmove
05900     04 4E 05 F1 | 	add	fp, #4
05904     A7 C8 01 FB | 	rdlong	arg04, fp
05908     E4 A6 01 F6 | 	mov	result1, arg04
0590c     04 4E 85 F1 | 	sub	fp, #4
05910     10 C8 05 F1 | 	add	arg04, #16
05914     E4 C8 C1 FA | 	rdbyte	arg04, arg04
05918     7F C8 05 F5 | 	and	arg04, #127
0591c     10 A6 05 F1 | 	add	result1, #16
05920     D3 C8 41 FC | 	wrbyte	arg04, result1
05924                 | LR__0605
05924     28 4E 05 F1 | 	add	fp, #40
05928     A7 A6 01 FB | 	rdlong	result1, fp
0592c     09 A6 65 F0 | 	shl	result1, #9
05930     04 4E 85 F1 | 	sub	fp, #4
05934     A7 A6 61 FC | 	wrlong	result1, fp
05938     24 4E 85 F1 | 	sub	fp, #36
0593c                 | ' 					__builtin_memcpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT) 512 ) ), ((UINT) 512 ) ) ;
0593c                 | ' 					fp->flag &= (BYTE)~ 0x80 ;
0593c                 | ' 				}
0593c                 | ' 
0593c                 | ' 
0593c                 | ' 				wcnt =  ((UINT) 512 )  * cc;
0593c                 | ' 				continue;
0593c     74 01 90 FD | 	jmp	#LR__0609
05940                 | LR__0606
05940     04 4E 05 F1 | 	add	fp, #4
05944     A7 DA 01 FB | 	rdlong	local02, fp
05948     1C DA 05 F1 | 	add	local02, #28
0594c     ED A6 01 FB | 	rdlong	result1, local02
05950     1C 4E 05 F1 | 	add	fp, #28
05954     A7 DA 01 FB | 	rdlong	local02, fp
05958     20 4E 85 F1 | 	sub	fp, #32
0595c     ED A6 09 F2 | 	cmp	result1, local02 wz
05960     90 00 90 AD |  if_e	jmp	#LR__0607
05964     04 4E 05 F1 | 	add	fp, #4
05968     A7 A6 01 FB | 	rdlong	result1, fp
0596c     D3 DC 01 F6 | 	mov	local03, result1
05970     04 4E 85 F1 | 	sub	fp, #4
05974     14 DC 05 F1 | 	add	local03, #20
05978     EE DC 01 FB | 	rdlong	local03, local03
0597c     0C A6 05 F1 | 	add	result1, #12
05980     D3 DE 01 FB | 	rdlong	local04, result1
05984     EF E0 01 F6 | 	mov	local05, local04
05988     F0 DC 11 F2 | 	cmp	local03, local05 wc
0598c     64 00 90 3D |  if_ae	jmp	#LR__0607
05990     18 4E 05 F1 | 	add	fp, #24
05994     A7 C8 01 FB | 	rdlong	arg04, fp
05998     01 C8 05 F1 | 	add	arg04, #1
0599c     E4 C2 C1 FA | 	rdbyte	arg01, arg04
059a0     14 4E 85 F1 | 	sub	fp, #20
059a4     A7 E2 01 FB | 	rdlong	local06, fp
059a8     28 E2 05 F1 | 	add	local06, #40
059ac     F1 E4 01 F6 | 	mov	local07, local06
059b0     1C 4E 05 F1 | 	add	fp, #28
059b4     A7 E6 01 FB | 	rdlong	local08, fp
059b8     20 4E 85 F1 | 	sub	fp, #32
059bc     01 E8 05 F6 | 	mov	local09, #1
059c0     F2 C4 01 F6 | 	mov	arg02, local07
059c4     F3 C6 01 F6 | 	mov	arg03, local08
059c8     01 C8 05 F6 | 	mov	arg04, #1
059cc     70 C8 BF FD | 	call	#_fatfs_cc_disk_read
059d0     D3 EA 09 F6 | 	mov	local10, result1 wz
059d4     1C 00 90 AD |  if_e	jmp	#LR__0607
059d8     04 4E 05 F1 | 	add	fp, #4
059dc     A7 EA 01 FB | 	rdlong	local10, fp
059e0     04 4E 85 F1 | 	sub	fp, #4
059e4     11 EA 05 F1 | 	add	local10, #17
059e8     F5 02 48 FC | 	wrbyte	#1, local10
059ec                 | ' 				fp->fptr < fp->obj.objsize &&
059ec                 | ' 				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
059ec                 | ' 					{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR ; } ;
059ec     01 A6 05 F6 | 	mov	result1, #1
059f0     E0 01 90 FD | 	jmp	#LR__0613
059f4                 | LR__0607
059f4     04 4E 05 F1 | 	add	fp, #4
059f8     A7 C8 01 FB | 	rdlong	arg04, fp
059fc     1C 4E 05 F1 | 	add	fp, #28
05a00     A7 A6 01 FB | 	rdlong	result1, fp
05a04     20 4E 85 F1 | 	sub	fp, #32
05a08     1C C8 05 F1 | 	add	arg04, #28
05a0c     E4 A6 61 FC | 	wrlong	result1, arg04
05a10                 | LR__0608
05a10     04 4E 05 F1 | 	add	fp, #4
05a14     A7 A6 01 FB | 	rdlong	result1, fp
05a18     14 A6 05 F1 | 	add	result1, #20
05a1c     D3 A6 01 FB | 	rdlong	result1, result1
05a20     FF A7 05 F5 | 	and	result1, #511
05a24     09 EC C5 F9 | 	decod	local11, #9
05a28     D3 EC 81 F1 | 	sub	local11, result1
05a2c     20 4E 05 F1 | 	add	fp, #32
05a30     A7 EC 61 FC | 	wrlong	local11, fp
05a34     18 4E 85 F1 | 	sub	fp, #24
05a38     A7 A6 01 FB | 	rdlong	result1, fp
05a3c     0C 4E 85 F1 | 	sub	fp, #12
05a40     D3 EC 19 F2 | 	cmp	local11, result1 wcz
05a44     0C 4E 05 11 |  if_a	add	fp, #12
05a48     A7 EC 01 1B |  if_a	rdlong	local11, fp
05a4c     18 4E 05 11 |  if_a	add	fp, #24
05a50     A7 EC 61 1C |  if_a	wrlong	local11, fp
05a54     24 4E 85 11 |  if_a	sub	fp, #36
05a58     04 4E 05 F1 | 	add	fp, #4
05a5c     A7 EC 01 FB | 	rdlong	local11, fp
05a60     F6 C2 01 F6 | 	mov	arg01, local11
05a64     28 C2 05 F1 | 	add	arg01, #40
05a68     14 EC 05 F1 | 	add	local11, #20
05a6c     F6 EC 01 FB | 	rdlong	local11, local11
05a70     FF ED 05 F5 | 	and	local11, #511
05a74     F6 C2 01 F1 | 	add	arg01, local11
05a78     2C 4E 05 F1 | 	add	fp, #44
05a7c     A7 C4 01 FB | 	rdlong	arg02, fp
05a80     0C 4E 85 F1 | 	sub	fp, #12
05a84     A7 C6 01 FB | 	rdlong	arg03, fp
05a88     24 4E 85 F1 | 	sub	fp, #36
05a8c     C8 88 B0 FD | 	call	#__system____builtin_memmove
05a90     04 4E 05 F1 | 	add	fp, #4
05a94     A7 A6 01 FB | 	rdlong	result1, fp
05a98     D3 EC 01 F6 | 	mov	local11, result1
05a9c     04 4E 85 F1 | 	sub	fp, #4
05aa0     10 A6 05 F1 | 	add	result1, #16
05aa4     D3 A6 C1 FA | 	rdbyte	result1, result1
05aa8     80 A6 45 F5 | 	or	result1, #128
05aac     10 EC 05 F1 | 	add	local11, #16
05ab0     F6 A6 41 FC | 	wrbyte	result1, local11
05ab4                 | LR__0609
05ab4     0C 4E 05 F1 | 	add	fp, #12
05ab8     A7 EC 01 FB | 	rdlong	local11, fp
05abc     18 4E 05 F1 | 	add	fp, #24
05ac0     A7 A6 01 FB | 	rdlong	result1, fp
05ac4     D3 EC 81 F1 | 	sub	local11, result1
05ac8     18 4E 85 F1 | 	sub	fp, #24
05acc     A7 EC 61 FC | 	wrlong	local11, fp
05ad0     04 4E 05 F1 | 	add	fp, #4
05ad4     A7 EE 01 FB | 	rdlong	local12, fp
05ad8     F7 EC 01 FB | 	rdlong	local11, local12
05adc     14 4E 05 F1 | 	add	fp, #20
05ae0     A7 F0 01 FB | 	rdlong	local13, fp
05ae4     F8 EC 01 F1 | 	add	local11, local13
05ae8     F7 EC 61 FC | 	wrlong	local11, local12
05aec     0C 4E 05 F1 | 	add	fp, #12
05af0     A7 EC 01 FB | 	rdlong	local11, fp
05af4     0C 4E 85 F1 | 	sub	fp, #12
05af8     A7 F2 01 FB | 	rdlong	local14, fp
05afc     F9 EC 01 F1 | 	add	local11, local14
05b00     0C 4E 05 F1 | 	add	fp, #12
05b04     A7 EC 61 FC | 	wrlong	local11, fp
05b08     2C 4E 85 F1 | 	sub	fp, #44
05b0c     A7 F4 01 FB | 	rdlong	local15, fp
05b10     FA EC 01 F6 | 	mov	local11, local15
05b14     14 F4 05 F1 | 	add	local15, #20
05b18     FA F4 01 FB | 	rdlong	local15, local15
05b1c     20 4E 05 F1 | 	add	fp, #32
05b20     A7 F6 01 FB | 	rdlong	local16, fp
05b24     FB F4 01 F1 | 	add	local15, local16
05b28     14 EC 05 F1 | 	add	local11, #20
05b2c     F6 F4 61 FC | 	wrlong	local15, local11
05b30     20 4E 85 F1 | 	sub	fp, #32
05b34     A7 F8 01 FB | 	rdlong	local17, fp
05b38     FC EC 01 F6 | 	mov	local11, local17
05b3c     FC FA 01 F6 | 	mov	local18, local17
05b40     04 4E 85 F1 | 	sub	fp, #4
05b44     14 F8 05 F1 | 	add	local17, #20
05b48     FC FC 01 FB | 	rdlong	local19, local17
05b4c     0C FA 05 F1 | 	add	local18, #12
05b50     FD FE 01 FB | 	rdlong	local20, local18
05b54     FF FC 19 F2 | 	cmp	local19, local20 wcz
05b58     24 00 90 ED |  if_be	jmp	#LR__0610
05b5c     04 4E 05 F1 | 	add	fp, #4
05b60     A7 E0 01 FB | 	rdlong	local05, fp
05b64     04 4E 85 F1 | 	sub	fp, #4
05b68     F0 DC 01 F6 | 	mov	local03, local05
05b6c     14 DC 05 F1 | 	add	local03, #20
05b70     EE DE 01 FB | 	rdlong	local04, local03
05b74     14 DC 85 F1 | 	sub	local03, #20
05b78     EF 00 02 F6 | 	mov	local21, local04
05b7c     20 00 90 FD | 	jmp	#LR__0611
05b80                 | LR__0610
05b80     04 4E 05 F1 | 	add	fp, #4
05b84     A7 E4 01 FB | 	rdlong	local07, fp
05b88     04 4E 85 F1 | 	sub	fp, #4
05b8c     F2 EA 01 F6 | 	mov	local10, local07
05b90     0C EA 05 F1 | 	add	local10, #12
05b94     F5 E6 01 FB | 	rdlong	local08, local10
05b98     0C EA 85 F1 | 	sub	local10, #12
05b9c     F3 00 02 F6 | 	mov	local21, local08
05ba0                 | LR__0611
05ba0     0C EC 05 F1 | 	add	local11, #12
05ba4     F6 00 62 FC | 	wrlong	local21, local11
05ba8     5C F9 9F FD | 	jmp	#LR__0593
05bac                 | LR__0612
05bac     04 4E 05 F1 | 	add	fp, #4
05bb0     A7 EE 01 FB | 	rdlong	local12, fp
05bb4     F7 D8 01 F6 | 	mov	local01, local12
05bb8     04 4E 85 F1 | 	sub	fp, #4
05bbc     10 EE 05 F1 | 	add	local12, #16
05bc0     F7 EC C1 FA | 	rdbyte	local11, local12
05bc4     40 EC 45 F5 | 	or	local11, #64
05bc8     10 D8 05 F1 | 	add	local01, #16
05bcc     EC EC 41 FC | 	wrbyte	local11, local01
05bd0                 | ' 
05bd0                 | ' 
05bd0                 | ' 
05bd0                 | ' 
05bd0                 | ' 
05bd0                 | ' 		__builtin_memcpy(fp->buf + fp->fptr % ((UINT) 512 ) , wbuff, wcnt) ;
05bd0                 | ' 		fp->flag |=  0x80 ;
05bd0                 | ' 
05bd0                 | ' 	}
05bd0                 | ' 
05bd0                 | ' 	fp->flag |=  0x40 ;
05bd0                 | ' 
05bd0                 | ' 	return FR_OK ;
05bd0     00 A6 05 F6 | 	mov	result1, #0
05bd4                 | LR__0613
05bd4     A7 F0 03 F6 | 	mov	ptra, fp
05bd8     B2 00 A0 FD | 	call	#popregs_
05bdc                 | _fatfs_cc_f_write_ret
05bdc     2D 00 64 FD | 	ret
05be0                 | 
05be0                 | _fatfs_cc_f_sync
05be0     00 4A 05 F6 | 	mov	COUNT_, #0
05be4     A8 00 A0 FD | 	call	#pushregs_
05be8     18 F0 07 F1 | 	add	ptra, #24
05bec     04 4E 05 F1 | 	add	fp, #4
05bf0     A7 C2 61 FC | 	wrlong	arg01, fp
05bf4     08 4E 05 F1 | 	add	fp, #8
05bf8     A7 C4 01 F6 | 	mov	arg02, fp
05bfc     0C 4E 85 F1 | 	sub	fp, #12
05c00     E0 E8 BF FD | 	call	#_fatfs_cc_validate
05c04     08 4E 05 F1 | 	add	fp, #8
05c08     A7 A6 61 FC | 	wrlong	result1, fp
05c0c     08 4E 85 F1 | 	sub	fp, #8
05c10     00 A6 0D F2 | 	cmp	result1, #0 wz
05c14     C0 01 90 5D |  if_ne	jmp	#LR__0623
05c18     04 4E 05 F1 | 	add	fp, #4
05c1c     A7 C8 01 FB | 	rdlong	arg04, fp
05c20     04 4E 85 F1 | 	sub	fp, #4
05c24     10 C8 05 F1 | 	add	arg04, #16
05c28     E4 C8 C1 FA | 	rdbyte	arg04, arg04
05c2c     40 C8 CD F7 | 	test	arg04, #64 wz
05c30     A4 01 90 AD |  if_e	jmp	#LR__0622
05c34     04 4E 05 F1 | 	add	fp, #4
05c38     A7 C8 01 FB | 	rdlong	arg04, fp
05c3c     04 4E 85 F1 | 	sub	fp, #4
05c40     10 C8 05 F1 | 	add	arg04, #16
05c44     E4 C8 C1 FA | 	rdbyte	arg04, arg04
05c48     80 C8 CD F7 | 	test	arg04, #128 wz
05c4c     64 00 90 AD |  if_e	jmp	#LR__0620
05c50     0C 4E 05 F1 | 	add	fp, #12
05c54     A7 C8 01 FB | 	rdlong	arg04, fp
05c58     01 C8 05 F1 | 	add	arg04, #1
05c5c     E4 C2 C1 FA | 	rdbyte	arg01, arg04
05c60     08 4E 85 F1 | 	sub	fp, #8
05c64     A7 C8 01 FB | 	rdlong	arg04, fp
05c68     E4 C4 01 F6 | 	mov	arg02, arg04
05c6c     28 C4 05 F1 | 	add	arg02, #40
05c70     04 4E 85 F1 | 	sub	fp, #4
05c74     1C C8 05 F1 | 	add	arg04, #28
05c78     E4 C6 01 FB | 	rdlong	arg03, arg04
05c7c     01 C8 05 F6 | 	mov	arg04, #1
05c80     7C C6 BF FD | 	call	#_fatfs_cc_disk_write
05c84     00 A6 0D F2 | 	cmp	result1, #0 wz
05c88     01 A6 05 56 |  if_ne	mov	result1, #1
05c8c     54 01 90 5D |  if_ne	jmp	#LR__0624
05c90     04 4E 05 F1 | 	add	fp, #4
05c94     A7 C8 01 FB | 	rdlong	arg04, fp
05c98     E4 C6 01 F6 | 	mov	arg03, arg04
05c9c     04 4E 85 F1 | 	sub	fp, #4
05ca0     10 C8 05 F1 | 	add	arg04, #16
05ca4     E4 C8 C1 FA | 	rdbyte	arg04, arg04
05ca8     7F C8 05 F5 | 	and	arg04, #127
05cac     10 C6 05 F1 | 	add	arg03, #16
05cb0     E3 C8 41 FC | 	wrbyte	arg04, arg03
05cb4                 | LR__0620
05cb4     F8 19 B0 FD | 	call	#_fatfs_cc__get_fattime
05cb8     10 4E 05 F1 | 	add	fp, #16
05cbc     A7 A6 61 FC | 	wrlong	result1, fp
05cc0     04 4E 85 F1 | 	sub	fp, #4
05cc4     A7 C2 01 FB | 	rdlong	arg01, fp
05cc8     08 4E 85 F1 | 	sub	fp, #8
05ccc     A7 C8 01 FB | 	rdlong	arg04, fp
05cd0     04 4E 85 F1 | 	sub	fp, #4
05cd4     20 C8 05 F1 | 	add	arg04, #32
05cd8     E4 C4 01 FB | 	rdlong	arg02, arg04
05cdc     70 CA BF FD | 	call	#_fatfs_cc_move_window
05ce0     08 4E 05 F1 | 	add	fp, #8
05ce4     A7 A6 61 FC | 	wrlong	result1, fp
05ce8     08 4E 85 F1 | 	sub	fp, #8
05cec     00 A6 0D F2 | 	cmp	result1, #0 wz
05cf0     E4 00 90 5D |  if_ne	jmp	#LR__0621
05cf4     04 4E 05 F1 | 	add	fp, #4
05cf8     A7 C8 01 FB | 	rdlong	arg04, fp
05cfc     24 C8 05 F1 | 	add	arg04, #36
05d00     E4 C8 01 FB | 	rdlong	arg04, arg04
05d04     10 4E 05 F1 | 	add	fp, #16
05d08     A7 C8 61 FC | 	wrlong	arg04, fp
05d0c     E4 C6 01 F6 | 	mov	arg03, arg04
05d10     0B C6 05 F1 | 	add	arg03, #11
05d14     E3 C6 C1 FA | 	rdbyte	arg03, arg03
05d18     20 C6 45 F5 | 	or	arg03, #32
05d1c     0B C8 05 F1 | 	add	arg04, #11
05d20     E4 C6 41 FC | 	wrbyte	arg03, arg04
05d24     10 4E 85 F1 | 	sub	fp, #16
05d28     A7 C8 01 FB | 	rdlong	arg04, fp
05d2c     E4 C2 01 FB | 	rdlong	arg01, arg04
05d30     10 4E 05 F1 | 	add	fp, #16
05d34     A7 C4 01 FB | 	rdlong	arg02, fp
05d38     14 4E 85 F1 | 	sub	fp, #20
05d3c     08 C8 05 F1 | 	add	arg04, #8
05d40     E4 C6 01 FB | 	rdlong	arg03, arg04
05d44     74 D7 BF FD | 	call	#_fatfs_cc_st_clust
05d48     14 4E 05 F1 | 	add	fp, #20
05d4c     A7 C2 01 FB | 	rdlong	arg01, fp
05d50     1C C2 05 F1 | 	add	arg01, #28
05d54     10 4E 85 F1 | 	sub	fp, #16
05d58     A7 C8 01 FB | 	rdlong	arg04, fp
05d5c     0C C8 05 F1 | 	add	arg04, #12
05d60     E4 C4 01 FB | 	rdlong	arg02, arg04
05d64     E1 C4 61 FC | 	wrlong	arg02, arg01
05d68     10 4E 05 F1 | 	add	fp, #16
05d6c     A7 C2 01 FB | 	rdlong	arg01, fp
05d70     16 C2 05 F1 | 	add	arg01, #22
05d74     04 4E 85 F1 | 	sub	fp, #4
05d78     A7 C4 01 FB | 	rdlong	arg02, fp
05d7c     E1 C4 61 FC | 	wrlong	arg02, arg01
05d80     04 4E 05 F1 | 	add	fp, #4
05d84     A7 C2 01 FB | 	rdlong	arg01, fp
05d88     12 C2 05 F1 | 	add	arg01, #18
05d8c     E1 00 58 FC | 	wrword	#0, arg01
05d90     08 4E 85 F1 | 	sub	fp, #8
05d94     A7 C8 01 FB | 	rdlong	arg04, fp
05d98     03 C8 05 F1 | 	add	arg04, #3
05d9c     E4 02 48 FC | 	wrbyte	#1, arg04
05da0     A7 C2 01 FB | 	rdlong	arg01, fp
05da4     0C 4E 85 F1 | 	sub	fp, #12
05da8     1C CA BF FD | 	call	#_fatfs_cc_sync_fs
05dac     08 4E 05 F1 | 	add	fp, #8
05db0     A7 A6 61 FC | 	wrlong	result1, fp
05db4     04 4E 85 F1 | 	sub	fp, #4
05db8     A7 C8 01 FB | 	rdlong	arg04, fp
05dbc     E4 C6 01 F6 | 	mov	arg03, arg04
05dc0     04 4E 85 F1 | 	sub	fp, #4
05dc4     10 C8 05 F1 | 	add	arg04, #16
05dc8     E4 C8 C1 FA | 	rdbyte	arg04, arg04
05dcc     BF C8 05 F5 | 	and	arg04, #191
05dd0     10 C6 05 F1 | 	add	arg03, #16
05dd4     E3 C8 41 FC | 	wrbyte	arg04, arg03
05dd8                 | LR__0621
05dd8                 | LR__0622
05dd8                 | LR__0623
05dd8                 | ' 					dir = fp->dir_ptr;
05dd8                 | ' 					dir[ 11 ] |=  0x20 ;
05dd8                 | ' 					st_clust(fp->obj.fs, dir, fp->obj.sclust);
05dd8                 | ' 					st_dword(dir +  28 , (DWORD)fp->obj.objsize);
05dd8                 | ' 					st_dword(dir +  22 , tm);
05dd8                 | ' 					st_word(dir +  18 , 0);
05dd8                 | ' 					fs->wflag = 1;
05dd8                 | ' 					res = sync_fs(fs);
05dd8                 | ' 					fp->flag &= (BYTE)~ 0x40 ;
05dd8                 | ' 				}
05dd8                 | ' 			}
05dd8                 | ' 		}
05dd8                 | ' 	}
05dd8                 | ' 
05dd8                 | ' 	return res ;
05dd8     08 4E 05 F1 | 	add	fp, #8
05ddc     A7 A6 01 FB | 	rdlong	result1, fp
05de0     08 4E 85 F1 | 	sub	fp, #8
05de4                 | LR__0624
05de4     A7 F0 03 F6 | 	mov	ptra, fp
05de8     B2 00 A0 FD | 	call	#popregs_
05dec                 | _fatfs_cc_f_sync_ret
05dec     2D 00 64 FD | 	ret
05df0                 | 
05df0                 | _fatfs_cc_f_close
05df0     01 4A 05 F6 | 	mov	COUNT_, #1
05df4     A8 00 A0 FD | 	call	#pushregs_
05df8     10 F0 07 F1 | 	add	ptra, #16
05dfc     04 4E 05 F1 | 	add	fp, #4
05e00     A7 C2 61 FC | 	wrlong	arg01, fp
05e04     04 4E 85 F1 | 	sub	fp, #4
05e08     D4 FD BF FD | 	call	#_fatfs_cc_f_sync
05e0c     08 4E 05 F1 | 	add	fp, #8
05e10     A7 A6 61 FC | 	wrlong	result1, fp
05e14     08 4E 85 F1 | 	sub	fp, #8
05e18     00 A6 0D F2 | 	cmp	result1, #0 wz
05e1c     38 00 90 5D |  if_ne	jmp	#LR__0630
05e20     04 4E 05 F1 | 	add	fp, #4
05e24     A7 C2 01 FB | 	rdlong	arg01, fp
05e28     08 4E 05 F1 | 	add	fp, #8
05e2c     A7 C4 01 F6 | 	mov	arg02, fp
05e30     0C 4E 85 F1 | 	sub	fp, #12
05e34     AC E6 BF FD | 	call	#_fatfs_cc_validate
05e38     08 4E 05 F1 | 	add	fp, #8
05e3c     A7 A6 61 FC | 	wrlong	result1, fp
05e40     08 4E 85 F1 | 	sub	fp, #8
05e44     00 A6 0D F2 | 	cmp	result1, #0 wz
05e48     04 4E 05 A1 |  if_e	add	fp, #4
05e4c     A7 D8 01 AB |  if_e	rdlong	local01, fp
05e50     04 4E 85 A1 |  if_e	sub	fp, #4
05e54     EC 00 68 AC |  if_e	wrlong	#0, local01
05e58                 | LR__0630
05e58                 | ' 
05e58                 | ' 
05e58                 | ' 
05e58                 | ' 
05e58                 | ' 			fp->obj.fs = 0;
05e58                 | ' #line 4192 "ff.c"
05e58                 | ' 		}
05e58                 | ' 	}
05e58                 | ' 	return res;
05e58     08 4E 05 F1 | 	add	fp, #8
05e5c     A7 A6 01 FB | 	rdlong	result1, fp
05e60     08 4E 85 F1 | 	sub	fp, #8
05e64     A7 F0 03 F6 | 	mov	ptra, fp
05e68     B2 00 A0 FD | 	call	#popregs_
05e6c                 | _fatfs_cc_f_close_ret
05e6c     2D 00 64 FD | 	ret
05e70                 | 
05e70                 | _fatfs_cc_f_lseek
05e70     00 4A 05 F6 | 	mov	COUNT_, #0
05e74     A8 00 A0 FD | 	call	#pushregs_
05e78     24 F0 07 F1 | 	add	ptra, #36
05e7c     04 4E 05 F1 | 	add	fp, #4
05e80     A7 C2 61 FC | 	wrlong	arg01, fp
05e84     04 4E 05 F1 | 	add	fp, #4
05e88     A7 C4 61 FC | 	wrlong	arg02, fp
05e8c     04 4E 85 F1 | 	sub	fp, #4
05e90     A7 C2 01 FB | 	rdlong	arg01, fp
05e94     0C 4E 05 F1 | 	add	fp, #12
05e98     A7 C4 01 F6 | 	mov	arg02, fp
05e9c     10 4E 85 F1 | 	sub	fp, #16
05ea0     40 E6 BF FD | 	call	#_fatfs_cc_validate
05ea4     0C 4E 05 F1 | 	add	fp, #12
05ea8     A7 A6 61 FC | 	wrlong	result1, fp
05eac     0C 4E 85 F1 | 	sub	fp, #12
05eb0     00 A6 0D F2 | 	cmp	result1, #0 wz
05eb4     1C 00 90 5D |  if_ne	jmp	#LR__0640
05eb8     04 4E 05 F1 | 	add	fp, #4
05ebc     A7 C8 01 FB | 	rdlong	arg04, fp
05ec0     11 C8 05 F1 | 	add	arg04, #17
05ec4     E4 C8 C1 FA | 	rdbyte	arg04, arg04
05ec8     08 4E 05 F1 | 	add	fp, #8
05ecc     A7 C8 61 FC | 	wrlong	arg04, fp
05ed0     0C 4E 85 F1 | 	sub	fp, #12
05ed4                 | LR__0640
05ed4     0C 4E 05 F1 | 	add	fp, #12
05ed8     A7 C8 09 FB | 	rdlong	arg04, fp wz
05edc     0C 4E 85 F1 | 	sub	fp, #12
05ee0     0C 4E 05 51 |  if_ne	add	fp, #12
05ee4     A7 A6 01 5B |  if_ne	rdlong	result1, fp
05ee8     0C 4E 85 51 |  if_ne	sub	fp, #12
05eec     40 06 90 5D |  if_ne	jmp	#LR__0663
05ef0     04 4E 05 F1 | 	add	fp, #4
05ef4     A7 C8 01 FB | 	rdlong	arg04, fp
05ef8     04 4E 05 F1 | 	add	fp, #4
05efc     A7 C6 01 FB | 	rdlong	arg03, fp
05f00     08 4E 85 F1 | 	sub	fp, #8
05f04     0C C8 05 F1 | 	add	arg04, #12
05f08     E4 C8 01 FB | 	rdlong	arg04, arg04
05f0c     E4 C6 19 F2 | 	cmp	arg03, arg04 wcz
05f10     3C 00 90 ED |  if_be	jmp	#LR__0641
05f14     04 4E 05 F1 | 	add	fp, #4
05f18     A7 C6 01 FB | 	rdlong	arg03, fp
05f1c     04 4E 85 F1 | 	sub	fp, #4
05f20     10 C6 05 F1 | 	add	arg03, #16
05f24     E3 C6 C1 FA | 	rdbyte	arg03, arg03
05f28     E3 C6 E1 F8 | 	getbyte	arg03, arg03, #0
05f2c     02 C6 CD F7 | 	test	arg03, #2 wz
05f30     1C 00 90 5D |  if_ne	jmp	#LR__0641
05f34     04 4E 05 F1 | 	add	fp, #4
05f38     A7 C6 01 FB | 	rdlong	arg03, fp
05f3c     0C C6 05 F1 | 	add	arg03, #12
05f40     E3 C6 01 FB | 	rdlong	arg03, arg03
05f44     04 4E 05 F1 | 	add	fp, #4
05f48     A7 C6 61 FC | 	wrlong	arg03, fp
05f4c     08 4E 85 F1 | 	sub	fp, #8
05f50                 | LR__0641
05f50     04 4E 05 F1 | 	add	fp, #4
05f54     A7 C6 01 FB | 	rdlong	arg03, fp
05f58     14 C6 05 F1 | 	add	arg03, #20
05f5c     E3 C6 01 FB | 	rdlong	arg03, arg03
05f60     1C 4E 05 F1 | 	add	fp, #28
05f64     A7 C6 61 FC | 	wrlong	arg03, fp
05f68     1C 4E 85 F1 | 	sub	fp, #28
05f6c     A7 C6 01 FB | 	rdlong	arg03, fp
05f70     18 4E 05 F1 | 	add	fp, #24
05f74     A7 00 68 FC | 	wrlong	#0, fp
05f78     14 C6 05 F1 | 	add	arg03, #20
05f7c     E3 00 68 FC | 	wrlong	#0, arg03
05f80     14 4E 85 F1 | 	sub	fp, #20
05f84     A7 C6 01 FB | 	rdlong	arg03, fp
05f88     08 4E 85 F1 | 	sub	fp, #8
05f8c     01 C6 15 F2 | 	cmp	arg03, #1 wc
05f90     E4 03 90 CD |  if_b	jmp	#LR__0657
05f94     10 4E 05 F1 | 	add	fp, #16
05f98     A7 C6 01 FB | 	rdlong	arg03, fp
05f9c     0A C6 05 F1 | 	add	arg03, #10
05fa0     E3 C8 E1 FA | 	rdword	arg04, arg03
05fa4     09 C8 65 F0 | 	shl	arg04, #9
05fa8     08 4E 05 F1 | 	add	fp, #8
05fac     A7 C8 61 FC | 	wrlong	arg04, fp
05fb0     08 4E 05 F1 | 	add	fp, #8
05fb4     A7 C8 01 FB | 	rdlong	arg04, fp
05fb8     20 4E 85 F1 | 	sub	fp, #32
05fbc     01 C8 15 F2 | 	cmp	arg04, #1 wc
05fc0     AC 00 90 CD |  if_b	jmp	#LR__0642
05fc4     08 4E 05 F1 | 	add	fp, #8
05fc8     A7 C8 01 FB | 	rdlong	arg04, fp
05fcc     01 C8 85 F1 | 	sub	arg04, #1
05fd0     10 4E 05 F1 | 	add	fp, #16
05fd4     A7 C6 01 FB | 	rdlong	arg03, fp
05fd8     E3 C8 11 FD | 	qdiv	arg04, arg03
05fdc     08 4E 05 F1 | 	add	fp, #8
05fe0     A7 A6 01 FB | 	rdlong	result1, fp
05fe4     01 A6 85 F1 | 	sub	result1, #1
05fe8     18 C8 61 FD | 	getqx	arg04
05fec     E3 A6 11 FD | 	qdiv	result1, arg03
05ff0     20 4E 85 F1 | 	sub	fp, #32
05ff4     18 C6 61 FD | 	getqx	arg03
05ff8     E3 C8 11 F2 | 	cmp	arg04, arg03 wc
05ffc     70 00 90 CD |  if_b	jmp	#LR__0642
06000     04 4E 05 F1 | 	add	fp, #4
06004     A7 C6 01 FB | 	rdlong	arg03, fp
06008     1C 4E 05 F1 | 	add	fp, #28
0600c     A7 A6 01 FB | 	rdlong	result1, fp
06010     01 A6 85 F1 | 	sub	result1, #1
06014     08 4E 85 F1 | 	sub	fp, #8
06018     A7 C8 01 FB | 	rdlong	arg04, fp
0601c     01 C8 85 F1 | 	sub	arg04, #1
06020     E4 A6 21 F5 | 	andn	result1, arg04
06024     14 C6 05 F1 | 	add	arg03, #20
06028     E3 A6 61 FC | 	wrlong	result1, arg03
0602c     10 4E 85 F1 | 	sub	fp, #16
06030     A7 C6 01 FB | 	rdlong	arg03, fp
06034     04 4E 85 F1 | 	sub	fp, #4
06038     A7 C8 01 FB | 	rdlong	arg04, fp
0603c     14 C8 05 F1 | 	add	arg04, #20
06040     E4 C8 01 FB | 	rdlong	arg04, arg04
06044     E4 C6 81 F1 | 	sub	arg03, arg04
06048     04 4E 05 F1 | 	add	fp, #4
0604c     A7 C6 61 FC | 	wrlong	arg03, fp
06050     04 4E 85 F1 | 	sub	fp, #4
06054     A7 C6 01 FB | 	rdlong	arg03, fp
06058     18 C6 05 F1 | 	add	arg03, #24
0605c     E3 C6 01 FB | 	rdlong	arg03, arg03
06060     10 4E 05 F1 | 	add	fp, #16
06064     A7 C6 61 FC | 	wrlong	arg03, fp
06068     14 4E 85 F1 | 	sub	fp, #20
0606c     D0 00 90 FD | 	jmp	#LR__0646
06070                 | LR__0642
06070     04 4E 05 F1 | 	add	fp, #4
06074     A7 C6 01 FB | 	rdlong	arg03, fp
06078     08 C6 05 F1 | 	add	arg03, #8
0607c     E3 C6 09 FB | 	rdlong	arg03, arg03 wz
06080     10 4E 05 F1 | 	add	fp, #16
06084     A7 C6 61 FC | 	wrlong	arg03, fp
06088     14 4E 85 F1 | 	sub	fp, #20
0608c     94 00 90 5D |  if_ne	jmp	#LR__0645
06090     04 4E 05 F1 | 	add	fp, #4
06094     A7 C2 01 FB | 	rdlong	arg01, fp
06098     04 4E 85 F1 | 	sub	fp, #4
0609c     00 C4 05 F6 | 	mov	arg02, #0
060a0     2C CD BF FD | 	call	#_fatfs_cc_create_chain
060a4     14 4E 05 F1 | 	add	fp, #20
060a8     A7 A6 61 FC | 	wrlong	result1, fp
060ac     14 4E 85 F1 | 	sub	fp, #20
060b0     01 A6 0D F2 | 	cmp	result1, #1 wz
060b4     1C 00 90 5D |  if_ne	jmp	#LR__0643
060b8     04 4E 05 F1 | 	add	fp, #4
060bc     A7 C6 01 FB | 	rdlong	arg03, fp
060c0     04 4E 85 F1 | 	sub	fp, #4
060c4     11 C6 05 F1 | 	add	arg03, #17
060c8     E3 04 48 FC | 	wrbyte	#2, arg03
060cc     02 A6 05 F6 | 	mov	result1, #2
060d0     5C 04 90 FD | 	jmp	#LR__0663
060d4                 | LR__0643
060d4     14 4E 05 F1 | 	add	fp, #20
060d8     A7 A6 01 FB | 	rdlong	result1, fp
060dc     14 4E 85 F1 | 	sub	fp, #20
060e0     FF FF 7F FF 
060e4     FF A7 0D F2 | 	cmp	result1, ##-1 wz
060e8     1C 00 90 5D |  if_ne	jmp	#LR__0644
060ec     04 4E 05 F1 | 	add	fp, #4
060f0     A7 C6 01 FB | 	rdlong	arg03, fp
060f4     04 4E 85 F1 | 	sub	fp, #4
060f8     11 C6 05 F1 | 	add	arg03, #17
060fc     E3 02 48 FC | 	wrbyte	#1, arg03
06100     01 A6 05 F6 | 	mov	result1, #1
06104     28 04 90 FD | 	jmp	#LR__0663
06108                 | LR__0644
06108     04 4E 05 F1 | 	add	fp, #4
0610c     A7 C6 01 FB | 	rdlong	arg03, fp
06110     10 4E 05 F1 | 	add	fp, #16
06114     A7 C8 01 FB | 	rdlong	arg04, fp
06118     14 4E 85 F1 | 	sub	fp, #20
0611c     08 C6 05 F1 | 	add	arg03, #8
06120     E3 C8 61 FC | 	wrlong	arg04, arg03
06124                 | LR__0645
06124     04 4E 05 F1 | 	add	fp, #4
06128     A7 C6 01 FB | 	rdlong	arg03, fp
0612c     10 4E 05 F1 | 	add	fp, #16
06130     A7 C8 01 FB | 	rdlong	arg04, fp
06134     14 4E 85 F1 | 	sub	fp, #20
06138     18 C6 05 F1 | 	add	arg03, #24
0613c     E3 C8 61 FC | 	wrlong	arg04, arg03
06140                 | LR__0646
06140     14 4E 05 F1 | 	add	fp, #20
06144     A7 C6 09 FB | 	rdlong	arg03, fp wz
06148     14 4E 85 F1 | 	sub	fp, #20
0614c     28 02 90 AD |  if_e	jmp	#LR__0656
06150                 | ' 				while (ofs > bcs) {
06150                 | LR__0647
06150     08 4E 05 F1 | 	add	fp, #8
06154     A7 C8 01 FB | 	rdlong	arg04, fp
06158     10 4E 05 F1 | 	add	fp, #16
0615c     A7 C6 01 FB | 	rdlong	arg03, fp
06160     18 4E 85 F1 | 	sub	fp, #24
06164     E3 C8 19 F2 | 	cmp	arg04, arg03 wcz
06168     68 01 90 ED |  if_be	jmp	#LR__0653
0616c     08 4E 05 F1 | 	add	fp, #8
06170     A7 C8 01 FB | 	rdlong	arg04, fp
06174     10 4E 05 F1 | 	add	fp, #16
06178     A7 C6 01 FB | 	rdlong	arg03, fp
0617c     E3 C8 81 F1 | 	sub	arg04, arg03
06180     10 4E 85 F1 | 	sub	fp, #16
06184     A7 C8 61 FC | 	wrlong	arg04, fp
06188     04 4E 85 F1 | 	sub	fp, #4
0618c     A7 C8 01 FB | 	rdlong	arg04, fp
06190     E4 A6 01 F6 | 	mov	result1, arg04
06194     14 C8 05 F1 | 	add	arg04, #20
06198     E4 C8 01 FB | 	rdlong	arg04, arg04
0619c     14 4E 05 F1 | 	add	fp, #20
061a0     A7 C6 01 FB | 	rdlong	arg03, fp
061a4     E3 C8 01 F1 | 	add	arg04, arg03
061a8     14 A6 05 F1 | 	add	result1, #20
061ac     D3 C8 61 FC | 	wrlong	arg04, result1
061b0     14 4E 85 F1 | 	sub	fp, #20
061b4     A7 C6 01 FB | 	rdlong	arg03, fp
061b8     04 4E 85 F1 | 	sub	fp, #4
061bc     10 C6 05 F1 | 	add	arg03, #16
061c0     E3 C6 C1 FA | 	rdbyte	arg03, arg03
061c4     02 C6 CD F7 | 	test	arg03, #2 wz
061c8     3C 00 90 AD |  if_e	jmp	#LR__0648
061cc     04 4E 05 F1 | 	add	fp, #4
061d0     A7 C2 01 FB | 	rdlong	arg01, fp
061d4     10 4E 05 F1 | 	add	fp, #16
061d8     A7 C4 01 FB | 	rdlong	arg02, fp
061dc     14 4E 85 F1 | 	sub	fp, #20
061e0     EC CB BF FD | 	call	#_fatfs_cc_create_chain
061e4     14 4E 05 F1 | 	add	fp, #20
061e8     A7 A6 61 FC | 	wrlong	result1, fp
061ec     00 A6 4D F2 | 	cmps	result1, #0 wz
061f0     14 4E 85 F1 | 	sub	fp, #20
061f4     08 4E 05 A1 |  if_e	add	fp, #8
061f8     A7 00 68 AC |  if_e	wrlong	#0, fp
061fc     08 4E 85 A1 |  if_e	sub	fp, #8
06200                 | ' 							ofs = 0; break;
06200     D0 00 90 AD |  if_e	jmp	#LR__0653
06204     24 00 90 FD | 	jmp	#LR__0649
06208                 | LR__0648
06208     04 4E 05 F1 | 	add	fp, #4
0620c     A7 C2 01 FB | 	rdlong	arg01, fp
06210     10 4E 05 F1 | 	add	fp, #16
06214     A7 C4 01 FB | 	rdlong	arg02, fp
06218     14 4E 85 F1 | 	sub	fp, #20
0621c     E8 C6 BF FD | 	call	#_fatfs_cc_get_fat
06220     14 4E 05 F1 | 	add	fp, #20
06224     A7 A6 61 FC | 	wrlong	result1, fp
06228     14 4E 85 F1 | 	sub	fp, #20
0622c                 | LR__0649
0622c     14 4E 05 F1 | 	add	fp, #20
06230     A7 C6 01 FB | 	rdlong	arg03, fp
06234     14 4E 85 F1 | 	sub	fp, #20
06238     FF FF 7F FF 
0623c     FF C7 0D F2 | 	cmp	arg03, ##-1 wz
06240     1C 00 90 5D |  if_ne	jmp	#LR__0650
06244     04 4E 05 F1 | 	add	fp, #4
06248     A7 C6 01 FB | 	rdlong	arg03, fp
0624c     04 4E 85 F1 | 	sub	fp, #4
06250     11 C6 05 F1 | 	add	arg03, #17
06254     E3 02 48 FC | 	wrbyte	#1, arg03
06258     01 A6 05 F6 | 	mov	result1, #1
0625c     D0 02 90 FD | 	jmp	#LR__0663
06260                 | LR__0650
06260     14 4E 05 F1 | 	add	fp, #20
06264     A7 C6 01 FB | 	rdlong	arg03, fp
06268     14 4E 85 F1 | 	sub	fp, #20
0626c     02 C6 15 F2 | 	cmp	arg03, #2 wc
06270     24 00 90 CD |  if_b	jmp	#LR__0651
06274     10 4E 05 F1 | 	add	fp, #16
06278     A7 C8 01 FB | 	rdlong	arg04, fp
0627c     04 4E 05 F1 | 	add	fp, #4
06280     A7 C6 01 FB | 	rdlong	arg03, fp
06284     14 4E 85 F1 | 	sub	fp, #20
06288     14 C8 05 F1 | 	add	arg04, #20
0628c     E4 C8 01 FB | 	rdlong	arg04, arg04
06290     E4 C6 11 F2 | 	cmp	arg03, arg04 wc
06294     1C 00 90 CD |  if_b	jmp	#LR__0652
06298                 | LR__0651
06298     04 4E 05 F1 | 	add	fp, #4
0629c     A7 C6 01 FB | 	rdlong	arg03, fp
062a0     04 4E 85 F1 | 	sub	fp, #4
062a4     11 C6 05 F1 | 	add	arg03, #17
062a8     E3 04 48 FC | 	wrbyte	#2, arg03
062ac     02 A6 05 F6 | 	mov	result1, #2
062b0     7C 02 90 FD | 	jmp	#LR__0663
062b4                 | LR__0652
062b4     04 4E 05 F1 | 	add	fp, #4
062b8     A7 C8 01 FB | 	rdlong	arg04, fp
062bc     10 4E 05 F1 | 	add	fp, #16
062c0     A7 C6 01 FB | 	rdlong	arg03, fp
062c4     14 4E 85 F1 | 	sub	fp, #20
062c8     18 C8 05 F1 | 	add	arg04, #24
062cc     E4 C6 61 FC | 	wrlong	arg03, arg04
062d0     7C FE 9F FD | 	jmp	#LR__0647
062d4                 | LR__0653
062d4     04 4E 05 F1 | 	add	fp, #4
062d8     A7 C6 01 FB | 	rdlong	arg03, fp
062dc     E3 C2 01 F6 | 	mov	arg01, arg03
062e0     14 C6 05 F1 | 	add	arg03, #20
062e4     E3 C4 01 FB | 	rdlong	arg02, arg03
062e8     04 4E 05 F1 | 	add	fp, #4
062ec     A7 C6 01 FB | 	rdlong	arg03, fp
062f0     E3 C4 01 F1 | 	add	arg02, arg03
062f4     14 C2 05 F1 | 	add	arg01, #20
062f8     E1 C4 61 FC | 	wrlong	arg02, arg01
062fc     A7 C6 01 FB | 	rdlong	arg03, fp
06300     08 4E 85 F1 | 	sub	fp, #8
06304     FF C7 CD F7 | 	test	arg03, #511 wz
06308     6C 00 90 AD |  if_e	jmp	#LR__0655
0630c     10 4E 05 F1 | 	add	fp, #16
06310     A7 C2 01 FB | 	rdlong	arg01, fp
06314     04 4E 05 F1 | 	add	fp, #4
06318     A7 C4 01 FB | 	rdlong	arg02, fp
0631c     14 4E 85 F1 | 	sub	fp, #20
06320     A4 C5 BF FD | 	call	#_fatfs_cc_clst2sect
06324     1C 4E 05 F1 | 	add	fp, #28
06328     A7 A6 61 FC | 	wrlong	result1, fp
0632c     1C 4E 85 F1 | 	sub	fp, #28
06330     00 A6 0D F2 | 	cmp	result1, #0 wz
06334     1C 00 90 5D |  if_ne	jmp	#LR__0654
06338     04 4E 05 F1 | 	add	fp, #4
0633c     A7 C6 01 FB | 	rdlong	arg03, fp
06340     04 4E 85 F1 | 	sub	fp, #4
06344     11 C6 05 F1 | 	add	arg03, #17
06348     E3 04 48 FC | 	wrbyte	#2, arg03
0634c     02 A6 05 F6 | 	mov	result1, #2
06350     DC 01 90 FD | 	jmp	#LR__0663
06354                 | LR__0654
06354     1C 4E 05 F1 | 	add	fp, #28
06358     A7 C8 01 FB | 	rdlong	arg04, fp
0635c     14 4E 85 F1 | 	sub	fp, #20
06360     A7 C6 01 FB | 	rdlong	arg03, fp
06364     09 C6 45 F0 | 	shr	arg03, #9
06368     E3 C8 01 F1 | 	add	arg04, arg03
0636c     14 4E 05 F1 | 	add	fp, #20
06370     A7 C8 61 FC | 	wrlong	arg04, fp
06374     1C 4E 85 F1 | 	sub	fp, #28
06378                 | LR__0655
06378                 | LR__0656
06378                 | LR__0657
06378     04 4E 05 F1 | 	add	fp, #4
0637c     A7 C8 01 FB | 	rdlong	arg04, fp
06380     E4 C6 01 F6 | 	mov	arg03, arg04
06384     04 4E 85 F1 | 	sub	fp, #4
06388     14 C6 05 F1 | 	add	arg03, #20
0638c     E3 C6 01 FB | 	rdlong	arg03, arg03
06390     0C C8 05 F1 | 	add	arg04, #12
06394     E4 C8 01 FB | 	rdlong	arg04, arg04
06398     E4 C6 19 F2 | 	cmp	arg03, arg04 wcz
0639c     3C 00 90 ED |  if_be	jmp	#LR__0658
063a0     04 4E 05 F1 | 	add	fp, #4
063a4     A7 C8 01 FB | 	rdlong	arg04, fp
063a8     E4 C6 01 F6 | 	mov	arg03, arg04
063ac     14 C8 05 F1 | 	add	arg04, #20
063b0     E4 C8 01 FB | 	rdlong	arg04, arg04
063b4     0C C6 05 F1 | 	add	arg03, #12
063b8     E3 C8 61 FC | 	wrlong	arg04, arg03
063bc     A7 C8 01 FB | 	rdlong	arg04, fp
063c0     E4 C6 01 F6 | 	mov	arg03, arg04
063c4     04 4E 85 F1 | 	sub	fp, #4
063c8     10 C8 05 F1 | 	add	arg04, #16
063cc     E4 C8 C1 FA | 	rdbyte	arg04, arg04
063d0     40 C8 45 F5 | 	or	arg04, #64
063d4     10 C6 05 F1 | 	add	arg03, #16
063d8     E3 C8 41 FC | 	wrbyte	arg04, arg03
063dc                 | LR__0658
063dc     04 4E 05 F1 | 	add	fp, #4
063e0     A7 C6 01 FB | 	rdlong	arg03, fp
063e4     04 4E 85 F1 | 	sub	fp, #4
063e8     14 C6 05 F1 | 	add	arg03, #20
063ec     E3 C6 01 FB | 	rdlong	arg03, arg03
063f0     FF C7 CD F7 | 	test	arg03, #511 wz
063f4     2C 01 90 AD |  if_e	jmp	#LR__0662
063f8     04 4E 05 F1 | 	add	fp, #4
063fc     A7 C8 01 FB | 	rdlong	arg04, fp
06400     18 4E 05 F1 | 	add	fp, #24
06404     A7 C6 01 FB | 	rdlong	arg03, fp
06408     1C 4E 85 F1 | 	sub	fp, #28
0640c     1C C8 05 F1 | 	add	arg04, #28
06410     E4 C8 01 FB | 	rdlong	arg04, arg04
06414     E4 C6 09 F2 | 	cmp	arg03, arg04 wz
06418     08 01 90 AD |  if_e	jmp	#LR__0662
0641c     04 4E 05 F1 | 	add	fp, #4
06420     A7 C6 01 FB | 	rdlong	arg03, fp
06424     04 4E 85 F1 | 	sub	fp, #4
06428     10 C6 05 F1 | 	add	arg03, #16
0642c     E3 C6 C1 FA | 	rdbyte	arg03, arg03
06430     80 C6 CD F7 | 	test	arg03, #128 wz
06434     7C 00 90 AD |  if_e	jmp	#LR__0660
06438     10 4E 05 F1 | 	add	fp, #16
0643c     A7 C6 01 FB | 	rdlong	arg03, fp
06440     01 C6 05 F1 | 	add	arg03, #1
06444     E3 C2 C1 FA | 	rdbyte	arg01, arg03
06448     0C 4E 85 F1 | 	sub	fp, #12
0644c     A7 C6 01 FB | 	rdlong	arg03, fp
06450     E3 C4 01 F6 | 	mov	arg02, arg03
06454     28 C4 05 F1 | 	add	arg02, #40
06458     04 4E 85 F1 | 	sub	fp, #4
0645c     1C C6 05 F1 | 	add	arg03, #28
06460     E3 C6 01 FB | 	rdlong	arg03, arg03
06464     01 C8 05 F6 | 	mov	arg04, #1
06468     94 BE BF FD | 	call	#_fatfs_cc_disk_write
0646c     00 A6 0D F2 | 	cmp	result1, #0 wz
06470     1C 00 90 AD |  if_e	jmp	#LR__0659
06474     04 4E 05 F1 | 	add	fp, #4
06478     A7 C6 01 FB | 	rdlong	arg03, fp
0647c     04 4E 85 F1 | 	sub	fp, #4
06480     11 C6 05 F1 | 	add	arg03, #17
06484     E3 02 48 FC | 	wrbyte	#1, arg03
06488     01 A6 05 F6 | 	mov	result1, #1
0648c     A0 00 90 FD | 	jmp	#LR__0663
06490                 | LR__0659
06490     04 4E 05 F1 | 	add	fp, #4
06494     A7 C8 01 FB | 	rdlong	arg04, fp
06498     E4 C6 01 F6 | 	mov	arg03, arg04
0649c     04 4E 85 F1 | 	sub	fp, #4
064a0     10 C8 05 F1 | 	add	arg04, #16
064a4     E4 C8 C1 FA | 	rdbyte	arg04, arg04
064a8     7F C8 05 F5 | 	and	arg04, #127
064ac     10 C6 05 F1 | 	add	arg03, #16
064b0     E3 C8 41 FC | 	wrbyte	arg04, arg03
064b4                 | LR__0660
064b4     10 4E 05 F1 | 	add	fp, #16
064b8     A7 C6 01 FB | 	rdlong	arg03, fp
064bc     01 C6 05 F1 | 	add	arg03, #1
064c0     E3 C2 C1 FA | 	rdbyte	arg01, arg03
064c4     0C 4E 85 F1 | 	sub	fp, #12
064c8     A7 C4 01 FB | 	rdlong	arg02, fp
064cc     28 C4 05 F1 | 	add	arg02, #40
064d0     18 4E 05 F1 | 	add	fp, #24
064d4     A7 C6 01 FB | 	rdlong	arg03, fp
064d8     1C 4E 85 F1 | 	sub	fp, #28
064dc     01 C8 05 F6 | 	mov	arg04, #1
064e0     5C BD BF FD | 	call	#_fatfs_cc_disk_read
064e4     00 A6 0D F2 | 	cmp	result1, #0 wz
064e8     1C 00 90 AD |  if_e	jmp	#LR__0661
064ec     04 4E 05 F1 | 	add	fp, #4
064f0     A7 C6 01 FB | 	rdlong	arg03, fp
064f4     04 4E 85 F1 | 	sub	fp, #4
064f8     11 C6 05 F1 | 	add	arg03, #17
064fc     E3 02 48 FC | 	wrbyte	#1, arg03
06500     01 A6 05 F6 | 	mov	result1, #1
06504     28 00 90 FD | 	jmp	#LR__0663
06508                 | LR__0661
06508     04 4E 05 F1 | 	add	fp, #4
0650c     A7 C8 01 FB | 	rdlong	arg04, fp
06510     18 4E 05 F1 | 	add	fp, #24
06514     A7 C6 01 FB | 	rdlong	arg03, fp
06518     1C 4E 85 F1 | 	sub	fp, #28
0651c     1C C8 05 F1 | 	add	arg04, #28
06520     E4 C6 61 FC | 	wrlong	arg03, arg04
06524                 | LR__0662
06524                 | ' 
06524                 | ' 			fp->sect = nsect;
06524                 | ' 		}
06524                 | ' 	}
06524                 | ' 
06524                 | ' 	return res ;
06524     0C 4E 05 F1 | 	add	fp, #12
06528     A7 A6 01 FB | 	rdlong	result1, fp
0652c     0C 4E 85 F1 | 	sub	fp, #12
06530                 | LR__0663
06530     A7 F0 03 F6 | 	mov	ptra, fp
06534     B2 00 A0 FD | 	call	#popregs_
06538                 | _fatfs_cc_f_lseek_ret
06538     2D 00 64 FD | 	ret
0653c                 | 
0653c                 | _fatfs_cc_f_opendir
0653c     01 4A 05 F6 | 	mov	COUNT_, #1
06540     A8 00 A0 FD | 	call	#pushregs_
06544     14 F0 07 F1 | 	add	ptra, #20
06548     04 4E 05 F1 | 	add	fp, #4
0654c     A7 C2 61 FC | 	wrlong	arg01, fp
06550     04 4E 05 F1 | 	add	fp, #4
06554     A7 C4 61 FC | 	wrlong	arg02, fp
06558     04 4E 85 F1 | 	sub	fp, #4
0655c     A7 C6 09 FB | 	rdlong	arg03, fp wz
06560     04 4E 85 F1 | 	sub	fp, #4
06564     09 A6 05 A6 |  if_e	mov	result1, #9
06568     78 01 90 AD |  if_e	jmp	#LR__0676
0656c     08 4E 05 F1 | 	add	fp, #8
06570     A7 C2 01 F6 | 	mov	arg01, fp
06574     08 4E 05 F1 | 	add	fp, #8
06578     A7 C4 01 F6 | 	mov	arg02, fp
0657c     10 4E 85 F1 | 	sub	fp, #16
06580     00 C6 05 F6 | 	mov	arg03, #0
06584     48 DA BF FD | 	call	#_fatfs_cc_mount_volume
06588     0C 4E 05 F1 | 	add	fp, #12
0658c     A7 A6 61 FC | 	wrlong	result1, fp
06590     0C 4E 85 F1 | 	sub	fp, #12
06594     00 A6 0D F2 | 	cmp	result1, #0 wz
06598     20 01 90 5D |  if_ne	jmp	#LR__0675
0659c     04 4E 05 F1 | 	add	fp, #4
065a0     A7 C6 01 FB | 	rdlong	arg03, fp
065a4     0C 4E 05 F1 | 	add	fp, #12
065a8     A7 A6 01 FB | 	rdlong	result1, fp
065ac     E3 A6 61 FC | 	wrlong	result1, arg03
065b0     0C 4E 85 F1 | 	sub	fp, #12
065b4     A7 C2 01 FB | 	rdlong	arg01, fp
065b8     04 4E 05 F1 | 	add	fp, #4
065bc     A7 C4 01 FB | 	rdlong	arg02, fp
065c0     08 4E 85 F1 | 	sub	fp, #8
065c4     C0 D4 BF FD | 	call	#_fatfs_cc_follow_path
065c8     0C 4E 05 F1 | 	add	fp, #12
065cc     A7 A6 61 FC | 	wrlong	result1, fp
065d0     0C 4E 85 F1 | 	sub	fp, #12
065d4     00 A6 0D F2 | 	cmp	result1, #0 wz
065d8     C4 00 90 5D |  if_ne	jmp	#LR__0674
065dc     04 4E 05 F1 | 	add	fp, #4
065e0     A7 C6 01 FB | 	rdlong	arg03, fp
065e4     04 4E 85 F1 | 	sub	fp, #4
065e8     2B C6 05 F1 | 	add	arg03, #43
065ec     E3 C6 C1 FA | 	rdbyte	arg03, arg03
065f0     80 C6 CD F7 | 	test	arg03, #128 wz
065f4     58 00 90 5D |  if_ne	jmp	#LR__0672
065f8     04 4E 05 F1 | 	add	fp, #4
065fc     A7 C6 01 FB | 	rdlong	arg03, fp
06600     04 4E 85 F1 | 	sub	fp, #4
06604     06 C6 05 F1 | 	add	arg03, #6
06608     E3 C6 C1 FA | 	rdbyte	arg03, arg03
0660c     10 C6 CD F7 | 	test	arg03, #16 wz
06610     30 00 90 AD |  if_e	jmp	#LR__0670
06614     04 4E 05 F1 | 	add	fp, #4
06618     A7 C6 01 FB | 	rdlong	arg03, fp
0661c     E3 D8 01 F6 | 	mov	local01, arg03
06620     0C 4E 05 F1 | 	add	fp, #12
06624     A7 C2 01 FB | 	rdlong	arg01, fp
06628     10 4E 85 F1 | 	sub	fp, #16
0662c     1C C6 05 F1 | 	add	arg03, #28
06630     E3 C4 01 FB | 	rdlong	arg02, arg03
06634     50 CE BF FD | 	call	#_fatfs_cc_ld_clust
06638     08 D8 05 F1 | 	add	local01, #8
0663c     EC A6 61 FC | 	wrlong	result1, local01
06640     0C 00 90 FD | 	jmp	#LR__0671
06644                 | LR__0670
06644     0C 4E 05 F1 | 	add	fp, #12
06648     A7 0A 68 FC | 	wrlong	#5, fp
0664c     0C 4E 85 F1 | 	sub	fp, #12
06650                 | LR__0671
06650                 | LR__0672
06650     0C 4E 05 F1 | 	add	fp, #12
06654     A7 D8 09 FB | 	rdlong	local01, fp wz
06658     0C 4E 85 F1 | 	sub	fp, #12
0665c     40 00 90 5D |  if_ne	jmp	#LR__0673
06660     04 4E 05 F1 | 	add	fp, #4
06664     A7 D8 01 FB | 	rdlong	local01, fp
06668     0C 4E 05 F1 | 	add	fp, #12
0666c     A7 C6 01 FB | 	rdlong	arg03, fp
06670     06 C6 05 F1 | 	add	arg03, #6
06674     E3 C6 E1 FA | 	rdword	arg03, arg03
06678     04 D8 05 F1 | 	add	local01, #4
0667c     EC C6 51 FC | 	wrword	arg03, local01
06680     0C 4E 85 F1 | 	sub	fp, #12
06684     A7 C2 01 FB | 	rdlong	arg01, fp
06688     04 4E 85 F1 | 	sub	fp, #4
0668c     00 C4 05 F6 | 	mov	arg02, #0
06690     20 CA BF FD | 	call	#_fatfs_cc_dir_sdi
06694     0C 4E 05 F1 | 	add	fp, #12
06698     A7 A6 61 FC | 	wrlong	result1, fp
0669c     0C 4E 85 F1 | 	sub	fp, #12
066a0                 | LR__0673
066a0                 | LR__0674
066a0     0C 4E 05 F1 | 	add	fp, #12
066a4     A7 D8 01 FB | 	rdlong	local01, fp
066a8     0C 4E 85 F1 | 	sub	fp, #12
066ac     04 D8 0D F2 | 	cmp	local01, #4 wz
066b0     0C 4E 05 A1 |  if_e	add	fp, #12
066b4     A7 0A 68 AC |  if_e	wrlong	#5, fp
066b8     0C 4E 85 A1 |  if_e	sub	fp, #12
066bc                 | LR__0675
066bc     0C 4E 05 F1 | 	add	fp, #12
066c0     A7 D8 09 FB | 	rdlong	local01, fp wz
066c4     0C 4E 85 F1 | 	sub	fp, #12
066c8     04 4E 05 51 |  if_ne	add	fp, #4
066cc     A7 D8 01 5B |  if_ne	rdlong	local01, fp
066d0     04 4E 85 51 |  if_ne	sub	fp, #4
066d4     EC 00 68 5C |  if_ne	wrlong	#0, local01
066d8                 | ' 
066d8                 | ' 	return res ;
066d8     0C 4E 05 F1 | 	add	fp, #12
066dc     A7 A6 01 FB | 	rdlong	result1, fp
066e0     0C 4E 85 F1 | 	sub	fp, #12
066e4                 | LR__0676
066e4     A7 F0 03 F6 | 	mov	ptra, fp
066e8     B2 00 A0 FD | 	call	#popregs_
066ec                 | _fatfs_cc_f_opendir_ret
066ec     2D 00 64 FD | 	ret
066f0                 | 
066f0                 | _fatfs_cc_f_closedir
066f0     00 4A 05 F6 | 	mov	COUNT_, #0
066f4     A8 00 A0 FD | 	call	#pushregs_
066f8     10 F0 07 F1 | 	add	ptra, #16
066fc     04 4E 05 F1 | 	add	fp, #4
06700     A7 C2 61 FC | 	wrlong	arg01, fp
06704     08 4E 05 F1 | 	add	fp, #8
06708     A7 C4 01 F6 | 	mov	arg02, fp
0670c     0C 4E 85 F1 | 	sub	fp, #12
06710     D0 DD BF FD | 	call	#_fatfs_cc_validate
06714     08 4E 05 F1 | 	add	fp, #8
06718     A7 A6 61 FC | 	wrlong	result1, fp
0671c     08 4E 85 F1 | 	sub	fp, #8
06720     00 A6 0D F2 | 	cmp	result1, #0 wz
06724     04 4E 05 A1 |  if_e	add	fp, #4
06728     A7 A6 01 AB |  if_e	rdlong	result1, fp
0672c     04 4E 85 A1 |  if_e	sub	fp, #4
06730     D3 00 68 AC |  if_e	wrlong	#0, result1
06734                 | ' 
06734                 | ' 
06734                 | ' 
06734                 | ' 
06734                 | ' 		dp->obj.fs = 0;
06734                 | ' #line 4633 "ff.c"
06734                 | ' 	}
06734                 | ' 	return res;
06734     08 4E 05 F1 | 	add	fp, #8
06738     A7 A6 01 FB | 	rdlong	result1, fp
0673c     08 4E 85 F1 | 	sub	fp, #8
06740     A7 F0 03 F6 | 	mov	ptra, fp
06744     B2 00 A0 FD | 	call	#popregs_
06748                 | _fatfs_cc_f_closedir_ret
06748     2D 00 64 FD | 	ret
0674c                 | 
0674c                 | _fatfs_cc_f_readdir
0674c     00 4A 05 F6 | 	mov	COUNT_, #0
06750     A8 00 A0 FD | 	call	#pushregs_
06754     14 F0 07 F1 | 	add	ptra, #20
06758     04 4E 05 F1 | 	add	fp, #4
0675c     A7 C2 61 FC | 	wrlong	arg01, fp
06760     04 4E 05 F1 | 	add	fp, #4
06764     A7 C4 61 FC | 	wrlong	arg02, fp
06768     04 4E 85 F1 | 	sub	fp, #4
0676c     A7 C2 01 FB | 	rdlong	arg01, fp
06770     0C 4E 05 F1 | 	add	fp, #12
06774     A7 C4 01 F6 | 	mov	arg02, fp
06778     10 4E 85 F1 | 	sub	fp, #16
0677c     64 DD BF FD | 	call	#_fatfs_cc_validate
06780     0C 4E 05 F1 | 	add	fp, #12
06784     A7 A6 61 FC | 	wrlong	result1, fp
06788     0C 4E 85 F1 | 	sub	fp, #12
0678c     00 A6 0D F2 | 	cmp	result1, #0 wz
06790     BC 00 90 5D |  if_ne	jmp	#LR__0683
06794     08 4E 05 F1 | 	add	fp, #8
06798     A7 A6 09 FB | 	rdlong	result1, fp wz
0679c     08 4E 85 F1 | 	sub	fp, #8
067a0     24 00 90 5D |  if_ne	jmp	#LR__0680
067a4     04 4E 05 F1 | 	add	fp, #4
067a8     A7 C2 01 FB | 	rdlong	arg01, fp
067ac     04 4E 85 F1 | 	sub	fp, #4
067b0     00 C4 05 F6 | 	mov	arg02, #0
067b4     FC C8 BF FD | 	call	#_fatfs_cc_dir_sdi
067b8     0C 4E 05 F1 | 	add	fp, #12
067bc     A7 A6 61 FC | 	wrlong	result1, fp
067c0     0C 4E 85 F1 | 	sub	fp, #12
067c4     88 00 90 FD | 	jmp	#LR__0682
067c8                 | LR__0680
067c8     04 4E 05 F1 | 	add	fp, #4
067cc     A7 C2 01 FB | 	rdlong	arg01, fp
067d0     04 4E 85 F1 | 	sub	fp, #4
067d4     00 C4 05 F6 | 	mov	arg02, #0
067d8     08 CD BF FD | 	call	#_fatfs_cc_dir_read
067dc     0C 4E 05 F1 | 	add	fp, #12
067e0     A7 A6 61 FC | 	wrlong	result1, fp
067e4     0C 4E 85 F1 | 	sub	fp, #12
067e8     04 A6 0D F2 | 	cmp	result1, #4 wz
067ec     0C 4E 05 A1 |  if_e	add	fp, #12
067f0     A7 00 68 AC |  if_e	wrlong	#0, fp
067f4     0C 4E 85 A1 |  if_e	sub	fp, #12
067f8     0C 4E 05 F1 | 	add	fp, #12
067fc     A7 A6 09 FB | 	rdlong	result1, fp wz
06800     0C 4E 85 F1 | 	sub	fp, #12
06804     48 00 90 5D |  if_ne	jmp	#LR__0681
06808     04 4E 05 F1 | 	add	fp, #4
0680c     A7 C2 01 FB | 	rdlong	arg01, fp
06810     04 4E 05 F1 | 	add	fp, #4
06814     A7 C4 01 FB | 	rdlong	arg02, fp
06818     08 4E 85 F1 | 	sub	fp, #8
0681c     58 CF BF FD | 	call	#_fatfs_cc_get_fileinfo
06820     04 4E 05 F1 | 	add	fp, #4
06824     A7 C2 01 FB | 	rdlong	arg01, fp
06828     04 4E 85 F1 | 	sub	fp, #4
0682c     00 C4 05 F6 | 	mov	arg02, #0
06830     E8 C9 BF FD | 	call	#_fatfs_cc_dir_next
06834     0C 4E 05 F1 | 	add	fp, #12
06838     A7 A6 61 FC | 	wrlong	result1, fp
0683c     0C 4E 85 F1 | 	sub	fp, #12
06840     04 A6 0D F2 | 	cmp	result1, #4 wz
06844     0C 4E 05 A1 |  if_e	add	fp, #12
06848     A7 00 68 AC |  if_e	wrlong	#0, fp
0684c     0C 4E 85 A1 |  if_e	sub	fp, #12
06850                 | LR__0681
06850                 | LR__0682
06850                 | LR__0683
06850                 | ' 			}
06850                 | ' 			;
06850                 | ' 		}
06850                 | ' 	}
06850                 | ' 	return res ;
06850     0C 4E 05 F1 | 	add	fp, #12
06854     A7 A6 01 FB | 	rdlong	result1, fp
06858     0C 4E 85 F1 | 	sub	fp, #12
0685c     A7 F0 03 F6 | 	mov	ptra, fp
06860     B2 00 A0 FD | 	call	#popregs_
06864                 | _fatfs_cc_f_readdir_ret
06864     2D 00 64 FD | 	ret
06868                 | 
06868                 | _fatfs_cc_f_stat
06868     00 4A 05 F6 | 	mov	COUNT_, #0
0686c     A8 00 A0 FD | 	call	#pushregs_
06870     3C F0 07 F1 | 	add	ptra, #60
06874     04 4E 05 F1 | 	add	fp, #4
06878     A7 C2 61 FC | 	wrlong	arg01, fp
0687c     04 4E 05 F1 | 	add	fp, #4
06880     A7 C4 61 FC | 	wrlong	arg02, fp
06884     04 4E 85 F1 | 	sub	fp, #4
06888     A7 C2 01 F6 | 	mov	arg01, fp
0688c     0C 4E 05 F1 | 	add	fp, #12
06890     A7 C4 01 F6 | 	mov	arg02, fp
06894     10 4E 85 F1 | 	sub	fp, #16
06898     00 C6 05 F6 | 	mov	arg03, #0
0689c     30 D7 BF FD | 	call	#_fatfs_cc_mount_volume
068a0     0C 4E 05 F1 | 	add	fp, #12
068a4     A7 A6 61 FC | 	wrlong	result1, fp
068a8     0C 4E 85 F1 | 	sub	fp, #12
068ac     00 A6 0D F2 | 	cmp	result1, #0 wz
068b0     74 00 90 5D |  if_ne	jmp	#LR__0693
068b4     10 4E 05 F1 | 	add	fp, #16
068b8     A7 C2 01 F6 | 	mov	arg01, fp
068bc     0C 4E 85 F1 | 	sub	fp, #12
068c0     A7 C4 01 FB | 	rdlong	arg02, fp
068c4     04 4E 85 F1 | 	sub	fp, #4
068c8     BC D1 BF FD | 	call	#_fatfs_cc_follow_path
068cc     0C 4E 05 F1 | 	add	fp, #12
068d0     A7 A6 61 FC | 	wrlong	result1, fp
068d4     0C 4E 85 F1 | 	sub	fp, #12
068d8     00 A6 0D F2 | 	cmp	result1, #0 wz
068dc     48 00 90 5D |  if_ne	jmp	#LR__0692
068e0     3B 4E 05 F1 | 	add	fp, #59
068e4     A7 A6 C1 FA | 	rdbyte	result1, fp
068e8     3B 4E 85 F1 | 	sub	fp, #59
068ec     80 A6 CD F7 | 	test	result1, #128 wz
068f0     0C 4E 05 51 |  if_ne	add	fp, #12
068f4     A7 0C 68 5C |  if_ne	wrlong	#6, fp
068f8     0C 4E 85 51 |  if_ne	sub	fp, #12
068fc     28 00 90 5D |  if_ne	jmp	#LR__0691
06900     08 4E 05 F1 | 	add	fp, #8
06904     A7 A6 09 FB | 	rdlong	result1, fp wz
06908     08 4E 85 F1 | 	sub	fp, #8
0690c     18 00 90 AD |  if_e	jmp	#LR__0690
06910     10 4E 05 F1 | 	add	fp, #16
06914     A7 C2 01 F6 | 	mov	arg01, fp
06918     08 4E 85 F1 | 	sub	fp, #8
0691c     A7 C4 01 FB | 	rdlong	arg02, fp
06920     08 4E 85 F1 | 	sub	fp, #8
06924     50 CE BF FD | 	call	#_fatfs_cc_get_fileinfo
06928                 | LR__0690
06928                 | LR__0691
06928                 | LR__0692
06928                 | LR__0693
06928                 | ' 			}
06928                 | ' 		}
06928                 | ' 		;
06928                 | ' 	}
06928                 | ' 
06928                 | ' 	return res ;
06928     0C 4E 05 F1 | 	add	fp, #12
0692c     A7 A6 01 FB | 	rdlong	result1, fp
06930     0C 4E 85 F1 | 	sub	fp, #12
06934     A7 F0 03 F6 | 	mov	ptra, fp
06938     B2 00 A0 FD | 	call	#popregs_
0693c                 | _fatfs_cc_f_stat_ret
0693c     2D 00 64 FD | 	ret
06940                 | 
06940                 | _fatfs_cc_f_unlink
06940     00 4A 05 F6 | 	mov	COUNT_, #0
06944     A8 00 A0 FD | 	call	#pushregs_
06948     6C F0 07 F1 | 	add	ptra, #108
0694c     04 4E 05 F1 | 	add	fp, #4
06950     A7 C2 61 FC | 	wrlong	arg01, fp
06954     60 4E 05 F1 | 	add	fp, #96
06958     A7 00 68 FC | 	wrlong	#0, fp
0695c     60 4E 85 F1 | 	sub	fp, #96
06960     A7 C2 01 F6 | 	mov	arg01, fp
06964     64 4E 05 F1 | 	add	fp, #100
06968     A7 C4 01 F6 | 	mov	arg02, fp
0696c     68 4E 85 F1 | 	sub	fp, #104
06970     02 C6 05 F6 | 	mov	arg03, #2
06974     58 D6 BF FD | 	call	#_fatfs_cc_mount_volume
06978     08 4E 05 F1 | 	add	fp, #8
0697c     A7 A6 61 FC | 	wrlong	result1, fp
06980     08 4E 85 F1 | 	sub	fp, #8
06984     00 A6 0D F2 | 	cmp	result1, #0 wz
06988     DC 01 90 5D |  if_ne	jmp	#LR__0708
0698c     68 4E 05 F1 | 	add	fp, #104
06990     A7 C6 01 FB | 	rdlong	arg03, fp
06994     5C 4E 85 F1 | 	sub	fp, #92
06998     A7 C6 61 FC | 	wrlong	arg03, fp
0699c     A7 C2 01 F6 | 	mov	arg01, fp
069a0     08 4E 85 F1 | 	sub	fp, #8
069a4     A7 C4 01 FB | 	rdlong	arg02, fp
069a8     04 4E 85 F1 | 	sub	fp, #4
069ac     D8 D0 BF FD | 	call	#_fatfs_cc_follow_path
069b0     08 4E 05 F1 | 	add	fp, #8
069b4     A7 A6 61 FC | 	wrlong	result1, fp
069b8     00 A6 4D F2 | 	cmps	result1, #0 wz
069bc     08 4E 85 F1 | 	sub	fp, #8
069c0     A4 01 90 5D |  if_ne	jmp	#LR__0707
069c4     37 4E 05 F1 | 	add	fp, #55
069c8     A7 A6 C1 FA | 	rdbyte	result1, fp
069cc     37 4E 85 F1 | 	sub	fp, #55
069d0     80 A6 CD F7 | 	test	result1, #128 wz
069d4     08 4E 05 51 |  if_ne	add	fp, #8
069d8     A7 0C 68 5C |  if_ne	wrlong	#6, fp
069dc     08 4E 85 51 |  if_ne	sub	fp, #8
069e0     1C 00 90 5D |  if_ne	jmp	#LR__0700
069e4     12 4E 05 F1 | 	add	fp, #18
069e8     A7 A6 C1 FA | 	rdbyte	result1, fp
069ec     12 4E 85 F1 | 	sub	fp, #18
069f0     01 A6 CD F7 | 	test	result1, #1 wz
069f4     08 4E 05 51 |  if_ne	add	fp, #8
069f8     A7 0E 68 5C |  if_ne	wrlong	#7, fp
069fc     08 4E 85 51 |  if_ne	sub	fp, #8
06a00                 | LR__0700
06a00     08 4E 05 F1 | 	add	fp, #8
06a04     A7 A6 09 FB | 	rdlong	result1, fp wz
06a08     08 4E 85 F1 | 	sub	fp, #8
06a0c     C4 00 90 5D |  if_ne	jmp	#LR__0703
06a10     68 4E 05 F1 | 	add	fp, #104
06a14     A7 C2 01 FB | 	rdlong	arg01, fp
06a18     40 4E 85 F1 | 	sub	fp, #64
06a1c     A7 C4 01 FB | 	rdlong	arg02, fp
06a20     28 4E 85 F1 | 	sub	fp, #40
06a24     60 CA BF FD | 	call	#_fatfs_cc_ld_clust
06a28     64 4E 05 F1 | 	add	fp, #100
06a2c     A7 A6 61 FC | 	wrlong	result1, fp
06a30     52 4E 85 F1 | 	sub	fp, #82
06a34     A7 A6 C1 FA | 	rdbyte	result1, fp
06a38     12 4E 85 F1 | 	sub	fp, #18
06a3c     10 A6 CD F7 | 	test	result1, #16 wz
06a40     90 00 90 AD |  if_e	jmp	#LR__0702
06a44     68 4E 05 F1 | 	add	fp, #104
06a48     A7 A6 01 FB | 	rdlong	result1, fp
06a4c     30 4E 85 F1 | 	sub	fp, #48
06a50     A7 A6 61 FC | 	wrlong	result1, fp
06a54     2C 4E 05 F1 | 	add	fp, #44
06a58     A7 C6 01 FB | 	rdlong	arg03, fp
06a5c     24 4E 85 F1 | 	sub	fp, #36
06a60     A7 C6 61 FC | 	wrlong	arg03, fp
06a64     08 4E 85 F1 | 	sub	fp, #8
06a68     A7 C2 01 F6 | 	mov	arg01, fp
06a6c     38 4E 85 F1 | 	sub	fp, #56
06a70     00 C4 05 F6 | 	mov	arg02, #0
06a74     3C C6 BF FD | 	call	#_fatfs_cc_dir_sdi
06a78     08 4E 05 F1 | 	add	fp, #8
06a7c     A7 A6 61 FC | 	wrlong	result1, fp
06a80     08 4E 85 F1 | 	sub	fp, #8
06a84     00 A6 0D F2 | 	cmp	result1, #0 wz
06a88     48 00 90 5D |  if_ne	jmp	#LR__0701
06a8c     A7 C2 01 F6 | 	mov	arg01, fp
06a90     38 C2 05 F1 | 	add	arg01, #56
06a94     00 C4 05 F6 | 	mov	arg02, #0
06a98     48 CA BF FD | 	call	#_fatfs_cc_dir_read
06a9c     08 4E 05 F1 | 	add	fp, #8
06aa0     A7 A6 61 FC | 	wrlong	result1, fp
06aa4     00 A6 4D F2 | 	cmps	result1, #0 wz
06aa8     08 4E 85 F1 | 	sub	fp, #8
06aac     08 4E 05 A1 |  if_e	add	fp, #8
06ab0     A7 0E 68 AC |  if_e	wrlong	#7, fp
06ab4     08 4E 85 A1 |  if_e	sub	fp, #8
06ab8     08 4E 05 F1 | 	add	fp, #8
06abc     A7 A6 01 FB | 	rdlong	result1, fp
06ac0     08 4E 85 F1 | 	sub	fp, #8
06ac4     04 A6 0D F2 | 	cmp	result1, #4 wz
06ac8     08 4E 05 A1 |  if_e	add	fp, #8
06acc     A7 00 68 AC |  if_e	wrlong	#0, fp
06ad0     08 4E 85 A1 |  if_e	sub	fp, #8
06ad4                 | LR__0701
06ad4                 | LR__0702
06ad4                 | LR__0703
06ad4     08 4E 05 F1 | 	add	fp, #8
06ad8     A7 A6 09 FB | 	rdlong	result1, fp wz
06adc     08 4E 85 F1 | 	sub	fp, #8
06ae0     84 00 90 5D |  if_ne	jmp	#LR__0706
06ae4     A7 C2 01 F6 | 	mov	arg01, fp
06ae8     0C C2 05 F1 | 	add	arg01, #12
06aec     40 CC BF FD | 	call	#_fatfs_cc_dir_remove
06af0     08 4E 05 F1 | 	add	fp, #8
06af4     A7 A6 61 FC | 	wrlong	result1, fp
06af8     08 4E 85 F1 | 	sub	fp, #8
06afc     00 A6 0D F2 | 	cmp	result1, #0 wz
06b00     38 00 90 5D |  if_ne	jmp	#LR__0704
06b04     64 4E 05 F1 | 	add	fp, #100
06b08     A7 A6 09 FB | 	rdlong	result1, fp wz
06b0c     64 4E 85 F1 | 	sub	fp, #100
06b10     28 00 90 AD |  if_e	jmp	#LR__0704
06b14     0C 4E 05 F1 | 	add	fp, #12
06b18     A7 C2 01 F6 | 	mov	arg01, fp
06b1c     58 4E 05 F1 | 	add	fp, #88
06b20     A7 C4 01 FB | 	rdlong	arg02, fp
06b24     64 4E 85 F1 | 	sub	fp, #100
06b28     00 C6 05 F6 | 	mov	arg03, #0
06b2c     8C C1 BF FD | 	call	#_fatfs_cc_remove_chain
06b30     08 4E 05 F1 | 	add	fp, #8
06b34     A7 A6 61 FC | 	wrlong	result1, fp
06b38     08 4E 85 F1 | 	sub	fp, #8
06b3c                 | LR__0704
06b3c     08 4E 05 F1 | 	add	fp, #8
06b40     A7 A6 09 FB | 	rdlong	result1, fp wz
06b44     08 4E 85 F1 | 	sub	fp, #8
06b48     1C 00 90 5D |  if_ne	jmp	#LR__0705
06b4c     68 4E 05 F1 | 	add	fp, #104
06b50     A7 C2 01 FB | 	rdlong	arg01, fp
06b54     68 4E 85 F1 | 	sub	fp, #104
06b58     6C BC BF FD | 	call	#_fatfs_cc_sync_fs
06b5c     08 4E 05 F1 | 	add	fp, #8
06b60     A7 A6 61 FC | 	wrlong	result1, fp
06b64     08 4E 85 F1 | 	sub	fp, #8
06b68                 | LR__0705
06b68                 | LR__0706
06b68                 | LR__0707
06b68                 | LR__0708
06b68                 | ' 			}
06b68                 | ' 		}
06b68                 | ' 		;
06b68                 | ' 	}
06b68                 | ' 
06b68                 | ' 	return res ;
06b68     08 4E 05 F1 | 	add	fp, #8
06b6c     A7 A6 01 FB | 	rdlong	result1, fp
06b70     08 4E 85 F1 | 	sub	fp, #8
06b74     A7 F0 03 F6 | 	mov	ptra, fp
06b78     B2 00 A0 FD | 	call	#popregs_
06b7c                 | _fatfs_cc_f_unlink_ret
06b7c     2D 00 64 FD | 	ret
06b80                 | 
06b80                 | _fatfs_cc_f_mkdir
06b80     00 4A 05 F6 | 	mov	COUNT_, #0
06b84     A8 00 A0 FD | 	call	#pushregs_
06b88     58 F0 07 F1 | 	add	ptra, #88
06b8c     04 4E 05 F1 | 	add	fp, #4
06b90     A7 C2 61 FC | 	wrlong	arg01, fp
06b94     A7 C2 01 F6 | 	mov	arg01, fp
06b98     44 4E 05 F1 | 	add	fp, #68
06b9c     A7 C4 01 F6 | 	mov	arg02, fp
06ba0     48 4E 85 F1 | 	sub	fp, #72
06ba4     02 C6 05 F6 | 	mov	arg03, #2
06ba8     24 D4 BF FD | 	call	#_fatfs_cc_mount_volume
06bac     08 4E 05 F1 | 	add	fp, #8
06bb0     A7 A6 61 FC | 	wrlong	result1, fp
06bb4     08 4E 85 F1 | 	sub	fp, #8
06bb8     00 A6 0D F2 | 	cmp	result1, #0 wz
06bbc     C4 02 90 5D |  if_ne	jmp	#LR__0715
06bc0     48 4E 05 F1 | 	add	fp, #72
06bc4     A7 C6 01 FB | 	rdlong	arg03, fp
06bc8     3C 4E 85 F1 | 	sub	fp, #60
06bcc     A7 C6 61 FC | 	wrlong	arg03, fp
06bd0     A7 C2 01 F6 | 	mov	arg01, fp
06bd4     08 4E 85 F1 | 	sub	fp, #8
06bd8     A7 C4 01 FB | 	rdlong	arg02, fp
06bdc     04 4E 85 F1 | 	sub	fp, #4
06be0     A4 CE BF FD | 	call	#_fatfs_cc_follow_path
06be4     08 4E 05 F1 | 	add	fp, #8
06be8     A7 A6 61 FC | 	wrlong	result1, fp
06bec     00 A6 4D F2 | 	cmps	result1, #0 wz
06bf0     08 4E 85 F1 | 	sub	fp, #8
06bf4     08 4E 05 A1 |  if_e	add	fp, #8
06bf8     A7 10 68 AC |  if_e	wrlong	#8, fp
06bfc     08 4E 85 A1 |  if_e	sub	fp, #8
06c00     08 4E 05 F1 | 	add	fp, #8
06c04     A7 A6 01 FB | 	rdlong	result1, fp
06c08     08 4E 85 F1 | 	sub	fp, #8
06c0c     04 A6 0D F2 | 	cmp	result1, #4 wz
06c10     70 02 90 5D |  if_ne	jmp	#LR__0714
06c14     48 4E 05 F1 | 	add	fp, #72
06c18     A7 C6 01 FB | 	rdlong	arg03, fp
06c1c     10 4E 85 F1 | 	sub	fp, #16
06c20     A7 C6 61 FC | 	wrlong	arg03, fp
06c24     A7 C2 01 F6 | 	mov	arg01, fp
06c28     38 4E 85 F1 | 	sub	fp, #56
06c2c     00 C4 05 F6 | 	mov	arg02, #0
06c30     9C C1 BF FD | 	call	#_fatfs_cc_create_chain
06c34     4C 4E 05 F1 | 	add	fp, #76
06c38     A7 A6 61 FC | 	wrlong	result1, fp
06c3c     44 4E 85 F1 | 	sub	fp, #68
06c40     A7 00 68 FC | 	wrlong	#0, fp
06c44     44 4E 05 F1 | 	add	fp, #68
06c48     A7 A6 09 FB | 	rdlong	result1, fp wz
06c4c     4C 4E 85 F1 | 	sub	fp, #76
06c50     08 4E 05 A1 |  if_e	add	fp, #8
06c54     A7 0E 68 AC |  if_e	wrlong	#7, fp
06c58     08 4E 85 A1 |  if_e	sub	fp, #8
06c5c     4C 4E 05 F1 | 	add	fp, #76
06c60     A7 A6 01 FB | 	rdlong	result1, fp
06c64     4C 4E 85 F1 | 	sub	fp, #76
06c68     01 A6 0D F2 | 	cmp	result1, #1 wz
06c6c     08 4E 05 A1 |  if_e	add	fp, #8
06c70     A7 04 68 AC |  if_e	wrlong	#2, fp
06c74     08 4E 85 A1 |  if_e	sub	fp, #8
06c78     4C 4E 05 F1 | 	add	fp, #76
06c7c     A7 C6 01 FB | 	rdlong	arg03, fp
06c80     4C 4E 85 F1 | 	sub	fp, #76
06c84     FF FF 7F FF 
06c88     FF C7 0D F2 | 	cmp	arg03, ##-1 wz
06c8c     08 4E 05 A1 |  if_e	add	fp, #8
06c90     A7 02 68 AC |  if_e	wrlong	#1, fp
06c94     08 4E 85 A1 |  if_e	sub	fp, #8
06c98     14 0A B0 FD | 	call	#_fatfs_cc__get_fattime
06c9c     54 4E 05 F1 | 	add	fp, #84
06ca0     A7 A6 61 FC | 	wrlong	result1, fp
06ca4     4C 4E 85 F1 | 	sub	fp, #76
06ca8     A7 A6 09 FB | 	rdlong	result1, fp wz
06cac     08 4E 85 F1 | 	sub	fp, #8
06cb0     1C 01 90 5D |  if_ne	jmp	#LR__0711
06cb4     48 4E 05 F1 | 	add	fp, #72
06cb8     A7 C2 01 FB | 	rdlong	arg01, fp
06cbc     04 4E 05 F1 | 	add	fp, #4
06cc0     A7 C4 01 FB | 	rdlong	arg02, fp
06cc4     4C 4E 85 F1 | 	sub	fp, #76
06cc8     28 C3 BF FD | 	call	#_fatfs_cc_dir_clear
06ccc     08 4E 05 F1 | 	add	fp, #8
06cd0     A7 A6 61 FC | 	wrlong	result1, fp
06cd4     00 A6 4D F2 | 	cmps	result1, #0 wz
06cd8     08 4E 85 F1 | 	sub	fp, #8
06cdc     F0 00 90 5D |  if_ne	jmp	#LR__0710
06ce0     48 4E 05 F1 | 	add	fp, #72
06ce4     A7 C2 01 FB | 	rdlong	arg01, fp
06ce8     48 4E 85 F1 | 	sub	fp, #72
06cec     30 C2 05 F1 | 	add	arg01, #48
06cf0     20 C4 05 F6 | 	mov	arg02, #32
06cf4     0B C6 05 F6 | 	mov	arg03, #11
06cf8     98 00 A0 FD | 	call	#\builtin_bytefill_
06cfc     48 4E 05 F1 | 	add	fp, #72
06d00     A7 A6 01 FB | 	rdlong	result1, fp
06d04     30 A6 05 F1 | 	add	result1, #48
06d08     D3 5C 48 FC | 	wrbyte	#46, result1
06d0c     A7 C6 01 FB | 	rdlong	arg03, fp
06d10     3B C6 05 F1 | 	add	arg03, #59
06d14     E3 20 48 FC | 	wrbyte	#16, arg03
06d18     A7 C2 01 FB | 	rdlong	arg01, fp
06d1c     46 C2 05 F1 | 	add	arg01, #70
06d20     0C 4E 05 F1 | 	add	fp, #12
06d24     A7 C4 01 FB | 	rdlong	arg02, fp
06d28     E1 C4 61 FC | 	wrlong	arg02, arg01
06d2c     0C 4E 85 F1 | 	sub	fp, #12
06d30     A7 C4 01 FB | 	rdlong	arg02, fp
06d34     E2 C2 01 F6 | 	mov	arg01, arg02
06d38     30 C4 05 F1 | 	add	arg02, #48
06d3c     04 4E 05 F1 | 	add	fp, #4
06d40     A7 C6 01 FB | 	rdlong	arg03, fp
06d44     4C 4E 85 F1 | 	sub	fp, #76
06d48     70 C7 BF FD | 	call	#_fatfs_cc_st_clust
06d4c     48 4E 05 F1 | 	add	fp, #72
06d50     A7 C4 01 FB | 	rdlong	arg02, fp
06d54     E2 C2 01 F6 | 	mov	arg01, arg02
06d58     50 C2 05 F1 | 	add	arg01, #80
06d5c     48 4E 85 F1 | 	sub	fp, #72
06d60     30 C4 05 F1 | 	add	arg02, #48
06d64     20 C6 05 F6 | 	mov	arg03, #32
06d68     EC 75 B0 FD | 	call	#__system____builtin_memmove
06d6c     48 4E 05 F1 | 	add	fp, #72
06d70     A7 C6 01 FB | 	rdlong	arg03, fp
06d74     51 C6 05 F1 | 	add	arg03, #81
06d78     E3 5C 48 FC | 	wrbyte	#46, arg03
06d7c     34 4E 85 F1 | 	sub	fp, #52
06d80     A7 C6 01 FB | 	rdlong	arg03, fp
06d84     3C 4E 05 F1 | 	add	fp, #60
06d88     A7 C6 61 FC | 	wrlong	arg03, fp
06d8c     08 4E 85 F1 | 	sub	fp, #8
06d90     A7 C4 01 FB | 	rdlong	arg02, fp
06d94     E2 C2 01 F6 | 	mov	arg01, arg02
06d98     50 C4 05 F1 | 	add	arg02, #80
06d9c     48 4E 85 F1 | 	sub	fp, #72
06da0     18 C7 BF FD | 	call	#_fatfs_cc_st_clust
06da4     48 4E 05 F1 | 	add	fp, #72
06da8     A7 C6 01 FB | 	rdlong	arg03, fp
06dac     48 4E 85 F1 | 	sub	fp, #72
06db0     03 C6 05 F1 | 	add	arg03, #3
06db4     E3 02 48 FC | 	wrbyte	#1, arg03
06db8     A7 C2 01 F6 | 	mov	arg01, fp
06dbc     0C C2 05 F1 | 	add	arg01, #12
06dc0     EC C8 BF FD | 	call	#_fatfs_cc_dir_register
06dc4     08 4E 05 F1 | 	add	fp, #8
06dc8     A7 A6 61 FC | 	wrlong	result1, fp
06dcc     08 4E 85 F1 | 	sub	fp, #8
06dd0                 | LR__0710
06dd0                 | LR__0711
06dd0     08 4E 05 F1 | 	add	fp, #8
06dd4     A7 A6 09 FB | 	rdlong	result1, fp wz
06dd8     08 4E 85 F1 | 	sub	fp, #8
06ddc     88 00 90 5D |  if_ne	jmp	#LR__0712
06de0     28 4E 05 F1 | 	add	fp, #40
06de4     A7 C2 01 FB | 	rdlong	arg01, fp
06de8     16 C2 05 F1 | 	add	arg01, #22
06dec     2C 4E 05 F1 | 	add	fp, #44
06df0     A7 C4 01 FB | 	rdlong	arg02, fp
06df4     E1 C4 61 FC | 	wrlong	arg02, arg01
06df8     0C 4E 85 F1 | 	sub	fp, #12
06dfc     A7 C2 01 FB | 	rdlong	arg01, fp
06e00     20 4E 85 F1 | 	sub	fp, #32
06e04     A7 C4 01 FB | 	rdlong	arg02, fp
06e08     24 4E 05 F1 | 	add	fp, #36
06e0c     A7 C6 01 FB | 	rdlong	arg03, fp
06e10     4C 4E 85 F1 | 	sub	fp, #76
06e14     A4 C6 BF FD | 	call	#_fatfs_cc_st_clust
06e18     28 4E 05 F1 | 	add	fp, #40
06e1c     A7 A6 01 FB | 	rdlong	result1, fp
06e20     0B A6 05 F1 | 	add	result1, #11
06e24     D3 20 48 FC | 	wrbyte	#16, result1
06e28     20 4E 05 F1 | 	add	fp, #32
06e2c     A7 A6 01 FB | 	rdlong	result1, fp
06e30     03 A6 05 F1 | 	add	result1, #3
06e34     D3 02 48 FC | 	wrbyte	#1, result1
06e38     40 4E 85 F1 | 	sub	fp, #64
06e3c     A7 A6 09 FB | 	rdlong	result1, fp wz
06e40     08 4E 85 F1 | 	sub	fp, #8
06e44     3C 00 90 5D |  if_ne	jmp	#LR__0713
06e48     48 4E 05 F1 | 	add	fp, #72
06e4c     A7 C2 01 FB | 	rdlong	arg01, fp
06e50     48 4E 85 F1 | 	sub	fp, #72
06e54     70 B9 BF FD | 	call	#_fatfs_cc_sync_fs
06e58     08 4E 05 F1 | 	add	fp, #8
06e5c     A7 A6 61 FC | 	wrlong	result1, fp
06e60     08 4E 85 F1 | 	sub	fp, #8
06e64     1C 00 90 FD | 	jmp	#LR__0713
06e68                 | LR__0712
06e68     38 4E 05 F1 | 	add	fp, #56
06e6c     A7 C2 01 F6 | 	mov	arg01, fp
06e70     14 4E 05 F1 | 	add	fp, #20
06e74     A7 C4 01 FB | 	rdlong	arg02, fp
06e78     4C 4E 85 F1 | 	sub	fp, #76
06e7c     00 C6 05 F6 | 	mov	arg03, #0
06e80     38 BE BF FD | 	call	#_fatfs_cc_remove_chain
06e84                 | LR__0713
06e84                 | LR__0714
06e84                 | LR__0715
06e84                 | ' 				remove_chain(&sobj, dcl, 0);
06e84                 | ' 			}
06e84                 | ' 		}
06e84                 | ' 		;
06e84                 | ' 	}
06e84                 | ' 
06e84                 | ' 	return res ;
06e84     08 4E 05 F1 | 	add	fp, #8
06e88     A7 A6 01 FB | 	rdlong	result1, fp
06e8c     08 4E 85 F1 | 	sub	fp, #8
06e90     A7 F0 03 F6 | 	mov	ptra, fp
06e94     B2 00 A0 FD | 	call	#popregs_
06e98                 | _fatfs_cc_f_mkdir_ret
06e98     2D 00 64 FD | 	ret
06e9c                 | 
06e9c                 | _fatfs_cc_f_rename
06e9c     01 4A 05 F6 | 	mov	COUNT_, #1
06ea0     A8 00 A0 FD | 	call	#pushregs_
06ea4     94 F0 07 F1 | 	add	ptra, #148
06ea8     04 4E 05 F1 | 	add	fp, #4
06eac     A7 C2 61 FC | 	wrlong	arg01, fp
06eb0     04 4E 05 F1 | 	add	fp, #4
06eb4     A7 C4 61 FC | 	wrlong	arg02, fp
06eb8     A7 C2 01 F6 | 	mov	arg01, fp
06ebc     08 4E 85 F1 | 	sub	fp, #8
06ec0     D0 CD BF FD | 	call	#_fatfs_cc_get_ldnumber
06ec4     04 4E 05 F1 | 	add	fp, #4
06ec8     A7 C2 01 F6 | 	mov	arg01, fp
06ecc     64 4E 05 F1 | 	add	fp, #100
06ed0     A7 C4 01 F6 | 	mov	arg02, fp
06ed4     68 4E 85 F1 | 	sub	fp, #104
06ed8     02 C6 05 F6 | 	mov	arg03, #2
06edc     F0 D0 BF FD | 	call	#_fatfs_cc_mount_volume
06ee0     0C 4E 05 F1 | 	add	fp, #12
06ee4     A7 A6 61 FC | 	wrlong	result1, fp
06ee8     0C 4E 85 F1 | 	sub	fp, #12
06eec     00 A6 0D F2 | 	cmp	result1, #0 wz
06ef0     3C 03 90 5D |  if_ne	jmp	#LR__0733
06ef4     68 4E 05 F1 | 	add	fp, #104
06ef8     A7 C6 01 FB | 	rdlong	arg03, fp
06efc     58 4E 85 F1 | 	sub	fp, #88
06f00     A7 C6 61 FC | 	wrlong	arg03, fp
06f04     A7 C2 01 F6 | 	mov	arg01, fp
06f08     0C 4E 85 F1 | 	sub	fp, #12
06f0c     A7 C4 01 FB | 	rdlong	arg02, fp
06f10     04 4E 85 F1 | 	sub	fp, #4
06f14     70 CB BF FD | 	call	#_fatfs_cc_follow_path
06f18     0C 4E 05 F1 | 	add	fp, #12
06f1c     A7 A6 61 FC | 	wrlong	result1, fp
06f20     00 A6 4D F2 | 	cmps	result1, #0 wz
06f24     0C 4E 85 F1 | 	sub	fp, #12
06f28     1C 00 90 5D |  if_ne	jmp	#LR__0720
06f2c     3B 4E 05 F1 | 	add	fp, #59
06f30     A7 A6 C1 FA | 	rdbyte	result1, fp
06f34     3B 4E 85 F1 | 	sub	fp, #59
06f38     A0 A6 CD F7 | 	test	result1, #160 wz
06f3c     0C 4E 05 51 |  if_ne	add	fp, #12
06f40     A7 0C 68 5C |  if_ne	wrlong	#6, fp
06f44     0C 4E 85 51 |  if_ne	sub	fp, #12
06f48                 | LR__0720
06f48     0C 4E 05 F1 | 	add	fp, #12
06f4c     A7 D8 09 FB | 	rdlong	local01, fp wz
06f50     0C 4E 85 F1 | 	sub	fp, #12
06f54     D8 02 90 5D |  if_ne	jmp	#LR__0732
06f58     6C 4E 05 F1 | 	add	fp, #108
06f5c     A7 C2 01 F6 | 	mov	arg01, fp
06f60     40 4E 85 F1 | 	sub	fp, #64
06f64     A7 C4 01 FB | 	rdlong	arg02, fp
06f68     2C 4E 85 F1 | 	sub	fp, #44
06f6c     20 C6 05 F6 | 	mov	arg03, #32
06f70     E4 73 B0 FD | 	call	#__system____builtin_memmove
06f74     3C 4E 05 F1 | 	add	fp, #60
06f78     A7 C2 01 F6 | 	mov	arg01, fp
06f7c     2C 4E 85 F1 | 	sub	fp, #44
06f80     A7 C4 01 F6 | 	mov	arg02, fp
06f84     10 4E 85 F1 | 	sub	fp, #16
06f88     2C C6 05 F6 | 	mov	arg03, #44
06f8c     C8 73 B0 FD | 	call	#__system____builtin_memmove
06f90     3C 4E 05 F1 | 	add	fp, #60
06f94     A7 C2 01 F6 | 	mov	arg01, fp
06f98     34 4E 85 F1 | 	sub	fp, #52
06f9c     A7 C4 01 FB | 	rdlong	arg02, fp
06fa0     08 4E 85 F1 | 	sub	fp, #8
06fa4     E0 CA BF FD | 	call	#_fatfs_cc_follow_path
06fa8     0C 4E 05 F1 | 	add	fp, #12
06fac     A7 A6 61 FC | 	wrlong	result1, fp
06fb0     0C 4E 85 F1 | 	sub	fp, #12
06fb4     00 A6 0D F2 | 	cmp	result1, #0 wz
06fb8     4C 00 90 5D |  if_ne	jmp	#LR__0723
06fbc     44 4E 05 F1 | 	add	fp, #68
06fc0     A7 A6 01 FB | 	rdlong	result1, fp
06fc4     2C 4E 85 F1 | 	sub	fp, #44
06fc8     A7 C6 01 FB | 	rdlong	arg03, fp
06fcc     18 4E 85 F1 | 	sub	fp, #24
06fd0     E3 A6 09 F2 | 	cmp	result1, arg03 wz
06fd4     20 00 90 5D |  if_ne	jmp	#LR__0721
06fd8     4C 4E 05 F1 | 	add	fp, #76
06fdc     A7 A6 01 FB | 	rdlong	result1, fp
06fe0     2C 4E 85 F1 | 	sub	fp, #44
06fe4     A7 C6 01 FB | 	rdlong	arg03, fp
06fe8     20 4E 85 F1 | 	sub	fp, #32
06fec     E3 A6 09 F2 | 	cmp	result1, arg03 wz
06ff0     04 D8 05 A6 |  if_e	mov	local01, #4
06ff4     04 00 90 AD |  if_e	jmp	#LR__0722
06ff8                 | LR__0721
06ff8     08 D8 05 F6 | 	mov	local01, #8
06ffc                 | LR__0722
06ffc     0C 4E 05 F1 | 	add	fp, #12
07000     A7 D8 61 FC | 	wrlong	local01, fp
07004     0C 4E 85 F1 | 	sub	fp, #12
07008                 | LR__0723
07008     0C 4E 05 F1 | 	add	fp, #12
0700c     A7 D8 01 FB | 	rdlong	local01, fp
07010     0C 4E 85 F1 | 	sub	fp, #12
07014     04 D8 0D F2 | 	cmp	local01, #4 wz
07018     C8 01 90 5D |  if_ne	jmp	#LR__0729
0701c     A7 C2 01 F6 | 	mov	arg01, fp
07020     3C C2 05 F1 | 	add	arg01, #60
07024     88 C6 BF FD | 	call	#_fatfs_cc_dir_register
07028     0C 4E 05 F1 | 	add	fp, #12
0702c     A7 A6 61 FC | 	wrlong	result1, fp
07030     0C 4E 85 F1 | 	sub	fp, #12
07034     00 A6 0D F2 | 	cmp	result1, #0 wz
07038     A8 01 90 5D |  if_ne	jmp	#LR__0728
0703c     58 4E 05 F1 | 	add	fp, #88
07040     A7 C2 01 FB | 	rdlong	arg01, fp
07044     34 4E 05 F1 | 	add	fp, #52
07048     A7 C2 61 FC | 	wrlong	arg01, fp
0704c     0D C2 05 F1 | 	add	arg01, #13
07050     20 4E 85 F1 | 	sub	fp, #32
07054     A7 C4 01 F6 | 	mov	arg02, fp
07058     6C 4E 85 F1 | 	sub	fp, #108
0705c     0D C4 05 F1 | 	add	arg02, #13
07060     13 C6 05 F6 | 	mov	arg03, #19
07064     F0 72 B0 FD | 	call	#__system____builtin_memmove
07068     8C 4E 05 F1 | 	add	fp, #140
0706c     A7 D8 01 FB | 	rdlong	local01, fp
07070     15 4E 85 F1 | 	sub	fp, #21
07074     A7 A6 C1 FA | 	rdbyte	result1, fp
07078     0B D8 05 F1 | 	add	local01, #11
0707c     EC A6 41 FC | 	wrbyte	result1, local01
07080     15 4E 05 F1 | 	add	fp, #21
07084     A7 D8 01 FB | 	rdlong	local01, fp
07088     8C 4E 85 F1 | 	sub	fp, #140
0708c     0B D8 05 F1 | 	add	local01, #11
07090     EC D8 C1 FA | 	rdbyte	local01, local01
07094     10 D8 CD F7 | 	test	local01, #16 wz
07098     24 00 90 5D |  if_ne	jmp	#LR__0724
0709c     8C 4E 05 F1 | 	add	fp, #140
070a0     A7 A6 01 FB | 	rdlong	result1, fp
070a4     D3 D8 01 F6 | 	mov	local01, result1
070a8     8C 4E 85 F1 | 	sub	fp, #140
070ac     0B A6 05 F1 | 	add	result1, #11
070b0     D3 A6 C1 FA | 	rdbyte	result1, result1
070b4     20 A6 45 F5 | 	or	result1, #32
070b8     0B D8 05 F1 | 	add	local01, #11
070bc     EC A6 41 FC | 	wrbyte	result1, local01
070c0                 | LR__0724
070c0     68 4E 05 F1 | 	add	fp, #104
070c4     A7 D8 01 FB | 	rdlong	local01, fp
070c8     03 D8 05 F1 | 	add	local01, #3
070cc     EC 02 48 FC | 	wrbyte	#1, local01
070d0     24 4E 05 F1 | 	add	fp, #36
070d4     A7 D8 01 FB | 	rdlong	local01, fp
070d8     8C 4E 85 F1 | 	sub	fp, #140
070dc     0B D8 05 F1 | 	add	local01, #11
070e0     EC D8 C1 FA | 	rdbyte	local01, local01
070e4     10 D8 CD F7 | 	test	local01, #16 wz
070e8     F8 00 90 AD |  if_e	jmp	#LR__0727
070ec     18 4E 05 F1 | 	add	fp, #24
070f0     A7 C6 01 FB | 	rdlong	arg03, fp
070f4     2C 4E 05 F1 | 	add	fp, #44
070f8     A7 D8 01 FB | 	rdlong	local01, fp
070fc     44 4E 85 F1 | 	sub	fp, #68
07100     EC C6 09 F2 | 	cmp	arg03, local01 wz
07104     DC 00 90 AD |  if_e	jmp	#LR__0727
07108     68 4E 05 F1 | 	add	fp, #104
0710c     A7 C2 01 FB | 	rdlong	arg01, fp
07110     E1 D8 01 F6 | 	mov	local01, arg01
07114     24 4E 05 F1 | 	add	fp, #36
07118     A7 C4 01 FB | 	rdlong	arg02, fp
0711c     8C 4E 85 F1 | 	sub	fp, #140
07120     64 C3 BF FD | 	call	#_fatfs_cc_ld_clust
07124     D3 C4 01 F6 | 	mov	arg02, result1
07128     EC C2 01 F6 | 	mov	arg01, local01
0712c     98 B7 BF FD | 	call	#_fatfs_cc_clst2sect
07130     90 4E 05 F1 | 	add	fp, #144
07134     A7 A6 61 FC | 	wrlong	result1, fp
07138     00 A6 4D F2 | 	cmps	result1, #0 wz
0713c     90 4E 85 F1 | 	sub	fp, #144
07140     0C 4E 05 A1 |  if_e	add	fp, #12
07144     A7 04 68 AC |  if_e	wrlong	#2, fp
07148     0C 4E 85 A1 |  if_e	sub	fp, #12
0714c     94 00 90 AD |  if_e	jmp	#LR__0726
07150     68 4E 05 F1 | 	add	fp, #104
07154     A7 C2 01 FB | 	rdlong	arg01, fp
07158     28 4E 05 F1 | 	add	fp, #40
0715c     A7 C4 01 FB | 	rdlong	arg02, fp
07160     90 4E 85 F1 | 	sub	fp, #144
07164     E8 B5 BF FD | 	call	#_fatfs_cc_move_window
07168     0C 4E 05 F1 | 	add	fp, #12
0716c     A7 A6 61 FC | 	wrlong	result1, fp
07170     5C 4E 05 F1 | 	add	fp, #92
07174     A7 D8 01 FB | 	rdlong	local01, fp
07178     50 D8 05 F1 | 	add	local01, #80
0717c     24 4E 05 F1 | 	add	fp, #36
07180     A7 D8 61 FC | 	wrlong	local01, fp
07184     80 4E 85 F1 | 	sub	fp, #128
07188     A7 D8 09 FB | 	rdlong	local01, fp wz
0718c     0C 4E 85 F1 | 	sub	fp, #12
07190     50 00 90 5D |  if_ne	jmp	#LR__0725
07194     8C 4E 05 F1 | 	add	fp, #140
07198     A7 D8 01 FB | 	rdlong	local01, fp
0719c     8C 4E 85 F1 | 	sub	fp, #140
071a0     01 D8 05 F1 | 	add	local01, #1
071a4     EC D8 C1 FA | 	rdbyte	local01, local01
071a8     2E D8 0D F2 | 	cmp	local01, #46 wz
071ac     34 00 90 5D |  if_ne	jmp	#LR__0725
071b0     68 4E 05 F1 | 	add	fp, #104
071b4     A7 C2 01 FB | 	rdlong	arg01, fp
071b8     24 4E 05 F1 | 	add	fp, #36
071bc     A7 C4 01 FB | 	rdlong	arg02, fp
071c0     48 4E 85 F1 | 	sub	fp, #72
071c4     A7 C6 01 FB | 	rdlong	arg03, fp
071c8     44 4E 85 F1 | 	sub	fp, #68
071cc     EC C2 BF FD | 	call	#_fatfs_cc_st_clust
071d0     68 4E 05 F1 | 	add	fp, #104
071d4     A7 D8 01 FB | 	rdlong	local01, fp
071d8     68 4E 85 F1 | 	sub	fp, #104
071dc     03 D8 05 F1 | 	add	local01, #3
071e0     EC 02 48 FC | 	wrbyte	#1, local01
071e4                 | LR__0725
071e4                 | LR__0726
071e4                 | LR__0727
071e4                 | LR__0728
071e4                 | LR__0729
071e4     0C 4E 05 F1 | 	add	fp, #12
071e8     A7 D8 09 FB | 	rdlong	local01, fp wz
071ec     0C 4E 85 F1 | 	sub	fp, #12
071f0     3C 00 90 5D |  if_ne	jmp	#LR__0731
071f4     A7 C2 01 F6 | 	mov	arg01, fp
071f8     10 C2 05 F1 | 	add	arg01, #16
071fc     30 C5 BF FD | 	call	#_fatfs_cc_dir_remove
07200     0C 4E 05 F1 | 	add	fp, #12
07204     A7 A6 61 FC | 	wrlong	result1, fp
07208     0C 4E 85 F1 | 	sub	fp, #12
0720c     00 A6 0D F2 | 	cmp	result1, #0 wz
07210     1C 00 90 5D |  if_ne	jmp	#LR__0730
07214     68 4E 05 F1 | 	add	fp, #104
07218     A7 C2 01 FB | 	rdlong	arg01, fp
0721c     68 4E 85 F1 | 	sub	fp, #104
07220     A4 B5 BF FD | 	call	#_fatfs_cc_sync_fs
07224     0C 4E 05 F1 | 	add	fp, #12
07228     A7 A6 61 FC | 	wrlong	result1, fp
0722c     0C 4E 85 F1 | 	sub	fp, #12
07230                 | LR__0730
07230                 | LR__0731
07230                 | LR__0732
07230                 | LR__0733
07230                 | ' 					res = sync_fs(fs);
07230                 | ' 				}
07230                 | ' 			}
07230                 | ' 
07230                 | ' 		}
07230                 | ' 		;
07230                 | ' 	}
07230                 | ' 
07230                 | ' 	return res ;
07230     0C 4E 05 F1 | 	add	fp, #12
07234     A7 A6 01 FB | 	rdlong	result1, fp
07238     0C 4E 85 F1 | 	sub	fp, #12
0723c     A7 F0 03 F6 | 	mov	ptra, fp
07240     B2 00 A0 FD | 	call	#popregs_
07244                 | _fatfs_cc_f_rename_ret
07244     2D 00 64 FD | 	ret
07248                 | 
07248                 | _fatfs_cc_time
07248     00 4A 05 F6 | 	mov	COUNT_, #0
0724c     A8 00 A0 FD | 	call	#pushregs_
07250     14 F0 07 F1 | 	add	ptra, #20
07254     04 4E 05 F1 | 	add	fp, #4
07258     A7 C2 61 FC | 	wrlong	arg01, fp
0725c     04 4E 05 F1 | 	add	fp, #4
07260     A7 C2 01 F6 | 	mov	arg01, fp
07264     08 4E 85 F1 | 	sub	fp, #8
07268     00 C4 05 F6 | 	mov	arg02, #0
0726c     40 15 B0 FD | 	call	#_fatfs_cc_gettimeofday
07270     08 4E 05 F1 | 	add	fp, #8
07274     A7 A6 01 FB | 	rdlong	result1, fp
07278     08 4E 05 F1 | 	add	fp, #8
0727c     A7 A6 61 FC | 	wrlong	result1, fp
07280     0C 4E 85 F1 | 	sub	fp, #12
07284     A7 A6 09 FB | 	rdlong	result1, fp wz
07288     04 4E 85 F1 | 	sub	fp, #4
0728c     18 00 90 AD |  if_e	jmp	#LR__0740
07290     04 4E 05 F1 | 	add	fp, #4
07294     A7 A6 01 FB | 	rdlong	result1, fp
07298     0C 4E 05 F1 | 	add	fp, #12
0729c     A7 C4 01 FB | 	rdlong	arg02, fp
072a0     10 4E 85 F1 | 	sub	fp, #16
072a4     D3 C4 61 FC | 	wrlong	arg02, result1
072a8                 | LR__0740
072a8                 | '         *tp = now;
072a8                 | '     return now;
072a8     10 4E 05 F1 | 	add	fp, #16
072ac     A7 A6 01 FB | 	rdlong	result1, fp
072b0     10 4E 85 F1 | 	sub	fp, #16
072b4     A7 F0 03 F6 | 	mov	ptra, fp
072b8     B2 00 A0 FD | 	call	#popregs_
072bc                 | _fatfs_cc_time_ret
072bc     2D 00 64 FD | 	ret
072c0                 | 
072c0                 | _fatfs_cc_mktime
072c0     06 4A 05 F6 | 	mov	COUNT_, #6
072c4     A8 00 A0 FD | 	call	#pushregs_
072c8     E1 D8 01 F6 | 	mov	local01, arg01
072cc     14 D8 05 F1 | 	add	local01, #20
072d0     EC C2 01 FB | 	rdlong	arg01, local01
072d4     14 D8 85 F1 | 	sub	local01, #20
072d8     46 C2 55 F2 | 	cmps	arg01, #70 wc
072dc                 | '                 return (time_t) -1;
072dc     01 A6 65 C6 |  if_b	neg	result1, #1
072e0     6C 01 90 CD |  if_b	jmp	#LR__0754
072e4     03 00 00 FF 
072e8     6C DB 05 F6 | 	mov	local02, ##1900
072ec     14 D8 05 F1 | 	add	local01, #20
072f0     EC A6 01 FB | 	rdlong	result1, local01
072f4     D3 DA 01 F1 | 	add	local02, result1
072f8     08 D8 85 F1 | 	sub	local01, #8
072fc     EC DC 01 FB | 	rdlong	local03, local01
07300     01 DC 85 F1 | 	sub	local03, #1
07304     04 D8 05 F1 | 	add	local01, #4
07308     EC C2 01 FB | 	rdlong	arg01, local01
0730c     10 D8 85 F1 | 	sub	local01, #16
07310     02 C2 65 F0 | 	shl	arg01, #2
07314     CB A6 01 F6 | 	mov	result1, ptr__fatfs_cc_dat__
07318     BC A6 05 F1 | 	add	result1, #188
0731c     D3 C2 01 F1 | 	add	arg01, result1
07320     E1 A6 01 FB | 	rdlong	result1, arg01
07324     D3 DC 01 F1 | 	add	local03, result1
07328     ED C2 01 F6 | 	mov	arg01, local02
0732c     0C 15 B0 FD | 	call	#_fatfs_cc__is_leap_year
07330     00 A6 0D F2 | 	cmp	result1, #0 wz
07334     1C 00 90 AD |  if_e	jmp	#LR__0750
07338     00 DE 05 F6 | 	mov	local04, #0
0733c     10 D8 05 F1 | 	add	local01, #16
07340     EC A6 01 FB | 	rdlong	result1, local01
07344     10 D8 85 F1 | 	sub	local01, #16
07348     02 A6 55 F2 | 	cmps	result1, #2 wc
0734c     01 DE 05 36 |  if_ae	mov	local04, #1
07350     04 00 90 FD | 	jmp	#LR__0751
07354                 | LR__0750
07354     00 DE 05 F6 | 	mov	local04, #0
07358                 | LR__0751
07358     04 D8 05 F1 | 	add	local01, #4
0735c     EC C2 01 FB | 	rdlong	arg01, local01
07360     04 D8 85 F1 | 	sub	local01, #4
07364     EC E0 01 FB | 	rdlong	local05, local01
07368     08 D8 05 F1 | 	add	local01, #8
0736c     EC A6 01 FB | 	rdlong	result1, local01
07370     07 00 00 FF 
07374     10 A6 05 FD | 	qmul	result1, ##3600
07378     EF DC 01 F1 | 	add	local03, local04
0737c     E1 DE 01 F6 | 	mov	local04, arg01
07380     04 DE 65 F0 | 	shl	local04, #4
07384     E1 DE 81 F1 | 	sub	local04, arg01
07388     02 DE 65 F0 | 	shl	local04, #2
0738c     EF E0 01 F1 | 	add	local05, local04
07390     08 D8 85 F1 | 	sub	local01, #8
07394     18 DE 61 FD | 	getqx	local04
07398     A8 00 00 FF 
0739c     80 DD 05 FD | 	qmul	local03, ##86400
073a0     EF E0 01 F1 | 	add	local05, local04
073a4     ED DC 01 F6 | 	mov	local03, local02
073a8     03 00 00 FF 
073ac     B2 DD 85 F1 | 	sub	local03, ##1970
073b0     18 DE 61 FD | 	getqx	local04
073b4     99 F0 00 FF 
073b8     80 DD 05 FD | 	qmul	local03, ##31536000
073bc     EF E0 01 F1 | 	add	local05, local04
073c0     ED DC 01 F6 | 	mov	local03, local02
073c4     03 00 00 FF 
073c8     B1 DD 85 F1 | 	sub	local03, ##1969
073cc     EE E2 51 F6 | 	abs	local06, local03 wc
073d0     02 E2 45 F0 | 	shr	local06, #2
073d4     F1 E2 81 F6 | 	negc	local06, local06
073d8     03 00 00 FF 
073dc     D1 DB 55 F2 | 	cmps	local02, ##2001 wc
073e0     18 DE 61 FD | 	getqx	local04
073e4     EF E0 01 F1 | 	add	local05, local04
073e8     18 00 90 CD |  if_b	jmp	#LR__0752
073ec     03 00 00 FF 
073f0     D0 DB 85 F1 | 	sub	local02, ##2000
073f4     ED DE 51 F6 | 	abs	local04, local02 wc
073f8     64 DE 15 FD | 	qdiv	local04, #100
073fc     18 DE 61 FD | 	getqx	local04
07400     EF E2 A1 F3 | 	sumnc	local06, local04
07404                 | LR__0752
07404     A8 00 00 FF 
07408     80 E3 05 FD | 	qmul	local06, ##86400
0740c     18 E2 61 FD | 	getqx	local06
07410     F1 E0 01 F1 | 	add	local05, local06
07414     D0 01 B0 FD | 	call	#_fatfs_cc__tzset
07418     88 96 05 F1 | 	add	ptr__fatfs_cc_dat__, #136
0741c     CB E2 01 FB | 	rdlong	local06, ptr__fatfs_cc_dat__
07420     F1 E0 01 F1 | 	add	local05, local06
07424     68 96 05 F1 | 	add	ptr__fatfs_cc_dat__, #104
07428     CB DC 01 FB | 	rdlong	local03, ptr__fatfs_cc_dat__
0742c     F0 96 85 F1 | 	sub	ptr__fatfs_cc_dat__, #240
07430     01 DC 0D F2 | 	cmp	local03, #1 wz
07434     14 00 90 5D |  if_ne	jmp	#LR__0753
07438     EC C2 01 F6 | 	mov	arg01, local01
0743c     9C 16 B0 FD | 	call	#_fatfs_cc___indst
07440     00 A6 0D F2 | 	cmp	result1, #0 wz
07444     07 00 00 5F 
07448     10 E0 85 51 |  if_ne	sub	local05, ##3600
0744c                 | LR__0753
0744c                 | '                 s -=  (3600L) ;
0744c                 | ' 
0744c                 | '         return s;
0744c     F0 A6 01 F6 | 	mov	result1, local05
07450                 | LR__0754
07450     A7 F0 03 F6 | 	mov	ptra, fp
07454     B2 00 A0 FD | 	call	#popregs_
07458                 | _fatfs_cc_mktime_ret
07458     2D 00 64 FD | 	ret
0745c                 | 
0745c                 | _fatfs_cc__gmtime_r
0745c     03 4A 05 F6 | 	mov	COUNT_, #3
07460     A8 00 A0 FD | 	call	#pushregs_
07464     E1 D8 01 FB | 	rdlong	local01, arg01
07468     A8 00 00 FF 
0746c     80 D9 15 FD | 	qdiv	local01, ##86400
07470     18 A6 61 FD | 	getqx	result1
07474     04 A6 05 F1 | 	add	result1, #4
07478     07 A6 15 FD | 	qdiv	result1, #7
0747c     18 C4 05 F1 | 	add	arg02, #24
07480     D1 7F 27 FF 
07484     00 D8 15 F2 | 	cmp	local01, ##1325376000 wc
07488     D1 7F 27 3F 
0748c     00 D8 85 31 |  if_ae	sub	local01, ##1325376000
07490     03 00 00 3F 
07494     DC DB 05 36 |  if_ae	mov	local02, ##2012
07498     03 00 00 CF 
0749c     B2 DB 05 C6 |  if_b	mov	local02, ##1970
074a0                 | ' 	  year = 1970;
074a0                 | ' 	}
074a0                 | ' 
074a0                 | ' 	for(;;) {
074a0     19 A6 61 FD | 	getqy	result1
074a4     E2 A6 61 FC | 	wrlong	result1, arg02
074a8     18 C4 85 F1 | 	sub	arg02, #24
074ac                 | LR__0760
074ac     ED C2 01 F6 | 	mov	arg01, local02
074b0     88 13 B0 FD | 	call	#_fatfs_cc__is_leap_year
074b4     00 A6 0D F2 | 	cmp	result1, #0 wz
074b8     42 F1 00 5F 
074bc     00 DD 05 56 |  if_ne	mov	local03, ##31622400
074c0     99 F0 00 AF 
074c4     80 DD 05 A6 |  if_e	mov	local03, ##31536000
074c8     EE D8 11 F2 | 	cmp	local01, local03 wc
074cc                 | ' 	    break;
074cc     01 DA 05 31 |  if_ae	add	local02, #1
074d0     EE D8 81 31 |  if_ae	sub	local01, local03
074d4     D4 FF 9F 3D |  if_ae	jmp	#LR__0760
074d8     A8 00 00 FF 
074dc     80 D9 15 FD | 	qdiv	local01, ##86400
074e0     ED DC 01 F6 | 	mov	local03, local02
074e4     03 00 00 FF 
074e8     6C DD 85 F1 | 	sub	local03, ##1900
074ec     14 C4 05 F1 | 	add	arg02, #20
074f0     E2 DC 61 FC | 	wrlong	local03, arg02
074f4     08 C4 05 F1 | 	add	arg02, #8
074f8     ED C2 01 F6 | 	mov	arg01, local02
074fc     18 DA 61 FD | 	getqx	local02
07500     E2 DA 61 FC | 	wrlong	local02, arg02
07504     1C C4 85 F1 | 	sub	arg02, #28
07508     30 13 B0 FD | 	call	#_fatfs_cc__is_leap_year
0750c     00 A6 0D F2 | 	cmp	result1, #0 wz
07510     1D DC 05 56 |  if_ne	mov	local03, #29
07514     1C DC 05 A6 |  if_e	mov	local03, #28
07518     90 96 05 F1 | 	add	ptr__fatfs_cc_dat__, #144
0751c     CB DC 61 FC | 	wrlong	local03, ptr__fatfs_cc_dat__
07520     90 96 85 F1 | 	sub	ptr__fatfs_cc_dat__, #144
07524                 | ' 
07524                 | '         days_per_mth[1] = _is_leap_year(year) ? 29 : 28;
07524                 | '         for (i = 0; mday >= days_per_mth[i]; i++)
07524     00 C2 05 F6 | 	mov	arg01, #0
07528     97 22 48 FB | 	callpa	#(@LR__0762-@LR__0761)>>2,fcache_load_ptr_
0752c                 | LR__0761
0752c     E1 DC 01 F6 | 	mov	local03, arg01
07530     02 DC 65 F0 | 	shl	local03, #2
07534     CB A6 01 F6 | 	mov	result1, ptr__fatfs_cc_dat__
07538     8C A6 05 F1 | 	add	result1, #140
0753c     D3 DC 01 F1 | 	add	local03, result1
07540     EE DC 01 FB | 	rdlong	local03, local03
07544     EE DA 51 F2 | 	cmps	local02, local03 wc
07548     24 00 90 CD |  if_b	jmp	#LR__0763
0754c     E1 A6 01 F6 | 	mov	result1, arg01
07550     02 A6 65 F0 | 	shl	result1, #2
07554     CB DC 01 F6 | 	mov	local03, ptr__fatfs_cc_dat__
07558     8C DC 05 F1 | 	add	local03, #140
0755c     EE A6 01 F1 | 	add	result1, local03
07560     D3 A6 01 FB | 	rdlong	result1, result1
07564     D3 DA 81 F1 | 	sub	local02, result1
07568     01 C2 05 F1 | 	add	arg01, #1
0756c     BC FF 9F FD | 	jmp	#LR__0761
07570                 | LR__0762
07570                 | LR__0763
07570     A8 00 00 FF 
07574     80 D9 15 FD | 	qdiv	local01, ##86400
07578     10 C4 05 F1 | 	add	arg02, #16
0757c     E2 C2 61 FC | 	wrlong	arg01, arg02
07580     01 DA 05 F1 | 	add	local02, #1
07584     04 C4 85 F1 | 	sub	arg02, #4
07588     E2 DA 61 FC | 	wrlong	local02, arg02
0758c     19 D8 61 FD | 	getqy	local01
07590     07 00 00 FF 
07594     10 D8 15 FD | 	qdiv	local01, ##3600
07598     18 DC 61 FD | 	getqx	local03
0759c     07 00 00 FF 
075a0     10 D8 15 FD | 	qdiv	local01, ##3600
075a4     04 C4 85 F1 | 	sub	arg02, #4
075a8     E2 DC 61 FC | 	wrlong	local03, arg02
075ac     19 D8 61 FD | 	getqy	local01
075b0     3C D8 15 FD | 	qdiv	local01, #60
075b4     18 DC 61 FD | 	getqx	local03
075b8     3C D8 15 FD | 	qdiv	local01, #60
075bc     04 C4 85 F1 | 	sub	arg02, #4
075c0     E2 DC 61 FC | 	wrlong	local03, arg02
075c4     04 C4 85 F1 | 	sub	arg02, #4
075c8                 | '         stm->tm_isdst = 0;
075c8                 | ' 
075c8                 | ' ;
075c8                 | '         return stm;
075c8     E2 A6 01 F6 | 	mov	result1, arg02
075cc     19 DC 61 FD | 	getqy	local03
075d0     E2 DC 61 FC | 	wrlong	local03, arg02
075d4     20 C4 05 F1 | 	add	arg02, #32
075d8     E2 00 68 FC | 	wrlong	#0, arg02
075dc     A7 F0 03 F6 | 	mov	ptra, fp
075e0     B2 00 A0 FD | 	call	#popregs_
075e4                 | _fatfs_cc__gmtime_r_ret
075e4     2D 00 64 FD | 	ret
075e8                 | 
075e8                 | _fatfs_cc__tzset
075e8     7C 00 00 FF 
075ec     66 C3 05 F6 | 	mov	arg01, ##@LR__2098
075f0     20 00 B0 FD | 	call	#_fatfs_cc_getenv
075f4     D3 C2 01 F6 | 	mov	arg01, result1
075f8     CB C4 01 F6 | 	mov	arg02, ptr__fatfs_cc_dat__
075fc     F0 C4 05 F1 | 	add	arg02, #240
07600     88 12 B0 FD | 	call	#_fatfs_cc___tzoffset
07604     88 96 05 F1 | 	add	ptr__fatfs_cc_dat__, #136
07608     CB A6 61 FC | 	wrlong	result1, ptr__fatfs_cc_dat__
0760c     88 96 85 F1 | 	sub	ptr__fatfs_cc_dat__, #136
07610                 | _fatfs_cc__tzset_ret
07610     2D 00 64 FD | 	ret
07614                 | 
07614                 | _fatfs_cc_getenv
07614     06 4A 05 F6 | 	mov	COUNT_, #6
07618     A8 00 A0 FD | 	call	#pushregs_
0761c     E1 D8 01 F6 | 	mov	local01, arg01
07620     E1 DA 01 F6 | 	mov	local02, arg01
07624     97 06 48 FB | 	callpa	#(@LR__0771-@LR__0770)>>2,fcache_load_ptr_
07628                 | LR__0770
07628     ED A6 C9 FA | 	rdbyte	result1, local02 wz
0762c     01 DA 05 51 |  if_ne	add	local02, #1
07630     F4 FF 9F 5D |  if_ne	jmp	#LR__0770
07634                 | LR__0771
07634     E1 DA 81 F1 | 	sub	local02, arg01
07638     ED A6 01 F6 | 	mov	result1, local02
0763c     40 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #320
07640     CB C6 09 FB | 	rdlong	arg03, ptr__fatfs_cc_dat__ wz
07644     40 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #320
07648                 | '             return 0;
07648     00 A6 05 A6 |  if_e	mov	result1, #0
0764c     54 00 90 AD |  if_e	jmp	#LR__0774
07650                 | ' 
07650                 | ' 	for (var = _environ_ptr; (name = *var) != 0; var++) {
07650     40 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #320
07654     CB DC 01 FB | 	rdlong	local03, ptr__fatfs_cc_dat__
07658     40 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #320
0765c                 | LR__0772
0765c     EE DE 09 FB | 	rdlong	local04, local03 wz
07660     3C 00 90 AD |  if_e	jmp	#LR__0773
07664     EF C2 01 F6 | 	mov	arg01, local04
07668     EC C4 01 F6 | 	mov	arg02, local01
0766c     ED C6 01 F6 | 	mov	arg03, local02
07670     40 A6 BF FD | 	call	#_fatfs_cc_strncmp
07674     00 A6 0D F2 | 	cmp	result1, #0 wz
07678     ED E0 01 A6 |  if_e	mov	local05, local02
0767c     EF E0 01 A1 |  if_e	add	local05, local04
07680     F0 E2 C1 AA |  if_e	rdbyte	local06, local05
07684     3D E2 0D A2 |  if_e	cmp	local06, #61 wz
07688                 | ' 			return name+len+1;
07688     ED DE 01 A1 |  if_e	add	local04, local02
0768c     01 DE 05 A1 |  if_e	add	local04, #1
07690     EF A6 01 A6 |  if_e	mov	result1, local04
07694     0C 00 90 AD |  if_e	jmp	#LR__0774
07698     04 DC 05 F1 | 	add	local03, #4
0769c     BC FF 9F FD | 	jmp	#LR__0772
076a0                 | LR__0773
076a0                 | ' 	}
076a0                 | ' 	return 0;
076a0     00 A6 05 F6 | 	mov	result1, #0
076a4                 | LR__0774
076a4     A7 F0 03 F6 | 	mov	ptra, fp
076a8     B2 00 A0 FD | 	call	#popregs_
076ac                 | _fatfs_cc_getenv_ret
076ac     2D 00 64 FD | 	ret
076b0                 | 
076b0                 | _fatfs_cc__get_fattime
076b0     00 4A 05 F6 | 	mov	COUNT_, #0
076b4     A8 00 A0 FD | 	call	#pushregs_
076b8     34 F0 07 F1 | 	add	ptra, #52
076bc     00 C2 05 F6 | 	mov	arg01, #0
076c0     84 FB BF FD | 	call	#_fatfs_cc_time
076c4     04 4E 05 F1 | 	add	fp, #4
076c8     A7 A6 61 FC | 	wrlong	result1, fp
076cc     A7 C2 01 F6 | 	mov	arg01, fp
076d0     0C 4E 05 F1 | 	add	fp, #12
076d4     A7 C4 01 F6 | 	mov	arg02, fp
076d8     10 4E 85 F1 | 	sub	fp, #16
076dc     7C FD BF FD | 	call	#_fatfs_cc__gmtime_r
076e0     24 4E 05 F1 | 	add	fp, #36
076e4     A7 C4 01 FB | 	rdlong	arg02, fp
076e8     50 C4 85 F1 | 	sub	arg02, #80
076ec     09 C4 65 F0 | 	shl	arg02, #9
076f0     04 4E 85 F1 | 	sub	fp, #4
076f4     A7 A6 01 FB | 	rdlong	result1, fp
076f8     01 A6 05 F1 | 	add	result1, #1
076fc     05 A6 65 F0 | 	shl	result1, #5
07700     D3 C4 41 F5 | 	or	arg02, result1
07704     04 4E 85 F1 | 	sub	fp, #4
07708     A7 A6 01 FB | 	rdlong	result1, fp
0770c     D3 C4 41 F5 | 	or	arg02, result1
07710     14 4E 85 F1 | 	sub	fp, #20
07714     A7 C4 61 FC | 	wrlong	arg02, fp
07718     10 4E 05 F1 | 	add	fp, #16
0771c     A7 C4 01 FB | 	rdlong	arg02, fp
07720     0B C4 65 F0 | 	shl	arg02, #11
07724     04 4E 85 F1 | 	sub	fp, #4
07728     A7 A6 01 FB | 	rdlong	result1, fp
0772c     05 A6 65 F0 | 	shl	result1, #5
07730     D3 C4 41 F5 | 	or	arg02, result1
07734     04 4E 85 F1 | 	sub	fp, #4
07738     A7 A6 01 FB | 	rdlong	result1, fp
0773c     D3 C4 41 F5 | 	or	arg02, result1
07740     04 4E 85 F1 | 	sub	fp, #4
07744     A7 C4 61 FC | 	wrlong	arg02, fp
07748                 | ' 
07748                 | '     now = time(0);
07748                 | '     _gmtime_r (&now, &date);
07748                 | '     ffdate = ((date.tm_year - 80) << 9) | ((date.tm_mon + 1) << 5) | ((date.tm_mday));
07748                 | '     fftime = (date.tm_hour << 11) | (date.tm_min << 5) | (date.tm_sec);
07748                 | '     return (ffdate << 16) | fftime;
07748     04 4E 85 F1 | 	sub	fp, #4
0774c     A7 A6 01 FB | 	rdlong	result1, fp
07750     10 A6 65 F0 | 	shl	result1, #16
07754     08 4E 85 F1 | 	sub	fp, #8
07758     E2 A6 41 F5 | 	or	result1, arg02
0775c     A7 F0 03 F6 | 	mov	ptra, fp
07760     B2 00 A0 FD | 	call	#popregs_
07764                 | _fatfs_cc__get_fattime_ret
07764     2D 00 64 FD | 	ret
07768                 | 
07768                 | _fatfs_cc_unixtime_0464
07768     00 4A 05 F6 | 	mov	COUNT_, #0
0776c     A8 00 A0 FD | 	call	#pushregs_
07770     34 F0 07 F1 | 	add	ptra, #52
07774     04 4E 05 F1 | 	add	fp, #4
07778     A7 C2 61 FC | 	wrlong	arg01, fp
0777c     04 4E 05 F1 | 	add	fp, #4
07780     A7 C4 61 FC | 	wrlong	arg02, fp
07784     04 4E 85 F1 | 	sub	fp, #4
07788     A7 C4 01 FB | 	rdlong	arg02, fp
0778c     09 C4 45 F0 | 	shr	arg02, #9
07790     7F C4 05 F5 | 	and	arg02, #127
07794     50 A6 05 F6 | 	mov	result1, #80
07798     E2 A6 01 F1 | 	add	result1, arg02
0779c     20 4E 05 F1 | 	add	fp, #32
077a0     A7 A6 61 FC | 	wrlong	result1, fp
077a4     20 4E 85 F1 | 	sub	fp, #32
077a8     A7 A6 01 FB | 	rdlong	result1, fp
077ac     05 A6 45 F0 | 	shr	result1, #5
077b0     D3 A6 41 F8 | 	getnib	result1, result1, #0
077b4     01 A6 85 F1 | 	sub	result1, #1
077b8     1C 4E 05 F1 | 	add	fp, #28
077bc     A7 A6 61 FC | 	wrlong	result1, fp
077c0     1C 4E 85 F1 | 	sub	fp, #28
077c4     A7 A6 01 FB | 	rdlong	result1, fp
077c8     1F A6 05 F5 | 	and	result1, #31
077cc     18 4E 05 F1 | 	add	fp, #24
077d0     A7 A6 61 FC | 	wrlong	result1, fp
077d4     14 4E 85 F1 | 	sub	fp, #20
077d8     A7 A6 01 FB | 	rdlong	result1, fp
077dc     0B A6 45 F0 | 	shr	result1, #11
077e0     1F A6 05 F5 | 	and	result1, #31
077e4     10 4E 05 F1 | 	add	fp, #16
077e8     A7 A6 61 FC | 	wrlong	result1, fp
077ec     10 4E 85 F1 | 	sub	fp, #16
077f0     A7 A6 01 FB | 	rdlong	result1, fp
077f4     05 A6 45 F0 | 	shr	result1, #5
077f8     3F A6 05 F5 | 	and	result1, #63
077fc     0C 4E 05 F1 | 	add	fp, #12
07800     A7 A6 61 FC | 	wrlong	result1, fp
07804     0C 4E 85 F1 | 	sub	fp, #12
07808     A7 C4 01 FB | 	rdlong	arg02, fp
0780c     1F C4 05 F5 | 	and	arg02, #31
07810     01 C4 65 F0 | 	shl	arg02, #1
07814     08 4E 05 F1 | 	add	fp, #8
07818     A7 C4 61 FC | 	wrlong	arg02, fp
0781c     A7 C2 01 F6 | 	mov	arg01, fp
07820     10 4E 85 F1 | 	sub	fp, #16
07824     98 FA BF FD | 	call	#_fatfs_cc_mktime
07828     0C 4E 05 F1 | 	add	fp, #12
0782c     A7 A6 61 FC | 	wrlong	result1, fp
07830                 | ' 
07830                 | '     date.tm_year = 80 + ((dosdate >> 9) & 0x7f);
07830                 | '     date.tm_mon = ((dosdate >> 5) & 0xf) - 1;
07830                 | '     date.tm_mday = (dosdate & 0x1f);
07830                 | '     date.tm_hour = (dostime >> 11) & 0x1f;
07830                 | '     date.tm_min = (dostime >> 5) & 0x3f;
07830                 | '     date.tm_sec = (dostime & 0x1f) << 1;
07830                 | ' 
07830                 | '     t = mktime(&date);
07830                 | ' #line 60 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
07830                 | '     return t;
07830     0C 4E 85 F1 | 	sub	fp, #12
07834     A7 F0 03 F6 | 	mov	ptra, fp
07838     B2 00 A0 FD | 	call	#popregs_
0783c                 | _fatfs_cc_unixtime_0464_ret
0783c     2D 00 64 FD | 	ret
07840                 | 
07840                 | _fatfs_cc__set_dos_error_0466
07840     E1 AA 01 F6 | 	mov	_var01, arg01
07844                 | ' #line 74 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
07844                 | '     switch (derr) {
07844     14 AA 25 F3 | 	fle	_var01, #20
07848     30 AA 61 FD | 	jmprel	_var01
0784c                 | LR__0780
0784c     50 00 90 FD | 	jmp	#LR__0781
07850     84 00 90 FD | 	jmp	#LR__0795
07854     80 00 90 FD | 	jmp	#LR__0796
07858     7C 00 90 FD | 	jmp	#LR__0797
0785c     48 00 90 FD | 	jmp	#LR__0782
07860     44 00 90 FD | 	jmp	#LR__0783
07864     40 00 90 FD | 	jmp	#LR__0784
07868     44 00 90 FD | 	jmp	#LR__0785
0786c     48 00 90 FD | 	jmp	#LR__0787
07870     54 00 90 FD | 	jmp	#LR__0790
07874     38 00 90 FD | 	jmp	#LR__0786
07878     4C 00 90 FD | 	jmp	#LR__0791
0787c     48 00 90 FD | 	jmp	#LR__0792
07880     44 00 90 FD | 	jmp	#LR__0793
07884     50 00 90 FD | 	jmp	#LR__0798
07888     4C 00 90 FD | 	jmp	#LR__0798
0788c     48 00 90 FD | 	jmp	#LR__0798
07890     2C 00 90 FD | 	jmp	#LR__0788
07894     38 00 90 FD | 	jmp	#LR__0794
07898     2C 00 90 FD | 	jmp	#LR__0789
0789c     38 00 90 FD | 	jmp	#LR__0798
078a0                 | LR__0781
078a0     00 AC 05 F6 | 	mov	_var02, #0
078a4                 | '         r = 0;
078a4                 | '         break;
078a4     34 00 90 FD | 	jmp	#LR__0799
078a8                 | LR__0782
078a8                 | LR__0783
078a8                 | LR__0784
078a8     04 AC 05 F6 | 	mov	_var02, #4
078ac                 | '         r =  4 ;
078ac                 | '         break;
078ac     2C 00 90 FD | 	jmp	#LR__0799
078b0                 | LR__0785
078b0                 | LR__0786
078b0     06 AC 05 F6 | 	mov	_var02, #6
078b4                 | '         r =  6 ;
078b4                 | '         break;
078b4     24 00 90 FD | 	jmp	#LR__0799
078b8                 | LR__0787
078b8     09 AC 05 F6 | 	mov	_var02, #9
078bc                 | '         r =  9 ;
078bc                 | '         break;
078bc     1C 00 90 FD | 	jmp	#LR__0799
078c0                 | LR__0788
078c0     07 AC 05 F6 | 	mov	_var02, #7
078c4                 | '         r =  7 ;
078c4                 | '         break;
078c4     14 00 90 FD | 	jmp	#LR__0799
078c8                 | LR__0789
078c8                 | LR__0790
078c8                 | LR__0791
078c8                 | LR__0792
078c8                 | LR__0793
078c8     0A AC 05 F6 | 	mov	_var02, #10
078cc                 | '         r =  10 ;
078cc                 | '         break;
078cc     0C 00 90 FD | 	jmp	#LR__0799
078d0                 | LR__0794
078d0     0B AC 05 F6 | 	mov	_var02, #11
078d4                 | '         r =  11 ;
078d4                 | '         break;
078d4     04 00 90 FD | 	jmp	#LR__0799
078d8                 | LR__0795
078d8                 | LR__0796
078d8                 | LR__0797
078d8                 | LR__0798
078d8     0C AC 05 F6 | 	mov	_var02, #12
078dc                 | '         r =  12 ;
078dc                 | '         break;
078dc                 | LR__0799
078dc                 | '     }
078dc                 | '     return _seterror(r);
078dc     00 AC 4D F2 | 	cmps	_var02, #0 wz
078e0     20 92 05 F1 | 	add	ptr___system__dat__, #32
078e4     C9 AC 61 FC | 	wrlong	_var02, ptr___system__dat__
078e8     20 92 85 F1 | 	sub	ptr___system__dat__, #32
078ec     01 A6 65 56 |  if_ne	neg	result1, #1
078f0     00 A6 05 A6 |  if_e	mov	result1, #0
078f4                 | _fatfs_cc__set_dos_error_0466_ret
078f4     2D 00 64 FD | 	ret
078f8                 | 
078f8                 | _fatfs_cc_v_creat
078f8     04 4A 05 F6 | 	mov	COUNT_, #4
078fc     A8 00 A0 FD | 	call	#pushregs_
07900     E1 D8 01 F6 | 	mov	local01, arg01
07904     E2 DA 01 F6 | 	mov	local02, arg02
07908     03 00 00 FF 
0790c     3C C2 05 F6 | 	mov	arg01, ##1596
07910                 | '     return _gc_alloc(size);
07910     10 C4 05 F6 | 	mov	arg02, #16
07914     74 76 B0 FD | 	call	#__system___gc_doalloc
07918     D3 DC 09 F6 | 	mov	local03, result1 wz
0791c                 | '       return _seterror( 7 );
0791c     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
07920     C9 0E 68 AC |  if_e	wrlong	#7, ptr___system__dat__
07924     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
07928     01 A6 65 A6 |  if_e	neg	result1, #1
0792c     50 00 90 AD |  if_e	jmp	#LR__0801
07930     EE C2 01 F6 | 	mov	arg01, local03
07934     00 C4 05 F6 | 	mov	arg02, #0
07938     03 00 00 FF 
0793c     3C C6 05 F6 | 	mov	arg03, ##1596
07940     98 00 A0 FD | 	call	#\builtin_bytefill_
07944     EE C2 01 F6 | 	mov	arg01, local03
07948     02 00 00 FF 
0794c     14 C2 05 F1 | 	add	arg01, ##1044
07950     ED C4 01 F6 | 	mov	arg02, local02
07954     07 C6 05 F6 | 	mov	arg03, #7
07958     20 CD BF FD | 	call	#_fatfs_cc_f_open
0795c     D3 DE 09 F6 | 	mov	local04, result1 wz
07960     14 00 90 AD |  if_e	jmp	#LR__0800
07964     EE C2 01 F6 | 	mov	arg01, local03
07968                 | '     return _gc_free(ptr);
07968     24 77 B0 FD | 	call	#__system___gc_free
0796c                 | '     free(f);
0796c                 | '     return _set_dos_error(r);
0796c     EF C2 01 F6 | 	mov	arg01, local04
07970     CC FE BF FD | 	call	#_fatfs_cc__set_dos_error_0466
07974     08 00 90 FD | 	jmp	#LR__0801
07978                 | LR__0800
07978     EC DC 61 FC | 	wrlong	local03, local01
0797c                 | '   }
0797c                 | '   fil->vfsdata = f;
0797c                 | '   return 0;
0797c     00 A6 05 F6 | 	mov	result1, #0
07980                 | LR__0801
07980     A7 F0 03 F6 | 	mov	ptra, fp
07984     B2 00 A0 FD | 	call	#popregs_
07988                 | _fatfs_cc_v_creat_ret
07988     2D 00 64 FD | 	ret
0798c                 | 
0798c                 | _fatfs_cc_v_close
0798c     02 4A 05 F6 | 	mov	COUNT_, #2
07990     A8 00 A0 FD | 	call	#pushregs_
07994     E1 D8 01 FB | 	rdlong	local01, arg01
07998     EC C2 01 F6 | 	mov	arg01, local01
0799c     02 00 00 FF 
079a0     14 C2 05 F1 | 	add	arg01, ##1044
079a4     48 E4 BF FD | 	call	#_fatfs_cc_f_close
079a8     D3 DA 01 F6 | 	mov	local02, result1
079ac     EC C2 01 F6 | 	mov	arg01, local01
079b0                 | '     return _gc_free(ptr);
079b0     DC 76 B0 FD | 	call	#__system___gc_free
079b4                 | '     FAT_FIL *f = fil->vfsdata;
079b4                 | '     r=f_close(&f->fil);
079b4                 | '     free(f);
079b4                 | '     return _set_dos_error(r);
079b4     ED C2 01 F6 | 	mov	arg01, local02
079b8     84 FE BF FD | 	call	#_fatfs_cc__set_dos_error_0466
079bc     A7 F0 03 F6 | 	mov	ptra, fp
079c0     B2 00 A0 FD | 	call	#popregs_
079c4                 | _fatfs_cc_v_close_ret
079c4     2D 00 64 FD | 	ret
079c8                 | 
079c8                 | _fatfs_cc_v_opendir
079c8     04 4A 05 F6 | 	mov	COUNT_, #4
079cc     A8 00 A0 FD | 	call	#pushregs_
079d0     E1 D8 01 F6 | 	mov	local01, arg01
079d4     E2 DA 01 F6 | 	mov	local02, arg02
079d8     2C C2 05 F6 | 	mov	arg01, #44
079dc                 | '     return _gc_alloc(size);
079dc     10 C4 05 F6 | 	mov	arg02, #16
079e0     A8 75 B0 FD | 	call	#__system___gc_doalloc
079e4     D3 DC 09 F6 | 	mov	local03, result1 wz
079e8                 | ' #line 158 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
079e8                 | '       return _seterror( 7 );
079e8     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
079ec     C9 0E 68 AC |  if_e	wrlong	#7, ptr___system__dat__
079f0     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
079f4     01 A6 65 A6 |  if_e	neg	result1, #1
079f8     34 00 90 AD |  if_e	jmp	#LR__0811
079fc     ED C4 01 F6 | 	mov	arg02, local02
07a00     EE C2 01 F6 | 	mov	arg01, local03
07a04     34 EB BF FD | 	call	#_fatfs_cc_f_opendir
07a08     D3 DE 09 F6 | 	mov	local04, result1 wz
07a0c     14 00 90 AD |  if_e	jmp	#LR__0810
07a10     EE C2 01 F6 | 	mov	arg01, local03
07a14                 | '     return _gc_free(ptr);
07a14     78 76 B0 FD | 	call	#__system___gc_free
07a18                 | '         free(f);
07a18                 | '         return _set_dos_error(r);
07a18     EF C2 01 F6 | 	mov	arg01, local04
07a1c     20 FE BF FD | 	call	#_fatfs_cc__set_dos_error_0466
07a20     0C 00 90 FD | 	jmp	#LR__0811
07a24                 | LR__0810
07a24     04 D8 05 F1 | 	add	local01, #4
07a28     EC DC 61 FC | 	wrlong	local03, local01
07a2c                 | '     }
07a2c                 | '     dir->vfsdata = f;
07a2c                 | '     return 0;
07a2c     00 A6 05 F6 | 	mov	result1, #0
07a30                 | LR__0811
07a30     A7 F0 03 F6 | 	mov	ptra, fp
07a34     B2 00 A0 FD | 	call	#popregs_
07a38                 | _fatfs_cc_v_opendir_ret
07a38     2D 00 64 FD | 	ret
07a3c                 | 
07a3c                 | _fatfs_cc_v_closedir
07a3c     02 4A 05 F6 | 	mov	COUNT_, #2
07a40     A8 00 A0 FD | 	call	#pushregs_
07a44     04 C2 05 F1 | 	add	arg01, #4
07a48     E1 D8 01 FB | 	rdlong	local01, arg01
07a4c     EC C2 01 F6 | 	mov	arg01, local01
07a50     9C EC BF FD | 	call	#_fatfs_cc_f_closedir
07a54     D3 DA 01 F6 | 	mov	local02, result1
07a58     EC C2 01 F6 | 	mov	arg01, local01
07a5c                 | '     return _gc_free(ptr);
07a5c     30 76 B0 FD | 	call	#__system___gc_free
07a60     00 DA 0D F2 | 	cmp	local02, #0 wz
07a64     ED C2 01 56 |  if_ne	mov	arg01, local02
07a68     D4 FD BF 5D |  if_ne	call	#_fatfs_cc__set_dos_error_0466
07a6c                 | '     return r;
07a6c     ED A6 01 F6 | 	mov	result1, local02
07a70     A7 F0 03 F6 | 	mov	ptra, fp
07a74     B2 00 A0 FD | 	call	#popregs_
07a78                 | _fatfs_cc_v_closedir_ret
07a78     2D 00 64 FD | 	ret
07a7c                 | 
07a7c                 | _fatfs_cc_v_readdir
07a7c     01 4A 05 F6 | 	mov	COUNT_, #1
07a80     A8 00 A0 FD | 	call	#pushregs_
07a84     2C F0 07 F1 | 	add	ptra, #44
07a88     04 4E 05 F1 | 	add	fp, #4
07a8c     A7 C2 61 FC | 	wrlong	arg01, fp
07a90     04 4E 05 F1 | 	add	fp, #4
07a94     A7 C4 61 FC | 	wrlong	arg02, fp
07a98     04 4E 85 F1 | 	sub	fp, #4
07a9c     A7 C4 01 FB | 	rdlong	arg02, fp
07aa0     04 C4 05 F1 | 	add	arg02, #4
07aa4     E2 C2 01 FB | 	rdlong	arg01, arg02
07aa8     08 4E 05 F1 | 	add	fp, #8
07aac     A7 C4 01 F6 | 	mov	arg02, fp
07ab0     0C 4E 85 F1 | 	sub	fp, #12
07ab4     94 EC BF FD | 	call	#_fatfs_cc_f_readdir
07ab8     28 4E 05 F1 | 	add	fp, #40
07abc     A7 A6 61 FC | 	wrlong	result1, fp
07ac0     28 4E 85 F1 | 	sub	fp, #40
07ac4     00 A6 0D F2 | 	cmp	result1, #0 wz
07ac8     14 00 90 AD |  if_e	jmp	#LR__0820
07acc                 | '         return _set_dos_error(r);
07acc     28 4E 05 F1 | 	add	fp, #40
07ad0     A7 C2 01 FB | 	rdlong	arg01, fp
07ad4     28 4E 85 F1 | 	sub	fp, #40
07ad8     64 FD BF FD | 	call	#_fatfs_cc__set_dos_error_0466
07adc     B0 00 90 FD | 	jmp	#LR__0823
07ae0                 | LR__0820
07ae0     18 4E 05 F1 | 	add	fp, #24
07ae4     A7 C4 C9 FA | 	rdbyte	arg02, fp wz
07ae8     18 4E 85 F1 | 	sub	fp, #24
07aec                 | '         return -1;
07aec     01 A6 65 A6 |  if_e	neg	result1, #1
07af0     9C 00 90 AD |  if_e	jmp	#LR__0823
07af4     08 4E 05 F1 | 	add	fp, #8
07af8     A7 C2 01 FB | 	rdlong	arg01, fp
07afc     10 4E 05 F1 | 	add	fp, #16
07b00     A7 C4 01 F6 | 	mov	arg02, fp
07b04     18 4E 85 F1 | 	sub	fp, #24
07b08     50 69 B0 FD | 	call	#__system____builtin_strcpy
07b0c     14 4E 05 F1 | 	add	fp, #20
07b10     A7 A6 C1 FA | 	rdbyte	result1, fp
07b14     14 4E 85 F1 | 	sub	fp, #20
07b18     10 A6 CD F7 | 	test	result1, #16 wz
07b1c     18 00 90 AD |  if_e	jmp	#LR__0821
07b20     08 4E 05 F1 | 	add	fp, #8
07b24     A7 A6 01 FB | 	rdlong	result1, fp
07b28     08 4E 85 F1 | 	sub	fp, #8
07b2c     50 A6 05 F1 | 	add	result1, #80
07b30     D3 02 48 FC | 	wrbyte	#1, result1
07b34     14 00 90 FD | 	jmp	#LR__0822
07b38                 | LR__0821
07b38     08 4E 05 F1 | 	add	fp, #8
07b3c     A7 A6 01 FB | 	rdlong	result1, fp
07b40     08 4E 85 F1 | 	sub	fp, #8
07b44     50 A6 05 F1 | 	add	result1, #80
07b48     D3 00 48 FC | 	wrbyte	#0, result1
07b4c                 | LR__0822
07b4c     08 4E 05 F1 | 	add	fp, #8
07b50     A7 A6 01 FB | 	rdlong	result1, fp
07b54     04 4E 05 F1 | 	add	fp, #4
07b58     A7 C4 01 FB | 	rdlong	arg02, fp
07b5c     48 A6 05 F1 | 	add	result1, #72
07b60     D3 C4 61 FC | 	wrlong	arg02, result1
07b64     04 4E 85 F1 | 	sub	fp, #4
07b68     A7 D8 01 FB | 	rdlong	local01, fp
07b6c     08 4E 05 F1 | 	add	fp, #8
07b70     A7 C2 E1 FA | 	rdword	arg01, fp
07b74     02 4E 05 F1 | 	add	fp, #2
07b78     A7 C4 E1 FA | 	rdword	arg02, fp
07b7c     12 4E 85 F1 | 	sub	fp, #18
07b80     E4 FB BF FD | 	call	#_fatfs_cc_unixtime_0464
07b84     4C D8 05 F1 | 	add	local01, #76
07b88     EC A6 61 FC | 	wrlong	result1, local01
07b8c                 | '         ent->d_type =  (0) ;
07b8c                 | '     }
07b8c                 | '     ent->d_size = finfo.fsize;
07b8c                 | '     ent->d_mtime = unixtime(finfo.fdate, finfo.ftime);
07b8c                 | '     return 0;
07b8c     00 A6 05 F6 | 	mov	result1, #0
07b90                 | LR__0823
07b90     A7 F0 03 F6 | 	mov	ptra, fp
07b94     B2 00 A0 FD | 	call	#popregs_
07b98                 | _fatfs_cc_v_readdir_ret
07b98     2D 00 64 FD | 	ret
07b9c                 | 
07b9c                 | _fatfs_cc_v_stat
07b9c     03 4A 05 F6 | 	mov	COUNT_, #3
07ba0     A8 00 A0 FD | 	call	#pushregs_
07ba4     30 F0 07 F1 | 	add	ptra, #48
07ba8     04 4E 05 F1 | 	add	fp, #4
07bac     A7 C2 61 FC | 	wrlong	arg01, fp
07bb0     04 4E 05 F1 | 	add	fp, #4
07bb4     A7 C4 61 FC | 	wrlong	arg02, fp
07bb8     08 4E 85 F1 | 	sub	fp, #8
07bbc     E2 C2 01 F6 | 	mov	arg01, arg02
07bc0     00 C4 05 F6 | 	mov	arg02, #0
07bc4     30 C6 05 F6 | 	mov	arg03, #48
07bc8     98 00 A0 FD | 	call	#\builtin_bytefill_
07bcc     04 4E 05 F1 | 	add	fp, #4
07bd0     A7 A6 01 FB | 	rdlong	result1, fp
07bd4     04 4E 85 F1 | 	sub	fp, #4
07bd8     D3 A6 C9 FA | 	rdbyte	result1, result1 wz
07bdc     2C 00 90 AD |  if_e	jmp	#LR__0830
07be0     04 4E 05 F1 | 	add	fp, #4
07be4     A7 A6 01 FB | 	rdlong	result1, fp
07be8     04 4E 85 F1 | 	sub	fp, #4
07bec     D3 A6 C1 FA | 	rdbyte	result1, result1
07bf0     2E A6 0D F2 | 	cmp	result1, #46 wz
07bf4     04 4E 05 A1 |  if_e	add	fp, #4
07bf8     A7 D8 01 AB |  if_e	rdlong	local01, fp
07bfc     04 4E 85 A1 |  if_e	sub	fp, #4
07c00     01 D8 05 A1 |  if_e	add	local01, #1
07c04     EC DA C9 AA |  if_e	rdbyte	local02, local01 wz
07c08     18 00 90 5D |  if_ne	jmp	#LR__0831
07c0c                 | LR__0830
07c0c     18 4E 05 F1 | 	add	fp, #24
07c10     A7 20 48 FC | 	wrbyte	#16, fp
07c14     0C 4E 85 F1 | 	sub	fp, #12
07c18     A7 00 68 FC | 	wrlong	#0, fp
07c1c     0C 4E 85 F1 | 	sub	fp, #12
07c20     24 00 90 FD | 	jmp	#LR__0832
07c24                 | LR__0831
07c24     04 4E 05 F1 | 	add	fp, #4
07c28     A7 C2 01 FB | 	rdlong	arg01, fp
07c2c     0C 4E 05 F1 | 	add	fp, #12
07c30     A7 C4 01 F6 | 	mov	arg02, fp
07c34     10 4E 85 F1 | 	sub	fp, #16
07c38     2C EC BF FD | 	call	#_fatfs_cc_f_stat
07c3c     0C 4E 05 F1 | 	add	fp, #12
07c40     A7 A6 61 FC | 	wrlong	result1, fp
07c44     0C 4E 85 F1 | 	sub	fp, #12
07c48                 | LR__0832
07c48     0C 4E 05 F1 | 	add	fp, #12
07c4c     A7 DA 09 FB | 	rdlong	local02, fp wz
07c50     0C 4E 85 F1 | 	sub	fp, #12
07c54     14 00 90 AD |  if_e	jmp	#LR__0833
07c58                 | '         return _set_dos_error(r);
07c58     0C 4E 05 F1 | 	add	fp, #12
07c5c     A7 C2 01 FB | 	rdlong	arg01, fp
07c60     0C 4E 85 F1 | 	sub	fp, #12
07c64     D8 FB BF FD | 	call	#_fatfs_cc__set_dos_error_0466
07c68     14 01 90 FD | 	jmp	#LR__0834
07c6c                 | LR__0833
07c6c     2C 4E 05 F1 | 	add	fp, #44
07c70     A7 48 6A FC | 	wrlong	#292, fp
07c74     14 4E 85 F1 | 	sub	fp, #20
07c78     A7 DC C1 FA | 	rdbyte	local03, fp
07c7c     18 4E 85 F1 | 	sub	fp, #24
07c80     01 DC CD F7 | 	test	local03, #1 wz
07c84     2C 4E 05 A1 |  if_e	add	fp, #44
07c88     A7 DC 01 AB |  if_e	rdlong	local03, fp
07c8c     92 DC 45 A5 |  if_e	or	local03, #146
07c90     A7 DC 61 AC |  if_e	wrlong	local03, fp
07c94     2C 4E 85 A1 |  if_e	sub	fp, #44
07c98     18 4E 05 F1 | 	add	fp, #24
07c9c     A7 DC C1 FA | 	rdbyte	local03, fp
07ca0     18 4E 85 F1 | 	sub	fp, #24
07ca4     10 DC CD F7 | 	test	local03, #16 wz
07ca8     2C 4E 05 51 |  if_ne	add	fp, #44
07cac     A7 DC 01 5B |  if_ne	rdlong	local03, fp
07cb0     08 00 00 5F 
07cb4     49 DC 45 55 |  if_ne	or	local03, ##4169
07cb8     A7 DC 61 5C |  if_ne	wrlong	local03, fp
07cbc     2C 4E 85 51 |  if_ne	sub	fp, #44
07cc0     08 4E 05 F1 | 	add	fp, #8
07cc4     A7 DC 01 FB | 	rdlong	local03, fp
07cc8     24 4E 05 F1 | 	add	fp, #36
07ccc     A7 DA 01 FB | 	rdlong	local02, fp
07cd0     08 DC 05 F1 | 	add	local03, #8
07cd4     EE DA 61 FC | 	wrlong	local02, local03
07cd8     24 4E 85 F1 | 	sub	fp, #36
07cdc     A7 DC 01 FB | 	rdlong	local03, fp
07ce0     0C DC 05 F1 | 	add	local03, #12
07ce4     EE 02 68 FC | 	wrlong	#1, local03
07ce8     A7 DC 01 FB | 	rdlong	local03, fp
07cec     08 4E 05 F1 | 	add	fp, #8
07cf0     A7 DA 01 FB | 	rdlong	local02, fp
07cf4     18 DC 05 F1 | 	add	local03, #24
07cf8     EE DA 61 FC | 	wrlong	local02, local03
07cfc     08 4E 85 F1 | 	sub	fp, #8
07d00     A7 DC 01 FB | 	rdlong	local03, fp
07d04     1C DC 05 F1 | 	add	local03, #28
07d08     01 00 80 FF 
07d0c     EE 00 68 FC | 	wrlong	##512, local03
07d10     A7 DA 01 FB | 	rdlong	local02, fp
07d14     ED DC 01 F6 | 	mov	local03, local02
07d18     18 DA 05 F1 | 	add	local02, #24
07d1c     ED DA 01 FB | 	rdlong	local02, local02
07d20     FF DB 05 F1 | 	add	local02, #511
07d24     ED DA 51 F6 | 	abs	local02, local02 wc
07d28     09 DA 45 F0 | 	shr	local02, #9
07d2c     ED DA 81 F6 | 	negc	local02, local02
07d30     20 DC 05 F1 | 	add	local03, #32
07d34     EE DA 61 FC | 	wrlong	local02, local03
07d38     A7 DA 01 FB | 	rdlong	local02, fp
07d3c     ED DC 01 F6 | 	mov	local03, local02
07d40     ED D8 01 F6 | 	mov	local01, local02
07d44     0C 4E 05 F1 | 	add	fp, #12
07d48     A7 C2 E1 FA | 	rdword	arg01, fp
07d4c     02 4E 05 F1 | 	add	fp, #2
07d50     A7 C4 E1 FA | 	rdword	arg02, fp
07d54     16 4E 85 F1 | 	sub	fp, #22
07d58     0C FA BF FD | 	call	#_fatfs_cc_unixtime_0464
07d5c     2C D8 05 F1 | 	add	local01, #44
07d60     EC A6 61 FC | 	wrlong	result1, local01
07d64     28 DA 05 F1 | 	add	local02, #40
07d68     ED A6 61 FC | 	wrlong	result1, local02
07d6c     24 DC 05 F1 | 	add	local03, #36
07d70     EE A6 61 FC | 	wrlong	result1, local03
07d74                 | '         mode |=  0010000  |  0100  |  0010  |  0001 ;
07d74                 | '     }
07d74                 | '     buf->st_mode = mode;
07d74                 | '     buf->st_nlink = 1;
07d74                 | '     buf->st_size = finfo.fsize;
07d74                 | '     buf->st_blksize = 512;
07d74                 | '     buf->st_blocks = (buf->st_size + 511) / 512;
07d74                 | '     buf->st_atime = buf->st_mtime = buf->st_ctime = unixtime(finfo.fdate, finfo.ftime);
07d74                 | ' #line 249 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
07d74                 | '     return r;
07d74     0C 4E 05 F1 | 	add	fp, #12
07d78     A7 A6 01 FB | 	rdlong	result1, fp
07d7c     0C 4E 85 F1 | 	sub	fp, #12
07d80                 | LR__0834
07d80     A7 F0 03 F6 | 	mov	ptra, fp
07d84     B2 00 A0 FD | 	call	#popregs_
07d88                 | _fatfs_cc_v_stat_ret
07d88     2D 00 64 FD | 	ret
07d8c                 | 
07d8c                 | _fatfs_cc_v_read
07d8c     00 4A 05 F6 | 	mov	COUNT_, #0
07d90     A8 00 A0 FD | 	call	#pushregs_
07d94     1C F0 07 F1 | 	add	ptra, #28
07d98     04 4E 05 F1 | 	add	fp, #4
07d9c     A7 C2 61 FC | 	wrlong	arg01, fp
07da0     04 4E 05 F1 | 	add	fp, #4
07da4     A7 C4 61 FC | 	wrlong	arg02, fp
07da8     04 4E 05 F1 | 	add	fp, #4
07dac     A7 C6 61 FC | 	wrlong	arg03, fp
07db0     08 4E 85 F1 | 	sub	fp, #8
07db4     A7 C2 01 FB | 	rdlong	arg01, fp
07db8     E1 C2 09 FB | 	rdlong	arg01, arg01 wz
07dbc     0C 4E 05 F1 | 	add	fp, #12
07dc0     A7 C2 61 FC | 	wrlong	arg01, fp
07dc4     10 4E 85 F1 | 	sub	fp, #16
07dc8                 | '         return _seterror( 5 );
07dc8     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
07dcc     C9 0A 68 AC |  if_e	wrlong	#5, ptr___system__dat__
07dd0     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
07dd4     01 A6 65 A6 |  if_e	neg	result1, #1
07dd8     B8 00 90 AD |  if_e	jmp	#LR__0842
07ddc     10 4E 05 F1 | 	add	fp, #16
07de0     A7 C2 01 FB | 	rdlong	arg01, fp
07de4     02 00 00 FF 
07de8     14 C2 05 F1 | 	add	arg01, ##1044
07dec     08 4E 85 F1 | 	sub	fp, #8
07df0     A7 C4 01 FB | 	rdlong	arg02, fp
07df4     04 4E 05 F1 | 	add	fp, #4
07df8     A7 C6 01 FB | 	rdlong	arg03, fp
07dfc     0C 4E 05 F1 | 	add	fp, #12
07e00     A7 C8 01 F6 | 	mov	arg04, fp
07e04     18 4E 85 F1 | 	sub	fp, #24
07e08     44 CF BF FD | 	call	#_fatfs_cc_f_read
07e0c     14 4E 05 F1 | 	add	fp, #20
07e10     A7 A6 61 FC | 	wrlong	result1, fp
07e14     14 4E 85 F1 | 	sub	fp, #20
07e18     00 A6 0D F2 | 	cmp	result1, #0 wz
07e1c     34 00 90 AD |  if_e	jmp	#LR__0840
07e20     04 4E 05 F1 | 	add	fp, #4
07e24     A7 C8 01 FB | 	rdlong	arg04, fp
07e28     E4 C6 01 F6 | 	mov	arg03, arg04
07e2c     08 C8 05 F1 | 	add	arg04, #8
07e30     E4 C8 01 FB | 	rdlong	arg04, arg04
07e34     20 C8 45 F5 | 	or	arg04, #32
07e38     08 C6 05 F1 | 	add	arg03, #8
07e3c     E3 C8 61 FC | 	wrlong	arg04, arg03
07e40                 | '         fil->state |=  (0x20) ;
07e40                 | '         return _set_dos_error(r);
07e40     10 4E 05 F1 | 	add	fp, #16
07e44     A7 C2 01 FB | 	rdlong	arg01, fp
07e48     14 4E 85 F1 | 	sub	fp, #20
07e4c     F0 F9 BF FD | 	call	#_fatfs_cc__set_dos_error_0466
07e50     40 00 90 FD | 	jmp	#LR__0842
07e54                 | LR__0840
07e54     18 4E 05 F1 | 	add	fp, #24
07e58     A7 A6 09 FB | 	rdlong	result1, fp wz
07e5c     18 4E 85 F1 | 	sub	fp, #24
07e60     24 00 90 5D |  if_ne	jmp	#LR__0841
07e64     04 4E 05 F1 | 	add	fp, #4
07e68     A7 A6 01 FB | 	rdlong	result1, fp
07e6c     D3 C8 01 F6 | 	mov	arg04, result1
07e70     04 4E 85 F1 | 	sub	fp, #4
07e74     08 A6 05 F1 | 	add	result1, #8
07e78     D3 A6 01 FB | 	rdlong	result1, result1
07e7c     10 A6 45 F5 | 	or	result1, #16
07e80     08 C8 05 F1 | 	add	arg04, #8
07e84     E4 A6 61 FC | 	wrlong	result1, arg04
07e88                 | LR__0841
07e88                 | '         fil->state |=  (0x10) ;
07e88                 | '     }
07e88                 | '     return x;
07e88     18 4E 05 F1 | 	add	fp, #24
07e8c     A7 A6 01 FB | 	rdlong	result1, fp
07e90     18 4E 85 F1 | 	sub	fp, #24
07e94                 | LR__0842
07e94     A7 F0 03 F6 | 	mov	ptra, fp
07e98     B2 00 A0 FD | 	call	#popregs_
07e9c                 | _fatfs_cc_v_read_ret
07e9c     2D 00 64 FD | 	ret
07ea0                 | 
07ea0                 | _fatfs_cc_v_write
07ea0     00 4A 05 F6 | 	mov	COUNT_, #0
07ea4     A8 00 A0 FD | 	call	#pushregs_
07ea8     1C F0 07 F1 | 	add	ptra, #28
07eac     04 4E 05 F1 | 	add	fp, #4
07eb0     A7 C2 61 FC | 	wrlong	arg01, fp
07eb4     04 4E 05 F1 | 	add	fp, #4
07eb8     A7 C4 61 FC | 	wrlong	arg02, fp
07ebc     04 4E 05 F1 | 	add	fp, #4
07ec0     A7 C6 61 FC | 	wrlong	arg03, fp
07ec4     08 4E 85 F1 | 	sub	fp, #8
07ec8     A7 C2 01 FB | 	rdlong	arg01, fp
07ecc     E1 C2 09 FB | 	rdlong	arg01, arg01 wz
07ed0     0C 4E 05 F1 | 	add	fp, #12
07ed4     A7 C2 61 FC | 	wrlong	arg01, fp
07ed8     10 4E 85 F1 | 	sub	fp, #16
07edc                 | '         return _seterror( 5 );
07edc     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
07ee0     C9 0A 68 AC |  if_e	wrlong	#5, ptr___system__dat__
07ee4     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
07ee8     01 A6 65 A6 |  if_e	neg	result1, #1
07eec     84 00 90 AD |  if_e	jmp	#LR__0851
07ef0     10 4E 05 F1 | 	add	fp, #16
07ef4     A7 C2 01 FB | 	rdlong	arg01, fp
07ef8     02 00 00 FF 
07efc     14 C2 05 F1 | 	add	arg01, ##1044
07f00     08 4E 85 F1 | 	sub	fp, #8
07f04     A7 C4 01 FB | 	rdlong	arg02, fp
07f08     04 4E 05 F1 | 	add	fp, #4
07f0c     A7 C6 01 FB | 	rdlong	arg03, fp
07f10     0C 4E 05 F1 | 	add	fp, #12
07f14     A7 C8 01 F6 | 	mov	arg04, fp
07f18     18 4E 85 F1 | 	sub	fp, #24
07f1c     CC D4 BF FD | 	call	#_fatfs_cc_f_write
07f20     14 4E 05 F1 | 	add	fp, #20
07f24     A7 A6 61 FC | 	wrlong	result1, fp
07f28     14 4E 85 F1 | 	sub	fp, #20
07f2c     00 A6 0D F2 | 	cmp	result1, #0 wz
07f30     34 00 90 AD |  if_e	jmp	#LR__0850
07f34     04 4E 05 F1 | 	add	fp, #4
07f38     A7 C8 01 FB | 	rdlong	arg04, fp
07f3c     E4 C6 01 F6 | 	mov	arg03, arg04
07f40     08 C8 05 F1 | 	add	arg04, #8
07f44     E4 C8 01 FB | 	rdlong	arg04, arg04
07f48     20 C8 45 F5 | 	or	arg04, #32
07f4c     08 C6 05 F1 | 	add	arg03, #8
07f50     E3 C8 61 FC | 	wrlong	arg04, arg03
07f54                 | '         fil->state |=  (0x20) ;
07f54                 | '         return _set_dos_error(r);
07f54     10 4E 05 F1 | 	add	fp, #16
07f58     A7 C2 01 FB | 	rdlong	arg01, fp
07f5c     14 4E 85 F1 | 	sub	fp, #20
07f60     DC F8 BF FD | 	call	#_fatfs_cc__set_dos_error_0466
07f64     0C 00 90 FD | 	jmp	#LR__0851
07f68                 | LR__0850
07f68                 | '     }
07f68                 | '     return x;
07f68     18 4E 05 F1 | 	add	fp, #24
07f6c     A7 A6 01 FB | 	rdlong	result1, fp
07f70     18 4E 85 F1 | 	sub	fp, #24
07f74                 | LR__0851
07f74     A7 F0 03 F6 | 	mov	ptra, fp
07f78     B2 00 A0 FD | 	call	#popregs_
07f7c                 | _fatfs_cc_v_write_ret
07f7c     2D 00 64 FD | 	ret
07f80                 | 
07f80                 | _fatfs_cc_v_lseek
07f80     04 4A 05 F6 | 	mov	COUNT_, #4
07f84     A8 00 A0 FD | 	call	#pushregs_
07f88     E2 D8 01 F6 | 	mov	local01, arg02
07f8c     E3 DA 01 F6 | 	mov	local02, arg03
07f90     E1 DC 01 FB | 	rdlong	local03, arg01
07f94     02 00 00 FF 
07f98     14 DC 0D F1 | 	add	local03, ##1044 wz
07f9c                 | '         return _seterror( 5 );
07f9c     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
07fa0     C9 0A 68 AC |  if_e	wrlong	#5, ptr___system__dat__
07fa4     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
07fa8     01 A6 65 A6 |  if_e	neg	result1, #1
07fac     4C 00 90 AD |  if_e	jmp	#LR__0862
07fb0     00 DA 0D F2 | 	cmp	local02, #0 wz
07fb4     24 00 90 AD |  if_e	jmp	#LR__0860
07fb8     01 DA 0D F2 | 	cmp	local02, #1 wz
07fbc     14 DC 05 A1 |  if_e	add	local03, #20
07fc0     EE DE 01 AB |  if_e	rdlong	local04, local03
07fc4     14 DC 85 A1 |  if_e	sub	local03, #20
07fc8     EF D8 01 A1 |  if_e	add	local01, local04
07fcc     0C DC 05 51 |  if_ne	add	local03, #12
07fd0     EE DE 01 5B |  if_ne	rdlong	local04, local03
07fd4     0C DC 85 51 |  if_ne	sub	local03, #12
07fd8     EF D8 01 51 |  if_ne	add	local01, local04
07fdc                 | LR__0860
07fdc     EC C4 01 F6 | 	mov	arg02, local01
07fe0     EE C2 01 F6 | 	mov	arg01, local03
07fe4     88 DE BF FD | 	call	#_fatfs_cc_f_lseek
07fe8     D3 C2 09 F6 | 	mov	arg01, result1 wz
07fec     08 00 90 AD |  if_e	jmp	#LR__0861
07ff0                 | '         return _set_dos_error(result);
07ff0     4C F8 BF FD | 	call	#_fatfs_cc__set_dos_error_0466
07ff4     04 00 90 FD | 	jmp	#LR__0862
07ff8                 | LR__0861
07ff8                 | '     }
07ff8                 | '     return offset;
07ff8     EC A6 01 F6 | 	mov	result1, local01
07ffc                 | LR__0862
07ffc     A7 F0 03 F6 | 	mov	ptra, fp
08000     B2 00 A0 FD | 	call	#popregs_
08004                 | _fatfs_cc_v_lseek_ret
08004     2D 00 64 FD | 	ret
08008                 | 
08008                 | _fatfs_cc_v_ioctl
08008                 | ' {
08008                 | '     return _seterror( 10 );
08008     20 92 05 F1 | 	add	ptr___system__dat__, #32
0800c     C9 14 68 FC | 	wrlong	#10, ptr___system__dat__
08010     20 92 85 F1 | 	sub	ptr___system__dat__, #32
08014     01 A6 65 F6 | 	neg	result1, #1
08018                 | _fatfs_cc_v_ioctl_ret
08018     2D 00 64 FD | 	ret
0801c                 | 
0801c                 | _fatfs_cc_v_mkdir
0801c     60 EB BF FD | 	call	#_fatfs_cc_f_mkdir
08020     D3 C2 01 F6 | 	mov	arg01, result1
08024                 | ' 
08024                 | '     r = f_mkdir(name);
08024                 | '     return _set_dos_error(r);
08024     18 F8 BF FD | 	call	#_fatfs_cc__set_dos_error_0466
08028                 | _fatfs_cc_v_mkdir_ret
08028     2D 00 64 FD | 	ret
0802c                 | 
0802c                 | _fatfs_cc_v_remove
0802c     10 E9 BF FD | 	call	#_fatfs_cc_f_unlink
08030     D3 C2 01 F6 | 	mov	arg01, result1
08034                 | ' 
08034                 | '     r = f_unlink(name);
08034                 | '     return _set_dos_error(r);
08034     08 F8 BF FD | 	call	#_fatfs_cc__set_dos_error_0466
08038                 | _fatfs_cc_v_remove_ret
08038     2D 00 64 FD | 	ret
0803c                 | 
0803c                 | _fatfs_cc_v_rmdir
0803c     00 E9 BF FD | 	call	#_fatfs_cc_f_unlink
08040     D3 C2 01 F6 | 	mov	arg01, result1
08044                 | ' 
08044                 | '     r = f_unlink(name);
08044                 | '     return _set_dos_error(r);
08044     F8 F7 BF FD | 	call	#_fatfs_cc__set_dos_error_0466
08048                 | _fatfs_cc_v_rmdir_ret
08048     2D 00 64 FD | 	ret
0804c                 | 
0804c                 | _fatfs_cc_v_rename
0804c     4C EE BF FD | 	call	#_fatfs_cc_f_rename
08050     D3 C2 01 F6 | 	mov	arg01, result1
08054                 | '     return _set_dos_error(r);
08054     E8 F7 BF FD | 	call	#_fatfs_cc__set_dos_error_0466
08058                 | _fatfs_cc_v_rename_ret
08058     2D 00 64 FD | 	ret
0805c                 | 
0805c                 | _fatfs_cc_v_open
0805c     07 4A 05 F6 | 	mov	COUNT_, #7
08060     A8 00 A0 FD | 	call	#pushregs_
08064     E1 D8 01 F6 | 	mov	local01, arg01
08068     E2 DA 01 F6 | 	mov	local02, arg02
0806c     E3 DC 01 F6 | 	mov	local03, arg03
08070     03 00 00 FF 
08074     3C C2 05 F6 | 	mov	arg01, ##1596
08078                 | '     return _gc_alloc(size);
08078     10 C4 05 F6 | 	mov	arg02, #16
0807c     0C 6F B0 FD | 	call	#__system___gc_doalloc
08080     D3 DE 09 F6 | 	mov	local04, result1 wz
08084                 | '       return _seterror( 7 );
08084     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
08088     C9 0E 68 AC |  if_e	wrlong	#7, ptr___system__dat__
0808c     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
08090     01 A6 65 A6 |  if_e	neg	result1, #1
08094     90 00 90 AD |  if_e	jmp	#LR__0876
08098     EF C2 01 F6 | 	mov	arg01, local04
0809c     00 C4 05 F6 | 	mov	arg02, #0
080a0     03 00 00 FF 
080a4     3C C6 05 F6 | 	mov	arg03, ##1596
080a8     98 00 A0 FD | 	call	#\builtin_bytefill_
080ac                 | '   switch (flags & 3) {
080ac     EE E0 01 F6 | 	mov	local05, local03
080b0     03 E0 0D F5 | 	and	local05, #3 wz
080b4     0C 00 90 AD |  if_e	jmp	#LR__0870
080b8     01 E0 0D F2 | 	cmp	local05, #1 wz
080bc     0C 00 90 AD |  if_e	jmp	#LR__0871
080c0     10 00 90 FD | 	jmp	#LR__0872
080c4                 | LR__0870
080c4     01 E2 05 F6 | 	mov	local06, #1
080c8                 | '       fs_flags =  0x01 ;
080c8                 | '       break;
080c8     0C 00 90 FD | 	jmp	#LR__0873
080cc                 | LR__0871
080cc     02 E2 05 F6 | 	mov	local06, #2
080d0                 | '       fs_flags =  0x02 ;
080d0                 | '       break;
080d0     04 00 90 FD | 	jmp	#LR__0873
080d4                 | LR__0872
080d4     03 E2 05 F6 | 	mov	local06, #3
080d8                 | '       fs_flags =  0x01  |  0x02 ;
080d8                 | '       break;
080d8                 | LR__0873
080d8     08 DC CD F7 | 	test	local03, #8 wz
080dc     18 E2 45 55 |  if_ne	or	local06, #24
080e0     08 00 90 5D |  if_ne	jmp	#LR__0874
080e4     20 DC CD F7 | 	test	local03, #32 wz
080e8     30 E2 45 55 |  if_ne	or	local06, #48
080ec                 | LR__0874
080ec     EF C2 01 F6 | 	mov	arg01, local04
080f0     02 00 00 FF 
080f4     14 C2 05 F1 | 	add	arg01, ##1044
080f8     ED C4 01 F6 | 	mov	arg02, local02
080fc     F1 C6 01 F6 | 	mov	arg03, local06
08100     78 C5 BF FD | 	call	#_fatfs_cc_f_open
08104     D3 E4 09 F6 | 	mov	local07, result1 wz
08108     14 00 90 AD |  if_e	jmp	#LR__0875
0810c     EF C2 01 F6 | 	mov	arg01, local04
08110                 | '     return _gc_free(ptr);
08110     7C 6F B0 FD | 	call	#__system___gc_free
08114                 | '     free(f);
08114                 | ' #line 417 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
08114                 | '     return _set_dos_error(r);
08114     F2 C2 01 F6 | 	mov	arg01, local07
08118     24 F7 BF FD | 	call	#_fatfs_cc__set_dos_error_0466
0811c     08 00 90 FD | 	jmp	#LR__0876
08120                 | LR__0875
08120     EC DE 61 FC | 	wrlong	local04, local01
08124                 | '   }
08124                 | '   fil->vfsdata = f;
08124                 | '   return 0;
08124     00 A6 05 F6 | 	mov	result1, #0
08128                 | LR__0876
08128     A7 F0 03 F6 | 	mov	ptra, fp
0812c     B2 00 A0 FD | 	call	#popregs_
08130                 | _fatfs_cc_v_open_ret
08130     2D 00 64 FD | 	ret
08134                 | 
08134                 | _fatfs_cc_v_flush
08134     E1 C2 01 FB | 	rdlong	arg01, arg01
08138     02 00 00 FF 
0813c     14 C2 0D F1 | 	add	arg01, ##1044 wz
08140                 | '         return _seterror( 5 );
08140     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
08144     C9 0A 68 AC |  if_e	wrlong	#5, ptr___system__dat__
08148     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
0814c     01 A6 65 A6 |  if_e	neg	result1, #1
08150     0C 00 90 AD |  if_e	jmp	#LR__0880
08154     88 DA BF FD | 	call	#_fatfs_cc_f_sync
08158     D3 C2 01 F6 | 	mov	arg01, result1
0815c                 | '     }
0815c                 | ' #line 437 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
0815c                 | '     result = f_sync(f);
0815c                 | ' #line 441 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
0815c                 | '     return _set_dos_error(result);
0815c     E0 F6 BF FD | 	call	#_fatfs_cc__set_dos_error_0466
08160                 | LR__0880
08160                 | _fatfs_cc_v_flush_ret
08160     2D 00 64 FD | 	ret
08164                 | 
08164                 | _fatfs_cc_v_init
08164                 | ' {
08164                 | '     return 0;
08164     00 A6 05 F6 | 	mov	result1, #0
08168                 | _fatfs_cc_v_init_ret
08168     2D 00 64 FD | 	ret
0816c                 | 
0816c                 | _fatfs_cc_v_deinit
0816c     7C 00 00 FF 
08170     69 C5 05 F6 | 	mov	arg02, ##@LR__2099
08174     00 C2 05 F6 | 	mov	arg01, #0
08178     00 C6 05 F6 | 	mov	arg03, #0
0817c     D8 C3 BF FD | 	call	#_fatfs_cc_f_mount
08180     08 90 05 F1 | 	add	objptr, #8
08184     C8 C2 01 FB | 	rdlong	arg01, objptr
08188     04 90 05 F1 | 	add	objptr, #4
0818c     C8 C4 01 FB | 	rdlong	arg02, objptr
08190     0C 90 85 F1 | 	sub	objptr, #12
08194     4C 6B B0 FD | 	call	#__system___freepins
08198                 | ' #line 462 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
08198                 | '     _freepins(f_pinmask);
08198                 | '     return 0;
08198     00 A6 05 F6 | 	mov	result1, #0
0819c                 | _fatfs_cc_v_deinit_ret
0819c     2D 00 64 FD | 	ret
081a0                 | 
081a0                 | _fatfs_cc_get_vfs
081a0     01 4A 05 F6 | 	mov	COUNT_, #1
081a4     A8 00 A0 FD | 	call	#pushregs_
081a8     E1 D8 01 F6 | 	mov	local01, arg01
081ac     50 C2 05 F6 | 	mov	arg01, #80
081b0     A8 6D B0 FD | 	call	#__system___gc_alloc_managed
081b4     D3 C2 01 F6 | 	mov	arg01, result1
081b8     C8 A6 01 F6 | 	mov	result1, objptr
081bc     14 A6 25 F4 | 	bith	result1, #20
081c0     E1 A6 61 FC | 	wrlong	result1, arg01
081c4     C8 A6 01 F6 | 	mov	result1, objptr
081c8     15 A6 25 F4 | 	bith	result1, #21
081cc     04 C2 05 F1 | 	add	arg01, #4
081d0     E1 A6 61 FC | 	wrlong	result1, arg01
081d4     C8 A6 01 F6 | 	mov	result1, objptr
081d8     34 A6 25 F4 | 	bith	result1, #52
081dc     04 C2 05 F1 | 	add	arg01, #4
081e0     E1 A6 61 FC | 	wrlong	result1, arg01
081e4     C8 A6 01 F6 | 	mov	result1, objptr
081e8     16 A6 25 F4 | 	bith	result1, #22
081ec     04 C2 05 F1 | 	add	arg01, #4
081f0     E1 A6 61 FC | 	wrlong	result1, arg01
081f4     C8 A6 01 F6 | 	mov	result1, objptr
081f8     00 28 00 FF 
081fc     00 A6 45 F5 | 	or	result1, ##5242880
08200     04 C2 05 F1 | 	add	arg01, #4
08204     E1 A6 61 FC | 	wrlong	result1, arg01
08208     C8 A6 01 F6 | 	mov	result1, objptr
0820c     35 A6 25 F4 | 	bith	result1, #53
08210     04 C2 05 F1 | 	add	arg01, #4
08214     E1 A6 61 FC | 	wrlong	result1, arg01
08218     04 C2 05 F1 | 	add	arg01, #4
0821c     E1 D8 61 FC | 	wrlong	local01, arg01
08220     04 C2 05 F1 | 	add	arg01, #4
08224     E1 00 68 FC | 	wrlong	#0, arg01
08228     C8 A6 01 F6 | 	mov	result1, objptr
0822c     54 A6 25 F4 | 	bith	result1, #84
08230     04 C2 05 F1 | 	add	arg01, #4
08234     E1 A6 61 FC | 	wrlong	result1, arg01
08238     C8 A6 01 F6 | 	mov	result1, objptr
0823c     17 A6 25 F4 | 	bith	result1, #23
08240     04 C2 05 F1 | 	add	arg01, #4
08244     E1 A6 61 FC | 	wrlong	result1, arg01
08248     C8 A6 01 F6 | 	mov	result1, objptr
0824c     00 48 00 FF 
08250     00 A6 45 F5 | 	or	result1, ##9437184
08254     04 C2 05 F1 | 	add	arg01, #4
08258     E1 A6 61 FC | 	wrlong	result1, arg01
0825c     C8 A6 01 F6 | 	mov	result1, objptr
08260     00 50 00 FF 
08264     00 A6 45 F5 | 	or	result1, ##10485760
08268     04 C2 05 F1 | 	add	arg01, #4
0826c     E1 A6 61 FC | 	wrlong	result1, arg01
08270     C8 A6 01 F6 | 	mov	result1, objptr
08274     00 58 00 FF 
08278     00 A6 45 F5 | 	or	result1, ##11534336
0827c     04 C2 05 F1 | 	add	arg01, #4
08280     E1 A6 61 FC | 	wrlong	result1, arg01
08284     C8 A6 01 F6 | 	mov	result1, objptr
08288     36 A6 25 F4 | 	bith	result1, #54
0828c     04 C2 05 F1 | 	add	arg01, #4
08290     E1 A6 61 FC | 	wrlong	result1, arg01
08294     C8 A6 01 F6 | 	mov	result1, objptr
08298     00 68 00 FF 
0829c     00 A6 45 F5 | 	or	result1, ##13631488
082a0     04 C2 05 F1 | 	add	arg01, #4
082a4     E1 A6 61 FC | 	wrlong	result1, arg01
082a8     C8 A6 01 F6 | 	mov	result1, objptr
082ac     55 A6 25 F4 | 	bith	result1, #85
082b0     04 C2 05 F1 | 	add	arg01, #4
082b4     E1 A6 61 FC | 	wrlong	result1, arg01
082b8     C8 A6 01 F6 | 	mov	result1, objptr
082bc     74 A6 25 F4 | 	bith	result1, #116
082c0     04 C2 05 F1 | 	add	arg01, #4
082c4     E1 A6 61 FC | 	wrlong	result1, arg01
082c8     C8 A6 01 F6 | 	mov	result1, objptr
082cc     18 A6 25 F4 | 	bith	result1, #24
082d0     04 C2 05 F1 | 	add	arg01, #4
082d4     E1 A6 61 FC | 	wrlong	result1, arg01
082d8     C8 A6 01 F6 | 	mov	result1, objptr
082dc     00 88 00 FF 
082e0     00 A6 45 F5 | 	or	result1, ##17825792
082e4     04 C2 05 F1 | 	add	arg01, #4
082e8     E1 A6 61 FC | 	wrlong	result1, arg01
082ec     C8 A6 01 F6 | 	mov	result1, objptr
082f0     00 90 00 FF 
082f4     00 A6 45 F5 | 	or	result1, ##18874368
082f8     04 C2 05 F1 | 	add	arg01, #4
082fc     E1 A6 61 FC | 	wrlong	result1, arg01
08300     4C C2 85 F1 | 	sub	arg01, #76
08304                 | ' 
08304                 | '     v->close = &v_close;
08304                 | '     v->read = &v_read;
08304                 | '     v->write = &v_write;
08304                 | '     v->lseek = &v_lseek;
08304                 | '     v->ioctl = &v_ioctl;
08304                 | '     v->flush = &v_flush;
08304                 | '     v->vfs_data = ptr;
08304                 | '     v->reserved = 0;
08304                 | ' 
08304                 | '     v->open = &v_open;
08304                 | '     v->creat = &v_creat;
08304                 | '     v->opendir = &v_opendir;
08304                 | '     v->closedir = &v_closedir;
08304                 | '     v->readdir = &v_readdir;
08304                 | '     v->stat = &v_stat;
08304                 | ' 
08304                 | '     v->mkdir = &v_mkdir;
08304                 | '     v->rmdir = &v_rmdir;
08304                 | ' 
08304                 | '     v->remove = &v_remove;
08304                 | '     v->rename = &v_rename;
08304                 | ' 
08304                 | '     v->init = &v_init;
08304                 | '     v->deinit = &v_deinit;
08304                 | ' 
08304                 | '     return v;
08304     E1 A6 01 F6 | 	mov	result1, arg01
08308     A7 F0 03 F6 | 	mov	ptra, fp
0830c     B2 00 A0 FD | 	call	#popregs_
08310                 | _fatfs_cc_get_vfs_ret
08310     2D 00 64 FD | 	ret
08314                 | 
08314                 | _fatfs_cc_xmit_mmc_0634
08314     10 90 05 F1 | 	add	objptr, #16
08318     C8 AA 01 FB | 	rdlong	_var01, objptr
0831c     08 90 05 F1 | 	add	objptr, #8
08320     C8 AC 01 FB | 	rdlong	_var02, objptr
08324     18 90 85 F1 | 	sub	objptr, #24
08328     40 AC 61 FD | 	dirl	_var02
0832c     28 02 64 FD | 	setq	#1
08330     E1 AE 01 FB | 	rdlong	_var03, arg01
08334     69 AE 61 FD | 	rev	_var03
08338     1B AE FD F9 | 	movbyts	_var03, #27
0833c     D6 AE 21 FC | 	wypin	_var03, _var02
08340     E2 AE 01 F6 | 	mov	_var03, arg02
08344     02 C4 4D F0 | 	shr	arg02, #2 wz
08348     03 AE 65 F0 | 	shl	_var03, #3
0834c     D5 AE 21 FC | 	wypin	_var03, _var01
08350     41 AC 61 FD | 	dirh	_var02
08354     08 C2 05 F1 | 	add	arg01, #8
08358     69 B0 61 FD | 	rev	_var04
0835c     1B B0 FD F9 | 	movbyts	_var04, #27
08360                 | LR__0890
08360     D6 B0 21 5C |  if_ne	wypin	_var04, _var02
08364     E1 B0 01 5B |  if_ne	rdlong	_var04, arg01
08368     04 C2 05 51 |  if_ne	add	arg01, #4
0836c     69 B0 61 5D |  if_ne	rev	_var04
08370     1B B0 FD 59 |  if_ne	movbyts	_var04, #27
08374                 | LR__0891
08374     40 AC 71 5D |  if_ne	testp	_var02 wc
08378     F8 FF 9F 1D |  if_a	jmp	#LR__0891
0837c     F8 C5 6D 5B |  if_ne	djnz	arg02, #LR__0890
08380                 | LR__0892
08380     40 AA 71 FD | 	testp	_var01 wc
08384     F8 FF 9F 3D |  if_ae	jmp	#LR__0892
08388     40 AC 61 FD | 	dirl	_var02
0838c     FF FF FF FF 
08390     D6 FE 2B FC | 	wypin	##-1, _var02
08394     41 AC 61 FD | 	dirh	_var02
08398                 | _fatfs_cc_xmit_mmc_0634_ret
08398     2D 00 64 FD | 	ret
0839c                 | 
0839c                 | _fatfs_cc_rcvr_mmc_0641
0839c     10 90 05 F1 | 	add	objptr, #16
083a0     C8 AA 01 FB | 	rdlong	_var01, objptr
083a4     0C 90 05 F1 | 	add	objptr, #12
083a8     C8 AC 01 FB | 	rdlong	_var02, objptr
083ac     1C 90 85 F1 | 	sub	objptr, #28
083b0     D6 02 08 FC | 	akpin	_var02
083b4     E2 AE 09 F6 | 	mov	_var03, arg02 wz
083b8     02 AE 4D F0 | 	shr	_var03, #2 wz
083bc     30 00 90 AD |  if_e	jmp	#LR__0902
083c0     D7 B0 01 F6 | 	mov	_var04, _var03
083c4     05 B0 65 F0 | 	shl	_var04, #5
083c8     D5 B0 21 FC | 	wypin	_var04, _var01
083cc     D6 7E 18 FC | 	wxpin	#63, _var02
083d0                 | LR__0900
083d0                 | LR__0901
083d0     40 AC 71 FD | 	testp	_var02 wc
083d4     F8 FF 9F 3D |  if_ae	jmp	#LR__0901
083d8     D6 B0 89 FA | 	rdpin	_var04, _var02
083dc     69 B0 61 FD | 	rev	_var04
083e0     1B B0 FD F9 | 	movbyts	_var04, #27
083e4     E1 B0 61 FC | 	wrlong	_var04, arg01
083e8     04 C2 05 F1 | 	add	arg01, #4
083ec     F8 AF 6D FB | 	djnz	_var03, #LR__0900
083f0                 | LR__0902
083f0     03 C4 0D F5 | 	and	arg02, #3 wz
083f4     24 00 90 AD |  if_e	jmp	#LR__0905
083f8     D6 4E 18 FC | 	wxpin	#39, _var02
083fc                 | LR__0903
083fc     D5 10 28 FC | 	wypin	#8, _var01
08400                 | LR__0904
08400     40 AC 71 FD | 	testp	_var02 wc
08404     F8 FF 9F 3D |  if_ae	jmp	#LR__0904
08408     D6 B0 89 FA | 	rdpin	_var04, _var02
0840c     69 B0 61 FD | 	rev	_var04
08410     E1 B0 41 FC | 	wrbyte	_var04, arg01
08414     01 C2 05 F1 | 	add	arg01, #1
08418     F8 C5 6D FB | 	djnz	arg02, #LR__0903
0841c                 | LR__0905
0841c                 | _fatfs_cc_rcvr_mmc_0641_ret
0841c     2D 00 64 FD | 	ret
08420                 | 
08420                 | _fatfs_cc_wait_ready_0645
08420     03 4A 05 F6 | 	mov	COUNT_, #3
08424     A8 00 A0 FD | 	call	#pushregs_
08428     F8 D9 01 F6 | 	mov	local01, ptra
0842c     1A DA 61 FD | 	getct	local02
08430     14 DC 05 FB | 	rdlong	local03, #20
08434     01 DC 45 F0 | 	shr	local03, #1
08438                 | ' 	UINT tmr, tmout;
08438                 | ' 
08438                 | ' 	tmr = _cnt();
08438                 | ' 	tmout =  (*(uint32_t *)0x14)  >> 1;
08438                 | ' 	for(;;) {
08438     04 F0 07 F1 | 	add	ptra, #4
0843c                 | LR__0910
0843c     EC C2 01 F6 | 	mov	arg01, local01
08440     01 C4 05 F6 | 	mov	arg02, #1
08444     54 FF BF FD | 	call	#_fatfs_cc_rcvr_mmc_0641
08448     EC C4 C1 FA | 	rdbyte	arg02, local01
0844c     FF C4 0D F2 | 	cmp	arg02, #255 wz
08450     01 A6 05 A6 |  if_e	mov	result1, #1
08454     1A A6 61 5D |  if_ne	getct	result1
08458     ED A6 81 51 |  if_ne	sub	result1, local02
0845c     EE A6 11 52 |  if_ne	cmp	result1, local03 wc
08460     00 A6 05 16 |  if_a	mov	result1, #0
08464     D4 FF 9F 4D |  if_c_and_nz	jmp	#LR__0910
08468     A7 F0 03 F6 | 	mov	ptra, fp
0846c     B2 00 A0 FD | 	call	#popregs_
08470                 | _fatfs_cc_wait_ready_0645_ret
08470     2D 00 64 FD | 	ret
08474                 | 
08474                 | _fatfs_cc_deselect_0651
08474     00 4A 05 F6 | 	mov	COUNT_, #0
08478     A8 00 A0 FD | 	call	#pushregs_
0847c     F8 C5 01 F6 | 	mov	arg02, ptra
08480     14 90 05 F1 | 	add	objptr, #20
08484     C8 C2 01 FB | 	rdlong	arg01, objptr
08488     14 90 85 F1 | 	sub	objptr, #20
0848c     04 F0 07 F1 | 	add	ptra, #4
08490     59 C2 61 FD | 	drvh	arg01
08494     1F 20 64 FD | 	waitx	#16
08498     E2 C2 01 F6 | 	mov	arg01, arg02
0849c     01 C4 05 F6 | 	mov	arg02, #1
084a0     F8 FE BF FD | 	call	#_fatfs_cc_rcvr_mmc_0641
084a4     A7 F0 03 F6 | 	mov	ptra, fp
084a8     B2 00 A0 FD | 	call	#popregs_
084ac                 | _fatfs_cc_deselect_0651_ret
084ac     2D 00 64 FD | 	ret
084b0                 | 
084b0                 | _fatfs_cc_select_0655
084b0     01 4A 05 F6 | 	mov	COUNT_, #1
084b4     A8 00 A0 FD | 	call	#pushregs_
084b8     F8 C5 01 F6 | 	mov	arg02, ptra
084bc     14 90 05 F1 | 	add	objptr, #20
084c0     C8 C2 01 FB | 	rdlong	arg01, objptr
084c4     08 90 05 F1 | 	add	objptr, #8
084c8     C8 D8 01 FB | 	rdlong	local01, objptr
084cc     1C 90 85 F1 | 	sub	objptr, #28
084d0     04 F0 07 F1 | 	add	ptra, #4
084d4     50 D8 61 FD | 	fltl	local01
084d8     58 C2 61 FD | 	drvl	arg01
084dc     1F 20 64 FD | 	waitx	#16
084e0     41 D8 61 FD | 	dirh	local01
084e4     E2 C2 01 F6 | 	mov	arg01, arg02
084e8     01 C4 05 F6 | 	mov	arg02, #1
084ec     AC FE BF FD | 	call	#_fatfs_cc_rcvr_mmc_0641
084f0     2C FF BF FD | 	call	#_fatfs_cc_wait_ready_0645
084f4     00 A6 0D F2 | 	cmp	result1, #0 wz
084f8     01 A6 05 56 |  if_ne	mov	result1, #1
084fc     08 00 90 5D |  if_ne	jmp	#LR__0920
08500     70 FF BF FD | 	call	#_fatfs_cc_deselect_0651
08504                 | ' 
08504                 | ' 	deselect();
08504                 | ' 	return 0;
08504     00 A6 05 F6 | 	mov	result1, #0
08508                 | LR__0920
08508     A7 F0 03 F6 | 	mov	ptra, fp
0850c     B2 00 A0 FD | 	call	#popregs_
08510                 | _fatfs_cc_select_0655_ret
08510     2D 00 64 FD | 	ret
08514                 | 
08514                 | _fatfs_cc_rcvr_datablock_0659
08514     05 4A 05 F6 | 	mov	COUNT_, #5
08518     A8 00 A0 FD | 	call	#pushregs_
0851c     E1 D8 01 F6 | 	mov	local01, arg01
08520     E2 DA 01 F6 | 	mov	local02, arg02
08524     F8 DD 01 F6 | 	mov	local03, ptra
08528     1A DE 61 FD | 	getct	local04
0852c     14 E0 05 FB | 	rdlong	local05, #20
08530     03 E0 45 F0 | 	shr	local05, #3
08534                 | ' 	UINT tmr, tmout;
08534                 | ' 
08534                 | ' 	tmr = _cnt();
08534                 | ' 	tmout =  (*(uint32_t *)0x14)  >> 3;
08534                 | ' 	for(;;) {
08534     04 F0 07 F1 | 	add	ptra, #4
08538                 | LR__0930
08538     EE C2 01 F6 | 	mov	arg01, local03
0853c     01 C4 05 F6 | 	mov	arg02, #1
08540     58 FE BF FD | 	call	#_fatfs_cc_rcvr_mmc_0641
08544     EE C4 C1 FA | 	rdbyte	arg02, local03
08548     FF C4 0D F2 | 	cmp	arg02, #255 wz
0854c     1A A6 61 AD |  if_e	getct	result1
08550     D3 C4 01 A6 |  if_e	mov	arg02, result1
08554     EF C4 81 A1 |  if_e	sub	arg02, local04
08558     F0 C4 11 A2 |  if_e	cmp	arg02, local05 wc
0855c     D8 FF 9F 8D |  if_c_and_z	jmp	#LR__0930
08560     EE E0 C1 FA | 	rdbyte	local05, local03
08564     FE E0 0D F2 | 	cmp	local05, #254 wz
08568     00 A6 05 56 |  if_ne	mov	result1, #0
0856c     1C 00 90 5D |  if_ne	jmp	#LR__0931
08570     EC C2 01 F6 | 	mov	arg01, local01
08574     ED C4 01 F6 | 	mov	arg02, local02
08578     20 FE BF FD | 	call	#_fatfs_cc_rcvr_mmc_0641
0857c     EE C2 01 F6 | 	mov	arg01, local03
08580     02 C4 05 F6 | 	mov	arg02, #2
08584     14 FE BF FD | 	call	#_fatfs_cc_rcvr_mmc_0641
08588                 | ' 
08588                 | ' 	rcvr_mmc(buff, btr);
08588                 | ' 	rcvr_mmc(d, 2);
08588                 | ' 
08588                 | ' 	return 1;
08588     01 A6 05 F6 | 	mov	result1, #1
0858c                 | LR__0931
0858c     A7 F0 03 F6 | 	mov	ptra, fp
08590     B2 00 A0 FD | 	call	#popregs_
08594                 | _fatfs_cc_rcvr_datablock_0659_ret
08594     2D 00 64 FD | 	ret
08598                 | 
08598                 | _fatfs_cc_xmit_datablock_0661
08598     03 4A 05 F6 | 	mov	COUNT_, #3
0859c     A8 00 A0 FD | 	call	#pushregs_
085a0     E1 D8 01 F6 | 	mov	local01, arg01
085a4     E2 DA 01 F6 | 	mov	local02, arg02
085a8     F8 DD 01 F6 | 	mov	local03, ptra
085ac     04 F0 07 F1 | 	add	ptra, #4
085b0     6C FE BF FD | 	call	#_fatfs_cc_wait_ready_0645
085b4     00 A6 0D F2 | 	cmp	result1, #0 wz
085b8     00 A6 05 A6 |  if_e	mov	result1, #0
085bc     58 00 90 AD |  if_e	jmp	#LR__0941
085c0     EE DA 41 FC | 	wrbyte	local02, local03
085c4     EE C2 01 F6 | 	mov	arg01, local03
085c8     01 C4 05 F6 | 	mov	arg02, #1
085cc     44 FD BF FD | 	call	#_fatfs_cc_xmit_mmc_0634
085d0     ED DA E1 F8 | 	getbyte	local02, local02, #0
085d4     FD DA 0D F2 | 	cmp	local02, #253 wz
085d8     38 00 90 AD |  if_e	jmp	#LR__0940
085dc     EC C2 01 F6 | 	mov	arg01, local01
085e0     09 C4 C5 F9 | 	decod	arg02, #9
085e4     2C FD BF FD | 	call	#_fatfs_cc_xmit_mmc_0634
085e8     EE C2 01 F6 | 	mov	arg01, local03
085ec     02 C4 05 F6 | 	mov	arg02, #2
085f0     A8 FD BF FD | 	call	#_fatfs_cc_rcvr_mmc_0641
085f4     EE C2 01 F6 | 	mov	arg01, local03
085f8     01 C4 05 F6 | 	mov	arg02, #1
085fc     9C FD BF FD | 	call	#_fatfs_cc_rcvr_mmc_0641
08600     EE DC C1 FA | 	rdbyte	local03, local03
08604     1F DC 05 F5 | 	and	local03, #31
08608     05 DC 0D F2 | 	cmp	local03, #5 wz
0860c                 | ' 			return 0;
0860c     00 A6 05 56 |  if_ne	mov	result1, #0
08610     04 00 90 5D |  if_ne	jmp	#LR__0941
08614                 | LR__0940
08614                 | ' 	}
08614                 | ' 
08614                 | ' 	return 1;
08614     01 A6 05 F6 | 	mov	result1, #1
08618                 | LR__0941
08618     A7 F0 03 F6 | 	mov	ptra, fp
0861c     B2 00 A0 FD | 	call	#popregs_
08620                 | _fatfs_cc_xmit_datablock_0661_ret
08620     2D 00 64 FD | 	ret
08624                 | 
08624                 | _fatfs_cc_send_cmd_0664
08624     04 4A 05 F6 | 	mov	COUNT_, #4
08628     A8 00 A0 FD | 	call	#pushregs_
0862c                 | _fatfs_cc_send_cmd_0664_enter
0862c     E1 D8 01 F6 | 	mov	local01, arg01
08630     E2 DA 01 F6 | 	mov	local02, arg02
08634     F8 DD 01 F6 | 	mov	local03, ptra
08638     EC A6 E1 F8 | 	getbyte	result1, local01, #0
0863c     80 A6 CD F7 | 	test	result1, #128 wz
08640     08 F0 07 F1 | 	add	ptra, #8
08644     20 00 90 AD |  if_e	jmp	#LR__0950
08648     EC D8 E1 F8 | 	getbyte	local01, local01, #0
0864c     7F D8 05 F5 | 	and	local01, #127
08650     37 C2 05 F6 | 	mov	arg01, #55
08654     00 C4 05 F6 | 	mov	arg02, #0
08658     C8 FF BF FD | 	call	#_fatfs_cc_send_cmd_0664
0865c     D3 C4 E1 F8 | 	getbyte	arg02, result1, #0
08660     02 C4 15 F2 | 	cmp	arg02, #2 wc
08664     BC 00 90 3D |  if_ae	jmp	#LR__0953
08668                 | LR__0950
08668     EC A6 E1 F8 | 	getbyte	result1, local01, #0
0866c     0C A6 0D F2 | 	cmp	result1, #12 wz
08670     14 00 90 AD |  if_e	jmp	#LR__0951
08674     FC FD BF FD | 	call	#_fatfs_cc_deselect_0651
08678     34 FE BF FD | 	call	#_fatfs_cc_select_0655
0867c     00 A6 0D F2 | 	cmp	result1, #0 wz
08680     FF A6 05 A6 |  if_e	mov	result1, #255
08684     9C 00 90 AD |  if_e	jmp	#LR__0953
08688                 | LR__0951
08688     EC C4 E1 F8 | 	getbyte	arg02, local01, #0
0868c     40 A6 05 F6 | 	mov	result1, #64
08690     E2 A6 41 F5 | 	or	result1, arg02
08694     EE A6 41 FC | 	wrbyte	result1, local03
08698     EE C4 01 F6 | 	mov	arg02, local03
0869c     01 C4 05 F1 | 	add	arg02, #1
086a0     1B DA FD F9 | 	movbyts	local02, #27
086a4     E2 DA 61 FC | 	wrlong	local02, arg02
086a8     01 DE 05 F6 | 	mov	local04, #1
086ac     EC DA 01 F6 | 	mov	local02, local01
086b0     07 DA 4D F7 | 	zerox	local02, #7 wz
086b4     95 DE 05 A6 |  if_e	mov	local04, #149
086b8     EC DA E1 F8 | 	getbyte	local02, local01, #0
086bc     08 DA 0D F2 | 	cmp	local02, #8 wz
086c0     87 DE 05 A6 |  if_e	mov	local04, #135
086c4     05 DC 05 F1 | 	add	local03, #5
086c8     EE DE 41 FC | 	wrbyte	local04, local03
086cc     05 DC 85 F1 | 	sub	local03, #5
086d0     EE C2 01 F6 | 	mov	arg01, local03
086d4     06 C4 05 F6 | 	mov	arg02, #6
086d8     38 FC BF FD | 	call	#_fatfs_cc_xmit_mmc_0634
086dc     EC D8 E1 F8 | 	getbyte	local01, local01, #0
086e0     0C D8 0D F2 | 	cmp	local01, #12 wz
086e4     EE C2 01 A6 |  if_e	mov	arg01, local03
086e8     06 C2 05 A1 |  if_e	add	arg01, #6
086ec     01 C4 05 A6 |  if_e	mov	arg02, #1
086f0     A8 FC BF AD |  if_e	call	#_fatfs_cc_rcvr_mmc_0641
086f4     0A DE 05 F6 | 	mov	local04, #10
086f8                 | ' 	n = 10;
086f8                 | ' 	do
086f8                 | LR__0952
086f8     EE C2 01 F6 | 	mov	arg01, local03
086fc     06 C2 05 F1 | 	add	arg01, #6
08700     01 C4 05 F6 | 	mov	arg02, #1
08704     94 FC BF FD | 	call	#_fatfs_cc_rcvr_mmc_0641
08708     06 DC 05 F1 | 	add	local03, #6
0870c     EE DA C1 FA | 	rdbyte	local02, local03
08710     06 DC 85 F1 | 	sub	local03, #6
08714     80 DA CD F7 | 	test	local02, #128 wz
08718     F7 DF 6D 5B |  if_ne	djnz	local04, #LR__0952
0871c                 | ' 
0871c                 | ' 	return buf[6];
0871c     06 DC 05 F1 | 	add	local03, #6
08720     EE A6 C1 FA | 	rdbyte	result1, local03
08724                 | LR__0953
08724     A7 F0 03 F6 | 	mov	ptra, fp
08728     B2 00 A0 FD | 	call	#popregs_
0872c                 | _fatfs_cc_send_cmd_0664_ret
0872c     2D 00 64 FD | 	ret
08730                 | 
08730                 | _fatfs_cc_disk_deinitialize
08730     04 4A 05 F6 | 	mov	COUNT_, #4
08734     A8 00 A0 FD | 	call	#pushregs_
08738     00 C2 4D F2 | 	cmps	arg01, #0 wz
0873c     10 90 05 F1 | 	add	objptr, #16
08740     C8 D8 01 FB | 	rdlong	local01, objptr
08744     04 90 05 F1 | 	add	objptr, #4
08748     C8 DA 01 FB | 	rdlong	local02, objptr
0874c     04 90 05 F1 | 	add	objptr, #4
08750     C8 DC 01 FB | 	rdlong	local03, objptr
08754     08 90 05 F1 | 	add	objptr, #8
08758     C8 DE 01 FB | 	rdlong	local04, objptr
0875c     04 90 85 F1 | 	sub	objptr, #4
08760     C8 C2 01 FB | 	rdlong	arg01, objptr
08764     1C 90 85 F1 | 	sub	objptr, #28
08768                 | ' #line 855 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
08768                 | '         return RES_NOTRDY;
08768     03 A6 05 56 |  if_ne	mov	result1, #3
0876c     34 00 90 5D |  if_ne	jmp	#LR__0960
08770     50 C2 61 FD | 	fltl	arg01
08774     E1 00 08 FC | 	wrpin	#0, arg01
08778     50 DE 61 FD | 	fltl	local04
0877c     EF 00 08 FC | 	wrpin	#0, local04
08780     50 DC 61 FD | 	fltl	local03
08784     EE 00 08 FC | 	wrpin	#0, local03
08788     50 D8 61 FD | 	fltl	local01
0878c     EC 00 08 FC | 	wrpin	#0, local01
08790     50 DA 61 FD | 	fltl	local02
08794     ED 00 08 FC | 	wrpin	#0, local02
08798     0A C2 05 F6 | 	mov	arg01, #10
0879c     18 5E B0 FD | 	call	#__system___waitms
087a0                 | '     }
087a0                 | ' #line 861 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
087a0                 | '     _pinclear(SMPIN_DO);
087a0                 | '     _pinclear(PIN_DO);
087a0                 | '     _pinclear(PIN_DI);
087a0                 | '     _pinclear(PIN_CLK);
087a0                 | '     _pinclear(PIN_SS);
087a0                 | ' 
087a0                 | '     _waitms(10);
087a0                 | ' 
087a0                 | '     return 0;
087a0     00 A6 05 F6 | 	mov	result1, #0
087a4                 | LR__0960
087a4     A7 F0 03 F6 | 	mov	ptra, fp
087a8     B2 00 A0 FD | 	call	#popregs_
087ac                 | _fatfs_cc_disk_deinitialize_ret
087ac     2D 00 64 FD | 	ret
087b0                 | 
087b0                 | _fatfs_cc_gettimeofday
087b0     04 4A 05 F6 | 	mov	COUNT_, #4
087b4     A8 00 A0 FD | 	call	#pushregs_
087b8     4C 5B B0 FD | 	call	#__system___getus
087bc     D3 D8 01 F6 | 	mov	local01, result1
087c0     4C 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #332
087c4     CB DA 01 FB | 	rdlong	local02, ptr__fatfs_cc_dat__
087c8     EC A6 01 F6 | 	mov	result1, local01
087cc     ED A6 81 F1 | 	sub	result1, local02
087d0     A1 07 00 FF 
087d4     40 A6 15 FD | 	qdiv	result1, ##1000000
087d8     4C 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #332
087dc     18 DA 61 FD | 	getqx	local02
087e0     A1 07 00 FF 
087e4     40 A6 15 FD | 	qdiv	result1, ##1000000
087e8     00 DA 0D F2 | 	cmp	local02, #0 wz
087ec     19 DC 61 FD | 	getqy	local03
087f0     20 00 90 AD |  if_e	jmp	#LR__0970
087f4     48 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #328
087f8     CB DE 01 FB | 	rdlong	local04, ptr__fatfs_cc_dat__
087fc     ED DE 01 F1 | 	add	local04, local02
08800     CB DE 61 FC | 	wrlong	local04, ptr__fatfs_cc_dat__
08804     EE D8 81 F1 | 	sub	local01, local03
08808     04 96 05 F1 | 	add	ptr__fatfs_cc_dat__, #4
0880c     CB D8 61 FC | 	wrlong	local01, ptr__fatfs_cc_dat__
08810     4C 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #332
08814                 | LR__0970
08814     48 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #328
08818     CB DE 01 FB | 	rdlong	local04, ptr__fatfs_cc_dat__
0881c     48 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #328
08820     E1 DE 61 FC | 	wrlong	local04, arg01
08824     04 C2 05 F1 | 	add	arg01, #4
08828     E1 DC 61 FC | 	wrlong	local03, arg01
0882c                 | '         lastsec += secs;
0882c                 | '         lastus = now - leftover;
0882c                 | '     }
0882c                 | '     tv->tv_sec = lastsec;
0882c                 | '     tv->tv_usec = leftover;
0882c                 | '     return 0;
0882c     00 A6 05 F6 | 	mov	result1, #0
08830     A7 F0 03 F6 | 	mov	ptra, fp
08834     B2 00 A0 FD | 	call	#popregs_
08838                 | _fatfs_cc_gettimeofday_ret
08838     2D 00 64 FD | 	ret
0883c                 | 
0883c                 | _fatfs_cc__is_leap_year
0883c     E1 A6 51 F6 | 	abs	result1, arg01 wc
08840     03 A6 05 F5 | 	and	result1, #3
08844     D3 A6 89 F6 | 	negc	result1, result1 wz
08848     38 00 90 5D |  if_ne	jmp	#LR__0981
0884c     E1 A6 51 F6 | 	abs	result1, arg01 wc
08850     64 A6 15 FD | 	qdiv	result1, #100
08854     19 A6 61 FD | 	getqy	result1
08858     D3 A6 89 F6 | 	negc	result1, result1 wz
0885c     1C 00 90 5D |  if_ne	jmp	#LR__0980
08860     E1 A6 51 F6 | 	abs	result1, arg01 wc
08864     90 A7 15 FD | 	qdiv	result1, #400
08868                 | '       return (0 == y % 400);
08868     00 A6 05 F6 | 	mov	result1, #0
0886c     19 AA 61 FD | 	getqy	_var01
08870     D5 AA 89 F6 | 	negc	_var01, _var01 wz
08874     01 A6 05 A6 |  if_e	mov	result1, #1
08878     0C 00 90 FD | 	jmp	#_fatfs_cc__is_leap_year_ret
0887c                 | LR__0980
0887c                 | '     return 1;
0887c     01 A6 05 F6 | 	mov	result1, #1
08880     04 00 90 FD | 	jmp	#_fatfs_cc__is_leap_year_ret
08884                 | LR__0981
08884                 | '   }
08884                 | '   return 0;
08884     00 A6 05 F6 | 	mov	result1, #0
08888                 | _fatfs_cc__is_leap_year_ret
08888     2D 00 64 FD | 	ret
0888c                 | 
0888c                 | _fatfs_cc___tzoffset
0888c     E1 AA 09 F6 | 	mov	_var01, arg01 wz
08890     FF FF FF FF 
08894     E2 FE 6B FC | 	wrlong	##-1, arg02
08898     01 AC 05 F6 | 	mov	_var02, #1
0889c     D5 AE C9 5A |  if_ne	rdbyte	_var03, _var01 wz
088a0                 | '                 return 0;
088a0     00 A6 05 A6 |  if_e	mov	result1, #0
088a4     30 02 90 AD |  if_e	jmp	#LR__1007
088a8     E2 00 68 FC | 	wrlong	#0, arg02
088ac     CB B0 01 F6 | 	mov	_var04, ptr__fatfs_cc_dat__
088b0     20 B1 05 F1 | 	add	_var04, #288
088b4     97 24 48 FB | 	callpa	#(@LR__0991-@LR__0990)>>2,fcache_load_ptr_
088b8                 | ' 
088b8                 | '        *hasdst = 0;
088b8                 | ' 
088b8                 | ' 	n = stdname;
088b8                 | '         while (*s && isalpha(*s)) {
088b8                 | LR__0990
088b8     D5 AE C9 FA | 	rdbyte	_var03, _var01 wz
088bc     40 00 90 AD |  if_e	jmp	#LR__0992
088c0     D5 C2 C1 FA | 	rdbyte	arg01, _var01
088c4                 | ' {
088c4                 | '   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
088c4     80 C2 35 F3 | 	fle	arg01, #128 wc
088c8                 | '     return __ctype[c];
088c8     CB A6 01 F6 | 	mov	result1, ptr__fatfs_cc_dat__
088cc     50 A7 05 F1 | 	add	result1, #336
088d0     D3 C2 01 F1 | 	add	arg01, result1
088d4     E1 A6 C1 FA | 	rdbyte	result1, arg01
088d8     0C A6 CD F7 | 	test	result1, #12 wz
088dc     20 00 90 AD |  if_e	jmp	#LR__0992
088e0     D5 B2 01 F6 | 	mov	_var05, _var01
088e4     D5 B4 01 F6 | 	mov	_var06, _var01
088e8     01 B4 05 F1 | 	add	_var06, #1
088ec     D9 B6 C1 FA | 	rdbyte	_var07, _var05
088f0     DA AA 01 F6 | 	mov	_var01, _var06
088f4     D8 B6 41 FC | 	wrbyte	_var07, _var04
088f8     01 B0 05 F1 | 	add	_var04, #1
088fc     B8 FF 9F FD | 	jmp	#LR__0990
08900                 | LR__0991
08900                 | LR__0992
08900     D8 00 48 FC | 	wrbyte	#0, _var04
08904     00 B8 05 F6 | 	mov	_var08, #0
08908     D5 AE C1 FA | 	rdbyte	_var03, _var01
0890c     2D AE 0D F2 | 	cmp	_var03, #45 wz
08910     01 AC 65 A6 |  if_e	neg	_var02, #1
08914     01 AA 05 A1 |  if_e	add	_var01, #1
08918     97 24 48 FB | 	callpa	#(@LR__0994-@LR__0993)>>2,fcache_load_ptr_
0891c                 | '                 sgn = -1;
0891c                 | '                 s++;
0891c                 | '         }
0891c                 | '         while (isdigit(*s)) {
0891c                 | LR__0993
0891c     D5 C2 C1 FA | 	rdbyte	arg01, _var01
08920                 | ' {
08920                 | '   return  (__ctype_get(c) & 0x02 ) ;
08920     80 C2 35 F3 | 	fle	arg01, #128 wc
08924                 | '     return __ctype[c];
08924     CB A6 01 F6 | 	mov	result1, ptr__fatfs_cc_dat__
08928     50 A7 05 F1 | 	add	result1, #336
0892c     D3 C2 01 F1 | 	add	arg01, result1
08930     E1 A6 C1 FA | 	rdbyte	result1, arg01
08934     02 A6 CD F7 | 	test	result1, #2 wz
08938     28 00 90 AD |  if_e	jmp	#LR__0995
0893c     DC AE 01 F6 | 	mov	_var03, _var08
08940     02 AE 65 F0 | 	shl	_var03, #2
08944     DC AE 01 F1 | 	add	_var03, _var08
08948     01 AE 65 F0 | 	shl	_var03, #1
0894c     D5 B2 C1 FA | 	rdbyte	_var05, _var01
08950     30 B2 85 F1 | 	sub	_var05, #48
08954     D9 AE 01 F1 | 	add	_var03, _var05
08958     D7 B8 01 F6 | 	mov	_var08, _var03
0895c     01 AA 05 F1 | 	add	_var01, #1
08960     B8 FF 9F FD | 	jmp	#LR__0993
08964                 | LR__0994
08964                 | LR__0995
08964     07 00 00 FF 
08968     10 B8 05 FD | 	qmul	_var08, ##3600
0896c     D5 AE C1 FA | 	rdbyte	_var03, _var01
08970     3A AE 0D F2 | 	cmp	_var03, #58 wz
08974     18 BA 61 FD | 	getqx	_var09
08978     68 00 90 5D |  if_ne	jmp	#LR__0999
0897c     00 B8 05 F6 | 	mov	_var08, #0
08980     01 AA 05 F1 | 	add	_var01, #1
08984     97 24 48 FB | 	callpa	#(@LR__0997-@LR__0996)>>2,fcache_load_ptr_
08988                 | '                 x = 0;
08988                 | '                 s++;
08988                 | '                 while (isdigit(*s)) {
08988                 | LR__0996
08988     D5 C2 C1 FA | 	rdbyte	arg01, _var01
0898c                 | ' {
0898c                 | '   return  (__ctype_get(c) & 0x02 ) ;
0898c     80 C2 35 F3 | 	fle	arg01, #128 wc
08990                 | '     return __ctype[c];
08990     CB A6 01 F6 | 	mov	result1, ptr__fatfs_cc_dat__
08994     50 A7 05 F1 | 	add	result1, #336
08998     D3 C2 01 F1 | 	add	arg01, result1
0899c     E1 A6 C1 FA | 	rdbyte	result1, arg01
089a0     02 A6 CD F7 | 	test	result1, #2 wz
089a4     28 00 90 AD |  if_e	jmp	#LR__0998
089a8     DC AE 01 F6 | 	mov	_var03, _var08
089ac     02 AE 65 F0 | 	shl	_var03, #2
089b0     DC AE 01 F1 | 	add	_var03, _var08
089b4     01 AE 65 F0 | 	shl	_var03, #1
089b8     D5 B2 C1 FA | 	rdbyte	_var05, _var01
089bc     30 B2 85 F1 | 	sub	_var05, #48
089c0     D9 AE 01 F1 | 	add	_var03, _var05
089c4     D7 B8 01 F6 | 	mov	_var08, _var03
089c8     01 AA 05 F1 | 	add	_var01, #1
089cc     B8 FF 9F FD | 	jmp	#LR__0996
089d0                 | LR__0997
089d0                 | LR__0998
089d0     DC B6 01 F6 | 	mov	_var07, _var08
089d4     04 B6 65 F0 | 	shl	_var07, #4
089d8     DC B6 81 F1 | 	sub	_var07, _var08
089dc     02 B6 65 F0 | 	shl	_var07, #2
089e0     DB BA 01 F1 | 	add	_var09, _var07
089e4                 | LR__0999
089e4     CB B0 01 F6 | 	mov	_var04, ptr__fatfs_cc_dat__
089e8     29 B1 05 F1 | 	add	_var04, #297
089ec     D5 C2 C1 FA | 	rdbyte	arg01, _var01
089f0                 | ' {
089f0                 | '   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
089f0     80 C2 35 F3 | 	fle	arg01, #128 wc
089f4                 | '     return __ctype[c];
089f4     CB A6 01 F6 | 	mov	result1, ptr__fatfs_cc_dat__
089f8     50 A7 05 F1 | 	add	result1, #336
089fc     D3 C2 01 F1 | 	add	arg01, result1
08a00     E1 A6 C1 FA | 	rdbyte	result1, arg01
08a04     0C A6 CD F7 | 	test	result1, #12 wz
08a08     48 00 90 AD |  if_e	jmp	#LR__1002
08a0c     E2 02 68 FC | 	wrlong	#1, arg02
08a10                 | '                 *hasdst = 1;
08a10                 | ' 		while (*s && isalpha(*s)) *n++ = *s++;
08a10                 | LR__1000
08a10     D5 AE C9 FA | 	rdbyte	_var03, _var01 wz
08a14     3C 00 90 AD |  if_e	jmp	#LR__1001
08a18     D5 C2 C1 FA | 	rdbyte	arg01, _var01
08a1c                 | ' {
08a1c                 | '   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
08a1c     80 C2 35 F3 | 	fle	arg01, #128 wc
08a20                 | '     return __ctype[c];
08a20     CB A6 01 F6 | 	mov	result1, ptr__fatfs_cc_dat__
08a24     50 A7 05 F1 | 	add	result1, #336
08a28     D3 C2 01 F1 | 	add	arg01, result1
08a2c     E1 A6 C1 FA | 	rdbyte	result1, arg01
08a30     0C A6 CD F7 | 	test	result1, #12 wz
08a34     1C 00 90 AD |  if_e	jmp	#LR__1001
08a38     D5 B4 01 F6 | 	mov	_var06, _var01
08a3c     01 B4 05 F1 | 	add	_var06, #1
08a40     D5 B6 C1 FA | 	rdbyte	_var07, _var01
08a44     DA AA 01 F6 | 	mov	_var01, _var06
08a48     D8 B6 41 FC | 	wrbyte	_var07, _var04
08a4c     01 B0 05 F1 | 	add	_var04, #1
08a50     BC FF 9F FD | 	jmp	#LR__1000
08a54                 | LR__1001
08a54                 | LR__1002
08a54     D8 00 48 FC | 	wrbyte	#0, _var04
08a58     20 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #288
08a5c     CB AE C9 FA | 	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
08a60     20 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #288
08a64     18 00 90 AD |  if_e	jmp	#LR__1003
08a68     20 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #288
08a6c     CB AE 01 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
08a70     08 96 85 F1 | 	sub	ptr__fatfs_cc_dat__, #8
08a74     CB AE 61 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
08a78     18 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #280
08a7c     14 00 90 FD | 	jmp	#LR__1004
08a80                 | LR__1003
08a80     32 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #306
08a84     CB AE 01 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
08a88     1A 96 85 F1 | 	sub	ptr__fatfs_cc_dat__, #26
08a8c     CB AE 61 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
08a90     18 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #280
08a94                 | LR__1004
08a94     29 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #297
08a98     CB AE C9 FA | 	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
08a9c     29 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #297
08aa0     18 00 90 AD |  if_e	jmp	#LR__1005
08aa4     29 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #297
08aa8     CB AE 01 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
08aac     0D 96 85 F1 | 	sub	ptr__fatfs_cc_dat__, #13
08ab0     CB AE 61 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
08ab4     1C 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #284
08ab8     14 00 90 FD | 	jmp	#LR__1006
08abc                 | LR__1005
08abc     20 97 05 F1 | 	add	ptr__fatfs_cc_dat__, #288
08ac0     CB AE 01 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
08ac4     04 96 85 F1 | 	sub	ptr__fatfs_cc_dat__, #4
08ac8     CB AE 61 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
08acc     1C 97 85 F1 | 	sub	ptr__fatfs_cc_dat__, #284
08ad0                 | LR__1006
08ad0     DD AC 01 FD | 	qmul	_var02, _var09
08ad4                 | ' 		_tzname[1] = stdname;
08ad4                 | ' 
08ad4                 | '         return sgn * off;
08ad4     18 A6 61 FD | 	getqx	result1
08ad8                 | LR__1007
08ad8                 | _fatfs_cc___tzoffset_ret
08ad8     2D 00 64 FD | 	ret
08adc                 | 
08adc                 | _fatfs_cc___indst
08adc     10 C2 05 F1 | 	add	arg01, #16
08ae0     E1 AA 01 FB | 	rdlong	_var01, arg01
08ae4     10 C2 85 F1 | 	sub	arg01, #16
08ae8     02 AA 0D F2 | 	cmp	_var01, #2 wz
08aec     30 00 90 5D |  if_ne	jmp	#LR__1010
08af0     07 AA 05 F6 | 	mov	_var01, #7
08af4     18 C2 05 F1 | 	add	arg01, #24
08af8     E1 AC 01 FB | 	rdlong	_var02, arg01
08afc     D6 AA 01 F1 | 	add	_var01, _var02
08b00     0C C2 85 F1 | 	sub	arg01, #12
08b04     E1 AE 01 FB | 	rdlong	_var03, arg01
08b08     D7 AA 81 F1 | 	sub	_var01, _var03
08b0c     00 AA 55 F2 | 	cmps	_var01, #0 wc
08b10                 | '                         return 1;
08b10     01 A6 05 C6 |  if_b	mov	result1, #1
08b14     70 00 90 CD |  if_b	jmp	#_fatfs_cc___indst_ret
08b18                 | '                 return 0;
08b18     00 A6 05 F6 | 	mov	result1, #0
08b1c     68 00 90 FD | 	jmp	#_fatfs_cc___indst_ret
08b20                 | LR__1010
08b20     10 C2 05 F1 | 	add	arg01, #16
08b24     E1 AA 01 FB | 	rdlong	_var01, arg01
08b28     10 C2 85 F1 | 	sub	arg01, #16
08b2c     0A AA 0D F2 | 	cmp	_var01, #10 wz
08b30     28 00 90 5D |  if_ne	jmp	#LR__1011
08b34     18 C2 05 F1 | 	add	arg01, #24
08b38     E1 AA 01 FB | 	rdlong	_var01, arg01
08b3c     0C C2 85 F1 | 	sub	arg01, #12
08b40     E1 B0 01 FB | 	rdlong	_var04, arg01
08b44     D8 AA 81 F1 | 	sub	_var01, _var04
08b48     00 AA 55 F2 | 	cmps	_var01, #0 wc
08b4c                 | '                         return 0;
08b4c     00 A6 05 C6 |  if_b	mov	result1, #0
08b50     34 00 90 CD |  if_b	jmp	#_fatfs_cc___indst_ret
08b54                 | '                 return 1;
08b54     01 A6 05 F6 | 	mov	result1, #1
08b58     2C 00 90 FD | 	jmp	#_fatfs_cc___indst_ret
08b5c                 | LR__1011
08b5c                 | '         }
08b5c                 | ' 
08b5c                 | '         return (t->tm_mon > 2 && t->tm_mon < 10);
08b5c     00 AA 05 F6 | 	mov	_var01, #0
08b60     10 C2 05 F1 | 	add	arg01, #16
08b64     E1 AC 01 FB | 	rdlong	_var02, arg01
08b68     10 C2 85 F1 | 	sub	arg01, #16
08b6c     03 AC 55 F2 | 	cmps	_var02, #3 wc
08b70     10 00 90 CD |  if_b	jmp	#LR__1012
08b74     10 C2 05 F1 | 	add	arg01, #16
08b78     E1 AE 01 FB | 	rdlong	_var03, arg01
08b7c     0A AE 55 F2 | 	cmps	_var03, #10 wc
08b80     01 AA 05 C6 |  if_b	mov	_var01, #1
08b84                 | LR__1012
08b84     D5 A6 01 F6 | 	mov	result1, _var01
08b88                 | _fatfs_cc___indst_ret
08b88     2D 00 64 FD | 	ret
08b8c                 | 
08b8c                 | ' 
08b8c                 | ' PUB Initialize
08b8c                 | _cpu_Initialize
08b8c                 | '     instructionPointer := $F0000000
08b8c     00 00 F8 FF 
08b90     C8 00 68 FC | 	wrlong	##-268435456, objptr
08b94                 | '     stackPointer := 0
08b94     08 90 05 F1 | 	add	objptr, #8
08b98     C8 00 68 FC | 	wrlong	#0, objptr
08b9c                 | '     debug := false
08b9c     89 90 05 F1 | 	add	objptr, #137
08ba0     C8 00 48 FC | 	wrbyte	#0, objptr
08ba4                 | '     bus.Initialize
08ba4     07 90 05 F1 | 	add	objptr, #7
08ba8     24 22 B0 FD | 	call	#_bus_Initialize
08bac     98 90 85 F1 | 	sub	objptr, #152
08bb0                 | _cpu_Initialize_ret
08bb0     2D 00 64 FD | 	ret
08bb4                 | 
08bb4                 | '     'bus.DebugStr(string("vm info: fox32 ram at "))
08bb4                 | '     'bus.DebugHex(bus.GetRamAddr, 8)
08bb4                 | '     'bus.DebugChar(10)
08bb4                 | ' 
08bb4                 | ' PUB Execute(cycles) | instructionHalf, temp, temp2, savedSize, skip
08bb4                 | _cpu_Execute
08bb4     26 4A 05 F6 | 	mov	COUNT_, #38
08bb8     A8 00 A0 FD | 	call	#pushregs_
08bbc     E1 D8 01 F6 | 	mov	local01, arg01
08bc0                 | '     repeat cycles
08bc0     EC DA 09 F6 | 	mov	local02, local01 wz
08bc4     F4 12 90 AD |  if_e	jmp	#LR__1121
08bc8                 | LR__1020
08bc8                 | '         instructionHalf := bus.ReadHalf(instructionPointer)
08bc8     C8 C2 01 FB | 	rdlong	arg01, objptr
08bcc                 | '     return memory.ReadHalf(address)
08bcc     01 00 00 FF 
08bd0     1C 91 05 F1 | 	add	objptr, ##796
08bd4     A0 2F B0 FD | 	call	#_memory_ReadHalf
08bd8     01 00 00 FF 
08bdc     1C 91 85 F1 | 	sub	objptr, ##796
08be0     D3 DC 01 F6 | 	mov	local03, result1
08be4                 | '         instructionPointerMut := instructionPointer + SZ_HALF
08be4     C8 26 02 FB | 	rdlong	muldivb_, objptr
08be8     02 26 06 F1 | 	add	muldivb_, #2
08bec     04 90 05 F1 | 	add	objptr, #4
08bf0     C8 26 62 FC | 	wrlong	muldivb_, objptr
08bf4                 | ' 
08bf4                 | '         opcode := (instructionHalf >> 8) & 63
08bf4     EE 26 02 F6 | 	mov	muldivb_, local03
08bf8     08 26 46 F0 | 	shr	muldivb_, #8
08bfc     3F 26 06 F5 | 	and	muldivb_, #63
08c00     8E 90 05 F1 | 	add	objptr, #142
08c04     C8 26 42 FC | 	wrbyte	muldivb_, objptr
08c08                 | '         condition := (instructionHalf >> 4) & 7
08c08     EE 26 02 F6 | 	mov	muldivb_, local03
08c0c     04 26 46 F0 | 	shr	muldivb_, #4
08c10     07 26 06 F5 | 	and	muldivb_, #7
08c14     01 90 05 F1 | 	add	objptr, #1
08c18     C8 26 42 FC | 	wrbyte	muldivb_, objptr
08c1c                 | '         offset := (instructionHalf >> 7) & 1
08c1c     EE 26 02 F6 | 	mov	muldivb_, local03
08c20     07 26 46 F0 | 	shr	muldivb_, #7
08c24     01 26 06 F5 | 	and	muldivb_, #1
08c28     01 90 05 F1 | 	add	objptr, #1
08c2c     C8 26 42 FC | 	wrbyte	muldivb_, objptr
08c30                 | '         target := (instructionHalf >> 2) & 3
08c30     EE 26 02 F6 | 	mov	muldivb_, local03
08c34     02 26 46 F0 | 	shr	muldivb_, #2
08c38     03 26 06 F5 | 	and	muldivb_, #3
08c3c     01 90 05 F1 | 	add	objptr, #1
08c40     C8 26 42 FC | 	wrbyte	muldivb_, objptr
08c44                 | '         source := instructionHalf & 3
08c44     EE 26 02 F6 | 	mov	muldivb_, local03
08c48     03 26 06 F5 | 	and	muldivb_, #3
08c4c     01 90 05 F1 | 	add	objptr, #1
08c50     C8 26 42 FC | 	wrbyte	muldivb_, objptr
08c54                 | '         size := ((instructionHalf >> 14))
08c54     EE DE 01 F6 | 	mov	local04, local03
08c58     0E DE 45 F0 | 	shr	local04, #14
08c5c     01 90 05 F1 | 	add	objptr, #1
08c60     C8 DE 41 FC | 	wrbyte	local04, objptr
08c64                 | '         if (size == 0)
08c64     EF DE E1 F8 | 	getbyte	local04, local04, #0
08c68     97 90 85 F1 | 	sub	objptr, #151
08c6c     00 DE 0D F2 | 	cmp	local04, #0 wz
08c70                 | '             size := 1
08c70     97 90 05 A1 |  if_e	add	objptr, #151
08c74     C8 02 48 AC |  if_e	wrbyte	#1, objptr
08c78     97 90 C5 F3 | 	sumz	objptr, #151
08c7c                 | '         else
08c7c                 | '             size *= 2
08c7c     C8 DE C1 5A |  if_ne	rdbyte	local04, objptr
08c80     01 DE 65 50 |  if_ne	shl	local04, #1
08c84     C8 DE 41 5C |  if_ne	wrbyte	local04, objptr
08c88     97 90 85 51 |  if_ne	sub	objptr, #151
08c8c                 | '         skip := ShouldSkip
08c8c     30 1F B0 FD | 	call	#_cpu_ShouldSkip
08c90     D3 E0 01 F6 | 	mov	local05, result1
08c94                 | ' 
08c94                 | '         if (instructionPointer == 0)
08c94     C8 DE 09 FB | 	rdlong	local04, objptr wz
08c98                 | '             'bus.DebugStr(string("vm warn: called non-existent jump table entry?"))
08c98                 | '             'bus.DebugChar(10)
08c98                 | '             debug := false
08c98     91 90 05 A1 |  if_e	add	objptr, #145
08c9c     C8 00 48 AC |  if_e	wrbyte	#0, objptr
08ca0     91 90 85 A1 |  if_e	sub	objptr, #145
08ca4                 | ' 
08ca4                 | '         if (debug)
08ca4     91 90 05 F1 | 	add	objptr, #145
08ca8     C8 DE C9 FA | 	rdbyte	local04, objptr wz
08cac     91 90 85 F1 | 	sub	objptr, #145
08cb0     18 01 90 AD |  if_e	jmp	#LR__1021
08cb4                 | '             bus.DebugHex(instructionPointer, 8)
08cb4     C8 C2 01 FB | 	rdlong	arg01, objptr
08cb8     08 C4 05 F6 | 	mov	arg02, #8
08cbc                 | '     text.Hex(h, digits)
08cbc                 | '     video.hex(val, digits)
08cbc     C1 02 00 FF 
08cc0     78 90 05 F1 | 	add	objptr, ##361080
08cc4     E8 40 B0 FD | 	call	#_p2videodrv_hex
08cc8                 | '     DebugChar(" ")
08cc8     20 C2 05 F6 | 	mov	arg01, #32
08ccc                 | '     text.Out(c)
08ccc                 | '     video.out(ch)
08ccc     D4 3A B0 FD | 	call	#_p2videodrv_out
08cd0                 | '             bus.DebugHex(instructionHalf, 4)
08cd0     EE C2 01 F6 | 	mov	arg01, local03
08cd4     04 C4 05 F6 | 	mov	arg02, #4
08cd8                 | '     text.Hex(h, digits)
08cd8                 | '     video.hex(val, digits)
08cd8     D4 40 B0 FD | 	call	#_p2videodrv_hex
08cdc                 | '     DebugChar(" ")
08cdc     20 C2 05 F6 | 	mov	arg01, #32
08ce0                 | '     text.Out(c)
08ce0                 | '     video.out(ch)
08ce0     C0 3A B0 FD | 	call	#_p2videodrv_out
08ce4                 | '             bus.DebugHex(opcode, 2)
08ce4     C0 02 00 FF 
08ce8     E6 91 85 F1 | 	sub	objptr, ##360934
08cec     C8 C2 C1 FA | 	rdbyte	arg01, objptr
08cf0     02 C4 05 F6 | 	mov	arg02, #2
08cf4                 | '     text.Hex(h, digits)
08cf4                 | '     video.hex(val, digits)
08cf4     C0 02 00 FF 
08cf8     E6 91 05 F1 | 	add	objptr, ##360934
08cfc     B0 40 B0 FD | 	call	#_p2videodrv_hex
08d00                 | '     DebugChar(" ")
08d00     20 C2 05 F6 | 	mov	arg01, #32
08d04                 | '     text.Out(c)
08d04                 | '     video.out(ch)
08d04     9C 3A B0 FD | 	call	#_p2videodrv_out
08d08                 | '             bus.DebugHex(condition, 2)
08d08     C0 02 00 FF 
08d0c     E5 91 85 F1 | 	sub	objptr, ##360933
08d10     C8 C2 C1 FA | 	rdbyte	arg01, objptr
08d14     02 C4 05 F6 | 	mov	arg02, #2
08d18                 | '     text.Hex(h, digits)
08d18                 | '     video.hex(val, digits)
08d18     C0 02 00 FF 
08d1c     E5 91 05 F1 | 	add	objptr, ##360933
08d20     8C 40 B0 FD | 	call	#_p2videodrv_hex
08d24                 | '     DebugChar(" ")
08d24     20 C2 05 F6 | 	mov	arg01, #32
08d28                 | '     text.Out(c)
08d28                 | '     video.out(ch)
08d28     78 3A B0 FD | 	call	#_p2videodrv_out
08d2c                 | '             bus.DebugHex(offset, 2)
08d2c     C0 02 00 FF 
08d30     E4 91 85 F1 | 	sub	objptr, ##360932
08d34     C8 C2 C1 FA | 	rdbyte	arg01, objptr
08d38     02 C4 05 F6 | 	mov	arg02, #2
08d3c                 | '     text.Hex(h, digits)
08d3c                 | '     video.hex(val, digits)
08d3c     C0 02 00 FF 
08d40     E4 91 05 F1 | 	add	objptr, ##360932
08d44     68 40 B0 FD | 	call	#_p2videodrv_hex
08d48                 | '     DebugChar(" ")
08d48     20 C2 05 F6 | 	mov	arg01, #32
08d4c                 | '     text.Out(c)
08d4c                 | '     video.out(ch)
08d4c     54 3A B0 FD | 	call	#_p2videodrv_out
08d50                 | '             bus.DebugHex(target, 2)
08d50     C0 02 00 FF 
08d54     E3 91 85 F1 | 	sub	objptr, ##360931
08d58     C8 C2 C1 FA | 	rdbyte	arg01, objptr
08d5c     02 C4 05 F6 | 	mov	arg02, #2
08d60                 | '     text.Hex(h, digits)
08d60                 | '     video.hex(val, digits)
08d60     C0 02 00 FF 
08d64     E3 91 05 F1 | 	add	objptr, ##360931
08d68     44 40 B0 FD | 	call	#_p2videodrv_hex
08d6c                 | '     DebugChar(" ")
08d6c     20 C2 05 F6 | 	mov	arg01, #32
08d70                 | '     text.Out(c)
08d70                 | '     video.out(ch)
08d70     30 3A B0 FD | 	call	#_p2videodrv_out
08d74                 | '             bus.DebugHex(source, 2)
08d74     C0 02 00 FF 
08d78     E2 91 85 F1 | 	sub	objptr, ##360930
08d7c     C8 C2 C1 FA | 	rdbyte	arg01, objptr
08d80     02 C4 05 F6 | 	mov	arg02, #2
08d84                 | '     text.Hex(h, digits)
08d84                 | '     video.hex(val, digits)
08d84     C0 02 00 FF 
08d88     E2 91 05 F1 | 	add	objptr, ##360930
08d8c     20 40 B0 FD | 	call	#_p2videodrv_hex
08d90                 | '     DebugChar(" ")
08d90     20 C2 05 F6 | 	mov	arg01, #32
08d94                 | '     text.Out(c)
08d94                 | '     video.out(ch)
08d94     0C 3A B0 FD | 	call	#_p2videodrv_out
08d98                 | '             bus.DebugHex(size, 2)
08d98     C0 02 00 FF 
08d9c     E1 91 85 F1 | 	sub	objptr, ##360929
08da0     C8 C2 C1 FA | 	rdbyte	arg01, objptr
08da4     02 C4 05 F6 | 	mov	arg02, #2
08da8                 | '     text.Hex(h, digits)
08da8                 | '     video.hex(val, digits)
08da8     C0 02 00 FF 
08dac     E1 91 05 F1 | 	add	objptr, ##360929
08db0     FC 3F B0 FD | 	call	#_p2videodrv_hex
08db4                 | '     DebugChar(" ")
08db4     20 C2 05 F6 | 	mov	arg01, #32
08db8                 | '     text.Out(c)
08db8                 | '     video.out(ch)
08db8     E8 39 B0 FD | 	call	#_p2videodrv_out
08dbc                 | '             bus.DebugChar(10)
08dbc     0A C2 05 F6 | 	mov	arg01, #10
08dc0                 | '     text.Out(c)
08dc0                 | '     video.out(ch)
08dc0     E0 39 B0 FD | 	call	#_p2videodrv_out
08dc4     C1 02 00 FF 
08dc8     78 90 85 F1 | 	sub	objptr, ##361080
08dcc                 | LR__1021
08dcc                 | ' 
08dcc                 | '         case opcode
08dcc     92 90 05 F1 | 	add	objptr, #146
08dd0     C8 E2 C1 FA | 	rdbyte	local06, objptr
08dd4     92 90 85 F1 | 	sub	objptr, #146
08dd8     F1 E4 01 F6 | 	mov	local07, local06
08ddc     3A E4 25 F3 | 	fle	local07, #58
08de0     30 E4 61 FD | 	jmprel	local07
08de4                 | LR__1022
08de4     BC 10 90 FD | 	jmp	#LR__1120
08de8     00 01 90 FD | 	jmp	#LR__1024
08dec     D4 02 90 FD | 	jmp	#LR__1034
08df0     D4 05 90 FD | 	jmp	#LR__1057
08df4     2C 07 90 FD | 	jmp	#LR__1065
08df8     98 07 90 FD | 	jmp	#LR__1067
08dfc     5C 09 90 FD | 	jmp	#LR__1075
08e00     B4 0A 90 FD | 	jmp	#LR__1081
08e04     38 0D 90 FD | 	jmp	#LR__1099
08e08     F4 0D 90 FD | 	jmp	#LR__1102
08e0c     38 0C 90 FD | 	jmp	#LR__1092
08e10     C8 0F 90 FD | 	jmp	#LR__1115
08e14     8C 10 90 FD | 	jmp	#LR__1120
08e18     88 10 90 FD | 	jmp	#LR__1120
08e1c     64 10 90 FD | 	jmp	#LR__1119
08e20     60 10 90 FD | 	jmp	#LR__1119
08e24     7C 10 90 FD | 	jmp	#LR__1120
08e28     24 01 90 FD | 	jmp	#LR__1026
08e2c     54 10 90 FD | 	jmp	#LR__1119
08e30     E8 05 90 FD | 	jmp	#LR__1059
08e34     08 03 90 FD | 	jmp	#LR__1037
08e38     C8 07 90 FD | 	jmp	#LR__1069
08e3c     90 09 90 FD | 	jmp	#LR__1077
08e40     A4 0B 90 FD | 	jmp	#LR__1090
08e44     1C 0D 90 FD | 	jmp	#LR__1100
08e48     24 0E 90 FD | 	jmp	#LR__1106
08e4c     1C 0C 90 FD | 	jmp	#LR__1093
08e50     D8 0F 90 FD | 	jmp	#LR__1117
08e54     4C 10 90 FD | 	jmp	#LR__1120
08e58     48 10 90 FD | 	jmp	#LR__1120
08e5c     24 10 90 FD | 	jmp	#LR__1119
08e60     20 10 90 FD | 	jmp	#LR__1119
08e64     6C 00 90 FD | 	jmp	#LR__1023
08e68     68 01 90 FD | 	jmp	#LR__1028
08e6c     54 03 90 FD | 	jmp	#LR__1042
08e70     FC 05 90 FD | 	jmp	#LR__1061
08e74     FC 07 90 FD | 	jmp	#LR__1071
08e78     6C 08 90 FD | 	jmp	#LR__1073
08e7c     C4 09 90 FD | 	jmp	#LR__1079
08e80     94 0B 90 FD | 	jmp	#LR__1091
08e84     30 0D 90 FD | 	jmp	#LR__1101
08e88     84 0E 90 FD | 	jmp	#LR__1110
08e8c     14 0F 90 FD | 	jmp	#LR__1114
08e90     F0 0F 90 FD | 	jmp	#LR__1119
08e94     EC 0F 90 FD | 	jmp	#LR__1119
08e98     E8 0F 90 FD | 	jmp	#LR__1119
08e9c     E4 0F 90 FD | 	jmp	#LR__1119
08ea0     E0 0F 90 FD | 	jmp	#LR__1119
08ea4     DC 0F 90 FD | 	jmp	#LR__1119
08ea8     90 01 90 FD | 	jmp	#LR__1031
08eac     E0 03 90 FD | 	jmp	#LR__1048
08eb0     10 06 90 FD | 	jmp	#LR__1063
08eb4     48 03 90 FD | 	jmp	#LR__1043
08eb8     2C 04 90 FD | 	jmp	#LR__1050
08ebc     C4 0F 90 FD | 	jmp	#LR__1119
08ec0     58 0A 90 FD | 	jmp	#LR__1083
08ec4     BC 0F 90 FD | 	jmp	#LR__1119
08ec8     EC 0B 90 FD | 	jmp	#LR__1095
08ecc     B4 0F 90 FD | 	jmp	#LR__1119
08ed0     D0 0F 90 FD | 	jmp	#LR__1120
08ed4                 | LR__1023
08ed4                 | '             OP_NOP, OP_HALT, OP_ISE, OP_ICL, OP_MSE, OP_MCL: ' nothing!
08ed4                 | '             OP_BRK:
08ed4                 | '                 debug := !debug
08ed4     91 90 05 F1 | 	add	objptr, #145
08ed8     C8 E4 C1 FA | 	rdbyte	local07, objptr
08edc     F2 E6 21 F6 | 	not	local08, local07
08ee0     C8 E6 41 FC | 	wrbyte	local08, objptr
08ee4     91 90 85 F1 | 	sub	objptr, #145
08ee8     B8 0F 90 FD | 	jmp	#LR__1120
08eec                 | LR__1024
08eec                 | '             OP_ADD:
08eec                 | '                 temp := ReadSource(false)
08eec     00 C2 05 F6 | 	mov	arg01, #0
08ef0     58 14 B0 FD | 	call	#_cpu_ReadSource
08ef4     D3 E8 01 F6 | 	mov	local09, result1
08ef8                 | '                 if not (skip)
08ef8     00 E0 0D F2 | 	cmp	local05, #0 wz
08efc     34 00 90 5D |  if_ne	jmp	#LR__1025
08f00                 | '                     temp2 := ReadTarget
08f00     60 16 B0 FD | 	call	#_cpu_ReadTarget
08f04     D3 EA 01 F6 | 	mov	local10, result1
08f08                 | '                     SetCarryFlag((temp2 > 0) and (temp +> $FFFFFFFF - temp2))
08f08     00 C2 05 F6 | 	mov	arg01, #0
08f0c     01 EA 55 F2 | 	cmps	local10, #1 wc
08f10     01 EC 65 36 |  if_ae	neg	local11, #1
08f14     F5 EC 81 31 |  if_ae	sub	local11, local10
08f18     F6 E8 19 32 |  if_ae	cmp	local09, local11 wcz
08f1c     01 C2 65 16 |  if_a	neg	arg01, #1
08f20     74 1E B0 FD | 	call	#_cpu_SetCarryFlag
08f24                 | '                     temp += temp2
08f24     F5 E8 09 F1 | 	add	local09, local10 wz
08f28                 | '                     SetZeroFlag(temp == 0)
08f28     00 C2 05 F6 | 	mov	arg01, #0
08f2c     01 C2 65 A6 |  if_e	neg	arg01, #1
08f30     2C 1E B0 FD | 	call	#_cpu_SetZeroFlag
08f34                 | LR__1025
08f34                 | '                 WriteTarget(temp, true, skip, false)
08f34     F0 EC 01 F6 | 	mov	local11, local05
08f38     F4 C2 01 F6 | 	mov	arg01, local09
08f3c     01 C4 65 F6 | 	neg	arg02, #1
08f40     F6 C6 01 F6 | 	mov	arg03, local11
08f44     00 C8 05 F6 | 	mov	arg04, #0
08f48     70 17 B0 FD | 	call	#_cpu_WriteTarget
08f4c     54 0F 90 FD | 	jmp	#LR__1120
08f50                 | LR__1026
08f50                 | '             OP_INC:
08f50                 | '                 temp := ReadSource(true)
08f50     01 C2 65 F6 | 	neg	arg01, #1
08f54     F4 13 B0 FD | 	call	#_cpu_ReadSource
08f58     D3 E8 01 F6 | 	mov	local09, result1
08f5c                 | '                 if not (skip)
08f5c     00 E0 0D F2 | 	cmp	local05, #0 wz
08f60     40 00 90 5D |  if_ne	jmp	#LR__1027
08f64                 | '                     temp2 := (1 << target)
08f64     01 EA 05 F6 | 	mov	local10, #1
08f68     95 90 05 F1 | 	add	objptr, #149
08f6c     C8 E6 C1 FA | 	rdbyte	local08, objptr
08f70     95 90 85 F1 | 	sub	objptr, #149
08f74     F3 EA 61 F0 | 	shl	local10, local08
08f78                 | '                     SetCarryFlag((temp2 > 0) and (temp +> $FFFFFFFF - temp2))
08f78     00 C2 05 F6 | 	mov	arg01, #0
08f7c     01 EA 55 F2 | 	cmps	local10, #1 wc
08f80     01 EC 65 36 |  if_ae	neg	local11, #1
08f84     F5 EC 81 31 |  if_ae	sub	local11, local10
08f88     F6 E8 19 32 |  if_ae	cmp	local09, local11 wcz
08f8c     01 C2 65 16 |  if_a	neg	arg01, #1
08f90     04 1E B0 FD | 	call	#_cpu_SetCarryFlag
08f94                 | '                     temp += temp2
08f94     F5 E8 09 F1 | 	add	local09, local10 wz
08f98                 | '                     SetZeroFlag(temp == 0)
08f98     00 C2 05 F6 | 	mov	arg01, #0
08f9c     01 C2 65 A6 |  if_e	neg	arg01, #1
08fa0     BC 1D B0 FD | 	call	#_cpu_SetZeroFlag
08fa4                 | LR__1027
08fa4                 | '                 target := source
08fa4     96 90 05 F1 | 	add	objptr, #150
08fa8     C8 E6 C1 FA | 	rdbyte	local08, objptr
08fac     01 90 85 F1 | 	sub	objptr, #1
08fb0     C8 E6 41 FC | 	wrbyte	local08, objptr
08fb4     95 90 85 F1 | 	sub	objptr, #149
08fb8                 | '                 WriteTarget(temp, true, skip, false)
08fb8     F0 EC 01 F6 | 	mov	local11, local05
08fbc     F4 C2 01 F6 | 	mov	arg01, local09
08fc0     01 C4 65 F6 | 	neg	arg02, #1
08fc4     F6 C6 01 F6 | 	mov	arg03, local11
08fc8     00 C8 05 F6 | 	mov	arg04, #0
08fcc     EC 16 B0 FD | 	call	#_cpu_WriteTarget
08fd0     D0 0E 90 FD | 	jmp	#LR__1120
08fd4                 | LR__1028
08fd4                 | '             OP_SUB:
08fd4                 | '                 temp2 := ReadSource(false)
08fd4     00 C2 05 F6 | 	mov	arg01, #0
08fd8     70 13 B0 FD | 	call	#_cpu_ReadSource
08fdc     D3 EA 01 F6 | 	mov	local10, result1
08fe0                 | '                 if not (skip)
08fe0     00 E0 0D F2 | 	cmp	local05, #0 wz
08fe4     34 00 90 5D |  if_ne	jmp	#LR__1030
08fe8                 | '                     temp := ReadTarget
08fe8     78 15 B0 FD | 	call	#_cpu_ReadTarget
08fec     D3 E8 01 F6 | 	mov	local09, result1
08ff0                 | '                     SetCarryFlag((temp2 > 0) and (temp +< 0 + temp2))
08ff0     00 EE 05 F6 | 	mov	local12, #0
08ff4     01 EA 55 F2 | 	cmps	local10, #1 wc
08ff8     08 00 90 CD |  if_b	jmp	#LR__1029
08ffc     F5 E8 11 F2 | 	cmp	local09, local10 wc
09000     01 EE 65 C6 |  if_b	neg	local12, #1
09004                 | LR__1029
09004     F7 C2 01 F6 | 	mov	arg01, local12
09008     8C 1D B0 FD | 	call	#_cpu_SetCarryFlag
0900c                 | '                     temp -= temp2
0900c     F5 E8 89 F1 | 	sub	local09, local10 wz
09010                 | '                     SetZeroFlag(temp == 0)
09010     00 C2 05 F6 | 	mov	arg01, #0
09014     01 C2 65 A6 |  if_e	neg	arg01, #1
09018     44 1D B0 FD | 	call	#_cpu_SetZeroFlag
0901c                 | LR__1030
0901c                 | '                 WriteTarget(temp, true, skip, false)
0901c     01 EE 65 F6 | 	neg	local12, #1
09020     F0 EC 01 F6 | 	mov	local11, local05
09024     F4 C2 01 F6 | 	mov	arg01, local09
09028     01 C4 65 F6 | 	neg	arg02, #1
0902c     F6 C6 01 F6 | 	mov	arg03, local11
09030     00 C8 05 F6 | 	mov	arg04, #0
09034     84 16 B0 FD | 	call	#_cpu_WriteTarget
09038     68 0E 90 FD | 	jmp	#LR__1120
0903c                 | LR__1031
0903c                 | '             OP_DEC:
0903c                 | '                 temp := ReadSource(true)
0903c     01 C2 65 F6 | 	neg	arg01, #1
09040     08 13 B0 FD | 	call	#_cpu_ReadSource
09044     D3 E8 01 F6 | 	mov	local09, result1
09048                 | '                 if not (skip)
09048     00 E0 0D F2 | 	cmp	local05, #0 wz
0904c     40 00 90 5D |  if_ne	jmp	#LR__1033
09050                 | '                     temp2 := (1 << target)
09050     01 EA 05 F6 | 	mov	local10, #1
09054     95 90 05 F1 | 	add	objptr, #149
09058     C8 EE C1 FA | 	rdbyte	local12, objptr
0905c     95 90 85 F1 | 	sub	objptr, #149
09060     F7 EA 61 F0 | 	shl	local10, local12
09064                 | '                     SetCarryFlag((temp2 > 0) and (temp +< 0 + temp2))
09064     00 EE 05 F6 | 	mov	local12, #0
09068     01 EA 55 F2 | 	cmps	local10, #1 wc
0906c     08 00 90 CD |  if_b	jmp	#LR__1032
09070     F5 E8 11 F2 | 	cmp	local09, local10 wc
09074     01 EE 65 C6 |  if_b	neg	local12, #1
09078                 | LR__1032
09078     F7 C2 01 F6 | 	mov	arg01, local12
0907c     18 1D B0 FD | 	call	#_cpu_SetCarryFlag
09080                 | '                     temp -= temp2
09080     F5 E8 89 F1 | 	sub	local09, local10 wz
09084                 | '                     SetZeroFlag(temp == 0)
09084     00 C2 05 F6 | 	mov	arg01, #0
09088     01 C2 65 A6 |  if_e	neg	arg01, #1
0908c     D0 1C B0 FD | 	call	#_cpu_SetZeroFlag
09090                 | LR__1033
09090                 | '                 target := source
09090     96 90 05 F1 | 	add	objptr, #150
09094     C8 E6 C1 FA | 	rdbyte	local08, objptr
09098     01 90 85 F1 | 	sub	objptr, #1
0909c     C8 E6 41 FC | 	wrbyte	local08, objptr
090a0     95 90 85 F1 | 	sub	objptr, #149
090a4                 | '                 WriteTarget(temp, true, skip, false)
090a4     01 EE 65 F6 | 	neg	local12, #1
090a8     F0 EC 01 F6 | 	mov	local11, local05
090ac     F4 C2 01 F6 | 	mov	arg01, local09
090b0     01 C4 65 F6 | 	neg	arg02, #1
090b4     F6 C6 01 F6 | 	mov	arg03, local11
090b8     00 C8 05 F6 | 	mov	arg04, #0
090bc     FC 15 B0 FD | 	call	#_cpu_WriteTarget
090c0     E0 0D 90 FD | 	jmp	#LR__1120
090c4                 | LR__1034
090c4                 | '             OP_MUL:
090c4                 | '                 temp := ReadSource(false)
090c4     00 C2 05 F6 | 	mov	arg01, #0
090c8     80 12 B0 FD | 	call	#_cpu_ReadSource
090cc     D3 E8 01 F6 | 	mov	local09, result1
090d0                 | '                 if not (skip)
090d0     00 E0 0D F2 | 	cmp	local05, #0 wz
090d4     48 00 90 5D |  if_ne	jmp	#LR__1036
090d8                 | '                     temp2 := ReadTarget
090d8     88 14 B0 FD | 	call	#_cpu_ReadTarget
090dc     D3 EA 09 F6 | 	mov	local10, result1 wz
090e0                 | '                     SetCarryFlag((temp2 <> 0) and (temp +> $FFFFFFFF / temp2))
090e0     00 EE 05 F6 | 	mov	local12, #0
090e4     18 00 90 AD |  if_e	jmp	#LR__1035
090e8     F5 EC 51 F6 | 	abs	local11, local10 wc
090ec     F6 02 18 FD | 	qdiv	#1, local11
090f0     18 EC 61 FD | 	getqx	local11
090f4     F6 EC A1 F6 | 	negnc	local11, local11
090f8     F6 E8 19 F2 | 	cmp	local09, local11 wcz
090fc     01 EE 65 16 |  if_a	neg	local12, #1
09100                 | LR__1035
09100     F7 C2 01 F6 | 	mov	arg01, local12
09104     90 1C B0 FD | 	call	#_cpu_SetCarryFlag
09108     F5 E8 01 FD | 	qmul	local09, local10
0910c                 | '                     temp *= temp2
0910c                 | '                     SetZeroFlag(temp == 0)
0910c     00 C2 05 F6 | 	mov	arg01, #0
09110     18 E8 61 FD | 	getqx	local09
09114     00 E8 0D F2 | 	cmp	local09, #0 wz
09118     01 C2 65 A6 |  if_e	neg	arg01, #1
0911c     40 1C B0 FD | 	call	#_cpu_SetZeroFlag
09120                 | LR__1036
09120                 | '                 WriteTarget(temp, true, skip, false)
09120     01 EE 65 F6 | 	neg	local12, #1
09124     F0 EC 01 F6 | 	mov	local11, local05
09128     F4 C2 01 F6 | 	mov	arg01, local09
0912c     01 C4 65 F6 | 	neg	arg02, #1
09130     F6 C6 01 F6 | 	mov	arg03, local11
09134     00 C8 05 F6 | 	mov	arg04, #0
09138     80 15 B0 FD | 	call	#_cpu_WriteTarget
0913c     64 0D 90 FD | 	jmp	#LR__1120
09140                 | LR__1037
09140                 | '             OP_IMUL: ' FIXME: is this correct? also need to implement carry flag
09140                 | '                 temp := ReadSource(false)
09140     00 C2 05 F6 | 	mov	arg01, #0
09144     04 12 B0 FD | 	call	#_cpu_ReadSource
09148     D3 E8 01 F6 | 	mov	local09, result1
0914c                 | '                 case size
0914c     97 90 05 F1 | 	add	objptr, #151
09150     C8 F0 C1 FA | 	rdbyte	local13, objptr
09154     97 90 85 F1 | 	sub	objptr, #151
09158     01 F0 0D F2 | 	cmp	local13, #1 wz
0915c     0C 00 90 AD |  if_e	jmp	#LR__1038
09160     02 F0 0D F2 | 	cmp	local13, #2 wz
09164     10 00 90 AD |  if_e	jmp	#LR__1039
09168     14 00 90 FD | 	jmp	#LR__1040
0916c                 | LR__1038
0916c                 | '                     SZ_BYTE: temp := ~temp ' sign extend 7
0916c     07 E8 65 F7 | 	signx	local09, #7
09170     F4 F2 01 F6 | 	mov	local14, local09
09174     08 00 90 FD | 	jmp	#LR__1040
09178                 | LR__1039
09178                 | '                     SZ_HALF: temp := ~~temp ' sign extend 15
09178     0F E8 65 F7 | 	signx	local09, #15
0917c     F4 F4 01 F6 | 	mov	local15, local09
09180                 | LR__1040
09180                 | '                 if not (skip)
09180     00 E0 0D F2 | 	cmp	local05, #0 wz
09184     1C 00 90 5D |  if_ne	jmp	#LR__1041
09188                 | '                     temp2 := temp * ReadTarget
09188     D8 13 B0 FD | 	call	#_cpu_ReadTarget
0918c     D3 E8 01 FD | 	qmul	local09, result1
09190                 | '                     SetZeroFlag(temp2 == 0)
09190     00 C2 05 F6 | 	mov	arg01, #0
09194     18 EA 61 FD | 	getqx	local10
09198     00 EA 0D F2 | 	cmp	local10, #0 wz
0919c     01 C2 65 A6 |  if_e	neg	arg01, #1
091a0     BC 1B B0 FD | 	call	#_cpu_SetZeroFlag
091a4                 | LR__1041
091a4                 | '                 WriteTarget(temp2, true, skip, false)
091a4     01 EE 65 F6 | 	neg	local12, #1
091a8     F0 EC 01 F6 | 	mov	local11, local05
091ac     F5 C2 01 F6 | 	mov	arg01, local10
091b0     01 C4 65 F6 | 	neg	arg02, #1
091b4     F6 C6 01 F6 | 	mov	arg03, local11
091b8     00 C8 05 F6 | 	mov	arg04, #0
091bc     FC 14 B0 FD | 	call	#_cpu_WriteTarget
091c0     E0 0C 90 FD | 	jmp	#LR__1120
091c4                 | LR__1042
091c4                 | '             OP_DIV:
091c4                 | '                 temp := ReadSource(false)
091c4     00 C2 05 F6 | 	mov	arg01, #0
091c8     80 11 B0 FD | 	call	#_cpu_ReadSource
091cc     D3 E8 01 F6 | 	mov	local09, result1
091d0                 | '                 WriteTarget(ReadTarget +/ temp, true, skip, false)
091d0     90 13 B0 FD | 	call	#_cpu_ReadTarget
091d4     F4 A6 11 FD | 	qdiv	result1, local09
091d8     01 EE 65 F6 | 	neg	local12, #1
091dc     F0 EC 01 F6 | 	mov	local11, local05
091e0     00 F6 05 F6 | 	mov	local16, #0
091e4     01 C4 65 F6 | 	neg	arg02, #1
091e8     F6 C6 01 F6 | 	mov	arg03, local11
091ec     00 C8 05 F6 | 	mov	arg04, #0
091f0     18 E6 61 FD | 	getqx	local08
091f4     F3 C2 01 F6 | 	mov	arg01, local08
091f8     C0 14 B0 FD | 	call	#_cpu_WriteTarget
091fc     A4 0C 90 FD | 	jmp	#LR__1120
09200                 | LR__1043
09200                 | '             OP_IDIV: ' FIXME: is this correct?
09200                 | '                 temp := ReadSource(false)
09200     00 C2 05 F6 | 	mov	arg01, #0
09204     44 11 B0 FD | 	call	#_cpu_ReadSource
09208     D3 E8 01 F6 | 	mov	local09, result1
0920c                 | '                 case size
0920c     97 90 05 F1 | 	add	objptr, #151
09210     C8 F8 C1 FA | 	rdbyte	local17, objptr
09214     97 90 85 F1 | 	sub	objptr, #151
09218     01 F8 0D F2 | 	cmp	local17, #1 wz
0921c     0C 00 90 AD |  if_e	jmp	#LR__1044
09220     02 F8 0D F2 | 	cmp	local17, #2 wz
09224     10 00 90 AD |  if_e	jmp	#LR__1045
09228     14 00 90 FD | 	jmp	#LR__1046
0922c                 | LR__1044
0922c                 | '                     SZ_BYTE: temp := ~temp ' sign extend 7
0922c     07 E8 65 F7 | 	signx	local09, #7
09230     F4 FA 01 F6 | 	mov	local18, local09
09234     08 00 90 FD | 	jmp	#LR__1046
09238                 | LR__1045
09238                 | '                     SZ_HALF: temp := ~~temp ' sign extend 15
09238     0F E8 65 F7 | 	signx	local09, #15
0923c     F4 FC 01 F6 | 	mov	local19, local09
09240                 | LR__1046
09240                 | '                 if not (skip)
09240     00 E0 0D F2 | 	cmp	local05, #0 wz
09244     20 00 90 5D |  if_ne	jmp	#LR__1047
09248                 | '                     temp2 := ReadTarget / temp
09248     18 13 B0 FD | 	call	#_cpu_ReadTarget
0924c     D3 24 02 F6 | 	mov	muldiva_, result1
09250     F4 26 02 F6 | 	mov	muldivb_, local09
09254     BA 00 A0 FD | 	call	#divide_
09258     13 EB 09 F6 | 	mov	local10, muldivb_ wz
0925c                 | '                     SetZeroFlag(temp2 == 0)
0925c     00 C2 05 F6 | 	mov	arg01, #0
09260     01 C2 65 A6 |  if_e	neg	arg01, #1
09264     F8 1A B0 FD | 	call	#_cpu_SetZeroFlag
09268                 | LR__1047
09268                 | '                 WriteTarget(temp2, true, skip, false)
09268     F5 E6 01 F6 | 	mov	local08, local10
0926c     01 EE 65 F6 | 	neg	local12, #1
09270     F0 EC 01 F6 | 	mov	local11, local05
09274     00 F6 05 F6 | 	mov	local16, #0
09278     F3 C2 01 F6 | 	mov	arg01, local08
0927c     01 C4 65 F6 | 	neg	arg02, #1
09280     F6 C6 01 F6 | 	mov	arg03, local11
09284     00 C8 05 F6 | 	mov	arg04, #0
09288     30 14 B0 FD | 	call	#_cpu_WriteTarget
0928c     14 0C 90 FD | 	jmp	#LR__1120
09290                 | LR__1048
09290                 | '             OP_REM:
09290                 | '                 temp := ReadSource(false)
09290     00 C2 05 F6 | 	mov	arg01, #0
09294     B4 10 B0 FD | 	call	#_cpu_ReadSource
09298     D3 E8 01 F6 | 	mov	local09, result1
0929c                 | '                 if not (skip)
0929c     00 E0 0D F2 | 	cmp	local05, #0 wz
092a0     1C 00 90 5D |  if_ne	jmp	#LR__1049
092a4                 | '                     temp2 := ReadTarget +// temp
092a4     BC 12 B0 FD | 	call	#_cpu_ReadTarget
092a8     F4 A6 11 FD | 	qdiv	result1, local09
092ac                 | '                     SetZeroFlag(temp2 == 0)
092ac     00 C2 05 F6 | 	mov	arg01, #0
092b0     19 EA 61 FD | 	getqy	local10
092b4     00 EA 0D F2 | 	cmp	local10, #0 wz
092b8     01 C2 65 A6 |  if_e	neg	arg01, #1
092bc     A0 1A B0 FD | 	call	#_cpu_SetZeroFlag
092c0                 | LR__1049
092c0                 | '                 WriteTarget(temp2, true, skip, false)
092c0     F5 E6 01 F6 | 	mov	local08, local10
092c4     01 EE 65 F6 | 	neg	local12, #1
092c8     F0 EC 01 F6 | 	mov	local11, local05
092cc     00 F6 05 F6 | 	mov	local16, #0
092d0     F3 C2 01 F6 | 	mov	arg01, local08
092d4     01 C4 65 F6 | 	neg	arg02, #1
092d8     F6 C6 01 F6 | 	mov	arg03, local11
092dc     00 C8 05 F6 | 	mov	arg04, #0
092e0     D8 13 B0 FD | 	call	#_cpu_WriteTarget
092e4     BC 0B 90 FD | 	jmp	#LR__1120
092e8                 | LR__1050
092e8                 | '             OP_IREM: ' FIXME: is this correct?
092e8                 | '                 temp := ReadSource(false)
092e8     00 C2 05 F6 | 	mov	arg01, #0
092ec     5C 10 B0 FD | 	call	#_cpu_ReadSource
092f0     D3 E8 01 F6 | 	mov	local09, result1
092f4                 | '                 if not (skip)
092f4     00 E0 0D F2 | 	cmp	local05, #0 wz
092f8     A4 00 90 5D |  if_ne	jmp	#LR__1056
092fc                 | '                     case size
092fc     97 90 05 F1 | 	add	objptr, #151
09300     C8 FE C1 FA | 	rdbyte	local20, objptr
09304     97 90 85 F1 | 	sub	objptr, #151
09308     01 FE 85 F1 | 	sub	local20, #1
0930c     04 FE 25 F3 | 	fle	local20, #4
09310     30 FE 61 FD | 	jmprel	local20
09314                 | LR__1051
09314     10 00 90 FD | 	jmp	#LR__1052
09318     38 00 90 FD | 	jmp	#LR__1053
0931c     80 00 90 FD | 	jmp	#LR__1055
09320     5C 00 90 FD | 	jmp	#LR__1054
09324     78 00 90 FD | 	jmp	#LR__1055
09328                 | LR__1052
09328                 | '                         SZ_BYTE:
09328                 | '                             temp := ~temp ' sign extend 7
09328     07 E8 65 F7 | 	signx	local09, #7
0932c     F4 00 02 F6 | 	mov	local21, local09
09330                 | '                             temp2 := ReadTarget // temp
09330     30 12 B0 FD | 	call	#_cpu_ReadTarget
09334     D3 24 02 F6 | 	mov	muldiva_, result1
09338     F4 26 02 F6 | 	mov	muldivb_, local09
0933c     BA 00 A0 FD | 	call	#divide_
09340     12 EB 09 F6 | 	mov	local10, muldiva_ wz
09344                 | '                             SetZeroFlag(temp2 == 0)
09344     00 C2 05 F6 | 	mov	arg01, #0
09348     01 C2 65 A6 |  if_e	neg	arg01, #1
0934c     10 1A B0 FD | 	call	#_cpu_SetZeroFlag
09350     4C 00 90 FD | 	jmp	#LR__1055
09354                 | LR__1053
09354                 | '                         SZ_HALF:
09354                 | '                             temp := ~~temp ' sign extend 15
09354     0F E8 65 F7 | 	signx	local09, #15
09358     F4 02 02 F6 | 	mov	local22, local09
0935c                 | '                             temp2 := ReadTarget // temp
0935c     04 12 B0 FD | 	call	#_cpu_ReadTarget
09360     D3 24 02 F6 | 	mov	muldiva_, result1
09364     F4 26 02 F6 | 	mov	muldivb_, local09
09368     BA 00 A0 FD | 	call	#divide_
0936c     12 EB 09 F6 | 	mov	local10, muldiva_ wz
09370                 | '                             SetZeroFlag(temp2 == 0)
09370     00 C2 05 F6 | 	mov	arg01, #0
09374     01 C2 65 A6 |  if_e	neg	arg01, #1
09378     E4 19 B0 FD | 	call	#_cpu_SetZeroFlag
0937c     20 00 90 FD | 	jmp	#LR__1055
09380                 | LR__1054
09380                 | '                         SZ_WORD:
09380                 | '                             temp2 := ReadTarget // temp
09380     E0 11 B0 FD | 	call	#_cpu_ReadTarget
09384     D3 24 02 F6 | 	mov	muldiva_, result1
09388     F4 26 02 F6 | 	mov	muldivb_, local09
0938c     BA 00 A0 FD | 	call	#divide_
09390     12 EB 09 F6 | 	mov	local10, muldiva_ wz
09394                 | '                             SetZeroFlag(temp2 == 0)
09394     00 C2 05 F6 | 	mov	arg01, #0
09398     01 C2 65 A6 |  if_e	neg	arg01, #1
0939c     C0 19 B0 FD | 	call	#_cpu_SetZeroFlag
093a0                 | LR__1055
093a0                 | LR__1056
093a0                 | '                 WriteTarget(temp2, true, skip, false)
093a0     F5 E6 01 F6 | 	mov	local08, local10
093a4     01 EE 65 F6 | 	neg	local12, #1
093a8     F0 EC 01 F6 | 	mov	local11, local05
093ac     00 F6 05 F6 | 	mov	local16, #0
093b0     F3 C2 01 F6 | 	mov	arg01, local08
093b4     01 C4 65 F6 | 	neg	arg02, #1
093b8     F6 C6 01 F6 | 	mov	arg03, local11
093bc     00 C8 05 F6 | 	mov	arg04, #0
093c0     F8 12 B0 FD | 	call	#_cpu_WriteTarget
093c4     DC 0A 90 FD | 	jmp	#LR__1120
093c8                 | LR__1057
093c8                 | '             OP_AND:
093c8                 | '                 temp := ReadSource(false)
093c8     00 C2 05 F6 | 	mov	arg01, #0
093cc     7C 0F B0 FD | 	call	#_cpu_ReadSource
093d0     D3 E8 01 F6 | 	mov	local09, result1
093d4                 | '                 if not (skip)
093d4     00 E0 0D F2 | 	cmp	local05, #0 wz
093d8     18 00 90 5D |  if_ne	jmp	#LR__1058
093dc                 | '                     temp2 := ReadTarget & temp
093dc     84 11 B0 FD | 	call	#_cpu_ReadTarget
093e0     D3 EA 01 F6 | 	mov	local10, result1
093e4     F4 EA 09 F5 | 	and	local10, local09 wz
093e8                 | '                     SetZeroFlag(temp2 == 0)
093e8     00 C2 05 F6 | 	mov	arg01, #0
093ec     01 C2 65 A6 |  if_e	neg	arg01, #1
093f0     6C 19 B0 FD | 	call	#_cpu_SetZeroFlag
093f4                 | LR__1058
093f4                 | '                 WriteTarget(temp2, true, skip, false)
093f4     F5 E6 01 F6 | 	mov	local08, local10
093f8     01 EE 65 F6 | 	neg	local12, #1
093fc     F0 EC 01 F6 | 	mov	local11, local05
09400     00 F6 05 F6 | 	mov	local16, #0
09404     F3 C2 01 F6 | 	mov	arg01, local08
09408     01 C4 65 F6 | 	neg	arg02, #1
0940c     F6 C6 01 F6 | 	mov	arg03, local11
09410     00 C8 05 F6 | 	mov	arg04, #0
09414     A4 12 B0 FD | 	call	#_cpu_WriteTarget
09418     88 0A 90 FD | 	jmp	#LR__1120
0941c                 | LR__1059
0941c                 | '             OP_OR:
0941c                 | '                 temp := ReadSource(false)
0941c     00 C2 05 F6 | 	mov	arg01, #0
09420     28 0F B0 FD | 	call	#_cpu_ReadSource
09424     D3 E8 01 F6 | 	mov	local09, result1
09428                 | '                 if not (skip)
09428     00 E0 0D F2 | 	cmp	local05, #0 wz
0942c     18 00 90 5D |  if_ne	jmp	#LR__1060
09430                 | '                     temp2 := ReadTarget | temp
09430     30 11 B0 FD | 	call	#_cpu_ReadTarget
09434     D3 EA 01 F6 | 	mov	local10, result1
09438     F4 EA 49 F5 | 	or	local10, local09 wz
0943c                 | '                     SetZeroFlag(temp2 == 0)
0943c     00 C2 05 F6 | 	mov	arg01, #0
09440     01 C2 65 A6 |  if_e	neg	arg01, #1
09444     18 19 B0 FD | 	call	#_cpu_SetZeroFlag
09448                 | LR__1060
09448                 | '                 WriteTarget(temp2, true, skip, false)
09448     F5 E6 01 F6 | 	mov	local08, local10
0944c     01 EE 65 F6 | 	neg	local12, #1
09450     F0 EC 01 F6 | 	mov	local11, local05
09454     00 F6 05 F6 | 	mov	local16, #0
09458     F3 C2 01 F6 | 	mov	arg01, local08
0945c     01 C4 65 F6 | 	neg	arg02, #1
09460     F6 C6 01 F6 | 	mov	arg03, local11
09464     00 C8 05 F6 | 	mov	arg04, #0
09468     50 12 B0 FD | 	call	#_cpu_WriteTarget
0946c     34 0A 90 FD | 	jmp	#LR__1120
09470                 | LR__1061
09470                 | '             OP_XOR:
09470                 | '                 temp := ReadSource(false)
09470     00 C2 05 F6 | 	mov	arg01, #0
09474     D4 0E B0 FD | 	call	#_cpu_ReadSource
09478     D3 E8 01 F6 | 	mov	local09, result1
0947c                 | '                 if not (skip)
0947c     00 E0 0D F2 | 	cmp	local05, #0 wz
09480     18 00 90 5D |  if_ne	jmp	#LR__1062
09484                 | '                     temp2 := ReadTarget ^ temp
09484     DC 10 B0 FD | 	call	#_cpu_ReadTarget
09488     D3 EA 01 F6 | 	mov	local10, result1
0948c     F4 EA 69 F5 | 	xor	local10, local09 wz
09490                 | '                     SetZeroFlag(temp2 == 0)
09490     00 C2 05 F6 | 	mov	arg01, #0
09494     01 C2 65 A6 |  if_e	neg	arg01, #1
09498     C4 18 B0 FD | 	call	#_cpu_SetZeroFlag
0949c                 | LR__1062
0949c                 | '                 WriteTarget(temp2, true, skip, false)
0949c     F5 E6 01 F6 | 	mov	local08, local10
094a0     01 EE 65 F6 | 	neg	local12, #1
094a4     F0 EC 01 F6 | 	mov	local11, local05
094a8     00 F6 05 F6 | 	mov	local16, #0
094ac     F3 C2 01 F6 | 	mov	arg01, local08
094b0     01 C4 65 F6 | 	neg	arg02, #1
094b4     F6 C6 01 F6 | 	mov	arg03, local11
094b8     00 C8 05 F6 | 	mov	arg04, #0
094bc     FC 11 B0 FD | 	call	#_cpu_WriteTarget
094c0     E0 09 90 FD | 	jmp	#LR__1120
094c4                 | LR__1063
094c4                 | '             OP_NOT:
094c4                 | '                 temp := !ReadSource(true)
094c4     01 C2 65 F6 | 	neg	arg01, #1
094c8     80 0E B0 FD | 	call	#_cpu_ReadSource
094cc     D3 E8 21 F6 | 	not	local09, result1
094d0                 | '                 if not (skip)
094d0     00 E0 0D F2 | 	cmp	local05, #0 wz
094d4     10 00 90 5D |  if_ne	jmp	#LR__1064
094d8                 | '                     SetZeroFlag(temp == 0)
094d8     00 C2 05 F6 | 	mov	arg01, #0
094dc     00 E8 0D F2 | 	cmp	local09, #0 wz
094e0     01 C2 65 A6 |  if_e	neg	arg01, #1
094e4     78 18 B0 FD | 	call	#_cpu_SetZeroFlag
094e8                 | LR__1064
094e8                 | '                 target := source
094e8     96 90 05 F1 | 	add	objptr, #150
094ec     C8 E6 C1 FA | 	rdbyte	local08, objptr
094f0     01 90 85 F1 | 	sub	objptr, #1
094f4     C8 E6 41 FC | 	wrbyte	local08, objptr
094f8     95 90 85 F1 | 	sub	objptr, #149
094fc                 | '                 WriteTarget(temp, true, skip, false)
094fc     F4 E6 01 F6 | 	mov	local08, local09
09500     01 EE 65 F6 | 	neg	local12, #1
09504     F0 EC 01 F6 | 	mov	local11, local05
09508     00 F6 05 F6 | 	mov	local16, #0
0950c     F3 C2 01 F6 | 	mov	arg01, local08
09510     01 C4 65 F6 | 	neg	arg02, #1
09514     F6 C6 01 F6 | 	mov	arg03, local11
09518     00 C8 05 F6 | 	mov	arg04, #0
0951c     9C 11 B0 FD | 	call	#_cpu_WriteTarget
09520     80 09 90 FD | 	jmp	#LR__1120
09524                 | LR__1065
09524                 | '             OP_SLA: ' shifts & rotates always use an 8-bit source
09524                 | '                 savedSize := size
09524     97 90 05 F1 | 	add	objptr, #151
09528     C8 04 C2 FA | 	rdbyte	local23, objptr
0952c                 | '                 size := SZ_BYTE
0952c     C8 02 48 FC | 	wrbyte	#1, objptr
09530     97 90 85 F1 | 	sub	objptr, #151
09534                 | '                 temp := ReadSource(false)
09534     00 C2 05 F6 | 	mov	arg01, #0
09538     10 0E B0 FD | 	call	#_cpu_ReadSource
0953c     D3 E8 01 F6 | 	mov	local09, result1
09540                 | '                 size := savedSize
09540     97 90 05 F1 | 	add	objptr, #151
09544     C8 04 42 FC | 	wrbyte	local23, objptr
09548     97 90 85 F1 | 	sub	objptr, #151
0954c                 | '                 if not (skip)
0954c     00 E0 0D F2 | 	cmp	local05, #0 wz
09550     18 00 90 5D |  if_ne	jmp	#LR__1066
09554                 | '                     temp2 := ReadTarget << temp
09554     0C 10 B0 FD | 	call	#_cpu_ReadTarget
09558     D3 EA 01 F6 | 	mov	local10, result1
0955c     F4 EA 69 F0 | 	shl	local10, local09 wz
09560                 | '                     SetZeroFlag(temp2 == 0)
09560     00 C2 05 F6 | 	mov	arg01, #0
09564     01 C2 65 A6 |  if_e	neg	arg01, #1
09568     F4 17 B0 FD | 	call	#_cpu_SetZeroFlag
0956c                 | LR__1066
0956c                 | '                 WriteTarget(temp2, true, skip, false)
0956c     F5 E6 01 F6 | 	mov	local08, local10
09570     01 EE 65 F6 | 	neg	local12, #1
09574     F0 EC 01 F6 | 	mov	local11, local05
09578     00 F6 05 F6 | 	mov	local16, #0
0957c     F3 C2 01 F6 | 	mov	arg01, local08
09580     01 C4 65 F6 | 	neg	arg02, #1
09584     F6 C6 01 F6 | 	mov	arg03, local11
09588     00 C8 05 F6 | 	mov	arg04, #0
0958c     2C 11 B0 FD | 	call	#_cpu_WriteTarget
09590     10 09 90 FD | 	jmp	#LR__1120
09594                 | LR__1067
09594                 | '             OP_SRA: ' shifts & rotates always use an 8-bit source
09594                 | '                 savedSize := size
09594     97 90 05 F1 | 	add	objptr, #151
09598     C8 04 C2 FA | 	rdbyte	local23, objptr
0959c                 | '                 size := SZ_BYTE
0959c     C8 02 48 FC | 	wrbyte	#1, objptr
095a0     97 90 85 F1 | 	sub	objptr, #151
095a4                 | '                 temp := ReadSource(false)
095a4     00 C2 05 F6 | 	mov	arg01, #0
095a8     A0 0D B0 FD | 	call	#_cpu_ReadSource
095ac     D3 E8 01 F6 | 	mov	local09, result1
095b0                 | '                 size := savedSize
095b0     97 90 05 F1 | 	add	objptr, #151
095b4     C8 04 42 FC | 	wrbyte	local23, objptr
095b8     97 90 85 F1 | 	sub	objptr, #151
095bc                 | '                 if not (skip)
095bc     00 E0 0D F2 | 	cmp	local05, #0 wz
095c0     18 00 90 5D |  if_ne	jmp	#LR__1068
095c4                 | '                     temp2 := ReadTarget ~> temp
095c4     9C 0F B0 FD | 	call	#_cpu_ReadTarget
095c8     D3 EA 01 F6 | 	mov	local10, result1
095cc     F4 EA C9 F0 | 	sar	local10, local09 wz
095d0                 | '                     SetZeroFlag(temp2 == 0)
095d0     00 C2 05 F6 | 	mov	arg01, #0
095d4     01 C2 65 A6 |  if_e	neg	arg01, #1
095d8     84 17 B0 FD | 	call	#_cpu_SetZeroFlag
095dc                 | LR__1068
095dc                 | '                 WriteTarget(temp2, true, skip, false)
095dc     F5 E6 01 F6 | 	mov	local08, local10
095e0     01 EE 65 F6 | 	neg	local12, #1
095e4     F0 EC 01 F6 | 	mov	local11, local05
095e8     00 F6 05 F6 | 	mov	local16, #0
095ec     F3 C2 01 F6 | 	mov	arg01, local08
095f0     01 C4 65 F6 | 	neg	arg02, #1
095f4     F6 C6 01 F6 | 	mov	arg03, local11
095f8     00 C8 05 F6 | 	mov	arg04, #0
095fc     BC 10 B0 FD | 	call	#_cpu_WriteTarget
09600     A0 08 90 FD | 	jmp	#LR__1120
09604                 | LR__1069
09604                 | '             OP_SRL: ' shifts & rotates always use an 8-bit source
09604                 | '                 savedSize := size
09604     97 90 05 F1 | 	add	objptr, #151
09608     C8 04 C2 FA | 	rdbyte	local23, objptr
0960c                 | '                 size := SZ_BYTE
0960c     C8 02 48 FC | 	wrbyte	#1, objptr
09610     97 90 85 F1 | 	sub	objptr, #151
09614                 | '                 temp := ReadSource(false)
09614     00 C2 05 F6 | 	mov	arg01, #0
09618     30 0D B0 FD | 	call	#_cpu_ReadSource
0961c     D3 E8 01 F6 | 	mov	local09, result1
09620                 | '                 size := savedSize
09620     97 90 05 F1 | 	add	objptr, #151
09624     C8 04 42 FC | 	wrbyte	local23, objptr
09628     97 90 85 F1 | 	sub	objptr, #151
0962c                 | '                 if not (skip)
0962c     00 E0 0D F2 | 	cmp	local05, #0 wz
09630     18 00 90 5D |  if_ne	jmp	#LR__1070
09634                 | '                     temp2 := ReadTarget >> temp
09634     2C 0F B0 FD | 	call	#_cpu_ReadTarget
09638     D3 EA 01 F6 | 	mov	local10, result1
0963c     F4 EA 49 F0 | 	shr	local10, local09 wz
09640                 | '                     SetZeroFlag(temp2 == 0)
09640     00 C2 05 F6 | 	mov	arg01, #0
09644     01 C2 65 A6 |  if_e	neg	arg01, #1
09648     14 17 B0 FD | 	call	#_cpu_SetZeroFlag
0964c                 | LR__1070
0964c                 | '                 WriteTarget(temp2, true, skip, false)
0964c     F5 E6 01 F6 | 	mov	local08, local10
09650     01 EE 65 F6 | 	neg	local12, #1
09654     F0 EC 01 F6 | 	mov	local11, local05
09658     00 F6 05 F6 | 	mov	local16, #0
0965c     F3 C2 01 F6 | 	mov	arg01, local08
09660     01 C4 65 F6 | 	neg	arg02, #1
09664     F6 C6 01 F6 | 	mov	arg03, local11
09668     00 C8 05 F6 | 	mov	arg04, #0
0966c     4C 10 B0 FD | 	call	#_cpu_WriteTarget
09670     30 08 90 FD | 	jmp	#LR__1120
09674                 | LR__1071
09674                 | '             OP_ROL: ' shifts & rotates always use an 8-bit source
09674                 | '                 savedSize := size
09674     97 90 05 F1 | 	add	objptr, #151
09678     C8 04 C2 FA | 	rdbyte	local23, objptr
0967c                 | '                 size := SZ_BYTE
0967c     C8 02 48 FC | 	wrbyte	#1, objptr
09680     97 90 85 F1 | 	sub	objptr, #151
09684                 | '                 temp := ReadSource(false)
09684     00 C2 05 F6 | 	mov	arg01, #0
09688     C0 0C B0 FD | 	call	#_cpu_ReadSource
0968c     D3 E8 01 F6 | 	mov	local09, result1
09690                 | '                 size := savedSize
09690     97 90 05 F1 | 	add	objptr, #151
09694     C8 04 42 FC | 	wrbyte	local23, objptr
09698     97 90 85 F1 | 	sub	objptr, #151
0969c                 | '                 if not (skip)
0969c     00 E0 0D F2 | 	cmp	local05, #0 wz
096a0     1C 00 90 5D |  if_ne	jmp	#LR__1072
096a4                 | '                     temp2 := ReadTarget <- temp
096a4     BC 0E B0 FD | 	call	#_cpu_ReadTarget
096a8     D3 EA 01 F6 | 	mov	local10, result1
096ac     F4 EA 21 F0 | 	rol	local10, local09
096b0                 | '                     SetZeroFlag(temp2 == 0)
096b0     00 C2 05 F6 | 	mov	arg01, #0
096b4     00 EA 0D F2 | 	cmp	local10, #0 wz
096b8     01 C2 65 A6 |  if_e	neg	arg01, #1
096bc     A0 16 B0 FD | 	call	#_cpu_SetZeroFlag
096c0                 | LR__1072
096c0                 | '                 WriteTarget(temp2, true, skip, false)
096c0     F5 E6 01 F6 | 	mov	local08, local10
096c4     01 EE 65 F6 | 	neg	local12, #1
096c8     F0 EC 01 F6 | 	mov	local11, local05
096cc     00 F6 05 F6 | 	mov	local16, #0
096d0     F3 C2 01 F6 | 	mov	arg01, local08
096d4     01 C4 65 F6 | 	neg	arg02, #1
096d8     F6 C6 01 F6 | 	mov	arg03, local11
096dc     00 C8 05 F6 | 	mov	arg04, #0
096e0     D8 0F B0 FD | 	call	#_cpu_WriteTarget
096e4     BC 07 90 FD | 	jmp	#LR__1120
096e8                 | LR__1073
096e8                 | '             OP_ROR: ' shifts & rotates always use an 8-bit source
096e8                 | '                 savedSize := size
096e8     97 90 05 F1 | 	add	objptr, #151
096ec     C8 04 C2 FA | 	rdbyte	local23, objptr
096f0                 | '                 size := SZ_BYTE
096f0     C8 02 48 FC | 	wrbyte	#1, objptr
096f4     97 90 85 F1 | 	sub	objptr, #151
096f8                 | '                 temp := ReadSource(false)
096f8     00 C2 05 F6 | 	mov	arg01, #0
096fc     4C 0C B0 FD | 	call	#_cpu_ReadSource
09700     D3 E8 01 F6 | 	mov	local09, result1
09704                 | '                 size := savedSize
09704     97 90 05 F1 | 	add	objptr, #151
09708     C8 04 42 FC | 	wrbyte	local23, objptr
0970c     97 90 85 F1 | 	sub	objptr, #151
09710                 | '                 if not (skip)
09710     00 E0 0D F2 | 	cmp	local05, #0 wz
09714     1C 00 90 5D |  if_ne	jmp	#LR__1074
09718                 | '                     temp2 := ReadTarget -> temp
09718     48 0E B0 FD | 	call	#_cpu_ReadTarget
0971c     D3 EA 01 F6 | 	mov	local10, result1
09720     F4 EA 01 F0 | 	ror	local10, local09
09724                 | '                     SetZeroFlag(temp2 == 0)
09724     00 C2 05 F6 | 	mov	arg01, #0
09728     00 EA 0D F2 | 	cmp	local10, #0 wz
0972c     01 C2 65 A6 |  if_e	neg	arg01, #1
09730     2C 16 B0 FD | 	call	#_cpu_SetZeroFlag
09734                 | LR__1074
09734                 | '                 WriteTarget(temp2, true, skip, false)
09734     F5 E6 01 F6 | 	mov	local08, local10
09738     01 EE 65 F6 | 	neg	local12, #1
0973c     F0 EC 01 F6 | 	mov	local11, local05
09740     00 F6 05 F6 | 	mov	local16, #0
09744     F3 C2 01 F6 | 	mov	arg01, local08
09748     01 C4 65 F6 | 	neg	arg02, #1
0974c     F6 C6 01 F6 | 	mov	arg03, local11
09750     00 C8 05 F6 | 	mov	arg04, #0
09754     64 0F B0 FD | 	call	#_cpu_WriteTarget
09758     48 07 90 FD | 	jmp	#LR__1120
0975c                 | LR__1075
0975c                 | '             OP_BSE: ' bit operations always use an 8-bit source
0975c                 | '                 savedSize := size
0975c     97 90 05 F1 | 	add	objptr, #151
09760     C8 04 C2 FA | 	rdbyte	local23, objptr
09764                 | '                 size := SZ_BYTE
09764     C8 02 48 FC | 	wrbyte	#1, objptr
09768     97 90 85 F1 | 	sub	objptr, #151
0976c                 | '                 temp := ReadSource(false)
0976c     00 C2 05 F6 | 	mov	arg01, #0
09770     D8 0B B0 FD | 	call	#_cpu_ReadSource
09774     D3 E8 01 F6 | 	mov	local09, result1
09778                 | '                 size := savedSize
09778     97 90 05 F1 | 	add	objptr, #151
0977c     C8 04 42 FC | 	wrbyte	local23, objptr
09780     97 90 85 F1 | 	sub	objptr, #151
09784                 | '                 if not (skip)
09784     00 E0 0D F2 | 	cmp	local05, #0 wz
09788     1C 00 90 5D |  if_ne	jmp	#LR__1076
0978c                 | '                     temp2 := ReadTarget | (1 << temp)
0978c     D4 0D B0 FD | 	call	#_cpu_ReadTarget
09790     F4 EC C1 F9 | 	decod	local11, local09
09794     D3 EA 01 F6 | 	mov	local10, result1
09798     F6 EA 49 F5 | 	or	local10, local11 wz
0979c                 | '                     SetZeroFlag(temp2 == 0)
0979c     00 C2 05 F6 | 	mov	arg01, #0
097a0     01 C2 65 A6 |  if_e	neg	arg01, #1
097a4     B8 15 B0 FD | 	call	#_cpu_SetZeroFlag
097a8                 | LR__1076
097a8                 | '                 WriteTarget(temp2, true, skip, false)
097a8     F5 E6 01 F6 | 	mov	local08, local10
097ac     01 EE 65 F6 | 	neg	local12, #1
097b0     F0 EC 01 F6 | 	mov	local11, local05
097b4     00 F6 05 F6 | 	mov	local16, #0
097b8     F3 C2 01 F6 | 	mov	arg01, local08
097bc     01 C4 65 F6 | 	neg	arg02, #1
097c0     F6 C6 01 F6 | 	mov	arg03, local11
097c4     00 C8 05 F6 | 	mov	arg04, #0
097c8     F0 0E B0 FD | 	call	#_cpu_WriteTarget
097cc     D4 06 90 FD | 	jmp	#LR__1120
097d0                 | LR__1077
097d0                 | '             OP_BCL: ' bit operations always use an 8-bit source
097d0                 | '                 savedSize := size
097d0     97 90 05 F1 | 	add	objptr, #151
097d4     C8 04 C2 FA | 	rdbyte	local23, objptr
097d8                 | '                 size := SZ_BYTE
097d8     C8 02 48 FC | 	wrbyte	#1, objptr
097dc     97 90 85 F1 | 	sub	objptr, #151
097e0                 | '                 temp := ReadSource(false)
097e0     00 C2 05 F6 | 	mov	arg01, #0
097e4     64 0B B0 FD | 	call	#_cpu_ReadSource
097e8     D3 E8 01 F6 | 	mov	local09, result1
097ec                 | '                 size := savedSize
097ec     97 90 05 F1 | 	add	objptr, #151
097f0     C8 04 42 FC | 	wrbyte	local23, objptr
097f4     97 90 85 F1 | 	sub	objptr, #151
097f8                 | '                 if not (skip)
097f8     00 E0 0D F2 | 	cmp	local05, #0 wz
097fc     1C 00 90 5D |  if_ne	jmp	#LR__1078
09800                 | '                     temp2 := ReadTarget & !(1 << temp)
09800     60 0D B0 FD | 	call	#_cpu_ReadTarget
09804     F4 EC C1 F9 | 	decod	local11, local09
09808     D3 EA 01 F6 | 	mov	local10, result1
0980c     F6 EA 29 F5 | 	andn	local10, local11 wz
09810                 | '                     SetZeroFlag(temp2 == 0)
09810     00 C2 05 F6 | 	mov	arg01, #0
09814     01 C2 65 A6 |  if_e	neg	arg01, #1
09818     44 15 B0 FD | 	call	#_cpu_SetZeroFlag
0981c                 | LR__1078
0981c                 | '                 WriteTarget(temp2, true, skip, false)
0981c     F5 E6 01 F6 | 	mov	local08, local10
09820     01 EE 65 F6 | 	neg	local12, #1
09824     F0 EC 01 F6 | 	mov	local11, local05
09828     00 F6 05 F6 | 	mov	local16, #0
0982c     F3 C2 01 F6 | 	mov	arg01, local08
09830     01 C4 65 F6 | 	neg	arg02, #1
09834     F6 C6 01 F6 | 	mov	arg03, local11
09838     00 C8 05 F6 | 	mov	arg04, #0
0983c     7C 0E B0 FD | 	call	#_cpu_WriteTarget
09840     60 06 90 FD | 	jmp	#LR__1120
09844                 | LR__1079
09844                 | '             OP_BTS: ' bit operations always use an 8-bit source
09844                 | '                 savedSize := size
09844     97 90 05 F1 | 	add	objptr, #151
09848     C8 04 C2 FA | 	rdbyte	local23, objptr
0984c                 | '                 size := SZ_BYTE
0984c     C8 02 48 FC | 	wrbyte	#1, objptr
09850     97 90 85 F1 | 	sub	objptr, #151
09854                 | '                 temp := ReadSource(false)
09854     00 C2 05 F6 | 	mov	arg01, #0
09858     F0 0A B0 FD | 	call	#_cpu_ReadSource
0985c     D3 E8 01 F6 | 	mov	local09, result1
09860                 | '                 size := savedSize
09860     97 90 05 F1 | 	add	objptr, #151
09864     C8 04 42 FC | 	wrbyte	local23, objptr
09868     97 90 85 F1 | 	sub	objptr, #151
0986c                 | '                 if not (skip)
0986c     00 E0 0D F2 | 	cmp	local05, #0 wz
09870     1C 00 90 5D |  if_ne	jmp	#LR__1080
09874                 | '                     temp2 := ReadTarget & (1 << temp)
09874     EC 0C B0 FD | 	call	#_cpu_ReadTarget
09878     F4 EC C1 F9 | 	decod	local11, local09
0987c     D3 EA 01 F6 | 	mov	local10, result1
09880     F6 EA 09 F5 | 	and	local10, local11 wz
09884                 | '                     SetZeroFlag(temp2 == 0)
09884     00 C2 05 F6 | 	mov	arg01, #0
09888     01 C2 65 A6 |  if_e	neg	arg01, #1
0988c     D0 14 B0 FD | 	call	#_cpu_SetZeroFlag
09890                 | LR__1080
09890                 | '                 WriteTarget(temp2, true, true, false) ' dummy write
09890     F5 E6 01 F6 | 	mov	local08, local10
09894     01 EE 65 F6 | 	neg	local12, #1
09898     01 EC 65 F6 | 	neg	local11, #1
0989c     00 F6 05 F6 | 	mov	local16, #0
098a0     F3 C2 01 F6 | 	mov	arg01, local08
098a4     01 C4 65 F6 | 	neg	arg02, #1
098a8     01 C6 65 F6 | 	neg	arg03, #1
098ac     00 C8 05 F6 | 	mov	arg04, #0
098b0     08 0E B0 FD | 	call	#_cpu_WriteTarget
098b4     EC 05 90 FD | 	jmp	#LR__1120
098b8                 | LR__1081
098b8                 | '             OP_CMP:
098b8                 | '                 temp2 := ReadSource(false)
098b8     00 C2 05 F6 | 	mov	arg01, #0
098bc     8C 0A B0 FD | 	call	#_cpu_ReadSource
098c0     D3 EA 01 F6 | 	mov	local10, result1
098c4                 | '                 if not (skip)
098c4     00 E0 0D F2 | 	cmp	local05, #0 wz
098c8     28 00 90 5D |  if_ne	jmp	#LR__1082
098cc                 | '                     temp := ReadTarget
098cc     94 0C B0 FD | 	call	#_cpu_ReadTarget
098d0     D3 E8 01 F6 | 	mov	local09, result1
098d4                 | '                     SetCarryFlag(temp2 +> temp)
098d4     00 C2 05 F6 | 	mov	arg01, #0
098d8     F4 EA 19 F2 | 	cmp	local10, local09 wcz
098dc     01 C2 65 16 |  if_a	neg	arg01, #1
098e0     B4 14 B0 FD | 	call	#_cpu_SetCarryFlag
098e4                 | '                     temp -= temp2
098e4     F5 E8 89 F1 | 	sub	local09, local10 wz
098e8                 | '                     SetZeroFlag(temp == 0)
098e8     00 C2 05 F6 | 	mov	arg01, #0
098ec     01 C2 65 A6 |  if_e	neg	arg01, #1
098f0     6C 14 B0 FD | 	call	#_cpu_SetZeroFlag
098f4                 | LR__1082
098f4                 | '                 WriteTarget(temp, true, true, false) ' dummy write
098f4     F4 E6 01 F6 | 	mov	local08, local09
098f8     01 EE 65 F6 | 	neg	local12, #1
098fc     01 EC 65 F6 | 	neg	local11, #1
09900     00 F6 05 F6 | 	mov	local16, #0
09904     F3 C2 01 F6 | 	mov	arg01, local08
09908     01 C4 65 F6 | 	neg	arg02, #1
0990c     01 C6 65 F6 | 	neg	arg03, #1
09910     00 C8 05 F6 | 	mov	arg04, #0
09914     A4 0D B0 FD | 	call	#_cpu_WriteTarget
09918     88 05 90 FD | 	jmp	#LR__1120
0991c                 | LR__1083
0991c                 | '             OP_ICMP:
0991c                 | '                 temp2 := ReadSource(false)
0991c     00 C2 05 F6 | 	mov	arg01, #0
09920     28 0A B0 FD | 	call	#_cpu_ReadSource
09924     D3 EA 01 F6 | 	mov	local10, result1
09928                 | '                 if not (skip)
09928     00 E0 0D F2 | 	cmp	local05, #0 wz
0992c     90 00 90 5D |  if_ne	jmp	#LR__1089
09930                 | '                     case size
09930     97 90 05 F1 | 	add	objptr, #151
09934     C8 06 C2 FA | 	rdbyte	local24, objptr
09938     97 90 85 F1 | 	sub	objptr, #151
0993c     01 06 86 F1 | 	sub	local24, #1
09940     04 06 26 F3 | 	fle	local24, #4
09944     30 06 62 FD | 	jmprel	local24
09948                 | LR__1084
09948     10 00 90 FD | 	jmp	#LR__1085
0994c     2C 00 90 FD | 	jmp	#LR__1086
09950     5C 00 90 FD | 	jmp	#LR__1088
09954     44 00 90 FD | 	jmp	#LR__1087
09958     54 00 90 FD | 	jmp	#LR__1088
0995c                 | LR__1085
0995c                 | '                         SZ_BYTE:
0995c                 | '                             temp2 := ~temp2 ' sign extend 7
0995c     07 EA 65 F7 | 	signx	local10, #7
09960     F5 08 02 F6 | 	mov	local25, local10
09964                 | '                             temp := ReadTarget
09964     FC 0B B0 FD | 	call	#_cpu_ReadTarget
09968     D3 E8 01 F6 | 	mov	local09, result1
0996c                 | '                             SetCarryFlag(temp < temp2)
0996c     F5 E8 51 F2 | 	cmps	local09, local10 wc
09970     E1 C2 A1 F1 | 	subx	arg01, arg01
09974     20 14 B0 FD | 	call	#_cpu_SetCarryFlag
09978     34 00 90 FD | 	jmp	#LR__1088
0997c                 | LR__1086
0997c                 | '                         SZ_HALF:
0997c                 | '                             temp2 := ~~temp2 ' sign extend 15
0997c     0F EA 65 F7 | 	signx	local10, #15
09980     F5 0A 02 F6 | 	mov	local26, local10
09984                 | '                             temp := ReadTarget
09984     DC 0B B0 FD | 	call	#_cpu_ReadTarget
09988     D3 E8 01 F6 | 	mov	local09, result1
0998c                 | '                             SetCarryFlag(temp < temp2)
0998c     F5 E8 51 F2 | 	cmps	local09, local10 wc
09990     E1 C2 A1 F1 | 	subx	arg01, arg01
09994     00 14 B0 FD | 	call	#_cpu_SetCarryFlag
09998     14 00 90 FD | 	jmp	#LR__1088
0999c                 | LR__1087
0999c                 | '                         SZ_WORD:
0999c                 | '                             temp := ReadTarget
0999c     C4 0B B0 FD | 	call	#_cpu_ReadTarget
099a0     D3 E8 01 F6 | 	mov	local09, result1
099a4                 | '                             SetCarryFlag(temp < temp2)
099a4     F5 E8 51 F2 | 	cmps	local09, local10 wc
099a8     E1 C2 A1 F1 | 	subx	arg01, arg01
099ac     E8 13 B0 FD | 	call	#_cpu_SetCarryFlag
099b0                 | LR__1088
099b0                 | '                     temp -= temp2
099b0     F5 E8 89 F1 | 	sub	local09, local10 wz
099b4                 | '                     SetZeroFlag(temp == 0)
099b4     00 C2 05 F6 | 	mov	arg01, #0
099b8     01 C2 65 A6 |  if_e	neg	arg01, #1
099bc     A0 13 B0 FD | 	call	#_cpu_SetZeroFlag
099c0                 | LR__1089
099c0                 | '                 WriteTarget(temp, true, true, false) ' dummy write
099c0     F4 E6 01 F6 | 	mov	local08, local09
099c4     01 EE 65 F6 | 	neg	local12, #1
099c8     01 EC 65 F6 | 	neg	local11, #1
099cc     00 F6 05 F6 | 	mov	local16, #0
099d0     F3 C2 01 F6 | 	mov	arg01, local08
099d4     01 C4 65 F6 | 	neg	arg02, #1
099d8     01 C6 65 F6 | 	neg	arg03, #1
099dc     00 C8 05 F6 | 	mov	arg04, #0
099e0     D8 0C B0 FD | 	call	#_cpu_WriteTarget
099e4     BC 04 90 FD | 	jmp	#LR__1120
099e8                 | LR__1090
099e8                 | '             OP_MOV: WriteTarget(ReadSource(false), true, skip, false)
099e8     00 C2 05 F6 | 	mov	arg01, #0
099ec     5C 09 B0 FD | 	call	#_cpu_ReadSource
099f0     D3 E6 01 F6 | 	mov	local08, result1
099f4     01 EE 65 F6 | 	neg	local12, #1
099f8     F0 EC 01 F6 | 	mov	local11, local05
099fc     00 F6 05 F6 | 	mov	local16, #0
09a00     F3 C2 01 F6 | 	mov	arg01, local08
09a04     01 C4 65 F6 | 	neg	arg02, #1
09a08     F6 C6 01 F6 | 	mov	arg03, local11
09a0c     00 C8 05 F6 | 	mov	arg04, #0
09a10     A8 0C B0 FD | 	call	#_cpu_WriteTarget
09a14     8C 04 90 FD | 	jmp	#LR__1120
09a18                 | LR__1091
09a18                 | '             OP_MOVZ: WriteTarget(ReadSource(false), false, skip, false)
09a18     00 C2 05 F6 | 	mov	arg01, #0
09a1c     2C 09 B0 FD | 	call	#_cpu_ReadSource
09a20     D3 E6 01 F6 | 	mov	local08, result1
09a24     00 EE 05 F6 | 	mov	local12, #0
09a28     F0 EC 01 F6 | 	mov	local11, local05
09a2c     00 F6 05 F6 | 	mov	local16, #0
09a30     F3 C2 01 F6 | 	mov	arg01, local08
09a34     00 C4 05 F6 | 	mov	arg02, #0
09a38     F6 C6 01 F6 | 	mov	arg03, local11
09a3c     00 C8 05 F6 | 	mov	arg04, #0
09a40     78 0C B0 FD | 	call	#_cpu_WriteTarget
09a44     5C 04 90 FD | 	jmp	#LR__1120
09a48                 | LR__1092
09a48                 | '             OP_PUSH:
09a48                 | '                 temp := ReadSource(false)
09a48     00 C2 05 F6 | 	mov	arg01, #0
09a4c     FC 08 B0 FD | 	call	#_cpu_ReadSource
09a50     D3 E6 01 F6 | 	mov	local08, result1
09a54     F3 E8 01 F6 | 	mov	local09, local08
09a58                 | '                 if not (skip)
09a58     00 E0 0D F2 | 	cmp	local05, #0 wz
09a5c                 | '                     Push(temp)
09a5c     F4 E6 01 A6 |  if_e	mov	local08, local09
09a60     F3 C2 01 A6 |  if_e	mov	arg01, local08
09a64     C8 05 B0 AD |  if_e	call	#_cpu_Push
09a68     38 04 90 FD | 	jmp	#LR__1120
09a6c                 | LR__1093
09a6c                 | '             OP_POP:
09a6c                 | '                 if not (skip)
09a6c     00 E0 0D F2 | 	cmp	local05, #0 wz
09a70     08 00 90 5D |  if_ne	jmp	#LR__1094
09a74                 | '                     temp := Pop
09a74     BC 06 B0 FD | 	call	#_cpu_Pop
09a78     D3 E8 01 F6 | 	mov	local09, result1
09a7c                 | LR__1094
09a7c                 | '                 target := source
09a7c     96 90 05 F1 | 	add	objptr, #150
09a80     C8 E6 C1 FA | 	rdbyte	local08, objptr
09a84     01 90 85 F1 | 	sub	objptr, #1
09a88     C8 E6 41 FC | 	wrbyte	local08, objptr
09a8c     95 90 85 F1 | 	sub	objptr, #149
09a90                 | '                 WriteTarget(temp, true, skip, false)
09a90     F4 E6 01 F6 | 	mov	local08, local09
09a94     01 EE 65 F6 | 	neg	local12, #1
09a98     F0 EC 01 F6 | 	mov	local11, local05
09a9c     00 F6 05 F6 | 	mov	local16, #0
09aa0     F3 C2 01 F6 | 	mov	arg01, local08
09aa4     01 C4 65 F6 | 	neg	arg02, #1
09aa8     F6 C6 01 F6 | 	mov	arg03, local11
09aac     00 C8 05 F6 | 	mov	arg04, #0
09ab0     08 0C B0 FD | 	call	#_cpu_WriteTarget
09ab4     EC 03 90 FD | 	jmp	#LR__1120
09ab8                 | LR__1095
09ab8                 | '             OP_RTA:
09ab8                 | '                 temp := ReadSource(false)
09ab8     00 C2 05 F6 | 	mov	arg01, #0
09abc     8C 08 B0 FD | 	call	#_cpu_ReadSource
09ac0     D3 E8 01 F6 | 	mov	local09, result1
09ac4                 | '                 case size
09ac4     97 90 05 F1 | 	add	objptr, #151
09ac8     C8 0C C2 FA | 	rdbyte	local27, objptr
09acc     97 90 85 F1 | 	sub	objptr, #151
09ad0     01 0C 0E F2 | 	cmp	local27, #1 wz
09ad4     0C 00 90 AD |  if_e	jmp	#LR__1096
09ad8     02 0C 0E F2 | 	cmp	local27, #2 wz
09adc     10 00 90 AD |  if_e	jmp	#LR__1097
09ae0     14 00 90 FD | 	jmp	#LR__1098
09ae4                 | LR__1096
09ae4                 | '                     SZ_BYTE:
09ae4                 | '                         temp := ~temp ' sign extend 7
09ae4     07 E8 65 F7 | 	signx	local09, #7
09ae8     F4 0E 02 F6 | 	mov	local28, local09
09aec     08 00 90 FD | 	jmp	#LR__1098
09af0                 | LR__1097
09af0                 | '                     SZ_HALF:
09af0                 | '                         temp := ~~temp ' sign extend 15
09af0     0F E8 65 F7 | 	signx	local09, #15
09af4     F4 10 02 F6 | 	mov	local29, local09
09af8                 | LR__1098
09af8                 | '                 savedSize := size
09af8     97 90 05 F1 | 	add	objptr, #151
09afc     C8 04 C2 FA | 	rdbyte	local23, objptr
09b00                 | '                 size := SZ_WORD
09b00     C8 08 48 FC | 	wrbyte	#4, objptr
09b04     97 90 85 F1 | 	sub	objptr, #151
09b08                 | '                 WriteTarget(instructionPointer + temp, false, skip, false)
09b08     C8 E6 01 FB | 	rdlong	local08, objptr
09b0c     F4 E6 01 F1 | 	add	local08, local09
09b10     00 EE 05 F6 | 	mov	local12, #0
09b14     F0 EC 01 F6 | 	mov	local11, local05
09b18     00 F6 05 F6 | 	mov	local16, #0
09b1c     F3 C2 01 F6 | 	mov	arg01, local08
09b20     00 C4 05 F6 | 	mov	arg02, #0
09b24     F6 C6 01 F6 | 	mov	arg03, local11
09b28     00 C8 05 F6 | 	mov	arg04, #0
09b2c     8C 0B B0 FD | 	call	#_cpu_WriteTarget
09b30                 | '                 size := savedSize
09b30     97 90 05 F1 | 	add	objptr, #151
09b34     C8 04 42 FC | 	wrbyte	local23, objptr
09b38     97 90 85 F1 | 	sub	objptr, #151
09b3c     64 03 90 FD | 	jmp	#LR__1120
09b40                 | LR__1099
09b40                 | '             OP_JMP:
09b40                 | '                 temp := ReadSource(false)
09b40     00 C2 05 F6 | 	mov	arg01, #0
09b44     04 08 B0 FD | 	call	#_cpu_ReadSource
09b48     D3 E6 01 F6 | 	mov	local08, result1
09b4c     F3 E8 01 F6 | 	mov	local09, local08
09b50                 | '                 if not (skip)
09b50     00 E0 0D F2 | 	cmp	local05, #0 wz
09b54                 | '                     instructionPointerMut := temp
09b54     04 90 05 A1 |  if_e	add	objptr, #4
09b58     C8 E8 61 AC |  if_e	wrlong	local09, objptr
09b5c     04 90 85 A1 |  if_e	sub	objptr, #4
09b60     40 03 90 FD | 	jmp	#LR__1120
09b64                 | LR__1100
09b64                 | '             OP_CALL:
09b64                 | '                 temp := ReadSource(false)
09b64     00 C2 05 F6 | 	mov	arg01, #0
09b68     E0 07 B0 FD | 	call	#_cpu_ReadSource
09b6c     D3 E6 01 F6 | 	mov	local08, result1
09b70     F3 E8 01 F6 | 	mov	local09, local08
09b74                 | '                 if not (skip)
09b74     00 E0 0D F2 | 	cmp	local05, #0 wz
09b78     28 03 90 5D |  if_ne	jmp	#LR__1120
09b7c                 | '                     savedSize := size
09b7c     97 90 05 F1 | 	add	objptr, #151
09b80     C8 04 C2 FA | 	rdbyte	local23, objptr
09b84                 | '                     size := SZ_WORD
09b84     C8 08 48 FC | 	wrbyte	#4, objptr
09b88                 | '                     Push(instructionPointerMut)
09b88     93 90 85 F1 | 	sub	objptr, #147
09b8c     C8 EE 01 FB | 	rdlong	local12, objptr
09b90     04 90 85 F1 | 	sub	objptr, #4
09b94     F7 E6 01 F6 | 	mov	local08, local12
09b98     F3 C2 01 F6 | 	mov	arg01, local08
09b9c     90 04 B0 FD | 	call	#_cpu_Push
09ba0                 | '                     size := savedSize
09ba0     97 90 05 F1 | 	add	objptr, #151
09ba4     C8 04 42 FC | 	wrbyte	local23, objptr
09ba8                 | '                     instructionPointerMut := temp
09ba8     93 90 85 F1 | 	sub	objptr, #147
09bac     C8 E8 61 FC | 	wrlong	local09, objptr
09bb0     04 90 85 F1 | 	sub	objptr, #4
09bb4     EC 02 90 FD | 	jmp	#LR__1120
09bb8                 | LR__1101
09bb8                 | '             OP_LOOP:
09bb8                 | '                 temp := ReadSource(false)
09bb8     00 C2 05 F6 | 	mov	arg01, #0
09bbc     8C 07 B0 FD | 	call	#_cpu_ReadSource
09bc0     D3 E6 01 F6 | 	mov	local08, result1
09bc4     F3 E8 01 F6 | 	mov	local09, local08
09bc8                 | '                 if not (skip)
09bc8     00 E0 0D F2 | 	cmp	local05, #0 wz
09bcc     D4 02 90 5D |  if_ne	jmp	#LR__1120
09bd0                 | '                     registers[31]--
09bd0     8C 90 05 F1 | 	add	objptr, #140
09bd4     C8 F6 01 FB | 	rdlong	local16, objptr
09bd8     FB EC 01 F6 | 	mov	local11, local16
09bdc     01 EC 85 F1 | 	sub	local11, #1
09be0     C8 EC 61 FC | 	wrlong	local11, objptr
09be4                 | '                     if (registers[31] <> 0)
09be4     F6 EE 01 F6 | 	mov	local12, local11
09be8     8C 90 85 F1 | 	sub	objptr, #140
09bec     F7 E6 09 F6 | 	mov	local08, local12 wz
09bf0                 | '                         instructionPointerMut := temp
09bf0     04 90 05 51 |  if_ne	add	objptr, #4
09bf4     C8 E8 61 5C |  if_ne	wrlong	local09, objptr
09bf8     04 90 85 51 |  if_ne	sub	objptr, #4
09bfc     A4 02 90 FD | 	jmp	#LR__1120
09c00                 | LR__1102
09c00                 | '             OP_RJMP:
09c00                 | '                 temp := ReadSource(false)
09c00     00 C2 05 F6 | 	mov	arg01, #0
09c04     44 07 B0 FD | 	call	#_cpu_ReadSource
09c08     D3 E8 01 F6 | 	mov	local09, result1
09c0c                 | '                 case size
09c0c     97 90 05 F1 | 	add	objptr, #151
09c10     C8 E6 C1 FA | 	rdbyte	local08, objptr
09c14     97 90 85 F1 | 	sub	objptr, #151
09c18     F3 12 02 F6 | 	mov	local30, local08
09c1c     01 12 0E F2 | 	cmp	local30, #1 wz
09c20     0C 00 90 AD |  if_e	jmp	#LR__1103
09c24     02 12 0E F2 | 	cmp	local30, #2 wz
09c28     18 00 90 AD |  if_e	jmp	#LR__1104
09c2c     24 00 90 FD | 	jmp	#LR__1105
09c30                 | LR__1103
09c30                 | '                     SZ_BYTE:
09c30                 | '                         temp := ~temp ' sign extend 7
09c30     F4 E6 01 F6 | 	mov	local08, local09
09c34     07 E6 65 F7 | 	signx	local08, #7
09c38     F3 14 02 F6 | 	mov	local31, local08
09c3c     0A E9 01 F6 | 	mov	local09, local31
09c40     10 00 90 FD | 	jmp	#LR__1105
09c44                 | LR__1104
09c44                 | '                     SZ_HALF:
09c44                 | '                         temp := ~~temp ' sign extend 15
09c44     F4 E6 01 F6 | 	mov	local08, local09
09c48     0F E6 65 F7 | 	signx	local08, #15
09c4c     F3 16 02 F6 | 	mov	local32, local08
09c50     0B E9 01 F6 | 	mov	local09, local32
09c54                 | LR__1105
09c54                 | '                 if not (skip)
09c54     00 E0 0D F2 | 	cmp	local05, #0 wz
09c58                 | '                     instructionPointerMut := instructionPointer + temp
09c58     C8 E6 01 AB |  if_e	rdlong	local08, objptr
09c5c     F4 E6 01 A1 |  if_e	add	local08, local09
09c60     04 90 05 A1 |  if_e	add	objptr, #4
09c64     C8 E6 61 AC |  if_e	wrlong	local08, objptr
09c68     04 90 85 A1 |  if_e	sub	objptr, #4
09c6c     34 02 90 FD | 	jmp	#LR__1120
09c70                 | LR__1106
09c70                 | '             OP_RCALL:
09c70                 | '                 temp := ReadSource(false)
09c70     00 C2 05 F6 | 	mov	arg01, #0
09c74     D4 06 B0 FD | 	call	#_cpu_ReadSource
09c78     D3 E8 01 F6 | 	mov	local09, result1
09c7c                 | '                 case size
09c7c     97 90 05 F1 | 	add	objptr, #151
09c80     C8 E6 C1 FA | 	rdbyte	local08, objptr
09c84     97 90 85 F1 | 	sub	objptr, #151
09c88     F3 18 02 F6 | 	mov	local33, local08
09c8c     01 18 0E F2 | 	cmp	local33, #1 wz
09c90     0C 00 90 AD |  if_e	jmp	#LR__1107
09c94     02 18 0E F2 | 	cmp	local33, #2 wz
09c98     18 00 90 AD |  if_e	jmp	#LR__1108
09c9c     24 00 90 FD | 	jmp	#LR__1109
09ca0                 | LR__1107
09ca0                 | '                     SZ_BYTE:
09ca0                 | '                         temp := ~temp ' sign extend 7
09ca0     F4 E6 01 F6 | 	mov	local08, local09
09ca4     07 E6 65 F7 | 	signx	local08, #7
09ca8     F3 1A 02 F6 | 	mov	local34, local08
09cac     0D E9 01 F6 | 	mov	local09, local34
09cb0     10 00 90 FD | 	jmp	#LR__1109
09cb4                 | LR__1108
09cb4                 | '                     SZ_HALF:
09cb4                 | '                         temp := ~~temp ' sign extend 15
09cb4     F4 E6 01 F6 | 	mov	local08, local09
09cb8     0F E6 65 F7 | 	signx	local08, #15
09cbc     F3 1C 02 F6 | 	mov	local35, local08
09cc0     0E E9 01 F6 | 	mov	local09, local35
09cc4                 | LR__1109
09cc4                 | '                 if not (skip)
09cc4     00 E0 0D F2 | 	cmp	local05, #0 wz
09cc8     D8 01 90 5D |  if_ne	jmp	#LR__1120
09ccc                 | '                     savedSize := size
09ccc     97 90 05 F1 | 	add	objptr, #151
09cd0     C8 04 C2 FA | 	rdbyte	local23, objptr
09cd4                 | '                     size := SZ_WORD
09cd4     C8 08 48 FC | 	wrbyte	#4, objptr
09cd8                 | '                     Push(instructionPointerMut)
09cd8     93 90 85 F1 | 	sub	objptr, #147
09cdc     C8 EE 01 FB | 	rdlong	local12, objptr
09ce0     04 90 85 F1 | 	sub	objptr, #4
09ce4     F7 C2 01 F6 | 	mov	arg01, local12
09ce8     44 03 B0 FD | 	call	#_cpu_Push
09cec                 | '                     size := savedSize
09cec     97 90 05 F1 | 	add	objptr, #151
09cf0     C8 04 42 FC | 	wrbyte	local23, objptr
09cf4     97 90 85 F1 | 	sub	objptr, #151
09cf8                 | '                     instructionPointerMut := instructionPointer + temp
09cf8     C8 E6 01 FB | 	rdlong	local08, objptr
09cfc     F4 E6 01 F1 | 	add	local08, local09
09d00     04 90 05 F1 | 	add	objptr, #4
09d04     C8 E6 61 FC | 	wrlong	local08, objptr
09d08     04 90 85 F1 | 	sub	objptr, #4
09d0c     94 01 90 FD | 	jmp	#LR__1120
09d10                 | LR__1110
09d10                 | '             OP_RLOOP:
09d10                 | '                 temp := ReadSource(false)
09d10     00 C2 05 F6 | 	mov	arg01, #0
09d14     34 06 B0 FD | 	call	#_cpu_ReadSource
09d18     D3 E8 01 F6 | 	mov	local09, result1
09d1c                 | '                 case size
09d1c     97 90 05 F1 | 	add	objptr, #151
09d20     C8 E6 C1 FA | 	rdbyte	local08, objptr
09d24     97 90 85 F1 | 	sub	objptr, #151
09d28     F3 1E 02 F6 | 	mov	local36, local08
09d2c     01 1E 0E F2 | 	cmp	local36, #1 wz
09d30     0C 00 90 AD |  if_e	jmp	#LR__1111
09d34     02 1E 0E F2 | 	cmp	local36, #2 wz
09d38     18 00 90 AD |  if_e	jmp	#LR__1112
09d3c     24 00 90 FD | 	jmp	#LR__1113
09d40                 | LR__1111
09d40                 | '                     SZ_BYTE:
09d40                 | '                         temp := ~temp ' sign extend 7
09d40     F4 E6 01 F6 | 	mov	local08, local09
09d44     07 E6 65 F7 | 	signx	local08, #7
09d48     F3 20 02 F6 | 	mov	local37, local08
09d4c     10 E9 01 F6 | 	mov	local09, local37
09d50     10 00 90 FD | 	jmp	#LR__1113
09d54                 | LR__1112
09d54                 | '                     SZ_HALF:
09d54                 | '                         temp := ~~temp ' sign extend 15
09d54     F4 E6 01 F6 | 	mov	local08, local09
09d58     0F E6 65 F7 | 	signx	local08, #15
09d5c     F3 22 02 F6 | 	mov	local38, local08
09d60     11 E9 01 F6 | 	mov	local09, local38
09d64                 | LR__1113
09d64                 | '                 if not (skip)
09d64     00 E0 0D F2 | 	cmp	local05, #0 wz
09d68     38 01 90 5D |  if_ne	jmp	#LR__1120
09d6c                 | '                     registers[31]--
09d6c     8C 90 05 F1 | 	add	objptr, #140
09d70     C8 F6 01 FB | 	rdlong	local16, objptr
09d74     FB EC 01 F6 | 	mov	local11, local16
09d78     01 EC 85 F1 | 	sub	local11, #1
09d7c     C8 EC 61 FC | 	wrlong	local11, objptr
09d80                 | '                     if (registers[31] <> 0)
09d80     F6 EE 01 F6 | 	mov	local12, local11
09d84     8C 90 85 F1 | 	sub	objptr, #140
09d88     F7 E6 09 F6 | 	mov	local08, local12 wz
09d8c                 | '                         instructionPointerMut := instructionPointer + temp
09d8c     C8 E6 01 5B |  if_ne	rdlong	local08, objptr
09d90     F4 E6 01 51 |  if_ne	add	local08, local09
09d94     04 90 05 51 |  if_ne	add	objptr, #4
09d98     C8 E6 61 5C |  if_ne	wrlong	local08, objptr
09d9c     04 90 85 51 |  if_ne	sub	objptr, #4
09da0     00 01 90 FD | 	jmp	#LR__1120
09da4                 | LR__1114
09da4                 | '             OP_RET:
09da4                 | '                 if not (skip)
09da4     00 E0 0D F2 | 	cmp	local05, #0 wz
09da8     F8 00 90 5D |  if_ne	jmp	#LR__1120
09dac                 | '                     savedSize := size
09dac     97 90 05 F1 | 	add	objptr, #151
09db0     C8 04 C2 FA | 	rdbyte	local23, objptr
09db4                 | '                     size := SZ_WORD
09db4     C8 08 48 FC | 	wrbyte	#4, objptr
09db8     97 90 85 F1 | 	sub	objptr, #151
09dbc                 | '                     instructionPointerMut := Pop
09dbc     74 03 B0 FD | 	call	#_cpu_Pop
09dc0     D3 E6 01 F6 | 	mov	local08, result1
09dc4     04 90 05 F1 | 	add	objptr, #4
09dc8     C8 E6 61 FC | 	wrlong	local08, objptr
09dcc                 | '                     size := savedSize
09dcc     93 90 05 F1 | 	add	objptr, #147
09dd0     C8 04 42 FC | 	wrbyte	local23, objptr
09dd4     97 90 85 F1 | 	sub	objptr, #151
09dd8     C8 00 90 FD | 	jmp	#LR__1120
09ddc                 | LR__1115
09ddc                 | '             OP_IN:
09ddc                 | '                 temp := ReadSource(false)
09ddc     00 C2 05 F6 | 	mov	arg01, #0
09de0     68 05 B0 FD | 	call	#_cpu_ReadSource
09de4     D3 E8 01 F6 | 	mov	local09, result1
09de8                 | '                 if not (skip)
09de8     00 E0 0D F2 | 	cmp	local05, #0 wz
09dec     14 00 90 5D |  if_ne	jmp	#LR__1116
09df0                 | '                     temp2 := bus.Read(temp)
09df0     F4 C2 01 F6 | 	mov	arg01, local09
09df4     98 90 05 F1 | 	add	objptr, #152
09df8     50 10 B0 FD | 	call	#_bus_Read
09dfc     98 90 85 F1 | 	sub	objptr, #152
09e00     D3 EA 01 F6 | 	mov	local10, result1
09e04                 | LR__1116
09e04                 | '                 WriteTarget(temp2, true, skip, false)
09e04     F5 E6 01 F6 | 	mov	local08, local10
09e08     01 EE 65 F6 | 	neg	local12, #1
09e0c     F0 EC 01 F6 | 	mov	local11, local05
09e10     00 F6 05 F6 | 	mov	local16, #0
09e14     F3 C2 01 F6 | 	mov	arg01, local08
09e18     01 C4 65 F6 | 	neg	arg02, #1
09e1c     F6 C6 01 F6 | 	mov	arg03, local11
09e20     00 C8 05 F6 | 	mov	arg04, #0
09e24     94 08 B0 FD | 	call	#_cpu_WriteTarget
09e28     78 00 90 FD | 	jmp	#LR__1120
09e2c                 | LR__1117
09e2c                 | '             OP_OUT:
09e2c                 | '                 temp := ReadSource(false)
09e2c     00 C2 05 F6 | 	mov	arg01, #0
09e30     18 05 B0 FD | 	call	#_cpu_ReadSource
09e34     D3 E8 01 F6 | 	mov	local09, result1
09e38                 | '                 temp2 := ReadTarget
09e38     28 07 B0 FD | 	call	#_cpu_ReadTarget
09e3c     D3 EA 01 F6 | 	mov	local10, result1
09e40                 | '                 if not (skip)
09e40     00 E0 0D F2 | 	cmp	local05, #0 wz
09e44     14 00 90 5D |  if_ne	jmp	#LR__1118
09e48                 | '                     bus.Write(temp2, temp)
09e48     F5 C2 01 F6 | 	mov	arg01, local10
09e4c     F4 C4 01 F6 | 	mov	arg02, local09
09e50     98 90 05 F1 | 	add	objptr, #152
09e54     E4 10 B0 FD | 	call	#_bus_Write
09e58     98 90 85 F1 | 	sub	objptr, #152
09e5c                 | LR__1118
09e5c                 | '                 WriteTarget(0, true, true, false)
09e5c     00 E6 05 F6 | 	mov	local08, #0
09e60     01 EE 65 F6 | 	neg	local12, #1
09e64     01 EC 65 F6 | 	neg	local11, #1
09e68     00 F6 05 F6 | 	mov	local16, #0
09e6c     00 C2 05 F6 | 	mov	arg01, #0
09e70     01 C4 65 F6 | 	neg	arg02, #1
09e74     01 C6 65 F6 | 	neg	arg03, #1
09e78     00 C8 05 F6 | 	mov	arg04, #0
09e7c     3C 08 B0 FD | 	call	#_cpu_WriteTarget
09e80     20 00 90 FD | 	jmp	#LR__1120
09e84                 | LR__1119
09e84                 | '             other: Panic(string("bad opcode"), opcode)
09e84     7C 00 00 FF 
09e88     6B E7 05 F6 | 	mov	local08, ##@LR__2100
09e8c     92 90 05 F1 | 	add	objptr, #146
09e90     C8 EC C1 FA | 	rdbyte	local11, objptr
09e94     92 90 85 F1 | 	sub	objptr, #146
09e98     F3 C2 01 F6 | 	mov	arg01, local08
09e9c     F6 C4 01 F6 | 	mov	arg02, local11
09ea0     24 00 B0 FD | 	call	#_cpu_Panic
09ea4                 | LR__1120
09ea4                 | ' 
09ea4                 | '         instructionPointer := instructionPointerMut
09ea4     04 90 05 F1 | 	add	objptr, #4
09ea8     C8 DE 01 FB | 	rdlong	local04, objptr
09eac     04 90 85 F1 | 	sub	objptr, #4
09eb0     C8 DE 61 FC | 	wrlong	local04, objptr
09eb4     01 DA 8D F1 | 	sub	local02, #1 wz
09eb8     0C ED 9F 5D |  if_ne	jmp	#LR__1020
09ebc                 | LR__1121
09ebc     A7 F0 03 F6 | 	mov	ptra, fp
09ec0     B2 00 A0 FD | 	call	#popregs_
09ec4                 | _cpu_Execute_ret
09ec4     2D 00 64 FD | 	ret
09ec8                 | 
09ec8                 | ' 
09ec8                 | ' PRI Panic(message, arg)
09ec8                 | _cpu_Panic
09ec8     02 4A 05 F6 | 	mov	COUNT_, #2
09ecc     A8 00 A0 FD | 	call	#pushregs_
09ed0     E1 D8 01 F6 | 	mov	local01, arg01
09ed4     E2 DA 01 F6 | 	mov	local02, arg02
09ed8                 | '     bus.DebugStr(string("vm panic: "))
09ed8     7C 00 00 FF 
09edc     76 C3 05 F6 | 	mov	arg01, ##@LR__2101
09ee0                 | '     text.PrintStr(s)
09ee0                 | '     video.printStr(str)
09ee0     C1 02 00 FF 
09ee4     78 90 05 F1 | 	add	objptr, ##361080
09ee8     B0 2B B0 FD | 	call	#_p2videodrv_printStr
09eec                 | '     bus.DebugStr(message)
09eec     EC C2 01 F6 | 	mov	arg01, local01
09ef0                 | '     text.PrintStr(s)
09ef0                 | '     video.printStr(str)
09ef0     A8 2B B0 FD | 	call	#_p2videodrv_printStr
09ef4                 | '     bus.DebugStr(string(" "))
09ef4     7C 00 00 FF 
09ef8     81 C3 05 F6 | 	mov	arg01, ##@LR__2102
09efc                 | '     text.PrintStr(s)
09efc                 | '     video.printStr(str)
09efc     9C 2B B0 FD | 	call	#_p2videodrv_printStr
09f00                 | '     bus.DebugHex(arg, 8)
09f00     ED C2 01 F6 | 	mov	arg01, local02
09f04     08 C4 05 F6 | 	mov	arg02, #8
09f08                 | '     text.Hex(h, digits)
09f08                 | '     video.hex(val, digits)
09f08     A4 2E B0 FD | 	call	#_p2videodrv_hex
09f0c                 | '     DebugChar(" ")
09f0c     20 C2 05 F6 | 	mov	arg01, #32
09f10                 | '     text.Out(c)
09f10                 | '     video.out(ch)
09f10     90 28 B0 FD | 	call	#_p2videodrv_out
09f14                 | '     bus.DebugChar(10)
09f14     0A C2 05 F6 | 	mov	arg01, #10
09f18                 | '     text.Out(c)
09f18                 | '     video.out(ch)
09f18     88 28 B0 FD | 	call	#_p2videodrv_out
09f1c     C1 02 00 FF 
09f20     78 90 85 F1 | 	sub	objptr, ##361080
09f24                 | '     bus.DebugHex(instructionPointer, 8)
09f24     C8 C2 01 FB | 	rdlong	arg01, objptr
09f28     08 C4 05 F6 | 	mov	arg02, #8
09f2c                 | '     text.Hex(h, digits)
09f2c                 | '     video.hex(val, digits)
09f2c     C1 02 00 FF 
09f30     78 90 05 F1 | 	add	objptr, ##361080
09f34     78 2E B0 FD | 	call	#_p2videodrv_hex
09f38                 | '     DebugChar(" ")
09f38     20 C2 05 F6 | 	mov	arg01, #32
09f3c                 | '     text.Out(c)
09f3c                 | '     video.out(ch)
09f3c     64 28 B0 FD | 	call	#_p2videodrv_out
09f40                 | '     bus.DebugHex(opcode, 2)
09f40     C0 02 00 FF 
09f44     E6 91 85 F1 | 	sub	objptr, ##360934
09f48     C8 C2 C1 FA | 	rdbyte	arg01, objptr
09f4c     02 C4 05 F6 | 	mov	arg02, #2
09f50                 | '     text.Hex(h, digits)
09f50                 | '     video.hex(val, digits)
09f50     C0 02 00 FF 
09f54     E6 91 05 F1 | 	add	objptr, ##360934
09f58     54 2E B0 FD | 	call	#_p2videodrv_hex
09f5c                 | '     DebugChar(" ")
09f5c     20 C2 05 F6 | 	mov	arg01, #32
09f60                 | '     text.Out(c)
09f60                 | '     video.out(ch)
09f60     40 28 B0 FD | 	call	#_p2videodrv_out
09f64                 | '     bus.DebugHex(condition, 2)
09f64     C0 02 00 FF 
09f68     E5 91 85 F1 | 	sub	objptr, ##360933
09f6c     C8 C2 C1 FA | 	rdbyte	arg01, objptr
09f70     02 C4 05 F6 | 	mov	arg02, #2
09f74                 | '     text.Hex(h, digits)
09f74                 | '     video.hex(val, digits)
09f74     C0 02 00 FF 
09f78     E5 91 05 F1 | 	add	objptr, ##360933
09f7c     30 2E B0 FD | 	call	#_p2videodrv_hex
09f80                 | '     DebugChar(" ")
09f80     20 C2 05 F6 | 	mov	arg01, #32
09f84                 | '     text.Out(c)
09f84                 | '     video.out(ch)
09f84     1C 28 B0 FD | 	call	#_p2videodrv_out
09f88                 | '     bus.DebugHex(offset, 2)
09f88     C0 02 00 FF 
09f8c     E4 91 85 F1 | 	sub	objptr, ##360932
09f90     C8 C2 C1 FA | 	rdbyte	arg01, objptr
09f94     02 C4 05 F6 | 	mov	arg02, #2
09f98                 | '     text.Hex(h, digits)
09f98                 | '     video.hex(val, digits)
09f98     C0 02 00 FF 
09f9c     E4 91 05 F1 | 	add	objptr, ##360932
09fa0     0C 2E B0 FD | 	call	#_p2videodrv_hex
09fa4                 | '     DebugChar(" ")
09fa4     20 C2 05 F6 | 	mov	arg01, #32
09fa8                 | '     text.Out(c)
09fa8                 | '     video.out(ch)
09fa8     F8 27 B0 FD | 	call	#_p2videodrv_out
09fac                 | '     bus.DebugHex(target, 2)
09fac     C0 02 00 FF 
09fb0     E3 91 85 F1 | 	sub	objptr, ##360931
09fb4     C8 C2 C1 FA | 	rdbyte	arg01, objptr
09fb8     02 C4 05 F6 | 	mov	arg02, #2
09fbc                 | '     text.Hex(h, digits)
09fbc                 | '     video.hex(val, digits)
09fbc     C0 02 00 FF 
09fc0     E3 91 05 F1 | 	add	objptr, ##360931
09fc4     E8 2D B0 FD | 	call	#_p2videodrv_hex
09fc8                 | '     DebugChar(" ")
09fc8     20 C2 05 F6 | 	mov	arg01, #32
09fcc                 | '     text.Out(c)
09fcc                 | '     video.out(ch)
09fcc     D4 27 B0 FD | 	call	#_p2videodrv_out
09fd0                 | '     bus.DebugHex(source, 2)
09fd0     C0 02 00 FF 
09fd4     E2 91 85 F1 | 	sub	objptr, ##360930
09fd8     C8 C2 C1 FA | 	rdbyte	arg01, objptr
09fdc     02 C4 05 F6 | 	mov	arg02, #2
09fe0                 | '     text.Hex(h, digits)
09fe0                 | '     video.hex(val, digits)
09fe0     C0 02 00 FF 
09fe4     E2 91 05 F1 | 	add	objptr, ##360930
09fe8     C4 2D B0 FD | 	call	#_p2videodrv_hex
09fec                 | '     DebugChar(" ")
09fec     20 C2 05 F6 | 	mov	arg01, #32
09ff0                 | '     text.Out(c)
09ff0                 | '     video.out(ch)
09ff0     B0 27 B0 FD | 	call	#_p2videodrv_out
09ff4                 | '     bus.DebugHex(size, 2)
09ff4     C0 02 00 FF 
09ff8     E1 91 85 F1 | 	sub	objptr, ##360929
09ffc     C8 C2 C1 FA | 	rdbyte	arg01, objptr
0a000     02 C4 05 F6 | 	mov	arg02, #2
0a004                 | '     text.Hex(h, digits)
0a004                 | '     video.hex(val, digits)
0a004     C0 02 00 FF 
0a008     E1 91 05 F1 | 	add	objptr, ##360929
0a00c     A0 2D B0 FD | 	call	#_p2videodrv_hex
0a010                 | '     DebugChar(" ")
0a010     20 C2 05 F6 | 	mov	arg01, #32
0a014                 | '     text.Out(c)
0a014                 | '     video.out(ch)
0a014     8C 27 B0 FD | 	call	#_p2videodrv_out
0a018                 | '     bus.DebugChar(10)
0a018     0A C2 05 F6 | 	mov	arg01, #10
0a01c                 | '     text.Out(c)
0a01c                 | '     video.out(ch)
0a01c     84 27 B0 FD | 	call	#_p2videodrv_out
0a020                 | '     repeat
0a020                 | LR__1130
0a020     FC FF 9F FD | 	jmp	#LR__1130
0a024     A7 F0 03 F6 | 	mov	ptra, fp
0a028     B2 00 A0 FD | 	call	#popregs_
0a02c                 | _cpu_Panic_ret
0a02c     2D 00 64 FD | 	ret
0a030                 | 
0a030                 | ' 
0a030                 | ' PRI Push(value)
0a030                 | _cpu_Push
0a030     04 4A 05 F6 | 	mov	COUNT_, #4
0a034     A8 00 A0 FD | 	call	#pushregs_
0a038     E1 D8 01 F6 | 	mov	local01, arg01
0a03c                 | '     stackPointer -= size
0a03c     08 90 05 F1 | 	add	objptr, #8
0a040     C8 DA 01 FB | 	rdlong	local02, objptr
0a044     8F 90 05 F1 | 	add	objptr, #143
0a048     C8 DC C1 FA | 	rdbyte	local03, objptr
0a04c     EE DA 81 F1 | 	sub	local02, local03
0a050     8F 90 85 F1 | 	sub	objptr, #143
0a054     C8 DA 61 FC | 	wrlong	local02, objptr
0a058                 | '     if (stackPointer & $80000000)
0a058     08 90 85 F1 | 	sub	objptr, #8
0a05c     1F DA 2D F4 | 	testbn	local02, #31 wz
0a060                 | '         Panic(string("stack pointer has high bit set???"), stackPointer)
0a060     7C 00 00 5F 
0a064     83 C3 05 56 |  if_ne	mov	arg01, ##@LR__2103
0a068     08 90 05 51 |  if_ne	add	objptr, #8
0a06c     C8 C4 01 5B |  if_ne	rdlong	arg02, objptr
0a070     08 90 85 51 |  if_ne	sub	objptr, #8
0a074     50 FE BF 5D |  if_ne	call	#_cpu_Panic
0a078                 | '     case size
0a078     97 90 05 F1 | 	add	objptr, #151
0a07c     C8 DE C1 FA | 	rdbyte	local04, objptr
0a080     97 90 85 F1 | 	sub	objptr, #151
0a084     01 DE 85 F1 | 	sub	local04, #1
0a088     04 DE 25 F3 | 	fle	local04, #4
0a08c     30 DE 61 FD | 	jmprel	local04
0a090                 | LR__1140
0a090     10 00 90 FD | 	jmp	#LR__1141
0a094     30 00 90 FD | 	jmp	#LR__1142
0a098     74 00 90 FD | 	jmp	#LR__1144
0a09c     4C 00 90 FD | 	jmp	#LR__1143
0a0a0     6C 00 90 FD | 	jmp	#LR__1144
0a0a4                 | LR__1141
0a0a4                 | '         SZ_BYTE: bus.WriteByte(stackPointer, value)
0a0a4     08 90 05 F1 | 	add	objptr, #8
0a0a8     C8 C2 01 FB | 	rdlong	arg01, objptr
0a0ac     EC C4 01 F6 | 	mov	arg02, local01
0a0b0                 | '     memory.WriteByte(address, value)
0a0b0     01 00 00 FF 
0a0b4     14 91 05 F1 | 	add	objptr, ##788
0a0b8     4C 1B B0 FD | 	call	#_memory_WriteByte
0a0bc     01 00 00 FF 
0a0c0     1C 91 85 F1 | 	sub	objptr, ##796
0a0c4     60 00 90 FD | 	jmp	#LR__1145
0a0c8                 | LR__1142
0a0c8                 | '         SZ_HALF: bus.WriteHalf(stackPointer, value)
0a0c8     08 90 05 F1 | 	add	objptr, #8
0a0cc     C8 C2 01 FB | 	rdlong	arg01, objptr
0a0d0     EC C4 01 F6 | 	mov	arg02, local01
0a0d4                 | '     memory.WriteHalf(address, value)
0a0d4     01 00 00 FF 
0a0d8     14 91 05 F1 | 	add	objptr, ##788
0a0dc     68 1B B0 FD | 	call	#_memory_WriteHalf
0a0e0     01 00 00 FF 
0a0e4     1C 91 85 F1 | 	sub	objptr, ##796
0a0e8     3C 00 90 FD | 	jmp	#LR__1145
0a0ec                 | LR__1143
0a0ec                 | '         SZ_WORD: bus.WriteWord(stackPointer, value)
0a0ec     08 90 05 F1 | 	add	objptr, #8
0a0f0     C8 C2 01 FB | 	rdlong	arg01, objptr
0a0f4     EC C4 01 F6 | 	mov	arg02, local01
0a0f8                 | '     memory.WriteWord(address, value)
0a0f8     01 00 00 FF 
0a0fc     14 91 05 F1 | 	add	objptr, ##788
0a100     88 1B B0 FD | 	call	#_memory_WriteWord
0a104     01 00 00 FF 
0a108     1C 91 85 F1 | 	sub	objptr, ##796
0a10c     18 00 90 FD | 	jmp	#LR__1145
0a110                 | LR__1144
0a110                 | '         other: Panic(string("bad size"), size)
0a110     7C 00 00 FF 
0a114     A5 C3 05 F6 | 	mov	arg01, ##@LR__2104
0a118     97 90 05 F1 | 	add	objptr, #151
0a11c     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0a120     97 90 85 F1 | 	sub	objptr, #151
0a124     A0 FD BF FD | 	call	#_cpu_Panic
0a128                 | LR__1145
0a128     A7 F0 03 F6 | 	mov	ptra, fp
0a12c     B2 00 A0 FD | 	call	#popregs_
0a130                 | _cpu_Push_ret
0a130     2D 00 64 FD | 	ret
0a134                 | 
0a134                 | ' 
0a134                 | ' PRI Pop
0a134                 | _cpu_Pop
0a134     02 4A 05 F6 | 	mov	COUNT_, #2
0a138     A8 00 A0 FD | 	call	#pushregs_
0a13c     00 D8 05 F6 | 	mov	local01, #0
0a140                 | '     case size
0a140     97 90 05 F1 | 	add	objptr, #151
0a144     C8 DA C1 FA | 	rdbyte	local02, objptr
0a148     97 90 85 F1 | 	sub	objptr, #151
0a14c     01 DA 85 F1 | 	sub	local02, #1
0a150     04 DA 25 F3 | 	fle	local02, #4
0a154     30 DA 61 FD | 	jmprel	local02
0a158                 | LR__1150
0a158     10 00 90 FD | 	jmp	#LR__1151
0a15c     30 00 90 FD | 	jmp	#LR__1152
0a160     74 00 90 FD | 	jmp	#LR__1154
0a164     4C 00 90 FD | 	jmp	#LR__1153
0a168     6C 00 90 FD | 	jmp	#LR__1154
0a16c                 | LR__1151
0a16c                 | '         SZ_BYTE: result := bus.ReadByte(stackPointer)
0a16c     08 90 05 F1 | 	add	objptr, #8
0a170     C8 C2 01 FB | 	rdlong	arg01, objptr
0a174                 | '     return memory.ReadByte(address)
0a174     01 00 00 FF 
0a178     14 91 05 F1 | 	add	objptr, ##788
0a17c     A4 17 B0 FD | 	call	#_memory_ReadByte
0a180     01 00 00 FF 
0a184     1C 91 85 F1 | 	sub	objptr, ##796
0a188     D3 D8 01 F6 | 	mov	local01, result1
0a18c     60 00 90 FD | 	jmp	#LR__1155
0a190                 | LR__1152
0a190                 | '         SZ_HALF: result := bus.ReadHalf(stackPointer)
0a190     08 90 05 F1 | 	add	objptr, #8
0a194     C8 C2 01 FB | 	rdlong	arg01, objptr
0a198                 | '     return memory.ReadHalf(address)
0a198     01 00 00 FF 
0a19c     14 91 05 F1 | 	add	objptr, ##788
0a1a0     D4 19 B0 FD | 	call	#_memory_ReadHalf
0a1a4     01 00 00 FF 
0a1a8     1C 91 85 F1 | 	sub	objptr, ##796
0a1ac     D3 D8 01 F6 | 	mov	local01, result1
0a1b0     3C 00 90 FD | 	jmp	#LR__1155
0a1b4                 | LR__1153
0a1b4                 | '         SZ_WORD: result := bus.ReadWord(stackPointer)
0a1b4     08 90 05 F1 | 	add	objptr, #8
0a1b8     C8 C2 01 FB | 	rdlong	arg01, objptr
0a1bc                 | '     return memory.ReadWord(address)
0a1bc     01 00 00 FF 
0a1c0     14 91 05 F1 | 	add	objptr, ##788
0a1c4     E4 19 B0 FD | 	call	#_memory_ReadWord
0a1c8     01 00 00 FF 
0a1cc     1C 91 85 F1 | 	sub	objptr, ##796
0a1d0     D3 D8 01 F6 | 	mov	local01, result1
0a1d4     18 00 90 FD | 	jmp	#LR__1155
0a1d8                 | LR__1154
0a1d8                 | '         other: Panic(string("bad size"), size)
0a1d8     7C 00 00 FF 
0a1dc     AE C3 05 F6 | 	mov	arg01, ##@LR__2105
0a1e0     97 90 05 F1 | 	add	objptr, #151
0a1e4     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0a1e8     97 90 85 F1 | 	sub	objptr, #151
0a1ec     D8 FC BF FD | 	call	#_cpu_Panic
0a1f0                 | LR__1155
0a1f0                 | '     stackPointer += size
0a1f0     08 90 05 F1 | 	add	objptr, #8
0a1f4     C8 DA 01 FB | 	rdlong	local02, objptr
0a1f8     8F 90 05 F1 | 	add	objptr, #143
0a1fc     C8 A6 C1 FA | 	rdbyte	result1, objptr
0a200     D3 DA 01 F1 | 	add	local02, result1
0a204     8F 90 85 F1 | 	sub	objptr, #143
0a208     C8 DA 61 FC | 	wrlong	local02, objptr
0a20c                 | '     if (stackPointer & $80000000)
0a20c     08 90 85 F1 | 	sub	objptr, #8
0a210     1F DA 2D F4 | 	testbn	local02, #31 wz
0a214                 | '         Panic(string("stack pointer has high bit set"), stackPointer)
0a214     7C 00 00 5F 
0a218     B7 C3 05 56 |  if_ne	mov	arg01, ##@LR__2106
0a21c     08 90 05 51 |  if_ne	add	objptr, #8
0a220     C8 C4 01 5B |  if_ne	rdlong	arg02, objptr
0a224     08 90 85 51 |  if_ne	sub	objptr, #8
0a228     9C FC BF 5D |  if_ne	call	#_cpu_Panic
0a22c     EC A6 01 F6 | 	mov	result1, local01
0a230     A7 F0 03 F6 | 	mov	ptra, fp
0a234     B2 00 A0 FD | 	call	#popregs_
0a238                 | _cpu_Pop_ret
0a238     2D 00 64 FD | 	ret
0a23c                 | 
0a23c                 | ' 
0a23c                 | ' PRI ReadRegister(register)
0a23c                 | _cpu_ReadRegister
0a23c     02 4A 05 F6 | 	mov	COUNT_, #2
0a240     A8 00 A0 FD | 	call	#pushregs_
0a244     E1 D8 01 F6 | 	mov	local01, arg01
0a248                 | '     case register
0a248     EC DA 01 F6 | 	mov	local02, local01
0a24c     00 DA 55 F2 | 	cmps	local02, #0 wc
0a250     08 00 90 CD |  if_b	jmp	#LR__1160
0a254     20 DA 55 F2 | 	cmps	local02, #32 wc
0a258     14 00 90 CD |  if_b	jmp	#LR__1161
0a25c                 | LR__1160
0a25c     20 DA 0D F2 | 	cmp	local02, #32 wz
0a260     24 00 90 AD |  if_e	jmp	#LR__1162
0a264     22 DA 0D F2 | 	cmp	local02, #34 wz
0a268     2C 00 90 AD |  if_e	jmp	#LR__1163
0a26c     38 00 90 FD | 	jmp	#LR__1164
0a270                 | LR__1161
0a270                 | '         0..31: return registers[register]
0a270     02 D8 65 F0 | 	shl	local01, #2
0a274     C8 DA 01 F6 | 	mov	local02, objptr
0a278     10 DA 05 F1 | 	add	local02, #16
0a27c     ED D8 01 F1 | 	add	local01, local02
0a280     EC A6 01 FB | 	rdlong	result1, local01
0a284     30 00 90 FD | 	jmp	#LR__1165
0a288                 | LR__1162
0a288                 | '         32: return stackPointer
0a288     08 90 05 F1 | 	add	objptr, #8
0a28c     C8 A6 01 FB | 	rdlong	result1, objptr
0a290     08 90 85 F1 | 	sub	objptr, #8
0a294     20 00 90 FD | 	jmp	#LR__1165
0a298                 | LR__1163
0a298                 | '         '33: return 0 ' resp, not used here
0a298                 | '         34: return framePointer
0a298     0C 90 05 F1 | 	add	objptr, #12
0a29c     C8 A6 01 FB | 	rdlong	result1, objptr
0a2a0     0C 90 85 F1 | 	sub	objptr, #12
0a2a4     10 00 90 FD | 	jmp	#LR__1165
0a2a8                 | LR__1164
0a2a8                 | '         other: Panic(string("bad register"), register)
0a2a8     7C 00 00 FF 
0a2ac     D6 C3 05 F6 | 	mov	arg01, ##@LR__2107
0a2b0     EC C4 01 F6 | 	mov	arg02, local01
0a2b4     10 FC BF FD | 	call	#_cpu_Panic
0a2b8                 | LR__1165
0a2b8     A7 F0 03 F6 | 	mov	ptra, fp
0a2bc     B2 00 A0 FD | 	call	#popregs_
0a2c0                 | _cpu_ReadRegister_ret
0a2c0     2D 00 64 FD | 	ret
0a2c4                 | 
0a2c4                 | ' 
0a2c4                 | ' PRI WriteRegister(register, value)
0a2c4                 | _cpu_WriteRegister
0a2c4     02 4A 05 F6 | 	mov	COUNT_, #2
0a2c8     A8 00 A0 FD | 	call	#pushregs_
0a2cc     E1 D8 01 F6 | 	mov	local01, arg01
0a2d0     E2 DA 01 F6 | 	mov	local02, arg02
0a2d4                 | '     case register
0a2d4     00 D8 55 F2 | 	cmps	local01, #0 wc
0a2d8     08 00 90 CD |  if_b	jmp	#LR__1170
0a2dc     20 D8 55 F2 | 	cmps	local01, #32 wc
0a2e0     14 00 90 CD |  if_b	jmp	#LR__1171
0a2e4                 | LR__1170
0a2e4     20 D8 0D F2 | 	cmp	local01, #32 wz
0a2e8     24 00 90 AD |  if_e	jmp	#LR__1172
0a2ec     22 D8 0D F2 | 	cmp	local01, #34 wz
0a2f0     2C 00 90 AD |  if_e	jmp	#LR__1173
0a2f4     38 00 90 FD | 	jmp	#LR__1174
0a2f8                 | LR__1171
0a2f8                 | '         0..31: registers[register] := value
0a2f8     02 D8 65 F0 | 	shl	local01, #2
0a2fc     C8 C4 01 F6 | 	mov	arg02, objptr
0a300     10 C4 05 F1 | 	add	arg02, #16
0a304     E2 D8 01 F1 | 	add	local01, arg02
0a308     EC DA 61 FC | 	wrlong	local02, local01
0a30c     30 00 90 FD | 	jmp	#LR__1175
0a310                 | LR__1172
0a310                 | '         32: stackPointer := value
0a310     08 90 05 F1 | 	add	objptr, #8
0a314     C8 DA 61 FC | 	wrlong	local02, objptr
0a318     08 90 85 F1 | 	sub	objptr, #8
0a31c     20 00 90 FD | 	jmp	#LR__1175
0a320                 | LR__1173
0a320                 | '         '33: return
0a320                 | '         34: framePointer := value
0a320     0C 90 05 F1 | 	add	objptr, #12
0a324     C8 DA 61 FC | 	wrlong	local02, objptr
0a328     0C 90 85 F1 | 	sub	objptr, #12
0a32c     10 00 90 FD | 	jmp	#LR__1175
0a330                 | LR__1174
0a330                 | '         other: Panic(string("bad register"), register)
0a330     7C 00 00 FF 
0a334     E3 C3 05 F6 | 	mov	arg01, ##@LR__2108
0a338     EC C4 01 F6 | 	mov	arg02, local01
0a33c     88 FB BF FD | 	call	#_cpu_Panic
0a340                 | LR__1175
0a340     A7 F0 03 F6 | 	mov	ptra, fp
0a344     B2 00 A0 FD | 	call	#popregs_
0a348                 | _cpu_WriteRegister_ret
0a348     2D 00 64 FD | 	ret
0a34c                 | 
0a34c                 | ' 
0a34c                 | ' ' affects global state!
0a34c                 | ' PRI ReadSource(stay) | register, pointer, value
0a34c                 | _cpu_ReadSource
0a34c     06 4A 05 F6 | 	mov	COUNT_, #6
0a350     A8 00 A0 FD | 	call	#pushregs_
0a354     E1 D8 01 F6 | 	mov	local01, arg01
0a358                 | '     case source
0a358     96 90 05 F1 | 	add	objptr, #150
0a35c     C8 DA C1 FA | 	rdbyte	local02, objptr
0a360     96 90 85 F1 | 	sub	objptr, #150
0a364     04 DA 25 F3 | 	fle	local02, #4
0a368     30 DA 61 FD | 	jmprel	local02
0a36c                 | LR__1180
0a36c     10 00 90 FD | 	jmp	#LR__1181
0a370     80 00 90 FD | 	jmp	#LR__1185
0a374     40 01 90 FD | 	jmp	#LR__1188
0a378     80 01 90 FD | 	jmp	#LR__1190
0a37c     BC 01 90 FD | 	jmp	#LR__1191
0a380                 | LR__1181
0a380                 | '         TY_REG:
0a380                 | '             register := bus.ReadByte(instructionPointerMut)
0a380     04 90 05 F1 | 	add	objptr, #4
0a384     C8 C2 01 FB | 	rdlong	arg01, objptr
0a388                 | '     return memory.ReadByte(address)
0a388     01 00 00 FF 
0a38c     18 91 05 F1 | 	add	objptr, ##792
0a390     90 15 B0 FD | 	call	#_memory_ReadByte
0a394     01 00 00 FF 
0a398     1C 91 85 F1 | 	sub	objptr, ##796
0a39c     D3 C2 01 F6 | 	mov	arg01, result1
0a3a0                 | '             if not (stay)
0a3a0     00 D8 0D F2 | 	cmp	local01, #0 wz
0a3a4                 | '                 instructionPointerMut += SZ_BYTE
0a3a4     04 90 05 A1 |  if_e	add	objptr, #4
0a3a8     C8 DC 01 AB |  if_e	rdlong	local03, objptr
0a3ac     01 DC 05 A1 |  if_e	add	local03, #1
0a3b0     C8 DC 61 AC |  if_e	wrlong	local03, objptr
0a3b4     04 90 85 A1 |  if_e	sub	objptr, #4
0a3b8                 | '             value := ReadRegister(register)
0a3b8     80 FE BF FD | 	call	#_cpu_ReadRegister
0a3bc     D3 DE 01 F6 | 	mov	local04, result1
0a3c0                 | '             case size
0a3c0     97 90 05 F1 | 	add	objptr, #151
0a3c4     C8 E0 C1 FA | 	rdbyte	local05, objptr
0a3c8     97 90 85 F1 | 	sub	objptr, #151
0a3cc     01 E0 0D F2 | 	cmp	local05, #1 wz
0a3d0     0C 00 90 AD |  if_e	jmp	#LR__1182
0a3d4     02 E0 0D F2 | 	cmp	local05, #2 wz
0a3d8     0C 00 90 AD |  if_e	jmp	#LR__1183
0a3dc     0C 00 90 FD | 	jmp	#LR__1184
0a3e0                 | LR__1182
0a3e0                 | '                 SZ_BYTE: value &= $000000FF
0a3e0     EF DE E1 F8 | 	getbyte	local04, local04, #0
0a3e4     04 00 90 FD | 	jmp	#LR__1184
0a3e8                 | LR__1183
0a3e8                 | '                 SZ_HALF: value &= $0000FFFF
0a3e8     EF DE 31 F9 | 	getword	local04, local04, #0
0a3ec                 | LR__1184
0a3ec                 | '             return value
0a3ec     EF A6 01 F6 | 	mov	result1, local04
0a3f0     64 01 90 FD | 	jmp	#LR__1192
0a3f4                 | LR__1185
0a3f4                 | '         TY_REGPTR:
0a3f4                 | '             register := bus.ReadByte(instructionPointerMut)
0a3f4     04 90 05 F1 | 	add	objptr, #4
0a3f8     C8 C2 01 FB | 	rdlong	arg01, objptr
0a3fc                 | '     return memory.ReadByte(address)
0a3fc     01 00 00 FF 
0a400     18 91 05 F1 | 	add	objptr, ##792
0a404     1C 15 B0 FD | 	call	#_memory_ReadByte
0a408     01 00 00 FF 
0a40c     1C 91 85 F1 | 	sub	objptr, ##796
0a410     D3 C2 01 F6 | 	mov	arg01, result1
0a414                 | '             pointer := ReadRegister(register)
0a414     24 FE BF FD | 	call	#_cpu_ReadRegister
0a418     D3 E2 01 F6 | 	mov	local06, result1
0a41c                 | '             instructionPointerMut += SZ_BYTE
0a41c     04 90 05 F1 | 	add	objptr, #4
0a420     C8 DC 01 FB | 	rdlong	local03, objptr
0a424     01 DC 05 F1 | 	add	local03, #1
0a428     C8 DC 61 FC | 	wrlong	local03, objptr
0a42c                 | '             if (offset <> 0)
0a42c     90 90 05 F1 | 	add	objptr, #144
0a430     C8 DC C9 FA | 	rdbyte	local03, objptr wz
0a434     94 90 85 F1 | 	sub	objptr, #148
0a438     30 00 90 AD |  if_e	jmp	#LR__1186
0a43c                 | '                 pointer += bus.ReadByte(instructionPointerMut)
0a43c     04 90 05 F1 | 	add	objptr, #4
0a440     C8 C2 01 FB | 	rdlong	arg01, objptr
0a444                 | '     return memory.ReadByte(address)
0a444     01 00 00 FF 
0a448     18 91 05 F1 | 	add	objptr, ##792
0a44c     D4 14 B0 FD | 	call	#_memory_ReadByte
0a450     D3 E2 01 F1 | 	add	local06, result1
0a454                 | '                 instructionPointerMut += SZ_BYTE
0a454     01 00 00 FF 
0a458     18 91 85 F1 | 	sub	objptr, ##792
0a45c     C8 DC 01 FB | 	rdlong	local03, objptr
0a460     01 DC 05 F1 | 	add	local03, #1
0a464     C8 DC 61 FC | 	wrlong	local03, objptr
0a468     04 90 85 F1 | 	sub	objptr, #4
0a46c                 | LR__1186
0a46c                 | '             value := ReadWithSize(pointer)
0a46c     F1 C2 01 F6 | 	mov	arg01, local06
0a470     D8 05 B0 FD | 	call	#_cpu_ReadWithSize
0a474     D3 DE 01 F6 | 	mov	local04, result1
0a478                 | '             if (stay)
0a478     00 D8 0D F2 | 	cmp	local01, #0 wz
0a47c     30 00 90 AD |  if_e	jmp	#LR__1187
0a480                 | '                 instructionPointerMut -= SZ_BYTE
0a480     04 90 05 F1 | 	add	objptr, #4
0a484     C8 DC 01 FB | 	rdlong	local03, objptr
0a488     01 DC 85 F1 | 	sub	local03, #1
0a48c     C8 DC 61 FC | 	wrlong	local03, objptr
0a490                 | '                 if (offset <> 0)
0a490     90 90 05 F1 | 	add	objptr, #144
0a494     C8 DC C9 FA | 	rdbyte	local03, objptr wz
0a498     94 90 85 F1 | 	sub	objptr, #148
0a49c                 | '                     instructionPointerMut -= SZ_BYTE
0a49c     04 90 05 51 |  if_ne	add	objptr, #4
0a4a0     C8 DC 01 5B |  if_ne	rdlong	local03, objptr
0a4a4     01 DC 85 51 |  if_ne	sub	local03, #1
0a4a8     C8 DC 61 5C |  if_ne	wrlong	local03, objptr
0a4ac     04 90 85 51 |  if_ne	sub	objptr, #4
0a4b0                 | LR__1187
0a4b0                 | '             return value
0a4b0     EF A6 01 F6 | 	mov	result1, local04
0a4b4     A0 00 90 FD | 	jmp	#LR__1192
0a4b8                 | LR__1188
0a4b8                 | '         TY_IMM:
0a4b8                 | '             value := ReadWithSize(instructionPointerMut)
0a4b8     04 90 05 F1 | 	add	objptr, #4
0a4bc     C8 C2 01 FB | 	rdlong	arg01, objptr
0a4c0     04 90 85 F1 | 	sub	objptr, #4
0a4c4     84 05 B0 FD | 	call	#_cpu_ReadWithSize
0a4c8     D3 DE 01 F6 | 	mov	local04, result1
0a4cc                 | '             if not (stay)
0a4cc     00 D8 0D F2 | 	cmp	local01, #0 wz
0a4d0     20 00 90 5D |  if_ne	jmp	#LR__1189
0a4d4                 | '                 instructionPointerMut += size
0a4d4     04 90 05 F1 | 	add	objptr, #4
0a4d8     C8 DC 01 FB | 	rdlong	local03, objptr
0a4dc     93 90 05 F1 | 	add	objptr, #147
0a4e0     C8 E2 C1 FA | 	rdbyte	local06, objptr
0a4e4     F1 DC 01 F1 | 	add	local03, local06
0a4e8     93 90 85 F1 | 	sub	objptr, #147
0a4ec     C8 DC 61 FC | 	wrlong	local03, objptr
0a4f0     04 90 85 F1 | 	sub	objptr, #4
0a4f4                 | LR__1189
0a4f4                 | '             return value
0a4f4     EF A6 01 F6 | 	mov	result1, local04
0a4f8     5C 00 90 FD | 	jmp	#LR__1192
0a4fc                 | LR__1190
0a4fc                 | '         TY_IMMPTR:
0a4fc                 | '             pointer := bus.ReadWord(instructionPointerMut)
0a4fc     04 90 05 F1 | 	add	objptr, #4
0a500     C8 C2 01 FB | 	rdlong	arg01, objptr
0a504                 | '     return memory.ReadWord(address)
0a504     01 00 00 FF 
0a508     18 91 05 F1 | 	add	objptr, ##792
0a50c     9C 16 B0 FD | 	call	#_memory_ReadWord
0a510     01 00 00 FF 
0a514     1C 91 85 F1 | 	sub	objptr, ##796
0a518     D3 C2 01 F6 | 	mov	arg01, result1
0a51c                 | '             if not (stay)
0a51c     00 D8 0D F2 | 	cmp	local01, #0 wz
0a520                 | '                 instructionPointerMut += SZ_WORD
0a520     04 90 05 A1 |  if_e	add	objptr, #4
0a524     C8 DC 01 AB |  if_e	rdlong	local03, objptr
0a528     04 DC 05 A1 |  if_e	add	local03, #4
0a52c     C8 DC 61 AC |  if_e	wrlong	local03, objptr
0a530     04 90 85 A1 |  if_e	sub	objptr, #4
0a534                 | '             return ReadWithSize(pointer)
0a534     14 05 B0 FD | 	call	#_cpu_ReadWithSize
0a538     1C 00 90 FD | 	jmp	#LR__1192
0a53c                 | LR__1191
0a53c                 | '         other: Panic(string("bad source"), source)
0a53c     7C 00 00 FF 
0a540     F0 C3 05 F6 | 	mov	arg01, ##@LR__2109
0a544     96 90 05 F1 | 	add	objptr, #150
0a548     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0a54c     96 90 85 F1 | 	sub	objptr, #150
0a550     74 F9 BF FD | 	call	#_cpu_Panic
0a554     00 A6 05 F6 | 	mov	result1, #0
0a558                 | LR__1192
0a558     A7 F0 03 F6 | 	mov	ptra, fp
0a55c     B2 00 A0 FD | 	call	#popregs_
0a560                 | _cpu_ReadSource_ret
0a560     2D 00 64 FD | 	ret
0a564                 | 
0a564                 | ' 
0a564                 | ' ' read target without affecting global state. must read source first before calling this
0a564                 | ' PRI ReadTarget | register, pointer, value
0a564                 | _cpu_ReadTarget
0a564     04 4A 05 F6 | 	mov	COUNT_, #4
0a568     A8 00 A0 FD | 	call	#pushregs_
0a56c                 | '     case target
0a56c     95 90 05 F1 | 	add	objptr, #149
0a570     C8 D8 C1 FA | 	rdbyte	local01, objptr
0a574     95 90 85 F1 | 	sub	objptr, #149
0a578     04 D8 25 F3 | 	fle	local01, #4
0a57c     30 D8 61 FD | 	jmprel	local01
0a580                 | LR__1200
0a580     10 00 90 FD | 	jmp	#LR__1201
0a584     68 00 90 FD | 	jmp	#LR__1205
0a588     CC 00 90 FD | 	jmp	#LR__1207
0a58c     DC 00 90 FD | 	jmp	#LR__1208
0a590     00 01 90 FD | 	jmp	#LR__1209
0a594                 | LR__1201
0a594                 | '         TY_REG:
0a594                 | '             register := bus.ReadByte(instructionPointerMut)
0a594     04 90 05 F1 | 	add	objptr, #4
0a598     C8 C2 01 FB | 	rdlong	arg01, objptr
0a59c                 | '     return memory.ReadByte(address)
0a59c     01 00 00 FF 
0a5a0     18 91 05 F1 | 	add	objptr, ##792
0a5a4     7C 13 B0 FD | 	call	#_memory_ReadByte
0a5a8     01 00 00 FF 
0a5ac     1C 91 85 F1 | 	sub	objptr, ##796
0a5b0     D3 C2 01 F6 | 	mov	arg01, result1
0a5b4                 | '             value := ReadRegister(register)
0a5b4     84 FC BF FD | 	call	#_cpu_ReadRegister
0a5b8     D3 DA 01 F6 | 	mov	local02, result1
0a5bc                 | '             case size
0a5bc     97 90 05 F1 | 	add	objptr, #151
0a5c0     C8 DC C1 FA | 	rdbyte	local03, objptr
0a5c4     97 90 85 F1 | 	sub	objptr, #151
0a5c8     01 DC 0D F2 | 	cmp	local03, #1 wz
0a5cc     0C 00 90 AD |  if_e	jmp	#LR__1202
0a5d0     02 DC 0D F2 | 	cmp	local03, #2 wz
0a5d4     0C 00 90 AD |  if_e	jmp	#LR__1203
0a5d8     0C 00 90 FD | 	jmp	#LR__1204
0a5dc                 | LR__1202
0a5dc                 | '                 SZ_BYTE: value &= $000000FF
0a5dc     ED DA E1 F8 | 	getbyte	local02, local02, #0
0a5e0     04 00 90 FD | 	jmp	#LR__1204
0a5e4                 | LR__1203
0a5e4                 | '                 SZ_HALF: value &= $0000FFFF
0a5e4     ED DA 31 F9 | 	getword	local02, local02, #0
0a5e8                 | LR__1204
0a5e8                 | '             return value
0a5e8     ED A6 01 F6 | 	mov	result1, local02
0a5ec     C0 00 90 FD | 	jmp	#LR__1210
0a5f0                 | LR__1205
0a5f0                 | '         TY_REGPTR:
0a5f0                 | '             pointer := ReadRegister(bus.ReadByte(instructionPointerMut))
0a5f0     04 90 05 F1 | 	add	objptr, #4
0a5f4     C8 C2 01 FB | 	rdlong	arg01, objptr
0a5f8                 | '     return memory.ReadByte(address)
0a5f8     01 00 00 FF 
0a5fc     18 91 05 F1 | 	add	objptr, ##792
0a600     20 13 B0 FD | 	call	#_memory_ReadByte
0a604     01 00 00 FF 
0a608     1C 91 85 F1 | 	sub	objptr, ##796
0a60c     D3 C2 01 F6 | 	mov	arg01, result1
0a610     28 FC BF FD | 	call	#_cpu_ReadRegister
0a614     D3 DE 01 F6 | 	mov	local04, result1
0a618                 | '             if (offset <> 0)
0a618     94 90 05 F1 | 	add	objptr, #148
0a61c     C8 DC C9 FA | 	rdbyte	local03, objptr wz
0a620     94 90 85 F1 | 	sub	objptr, #148
0a624     24 00 90 AD |  if_e	jmp	#LR__1206
0a628                 | '                 pointer += bus.ReadByte(instructionPointerMut + SZ_BYTE)
0a628     04 90 05 F1 | 	add	objptr, #4
0a62c     C8 C2 01 FB | 	rdlong	arg01, objptr
0a630     01 C2 05 F1 | 	add	arg01, #1
0a634                 | '     return memory.ReadByte(address)
0a634     01 00 00 FF 
0a638     18 91 05 F1 | 	add	objptr, ##792
0a63c     E4 12 B0 FD | 	call	#_memory_ReadByte
0a640     01 00 00 FF 
0a644     1C 91 85 F1 | 	sub	objptr, ##796
0a648     D3 DE 01 F1 | 	add	local04, result1
0a64c                 | LR__1206
0a64c                 | '             return ReadWithSize(pointer)
0a64c     EF C2 01 F6 | 	mov	arg01, local04
0a650     F8 03 B0 FD | 	call	#_cpu_ReadWithSize
0a654     58 00 90 FD | 	jmp	#LR__1210
0a658                 | LR__1207
0a658                 | '         TY_IMM:
0a658                 | '             return ReadWithSize(instructionPointerMut)
0a658     04 90 05 F1 | 	add	objptr, #4
0a65c     C8 C2 01 FB | 	rdlong	arg01, objptr
0a660     04 90 85 F1 | 	sub	objptr, #4
0a664     E4 03 B0 FD | 	call	#_cpu_ReadWithSize
0a668     44 00 90 FD | 	jmp	#LR__1210
0a66c                 | LR__1208
0a66c                 | '         TY_IMMPTR:
0a66c                 | '             return ReadWithSize(bus.ReadWord(instructionPointerMut))
0a66c     04 90 05 F1 | 	add	objptr, #4
0a670     C8 C2 01 FB | 	rdlong	arg01, objptr
0a674                 | '     return memory.ReadWord(address)
0a674     01 00 00 FF 
0a678     18 91 05 F1 | 	add	objptr, ##792
0a67c     2C 15 B0 FD | 	call	#_memory_ReadWord
0a680     01 00 00 FF 
0a684     1C 91 85 F1 | 	sub	objptr, ##796
0a688     D3 C2 01 F6 | 	mov	arg01, result1
0a68c     BC 03 B0 FD | 	call	#_cpu_ReadWithSize
0a690     1C 00 90 FD | 	jmp	#LR__1210
0a694                 | LR__1209
0a694                 | '         other: Panic(string("bad target"), target)
0a694     7C 00 00 FF 
0a698     FB C3 05 F6 | 	mov	arg01, ##@LR__2110
0a69c     95 90 05 F1 | 	add	objptr, #149
0a6a0     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0a6a4     95 90 85 F1 | 	sub	objptr, #149
0a6a8     1C F8 BF FD | 	call	#_cpu_Panic
0a6ac     00 A6 05 F6 | 	mov	result1, #0
0a6b0                 | LR__1210
0a6b0     A7 F0 03 F6 | 	mov	ptra, fp
0a6b4     B2 00 A0 FD | 	call	#popregs_
0a6b8                 | _cpu_ReadTarget_ret
0a6b8     2D 00 64 FD | 	ret
0a6bc                 | 
0a6bc                 | ' 
0a6bc                 | ' ' affects global state!
0a6bc                 | ' PRI WriteTarget(value, keepUpperBits, skip, stay) | register, pointer, temp
0a6bc                 | _cpu_WriteTarget
0a6bc     0C 4A 05 F6 | 	mov	COUNT_, #12
0a6c0     A8 00 A0 FD | 	call	#pushregs_
0a6c4     E1 D8 01 F6 | 	mov	local01, arg01
0a6c8     E2 DA 01 F6 | 	mov	local02, arg02
0a6cc     E3 DC 01 F6 | 	mov	local03, arg03
0a6d0     E4 DE 01 F6 | 	mov	local04, arg04
0a6d4                 | '     case target
0a6d4     95 90 05 F1 | 	add	objptr, #149
0a6d8     C8 E0 C1 FA | 	rdbyte	local05, objptr
0a6dc     95 90 85 F1 | 	sub	objptr, #149
0a6e0     04 E0 25 F3 | 	fle	local05, #4
0a6e4     30 E0 61 FD | 	jmprel	local05
0a6e8                 | LR__1220
0a6e8     10 00 90 FD | 	jmp	#LR__1221
0a6ec     D0 00 90 FD | 	jmp	#LR__1228
0a6f0     28 02 90 FD | 	jmp	#LR__1236
0a6f4     50 02 90 FD | 	jmp	#LR__1237
0a6f8     2C 03 90 FD | 	jmp	#LR__1244
0a6fc                 | LR__1221
0a6fc                 | '         TY_REG:
0a6fc                 | '             register := bus.ReadByte(instructionPointerMut)
0a6fc     04 90 05 F1 | 	add	objptr, #4
0a700     C8 C2 01 FB | 	rdlong	arg01, objptr
0a704                 | '     return memory.ReadByte(address)
0a704     01 00 00 FF 
0a708     18 91 05 F1 | 	add	objptr, ##792
0a70c     14 12 B0 FD | 	call	#_memory_ReadByte
0a710     01 00 00 FF 
0a714     1C 91 85 F1 | 	sub	objptr, ##796
0a718     D3 E2 01 F6 | 	mov	local06, result1
0a71c                 | '             if not (stay)
0a71c     00 DE 0D F2 | 	cmp	local04, #0 wz
0a720                 | '                 instructionPointerMut += SZ_BYTE
0a720     04 90 05 A1 |  if_e	add	objptr, #4
0a724     C8 E4 01 AB |  if_e	rdlong	local07, objptr
0a728     01 E4 05 A1 |  if_e	add	local07, #1
0a72c     C8 E4 61 AC |  if_e	wrlong	local07, objptr
0a730     04 90 85 A1 |  if_e	sub	objptr, #4
0a734                 | '             if (keepUpperBits)
0a734     00 DA 0D F2 | 	cmp	local02, #0 wz
0a738     70 00 90 AD |  if_e	jmp	#LR__1227
0a73c                 | '                 temp := ReadRegister(register)
0a73c     F1 C2 01 F6 | 	mov	arg01, local06
0a740     F8 FA BF FD | 	call	#_cpu_ReadRegister
0a744     D3 E6 01 F6 | 	mov	local08, result1
0a748                 | '                 case size
0a748     97 90 05 F1 | 	add	objptr, #151
0a74c     C8 E8 C1 FA | 	rdbyte	local09, objptr
0a750     97 90 85 F1 | 	sub	objptr, #151
0a754     01 E8 85 F1 | 	sub	local09, #1
0a758     04 E8 25 F3 | 	fle	local09, #4
0a75c     30 E8 61 FD | 	jmprel	local09
0a760                 | LR__1222
0a760     10 00 90 FD | 	jmp	#LR__1223
0a764     1C 00 90 FD | 	jmp	#LR__1224
0a768     28 00 90 FD | 	jmp	#LR__1225
0a76c     3C 00 90 FD | 	jmp	#LR__1226
0a770     20 00 90 FD | 	jmp	#LR__1225
0a774                 | LR__1223
0a774                 | '                     SZ_BYTE: value := (temp & $FFFFFF00) | (value & $000000FF)
0a774     FF E6 25 F5 | 	andn	local08, #255
0a778     EC D8 E1 F8 | 	getbyte	local01, local01, #0
0a77c     F3 D8 41 F5 | 	or	local01, local08
0a780     28 00 90 FD | 	jmp	#LR__1226
0a784                 | LR__1224
0a784                 | '                     SZ_HALF: value := (temp & $FFFF0000) | (value & $0000FFFF)
0a784     E0 E7 05 F4 | 	bitl	local08, #480
0a788     EC D8 31 F9 | 	getword	local01, local01, #0
0a78c     F3 D8 41 F5 | 	or	local01, local08
0a790     18 00 90 FD | 	jmp	#LR__1226
0a794                 | LR__1225
0a794                 | '                     SZ_WORD:
0a794                 | '                     other: Panic(string("bad size"), size)
0a794     7D 00 00 FF 
0a798     06 C2 05 F6 | 	mov	arg01, ##@LR__2111
0a79c     97 90 05 F1 | 	add	objptr, #151
0a7a0     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0a7a4     97 90 85 F1 | 	sub	objptr, #151
0a7a8     1C F7 BF FD | 	call	#_cpu_Panic
0a7ac                 | LR__1226
0a7ac                 | LR__1227
0a7ac                 | '             if not (skip)
0a7ac     00 DC 0D F2 | 	cmp	local03, #0 wz
0a7b0                 | '                 WriteRegister(register, value)
0a7b0     F1 C2 01 A6 |  if_e	mov	arg01, local06
0a7b4     EC C4 01 A6 |  if_e	mov	arg02, local01
0a7b8     08 FB BF AD |  if_e	call	#_cpu_WriteRegister
0a7bc     80 02 90 FD | 	jmp	#LR__1245
0a7c0                 | LR__1228
0a7c0                 | '         TY_REGPTR:
0a7c0                 | '             register := bus.ReadByte(instructionPointerMut)
0a7c0     04 90 05 F1 | 	add	objptr, #4
0a7c4     C8 C2 01 FB | 	rdlong	arg01, objptr
0a7c8                 | '     return memory.ReadByte(address)
0a7c8     01 00 00 FF 
0a7cc     18 91 05 F1 | 	add	objptr, ##792
0a7d0     50 11 B0 FD | 	call	#_memory_ReadByte
0a7d4     01 00 00 FF 
0a7d8     1C 91 85 F1 | 	sub	objptr, ##796
0a7dc     D3 C2 01 F6 | 	mov	arg01, result1
0a7e0                 | '             pointer := ReadRegister(register)
0a7e0     58 FA BF FD | 	call	#_cpu_ReadRegister
0a7e4     D3 EA 01 F6 | 	mov	local10, result1
0a7e8                 | '             instructionPointerMut += SZ_BYTE
0a7e8     04 90 05 F1 | 	add	objptr, #4
0a7ec     C8 E4 01 FB | 	rdlong	local07, objptr
0a7f0     01 E4 05 F1 | 	add	local07, #1
0a7f4     C8 E4 61 FC | 	wrlong	local07, objptr
0a7f8                 | '             if (offset <> 0)
0a7f8     90 90 05 F1 | 	add	objptr, #144
0a7fc     C8 E4 C9 FA | 	rdbyte	local07, objptr wz
0a800     94 90 85 F1 | 	sub	objptr, #148
0a804     30 00 90 AD |  if_e	jmp	#LR__1229
0a808                 | '                 pointer += bus.ReadByte(instructionPointerMut)
0a808     04 90 05 F1 | 	add	objptr, #4
0a80c     C8 C2 01 FB | 	rdlong	arg01, objptr
0a810                 | '     return memory.ReadByte(address)
0a810     01 00 00 FF 
0a814     18 91 05 F1 | 	add	objptr, ##792
0a818     08 11 B0 FD | 	call	#_memory_ReadByte
0a81c     D3 EA 01 F1 | 	add	local10, result1
0a820                 | '                 instructionPointerMut += SZ_BYTE
0a820     01 00 00 FF 
0a824     18 91 85 F1 | 	sub	objptr, ##792
0a828     C8 E4 01 FB | 	rdlong	local07, objptr
0a82c     01 E4 05 F1 | 	add	local07, #1
0a830     C8 E4 61 FC | 	wrlong	local07, objptr
0a834     04 90 85 F1 | 	sub	objptr, #4
0a838                 | LR__1229
0a838                 | '             if (keepUpperBits)
0a838     00 DA 0D F2 | 	cmp	local02, #0 wz
0a83c     80 00 90 AD |  if_e	jmp	#LR__1234
0a840                 | '                 temp := bus.ReadWord(pointer)
0a840     F5 C2 01 F6 | 	mov	arg01, local10
0a844                 | '     return memory.ReadWord(address)
0a844     01 00 00 FF 
0a848     1C 91 05 F1 | 	add	objptr, ##796
0a84c     5C 13 B0 FD | 	call	#_memory_ReadWord
0a850     D3 E6 01 F6 | 	mov	local08, result1
0a854                 | '                 case size
0a854     01 00 00 FF 
0a858     85 90 85 F1 | 	sub	objptr, ##645
0a85c     C8 EC C1 FA | 	rdbyte	local11, objptr
0a860     97 90 85 F1 | 	sub	objptr, #151
0a864     01 EC 85 F1 | 	sub	local11, #1
0a868     04 EC 25 F3 | 	fle	local11, #4
0a86c     30 EC 61 FD | 	jmprel	local11
0a870                 | LR__1230
0a870     10 00 90 FD | 	jmp	#LR__1231
0a874     1C 00 90 FD | 	jmp	#LR__1232
0a878     28 00 90 FD | 	jmp	#LR__1233
0a87c     4C 00 90 FD | 	jmp	#LR__1235
0a880     20 00 90 FD | 	jmp	#LR__1233
0a884                 | LR__1231
0a884                 | '                     SZ_BYTE: value := (temp & $FFFFFF00) | (value & $000000FF)
0a884     FF E6 25 F5 | 	andn	local08, #255
0a888     EC D8 E1 F8 | 	getbyte	local01, local01, #0
0a88c     F3 D8 41 F5 | 	or	local01, local08
0a890     38 00 90 FD | 	jmp	#LR__1235
0a894                 | LR__1232
0a894                 | '                     SZ_HALF: value := (temp & $FFFF0000) | (value & $0000FFFF)
0a894     E0 E7 05 F4 | 	bitl	local08, #480
0a898     EC D8 31 F9 | 	getword	local01, local01, #0
0a89c     F3 D8 41 F5 | 	or	local01, local08
0a8a0     28 00 90 FD | 	jmp	#LR__1235
0a8a4                 | LR__1233
0a8a4                 | '                     SZ_WORD:
0a8a4                 | '                     other: Panic(string("bad size"), size)
0a8a4     7D 00 00 FF 
0a8a8     0F C2 05 F6 | 	mov	arg01, ##@LR__2112
0a8ac     97 90 05 F1 | 	add	objptr, #151
0a8b0     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0a8b4     97 90 85 F1 | 	sub	objptr, #151
0a8b8     0C F6 BF FD | 	call	#_cpu_Panic
0a8bc     0C 00 90 FD | 	jmp	#LR__1235
0a8c0                 | LR__1234
0a8c0                 | '             else
0a8c0                 | '                 size := SZ_WORD ' we need to write a full word to clear the upper bits
0a8c0     97 90 05 F1 | 	add	objptr, #151
0a8c4     C8 08 48 FC | 	wrbyte	#4, objptr
0a8c8     97 90 85 F1 | 	sub	objptr, #151
0a8cc                 | LR__1235
0a8cc                 | '             if not (skip)
0a8cc     00 DC 0D F2 | 	cmp	local03, #0 wz
0a8d0                 | '                 WriteWithSize(pointer, value)
0a8d0     F5 C2 01 A6 |  if_e	mov	arg01, local10
0a8d4     EC C4 01 A6 |  if_e	mov	arg02, local01
0a8d8     24 02 B0 AD |  if_e	call	#_cpu_WriteWithSize
0a8dc                 | '             if (stay)
0a8dc     00 DE 0D F2 | 	cmp	local04, #0 wz
0a8e0     5C 01 90 AD |  if_e	jmp	#LR__1245
0a8e4                 | '                 instructionPointerMut -= SZ_BYTE
0a8e4     04 90 05 F1 | 	add	objptr, #4
0a8e8     C8 E4 01 FB | 	rdlong	local07, objptr
0a8ec     01 E4 85 F1 | 	sub	local07, #1
0a8f0     C8 E4 61 FC | 	wrlong	local07, objptr
0a8f4                 | '                 if (offset <> 0)
0a8f4     90 90 05 F1 | 	add	objptr, #144
0a8f8     C8 E4 C9 FA | 	rdbyte	local07, objptr wz
0a8fc     94 90 85 F1 | 	sub	objptr, #148
0a900     3C 01 90 AD |  if_e	jmp	#LR__1245
0a904                 | '                     instructionPointerMut -= SZ_BYTE
0a904     04 90 05 F1 | 	add	objptr, #4
0a908     C8 E4 01 FB | 	rdlong	local07, objptr
0a90c     01 E4 85 F1 | 	sub	local07, #1
0a910     C8 E4 61 FC | 	wrlong	local07, objptr
0a914     04 90 85 F1 | 	sub	objptr, #4
0a918     24 01 90 FD | 	jmp	#LR__1245
0a91c                 | LR__1236
0a91c                 | '         TY_IMM:
0a91c                 | '             if not (stay)
0a91c     00 DE 0D F2 | 	cmp	local04, #0 wz
0a920     1C 01 90 5D |  if_ne	jmp	#LR__1245
0a924                 | '                 instructionPointerMut += size
0a924     04 90 05 F1 | 	add	objptr, #4
0a928     C8 E4 01 FB | 	rdlong	local07, objptr
0a92c     93 90 05 F1 | 	add	objptr, #147
0a930     C8 EC C1 FA | 	rdbyte	local11, objptr
0a934     F6 E4 01 F1 | 	add	local07, local11
0a938     93 90 85 F1 | 	sub	objptr, #147
0a93c     C8 E4 61 FC | 	wrlong	local07, objptr
0a940     04 90 85 F1 | 	sub	objptr, #4
0a944     F8 00 90 FD | 	jmp	#LR__1245
0a948                 | LR__1237
0a948                 | '         TY_IMMPTR:
0a948                 | '             pointer := bus.ReadWord(instructionPointerMut)
0a948     04 90 05 F1 | 	add	objptr, #4
0a94c     C8 C2 01 FB | 	rdlong	arg01, objptr
0a950                 | '     return memory.ReadWord(address)
0a950     01 00 00 FF 
0a954     18 91 05 F1 | 	add	objptr, ##792
0a958     50 12 B0 FD | 	call	#_memory_ReadWord
0a95c     01 00 00 FF 
0a960     1C 91 85 F1 | 	sub	objptr, ##796
0a964     D3 EA 01 F6 | 	mov	local10, result1
0a968                 | '             if (keepUpperBits)
0a968     00 DA 0D F2 | 	cmp	local02, #0 wz
0a96c     80 00 90 AD |  if_e	jmp	#LR__1242
0a970                 | '                 temp := bus.ReadWord(pointer)
0a970     F5 C2 01 F6 | 	mov	arg01, local10
0a974                 | '     return memory.ReadWord(address)
0a974     01 00 00 FF 
0a978     1C 91 05 F1 | 	add	objptr, ##796
0a97c     2C 12 B0 FD | 	call	#_memory_ReadWord
0a980     D3 E6 01 F6 | 	mov	local08, result1
0a984                 | '                 case size
0a984     01 00 00 FF 
0a988     85 90 85 F1 | 	sub	objptr, ##645
0a98c     C8 EE C1 FA | 	rdbyte	local12, objptr
0a990     97 90 85 F1 | 	sub	objptr, #151
0a994     01 EE 85 F1 | 	sub	local12, #1
0a998     04 EE 25 F3 | 	fle	local12, #4
0a99c     30 EE 61 FD | 	jmprel	local12
0a9a0                 | LR__1238
0a9a0     10 00 90 FD | 	jmp	#LR__1239
0a9a4     1C 00 90 FD | 	jmp	#LR__1240
0a9a8     28 00 90 FD | 	jmp	#LR__1241
0a9ac     4C 00 90 FD | 	jmp	#LR__1243
0a9b0     20 00 90 FD | 	jmp	#LR__1241
0a9b4                 | LR__1239
0a9b4                 | '                     SZ_BYTE: value := (temp & $FFFFFF00) | (value & $000000FF)
0a9b4     FF E6 25 F5 | 	andn	local08, #255
0a9b8     EC D8 E1 F8 | 	getbyte	local01, local01, #0
0a9bc     F3 D8 41 F5 | 	or	local01, local08
0a9c0     38 00 90 FD | 	jmp	#LR__1243
0a9c4                 | LR__1240
0a9c4                 | '                     SZ_HALF: value := (temp & $FFFF0000) | (value & $0000FFFF)
0a9c4     E0 E7 05 F4 | 	bitl	local08, #480
0a9c8     EC D8 31 F9 | 	getword	local01, local01, #0
0a9cc     F3 D8 41 F5 | 	or	local01, local08
0a9d0     28 00 90 FD | 	jmp	#LR__1243
0a9d4                 | LR__1241
0a9d4                 | '                     SZ_WORD:
0a9d4                 | '                     other: Panic(string("bad size"), size)
0a9d4     7D 00 00 FF 
0a9d8     18 C2 05 F6 | 	mov	arg01, ##@LR__2113
0a9dc     97 90 05 F1 | 	add	objptr, #151
0a9e0     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0a9e4     97 90 85 F1 | 	sub	objptr, #151
0a9e8     DC F4 BF FD | 	call	#_cpu_Panic
0a9ec     0C 00 90 FD | 	jmp	#LR__1243
0a9f0                 | LR__1242
0a9f0                 | '             else
0a9f0                 | '                 size := SZ_WORD ' we need to write a full word to clear the upper bits
0a9f0     97 90 05 F1 | 	add	objptr, #151
0a9f4     C8 08 48 FC | 	wrbyte	#4, objptr
0a9f8     97 90 85 F1 | 	sub	objptr, #151
0a9fc                 | LR__1243
0a9fc                 | '             if not (stay)
0a9fc     00 DE 0D F2 | 	cmp	local04, #0 wz
0aa00                 | '                 instructionPointerMut += SZ_WORD
0aa00     04 90 05 A1 |  if_e	add	objptr, #4
0aa04     C8 E4 01 AB |  if_e	rdlong	local07, objptr
0aa08     04 E4 05 A1 |  if_e	add	local07, #4
0aa0c     C8 E4 61 AC |  if_e	wrlong	local07, objptr
0aa10     04 90 85 A1 |  if_e	sub	objptr, #4
0aa14                 | '             if not (skip)
0aa14     00 DC 0D F2 | 	cmp	local03, #0 wz
0aa18                 | '                 WriteWithSize(pointer, value)
0aa18     F5 C2 01 A6 |  if_e	mov	arg01, local10
0aa1c     EC C4 01 A6 |  if_e	mov	arg02, local01
0aa20     DC 00 B0 AD |  if_e	call	#_cpu_WriteWithSize
0aa24     18 00 90 FD | 	jmp	#LR__1245
0aa28                 | LR__1244
0aa28                 | '         other: Panic(string("bad target"), target)
0aa28     7D 00 00 FF 
0aa2c     21 C2 05 F6 | 	mov	arg01, ##@LR__2114
0aa30     95 90 05 F1 | 	add	objptr, #149
0aa34     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0aa38     95 90 85 F1 | 	sub	objptr, #149
0aa3c     88 F4 BF FD | 	call	#_cpu_Panic
0aa40                 | LR__1245
0aa40     A7 F0 03 F6 | 	mov	ptra, fp
0aa44     B2 00 A0 FD | 	call	#popregs_
0aa48                 | _cpu_WriteTarget_ret
0aa48     2D 00 64 FD | 	ret
0aa4c                 | 
0aa4c                 | ' 
0aa4c                 | ' PRI ReadWithSize(address)
0aa4c                 | _cpu_ReadWithSize
0aa4c     02 4A 05 F6 | 	mov	COUNT_, #2
0aa50     A8 00 A0 FD | 	call	#pushregs_
0aa54     E1 D8 01 F6 | 	mov	local01, arg01
0aa58                 | '     case size
0aa58     97 90 05 F1 | 	add	objptr, #151
0aa5c     C8 DA C1 FA | 	rdbyte	local02, objptr
0aa60     97 90 85 F1 | 	sub	objptr, #151
0aa64     01 DA 85 F1 | 	sub	local02, #1
0aa68     04 DA 25 F3 | 	fle	local02, #4
0aa6c     30 DA 61 FD | 	jmprel	local02
0aa70                 | LR__1250
0aa70     10 00 90 FD | 	jmp	#LR__1251
0aa74     28 00 90 FD | 	jmp	#LR__1252
0aa78     5C 00 90 FD | 	jmp	#LR__1254
0aa7c     3C 00 90 FD | 	jmp	#LR__1253
0aa80     54 00 90 FD | 	jmp	#LR__1254
0aa84                 | LR__1251
0aa84                 | '         SZ_BYTE: return bus.ReadByte(address)
0aa84     EC C2 01 F6 | 	mov	arg01, local01
0aa88                 | '     return memory.ReadByte(address)
0aa88     01 00 00 FF 
0aa8c     1C 91 05 F1 | 	add	objptr, ##796
0aa90     90 0E B0 FD | 	call	#_memory_ReadByte
0aa94     01 00 00 FF 
0aa98     1C 91 85 F1 | 	sub	objptr, ##796
0aa9c     54 00 90 FD | 	jmp	#LR__1255
0aaa0                 | LR__1252
0aaa0                 | '         SZ_HALF: return bus.ReadHalf(address)
0aaa0     EC C2 01 F6 | 	mov	arg01, local01
0aaa4                 | '     return memory.ReadHalf(address)
0aaa4     01 00 00 FF 
0aaa8     1C 91 05 F1 | 	add	objptr, ##796
0aaac     C8 10 B0 FD | 	call	#_memory_ReadHalf
0aab0     01 00 00 FF 
0aab4     1C 91 85 F1 | 	sub	objptr, ##796
0aab8     38 00 90 FD | 	jmp	#LR__1255
0aabc                 | LR__1253
0aabc                 | '         SZ_WORD: return bus.ReadWord(address)
0aabc     EC C2 01 F6 | 	mov	arg01, local01
0aac0                 | '     return memory.ReadWord(address)
0aac0     01 00 00 FF 
0aac4     1C 91 05 F1 | 	add	objptr, ##796
0aac8     E0 10 B0 FD | 	call	#_memory_ReadWord
0aacc     01 00 00 FF 
0aad0     1C 91 85 F1 | 	sub	objptr, ##796
0aad4     1C 00 90 FD | 	jmp	#LR__1255
0aad8                 | LR__1254
0aad8                 | '         other: Panic(string("bad size"), size)
0aad8     7D 00 00 FF 
0aadc     2C C2 05 F6 | 	mov	arg01, ##@LR__2115
0aae0     97 90 05 F1 | 	add	objptr, #151
0aae4     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0aae8     97 90 85 F1 | 	sub	objptr, #151
0aaec     D8 F3 BF FD | 	call	#_cpu_Panic
0aaf0     00 A6 05 F6 | 	mov	result1, #0
0aaf4                 | LR__1255
0aaf4     A7 F0 03 F6 | 	mov	ptra, fp
0aaf8     B2 00 A0 FD | 	call	#popregs_
0aafc                 | _cpu_ReadWithSize_ret
0aafc     2D 00 64 FD | 	ret
0ab00                 | 
0ab00                 | ' 
0ab00                 | ' PRI WriteWithSize(address, value)
0ab00                 | _cpu_WriteWithSize
0ab00     03 4A 05 F6 | 	mov	COUNT_, #3
0ab04     A8 00 A0 FD | 	call	#pushregs_
0ab08     E1 D8 01 F6 | 	mov	local01, arg01
0ab0c     E2 DA 01 F6 | 	mov	local02, arg02
0ab10                 | '     case size
0ab10     97 90 05 F1 | 	add	objptr, #151
0ab14     C8 DC C1 FA | 	rdbyte	local03, objptr
0ab18     97 90 85 F1 | 	sub	objptr, #151
0ab1c     01 DC 85 F1 | 	sub	local03, #1
0ab20     04 DC 25 F3 | 	fle	local03, #4
0ab24     30 DC 61 FD | 	jmprel	local03
0ab28                 | LR__1260
0ab28     10 00 90 FD | 	jmp	#LR__1261
0ab2c     2C 00 90 FD | 	jmp	#LR__1262
0ab30     68 00 90 FD | 	jmp	#LR__1264
0ab34     44 00 90 FD | 	jmp	#LR__1263
0ab38     60 00 90 FD | 	jmp	#LR__1264
0ab3c                 | LR__1261
0ab3c                 | '         SZ_BYTE: bus.WriteByte(address, value)
0ab3c     EC C2 01 F6 | 	mov	arg01, local01
0ab40     ED C4 01 F6 | 	mov	arg02, local02
0ab44                 | '     memory.WriteByte(address, value)
0ab44     01 00 00 FF 
0ab48     1C 91 05 F1 | 	add	objptr, ##796
0ab4c     B8 10 B0 FD | 	call	#_memory_WriteByte
0ab50     01 00 00 FF 
0ab54     1C 91 85 F1 | 	sub	objptr, ##796
0ab58     58 00 90 FD | 	jmp	#LR__1265
0ab5c                 | LR__1262
0ab5c                 | '         SZ_HALF: bus.WriteHalf(address, value)
0ab5c     EC C2 01 F6 | 	mov	arg01, local01
0ab60     ED C4 01 F6 | 	mov	arg02, local02
0ab64                 | '     memory.WriteHalf(address, value)
0ab64     01 00 00 FF 
0ab68     1C 91 05 F1 | 	add	objptr, ##796
0ab6c     D8 10 B0 FD | 	call	#_memory_WriteHalf
0ab70     01 00 00 FF 
0ab74     1C 91 85 F1 | 	sub	objptr, ##796
0ab78     38 00 90 FD | 	jmp	#LR__1265
0ab7c                 | LR__1263
0ab7c                 | '         SZ_WORD: bus.WriteWord(address, value)
0ab7c     EC C2 01 F6 | 	mov	arg01, local01
0ab80     ED C4 01 F6 | 	mov	arg02, local02
0ab84                 | '     memory.WriteWord(address, value)
0ab84     01 00 00 FF 
0ab88     1C 91 05 F1 | 	add	objptr, ##796
0ab8c     FC 10 B0 FD | 	call	#_memory_WriteWord
0ab90     01 00 00 FF 
0ab94     1C 91 85 F1 | 	sub	objptr, ##796
0ab98     18 00 90 FD | 	jmp	#LR__1265
0ab9c                 | LR__1264
0ab9c                 | '         other: Panic(string("bad size"), size)
0ab9c     7D 00 00 FF 
0aba0     35 C2 05 F6 | 	mov	arg01, ##@LR__2116
0aba4     97 90 05 F1 | 	add	objptr, #151
0aba8     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0abac     97 90 85 F1 | 	sub	objptr, #151
0abb0     14 F3 BF FD | 	call	#_cpu_Panic
0abb4                 | LR__1265
0abb4     A7 F0 03 F6 | 	mov	ptra, fp
0abb8     B2 00 A0 FD | 	call	#popregs_
0abbc                 | _cpu_WriteWithSize_ret
0abbc     2D 00 64 FD | 	ret
0abc0                 | 
0abc0                 | ' 
0abc0                 | ' PRI ShouldSkip
0abc0                 | _cpu_ShouldSkip
0abc0                 | '     case condition
0abc0     93 90 05 F1 | 	add	objptr, #147
0abc4     C8 AA C1 FA | 	rdbyte	_var01, objptr
0abc8     93 90 85 F1 | 	sub	objptr, #147
0abcc     07 AA 25 F3 | 	fle	_var01, #7
0abd0     30 AA 61 FD | 	jmprel	_var01
0abd4                 | LR__1270
0abd4     1C 00 90 FD | 	jmp	#LR__1271
0abd8     20 00 90 FD | 	jmp	#LR__1272
0abdc     48 00 90 FD | 	jmp	#LR__1273
0abe0     74 00 90 FD | 	jmp	#LR__1274
0abe4     9C 00 90 FD | 	jmp	#LR__1275
0abe8     C8 00 90 FD | 	jmp	#LR__1276
0abec     1C 01 90 FD | 	jmp	#LR__1279
0abf0     64 01 90 FD | 	jmp	#LR__1281
0abf4                 | LR__1271
0abf4                 | '         CD_ALWAYS:
0abf4                 | '             return false
0abf4     00 A6 05 F6 | 	mov	result1, #0
0abf8     60 01 90 FD | 	jmp	#LR__1282
0abfc                 | LR__1272
0abfc                 | '         CD_IFZ:
0abfc                 | '             return ZeroFlag == false
0abfc     00 AC 05 F6 | 	mov	_var02, #0
0ac00                 | '     return ((flags & 1) <> 0)
0ac00     00 A6 05 F6 | 	mov	result1, #0
0ac04     90 90 05 F1 | 	add	objptr, #144
0ac08     C8 AA C1 FA | 	rdbyte	_var01, objptr
0ac0c     90 90 85 F1 | 	sub	objptr, #144
0ac10     01 AA CD F7 | 	test	_var01, #1 wz
0ac14     01 A6 65 56 |  if_ne	neg	result1, #1
0ac18     00 A6 0D F2 | 	cmp	result1, #0 wz
0ac1c     00 AC 25 A6 |  if_e	not	_var02, #0
0ac20     D6 A6 01 F6 | 	mov	result1, _var02
0ac24     34 01 90 FD | 	jmp	#LR__1282
0ac28                 | LR__1273
0ac28                 | '         CD_IFNZ:
0ac28                 | '             return ZeroFlag == true
0ac28     00 AC 05 F6 | 	mov	_var02, #0
0ac2c                 | '     return ((flags & 1) <> 0)
0ac2c     00 A6 05 F6 | 	mov	result1, #0
0ac30     90 90 05 F1 | 	add	objptr, #144
0ac34     C8 AA C1 FA | 	rdbyte	_var01, objptr
0ac38     90 90 85 F1 | 	sub	objptr, #144
0ac3c     01 AA CD F7 | 	test	_var01, #1 wz
0ac40     01 A6 65 56 |  if_ne	neg	result1, #1
0ac44     FF FF 7F FF 
0ac48     FF A7 0D F2 | 	cmp	result1, ##-1 wz
0ac4c     00 AC 25 A6 |  if_e	not	_var02, #0
0ac50     D6 A6 01 F6 | 	mov	result1, _var02
0ac54     04 01 90 FD | 	jmp	#LR__1282
0ac58                 | LR__1274
0ac58                 | '         CD_IFC:
0ac58                 | '             return CarryFlag == false
0ac58     00 AC 05 F6 | 	mov	_var02, #0
0ac5c                 | '     return ((flags & 2) <> 0)
0ac5c     00 A6 05 F6 | 	mov	result1, #0
0ac60     90 90 05 F1 | 	add	objptr, #144
0ac64     C8 AA C1 FA | 	rdbyte	_var01, objptr
0ac68     90 90 85 F1 | 	sub	objptr, #144
0ac6c     02 AA CD F7 | 	test	_var01, #2 wz
0ac70     01 A6 65 56 |  if_ne	neg	result1, #1
0ac74     00 A6 0D F2 | 	cmp	result1, #0 wz
0ac78     00 AC 25 A6 |  if_e	not	_var02, #0
0ac7c     D6 A6 01 F6 | 	mov	result1, _var02
0ac80     D8 00 90 FD | 	jmp	#LR__1282
0ac84                 | LR__1275
0ac84                 | '         CD_IFNC:
0ac84                 | '             return CarryFlag == true
0ac84     00 AC 05 F6 | 	mov	_var02, #0
0ac88                 | '     return ((flags & 2) <> 0)
0ac88     00 A6 05 F6 | 	mov	result1, #0
0ac8c     90 90 05 F1 | 	add	objptr, #144
0ac90     C8 AA C1 FA | 	rdbyte	_var01, objptr
0ac94     90 90 85 F1 | 	sub	objptr, #144
0ac98     02 AA CD F7 | 	test	_var01, #2 wz
0ac9c     01 A6 65 56 |  if_ne	neg	result1, #1
0aca0     FF FF 7F FF 
0aca4     FF A7 0D F2 | 	cmp	result1, ##-1 wz
0aca8     00 AC 25 A6 |  if_e	not	_var02, #0
0acac     D6 A6 01 F6 | 	mov	result1, _var02
0acb0     A8 00 90 FD | 	jmp	#LR__1282
0acb4                 | LR__1276
0acb4                 | '         CD_IFGT:
0acb4                 | '             return (ZeroFlag == true) or (CarryFlag == true)
0acb4     00 AC 05 F6 | 	mov	_var02, #0
0acb8                 | '     return ((flags & 1) <> 0)
0acb8     00 A6 05 F6 | 	mov	result1, #0
0acbc     90 90 05 F1 | 	add	objptr, #144
0acc0     C8 AA C1 FA | 	rdbyte	_var01, objptr
0acc4     90 90 85 F1 | 	sub	objptr, #144
0acc8     01 AA CD F7 | 	test	_var01, #1 wz
0accc     01 A6 65 56 |  if_ne	neg	result1, #1
0acd0     FF FF 7F FF 
0acd4     FF A7 0D F2 | 	cmp	result1, ##-1 wz
0acd8     24 00 90 AD |  if_e	jmp	#LR__1277
0acdc                 | '     return ((flags & 2) <> 0)
0acdc     00 A6 05 F6 | 	mov	result1, #0
0ace0     90 90 05 F1 | 	add	objptr, #144
0ace4     C8 AA C1 FA | 	rdbyte	_var01, objptr
0ace8     90 90 85 F1 | 	sub	objptr, #144
0acec     02 AA CD F7 | 	test	_var01, #2 wz
0acf0     01 A6 65 56 |  if_ne	neg	result1, #1
0acf4     FF FF 7F FF 
0acf8     FF A7 0D F2 | 	cmp	result1, ##-1 wz
0acfc     04 00 90 5D |  if_ne	jmp	#LR__1278
0ad00                 | LR__1277
0ad00     D6 AC 21 F6 | 	not	_var02, _var02
0ad04                 | LR__1278
0ad04     D6 A6 01 F6 | 	mov	result1, _var02
0ad08     50 00 90 FD | 	jmp	#LR__1282
0ad0c                 | LR__1279
0ad0c                 | '         CD_IFLTEQ:
0ad0c                 | '             return (ZeroFlag == false) and (CarryFlag == false)
0ad0c     00 AC 05 F6 | 	mov	_var02, #0
0ad10                 | '     return ((flags & 1) <> 0)
0ad10     00 A6 05 F6 | 	mov	result1, #0
0ad14     90 90 05 F1 | 	add	objptr, #144
0ad18     C8 AA C1 FA | 	rdbyte	_var01, objptr
0ad1c     90 90 85 F1 | 	sub	objptr, #144
0ad20     01 AA CD F7 | 	test	_var01, #1 wz
0ad24     01 A6 65 56 |  if_ne	neg	result1, #1
0ad28     00 A6 0D F2 | 	cmp	result1, #0 wz
0ad2c     20 00 90 5D |  if_ne	jmp	#LR__1280
0ad30                 | '     return ((flags & 2) <> 0)
0ad30     00 A6 05 F6 | 	mov	result1, #0
0ad34     90 90 05 F1 | 	add	objptr, #144
0ad38     C8 AA C1 FA | 	rdbyte	_var01, objptr
0ad3c     90 90 85 F1 | 	sub	objptr, #144
0ad40     02 AA CD F7 | 	test	_var01, #2 wz
0ad44     01 A6 65 56 |  if_ne	neg	result1, #1
0ad48     00 A6 0D F2 | 	cmp	result1, #0 wz
0ad4c     D6 AC 21 A6 |  if_e	not	_var02, _var02
0ad50                 | LR__1280
0ad50     D6 A6 01 F6 | 	mov	result1, _var02
0ad54     04 00 90 FD | 	jmp	#LR__1282
0ad58                 | LR__1281
0ad58     00 A6 05 F6 | 	mov	result1, #0
0ad5c                 | LR__1282
0ad5c                 | _cpu_ShouldSkip_ret
0ad5c     2D 00 64 FD | 	ret
0ad60                 | 
0ad60                 | ' 
0ad60                 | ' PRI SetZeroFlag(set)
0ad60                 | _cpu_SetZeroFlag
0ad60                 | '     if (set)
0ad60     00 C2 0D F2 | 	cmp	arg01, #0 wz
0ad64     18 00 90 AD |  if_e	jmp	#LR__1290
0ad68                 | '         flags |= 1
0ad68     90 90 05 F1 | 	add	objptr, #144
0ad6c     C8 C2 C1 FA | 	rdbyte	arg01, objptr
0ad70     01 C2 45 F5 | 	or	arg01, #1
0ad74     C8 C2 41 FC | 	wrbyte	arg01, objptr
0ad78     90 90 85 F1 | 	sub	objptr, #144
0ad7c     14 00 90 FD | 	jmp	#LR__1291
0ad80                 | LR__1290
0ad80                 | '     else
0ad80                 | '         flags &= !1
0ad80     90 90 05 F1 | 	add	objptr, #144
0ad84     C8 C2 C1 FA | 	rdbyte	arg01, objptr
0ad88     01 C2 25 F5 | 	andn	arg01, #1
0ad8c     C8 C2 41 FC | 	wrbyte	arg01, objptr
0ad90     90 90 85 F1 | 	sub	objptr, #144
0ad94                 | LR__1291
0ad94                 | _cpu_SetZeroFlag_ret
0ad94     2D 00 64 FD | 	ret
0ad98                 | 
0ad98                 | ' PRI SetCarryFlag(set)
0ad98                 | _cpu_SetCarryFlag
0ad98                 | '     if (set)
0ad98     00 C2 0D F2 | 	cmp	arg01, #0 wz
0ad9c     18 00 90 AD |  if_e	jmp	#LR__1300
0ada0                 | '         flags |= 2
0ada0     90 90 05 F1 | 	add	objptr, #144
0ada4     C8 C2 C1 FA | 	rdbyte	arg01, objptr
0ada8     02 C2 45 F5 | 	or	arg01, #2
0adac     C8 C2 41 FC | 	wrbyte	arg01, objptr
0adb0     90 90 85 F1 | 	sub	objptr, #144
0adb4     14 00 90 FD | 	jmp	#LR__1301
0adb8                 | LR__1300
0adb8                 | '     else
0adb8                 | '         flags &= !2
0adb8     90 90 05 F1 | 	add	objptr, #144
0adbc     C8 C2 C1 FA | 	rdbyte	arg01, objptr
0adc0     02 C2 25 F5 | 	andn	arg01, #2
0adc4     C8 C2 41 FC | 	wrbyte	arg01, objptr
0adc8     90 90 85 F1 | 	sub	objptr, #144
0adcc                 | LR__1301
0adcc                 | _cpu_SetCarryFlag_ret
0adcc     2D 00 64 FD | 	ret
0add0                 | 
0add0                 | ' 
0add0                 | ' PUB Initialize()
0add0                 | _bus_Initialize
0add0                 | '     text.InitVga(-1, VGA_BASE_PIN, VGA_VSYNC_PIN, 0, text#VGA)
0add0     01 C2 65 F6 | 	neg	arg01, #1
0add4     28 C4 05 F6 | 	mov	arg02, #40
0add8     2C C6 05 F6 | 	mov	arg03, #44
0addc     00 C8 05 F6 | 	mov	arg04, #0
0ade0     01 CA 05 F6 | 	mov	arg05, #1
0ade4     01 02 00 FF 
0ade8     8C 90 05 F1 | 	add	objptr, ##262796
0adec     3C 0F B0 FD | 	call	#_p2textdrv_initVga
0adf0                 | '     color := $F0
0adf0     01 02 00 FF 
0adf4     1C 90 85 F1 | 	sub	objptr, ##262684
0adf8     C8 E0 49 FC | 	wrbyte	#240, objptr
0adfc                 | '     text.SetTextColours(color >> 4, color & $F)
0adfc     F0 C4 E5 F8 | 	getbyte	arg02, #240, #0
0ae00     E2 C4 41 F8 | 	getnib	arg02, arg02, #0
0ae04     0F C2 05 F6 | 	mov	arg01, #15
0ae08     01 02 00 FF 
0ae0c     1C 90 05 F1 | 	add	objptr, ##262684
0ae10                 | '     video.setTextColours(fg, bg)
0ae10     44 1E B0 FD | 	call	#_p2videodrv_setTextColours
0ae14                 | '     text.Clear
0ae14                 | '     video.clear()
0ae14     BF 00 00 FF 
0ae18     54 91 05 F1 | 	add	objptr, ##98132
0ae1c     84 1D B0 FD | 	call	#_p2videodrv_clear
0ae20     C0 02 00 FF 
0ae24     E0 91 85 F1 | 	sub	objptr, ##360928
0ae28                 | '     usb.Start
0ae28     E0 1F B0 FD | 	call	#_usbnew_0016_start
0ae2c                 | '     disk.Initialize
0ae2c     74 90 05 F1 | 	add	objptr, #116
0ae30     F4 08 B0 FD | 	call	#_disk_Initialize
0ae34                 | '     readState := 0
0ae34     08 90 85 F1 | 	sub	objptr, #8
0ae38     C8 00 48 FC | 	wrbyte	#0, objptr
0ae3c                 | '     printState := 0
0ae3c     01 90 05 F1 | 	add	objptr, #1
0ae40     C8 00 48 FC | 	wrbyte	#0, objptr
0ae44     6D 90 85 F1 | 	sub	objptr, #109
0ae48                 | _bus_Initialize_ret
0ae48     2D 00 64 FD | 	ret
0ae4c                 | 
0ae4c                 | ' 
0ae4c                 | ' PUB Read(port): r | temp
0ae4c                 | _bus_Read
0ae4c     01 4A 05 F6 | 	mov	COUNT_, #1
0ae50     A8 00 A0 FD | 	call	#pushregs_
0ae54     E1 D8 09 F6 | 	mov	local01, arg01 wz
0ae58                 | '     case port
0ae58     34 00 90 AD |  if_e	jmp	#LR__1311
0ae5c     08 00 40 FF 
0ae60     00 D8 55 F2 | 	cmps	local01, ##-2147479552 wc
0ae64     0C 00 90 CD |  if_b	jmp	#LR__1310
0ae68     08 00 40 FF 
0ae6c     04 D8 55 F2 | 	cmps	local01, ##-2147479548 wc
0ae70     94 00 90 CD |  if_b	jmp	#LR__1314
0ae74                 | LR__1310
0ae74     10 00 40 FF 
0ae78     00 D8 55 F2 | 	cmps	local01, ##-2147475456 wc
0ae7c     AC 00 90 CD |  if_b	jmp	#LR__1316
0ae80     10 00 40 FF 
0ae84     04 D8 55 F2 | 	cmps	local01, ##-2147475452 wc
0ae88     90 00 90 CD |  if_b	jmp	#LR__1315
0ae8c     9C 00 90 FD | 	jmp	#LR__1316
0ae90                 | LR__1311
0ae90                 | '         $00000000:
0ae90                 | '             if readState == 1
0ae90     6C 90 05 F1 | 	add	objptr, #108
0ae94     C8 A6 C1 FA | 	rdbyte	result1, objptr
0ae98     6C 90 85 F1 | 	sub	objptr, #108
0ae9c     01 A6 0D F2 | 	cmp	result1, #1 wz
0aea0     18 00 90 5D |  if_ne	jmp	#LR__1312
0aea4                 | '                 readState := 2
0aea4     6C 90 05 F1 | 	add	objptr, #108
0aea8     C8 04 48 FC | 	wrbyte	#2, objptr
0aeac                 | '                 return ret0
0aeac     05 90 05 F1 | 	add	objptr, #5
0aeb0     C8 A6 C1 FA | 	rdbyte	result1, objptr
0aeb4     71 90 85 F1 | 	sub	objptr, #113
0aeb8     74 00 90 FD | 	jmp	#LR__1317
0aebc                 | LR__1312
0aebc                 | '             if readState == 2
0aebc     6C 90 05 F1 | 	add	objptr, #108
0aec0     C8 A6 C1 FA | 	rdbyte	result1, objptr
0aec4     6C 90 85 F1 | 	sub	objptr, #108
0aec8     02 A6 0D F2 | 	cmp	result1, #2 wz
0aecc     18 00 90 5D |  if_ne	jmp	#LR__1313
0aed0                 | '                 readState := 0
0aed0     6C 90 05 F1 | 	add	objptr, #108
0aed4     C8 00 48 FC | 	wrbyte	#0, objptr
0aed8                 | '                 return ret1
0aed8     06 90 05 F1 | 	add	objptr, #6
0aedc     C8 A6 C1 FA | 	rdbyte	result1, objptr
0aee0     72 90 85 F1 | 	sub	objptr, #114
0aee4     48 00 90 FD | 	jmp	#LR__1317
0aee8                 | LR__1313
0aee8                 | '             if temp := usb.get_key
0aee8     7C 1F B0 FD | 	call	#_usbnew_0016_get_key
0aeec     D3 D8 09 F6 | 	mov	local01, result1 wz
0aef0     38 00 90 AD |  if_e	jmp	#LR__1316
0aef4                 | '                 if temp := Scan2Ascii(temp)
0aef4     EC C2 01 F6 | 	mov	arg01, local01
0aef8     C0 04 B0 FD | 	call	#_bus_Scan2Ascii
0aefc     00 A6 0D F2 | 	cmp	result1, #0 wz
0af00                 | '                     return temp
0af00     2C 00 90 5D |  if_ne	jmp	#LR__1317
0af04     24 00 90 FD | 	jmp	#LR__1316
0af08                 | LR__1314
0af08                 | '         $80001000..$80001003:
0af08                 | '             return disk.Size(port & $0F)
0af08     EC C2 41 F8 | 	getnib	arg01, local01, #0
0af0c     74 90 05 F1 | 	add	objptr, #116
0af10     E8 08 B0 FD | 	call	#_disk_Size
0af14     74 90 85 F1 | 	sub	objptr, #116
0af18     14 00 90 FD | 	jmp	#LR__1317
0af1c                 | LR__1315
0af1c                 | '         $80002000..$80002003:
0af1c                 | '             return diskBufferPointer
0af1c     68 90 05 F1 | 	add	objptr, #104
0af20     C8 A6 01 FB | 	rdlong	result1, objptr
0af24     68 90 85 F1 | 	sub	objptr, #104
0af28     04 00 90 FD | 	jmp	#LR__1317
0af2c                 | LR__1316
0af2c                 | '     return 0
0af2c     00 A6 05 F6 | 	mov	result1, #0
0af30                 | LR__1317
0af30     A7 F0 03 F6 | 	mov	ptra, fp
0af34     B2 00 A0 FD | 	call	#popregs_
0af38                 | _bus_Read_ret
0af38     2D 00 64 FD | 	ret
0af3c                 | 
0af3c                 | ' 
0af3c                 | ' PUB Write(port, value) | i, temp
0af3c                 | _bus_Write
0af3c     04 4A 05 F6 | 	mov	COUNT_, #4
0af40     A8 00 A0 FD | 	call	#pushregs_
0af44     E1 D8 09 F6 | 	mov	local01, arg01 wz
0af48     E2 DA 01 F6 | 	mov	local02, arg02
0af4c                 | '     case port
0af4c     4C 00 90 AD |  if_e	jmp	#LR__1322
0af50     10 00 40 FF 
0af54     00 D8 55 F2 | 	cmps	local01, ##-2147475456 wc
0af58     0C 00 90 CD |  if_b	jmp	#LR__1320
0af5c     10 00 40 FF 
0af60     04 D8 55 F2 | 	cmps	local01, ##-2147475452 wc
0af64     60 00 90 CD |  if_b	jmp	#LR__1323
0af68                 | LR__1320
0af68     18 00 40 FF 
0af6c     00 D8 55 F2 | 	cmps	local01, ##-2147471360 wc
0af70     0C 00 90 CD |  if_b	jmp	#LR__1321
0af74     18 00 40 FF 
0af78     04 D8 55 F2 | 	cmps	local01, ##-2147471356 wc
0af7c     58 00 90 CD |  if_b	jmp	#LR__1324
0af80                 | LR__1321
0af80     20 00 40 FF 
0af84     00 D8 55 F2 | 	cmps	local01, ##-2147467264 wc
0af88     44 01 90 CD |  if_b	jmp	#LR__1328
0af8c     20 00 40 FF 
0af90     04 D8 55 F2 | 	cmps	local01, ##-2147467260 wc
0af94     A4 00 90 CD |  if_b	jmp	#LR__1326
0af98     34 01 90 FD | 	jmp	#LR__1328
0af9c                 | LR__1322
0af9c                 | '         $00000000:
0af9c                 | '             value := ConvertChar(value & $FF)
0af9c     ED C2 E1 F8 | 	getbyte	arg01, local02, #0
0afa0     38 01 B0 FD | 	call	#_bus_ConvertChar
0afa4     D3 DA 09 F6 | 	mov	local02, result1 wz
0afa8                 | '             if value <> 0
0afa8                 | '                 DebugChar(value)
0afa8     ED C2 01 56 |  if_ne	mov	arg01, local02
0afac     20 01 90 AD |  if_e	jmp	#LR__1328
0afb0                 | '     text.Out(c)
0afb0                 | '     video.out(ch)
0afb0     C0 02 00 FF 
0afb4     E0 91 05 F1 | 	add	objptr, ##360928
0afb8     E8 17 B0 FD | 	call	#_p2videodrv_out
0afbc     C0 02 00 FF 
0afc0     E0 91 85 F1 | 	sub	objptr, ##360928
0afc4     08 01 90 FD | 	jmp	#LR__1328
0afc8                 | LR__1323
0afc8                 | '         $80002000..$80002003:
0afc8                 | '             diskBufferPointer := value
0afc8     68 90 05 F1 | 	add	objptr, #104
0afcc     C8 DA 61 FC | 	wrlong	local02, objptr
0afd0     68 90 85 F1 | 	sub	objptr, #104
0afd4     F8 00 90 FD | 	jmp	#LR__1328
0afd8                 | LR__1324
0afd8                 | '         $80003000..$80003003:
0afd8                 | '             disk.Seek(port & $0F, value)
0afd8     EC C2 41 F8 | 	getnib	arg01, local01, #0
0afdc     ED C4 01 F6 | 	mov	arg02, local02
0afe0     74 90 05 F1 | 	add	objptr, #116
0afe4     E8 07 B0 FD | 	call	#_disk_Seek
0afe8                 | '             temp := disk.Read(port & $0F)
0afe8     EC C2 41 F8 | 	getnib	arg01, local01, #0
0afec     BC 08 B0 FD | 	call	#_disk_Read
0aff0     74 90 85 F1 | 	sub	objptr, #116
0aff4     D3 DC 01 F6 | 	mov	local03, result1
0aff8                 | '             repeat i from 0 to 511
0aff8     00 DE 05 F6 | 	mov	local04, #0
0affc                 | LR__1325
0affc                 | '                 WriteByte(diskBufferPointer + i, byte[temp + i])
0affc     68 90 05 F1 | 	add	objptr, #104
0b000     C8 C2 01 FB | 	rdlong	arg01, objptr
0b004     EF C2 01 F1 | 	add	arg01, local04
0b008     EE DA 01 F6 | 	mov	local02, local03
0b00c     EF DA 01 F1 | 	add	local02, local04
0b010     ED C4 C1 FA | 	rdbyte	arg02, local02
0b014                 | '     memory.WriteByte(address, value)
0b014     01 00 00 FF 
0b018     1C 90 05 F1 | 	add	objptr, ##540
0b01c     E8 0B B0 FD | 	call	#_memory_WriteByte
0b020     01 00 00 FF 
0b024     84 90 85 F1 | 	sub	objptr, ##644
0b028     01 DE 05 F1 | 	add	local04, #1
0b02c     01 00 00 FF 
0b030     00 DE 55 F2 | 	cmps	local04, ##512 wc
0b034     C4 FF 9F CD |  if_b	jmp	#LR__1325
0b038     94 00 90 FD | 	jmp	#LR__1328
0b03c                 | LR__1326
0b03c                 | '         $80004000..$80004003:
0b03c                 | '             disk.Seek(port & $0F, value)
0b03c     EC C2 41 F8 | 	getnib	arg01, local01, #0
0b040     ED C4 01 F6 | 	mov	arg02, local02
0b044     74 90 05 F1 | 	add	objptr, #116
0b048     84 07 B0 FD | 	call	#_disk_Seek
0b04c     74 90 85 F1 | 	sub	objptr, #116
0b050                 | '             repeat i from 0 to 511
0b050     00 DE 05 F6 | 	mov	local04, #0
0b054                 | LR__1327
0b054                 | '                 disk.WriteBuffer(i, ReadByte(diskBufferPointer + i))
0b054     68 90 05 F1 | 	add	objptr, #104
0b058     C8 C2 01 FB | 	rdlong	arg01, objptr
0b05c     EF C2 01 F1 | 	add	arg01, local04
0b060                 | '     return memory.ReadByte(address)
0b060     01 00 00 FF 
0b064     1C 90 05 F1 | 	add	objptr, ##540
0b068     B8 08 B0 FD | 	call	#_memory_ReadByte
0b06c     D3 C4 01 F6 | 	mov	arg02, result1
0b070     EF C2 01 F6 | 	mov	arg01, local04
0b074     01 00 00 FF 
0b078     10 90 85 F1 | 	sub	objptr, ##528
0b07c                 | '     byte[@buffer][offset] := value
0b07c     C8 DC 01 F6 | 	mov	local03, objptr
0b080     10 DC 05 F1 | 	add	local03, #16
0b084     EE C2 01 F1 | 	add	arg01, local03
0b088     E1 C4 41 FC | 	wrbyte	arg02, arg01
0b08c     74 90 85 F1 | 	sub	objptr, #116
0b090     01 DE 05 F1 | 	add	local04, #1
0b094     01 00 00 FF 
0b098     00 DE 55 F2 | 	cmps	local04, ##512 wc
0b09c     B4 FF 9F CD |  if_b	jmp	#LR__1327
0b0a0                 | '             disk.Write(port & $0F)
0b0a0     EC C2 41 F8 | 	getnib	arg01, local01, #0
0b0a4     74 90 05 F1 | 	add	objptr, #116
0b0a8     40 08 B0 FD | 	call	#_disk_Write
0b0ac                 | '             disk.Sync(port & $0F)
0b0ac     EC C2 41 F8 | 	getnib	arg01, local01, #0
0b0b0                 | '     c.fflush(image[id])
0b0b0     02 C2 65 F0 | 	shl	arg01, #2
0b0b4     C8 C2 01 F1 | 	add	arg01, objptr
0b0b8     E1 C2 01 FB | 	rdlong	arg01, arg01
0b0bc     01 00 00 FF 
0b0c0     10 90 05 F1 | 	add	objptr, ##528
0b0c4     88 58 BF FD | 	call	#_libc_a_fflush
0b0c8     01 00 00 FF 
0b0cc     84 90 85 F1 | 	sub	objptr, ##644
0b0d0                 | LR__1328
0b0d0     A7 F0 03 F6 | 	mov	ptra, fp
0b0d4     B2 00 A0 FD | 	call	#popregs_
0b0d8                 | _bus_Write_ret
0b0d8     2D 00 64 FD | 	ret
0b0dc                 | 
0b0dc                 | ' 
0b0dc                 | ' PUB ConvertChar(c): r | row, col
0b0dc                 | _bus_ConvertChar
0b0dc     04 4A 05 F6 | 	mov	COUNT_, #4
0b0e0     A8 00 A0 FD | 	call	#pushregs_
0b0e4     E1 D8 01 F6 | 	mov	local01, arg01
0b0e8                 | '     case printState
0b0e8     6D 90 05 F1 | 	add	objptr, #109
0b0ec     C8 DA C1 FA | 	rdbyte	local02, objptr
0b0f0     6D 90 85 F1 | 	sub	objptr, #109
0b0f4     03 DA 25 F3 | 	fle	local02, #3
0b0f8     30 DA 61 FD | 	jmprel	local02
0b0fc                 | LR__1330
0b0fc     54 02 90 FD | 	jmp	#LR__1340
0b100     08 00 90 FD | 	jmp	#LR__1331
0b104     1C 00 90 FD | 	jmp	#LR__1332
0b108     A0 02 90 FD | 	jmp	#LR__1346
0b10c                 | LR__1331
0b10c                 | '         1:
0b10c                 | '             param0 := c
0b10c     6F 90 05 F1 | 	add	objptr, #111
0b110     C8 D8 41 FC | 	wrbyte	local01, objptr
0b114                 | '             printState := 2
0b114     02 90 85 F1 | 	sub	objptr, #2
0b118     C8 04 48 FC | 	wrbyte	#2, objptr
0b11c     6D 90 85 F1 | 	sub	objptr, #109
0b120     88 02 90 FD | 	jmp	#LR__1346
0b124                 | LR__1332
0b124                 | '         2:
0b124                 | '             case printMode
0b124     6E 90 05 F1 | 	add	objptr, #110
0b128     C8 DC C1 FA | 	rdbyte	local03, objptr
0b12c     6E 90 85 F1 | 	sub	objptr, #110
0b130     EE DC 85 F1 | 	sub	local03, #238
0b134     06 DC 25 F3 | 	fle	local03, #6
0b138     30 DC 61 FD | 	jmprel	local03
0b13c                 | LR__1333
0b13c     18 00 90 FD | 	jmp	#LR__1334
0b140     00 02 90 FD | 	jmp	#LR__1339
0b144     80 00 90 FD | 	jmp	#LR__1335
0b148     04 01 90 FD | 	jmp	#LR__1336
0b14c     24 01 90 FD | 	jmp	#LR__1337
0b150     5C 01 90 FD | 	jmp	#LR__1338
0b154     EC 01 90 FD | 	jmp	#LR__1339
0b158                 | LR__1334
0b158                 | '                 $EE:
0b158                 | '                     ' return a two-byte parameter
0b158                 | '                     if (param0 == 0) and (c == 0)
0b158     6F 90 05 F1 | 	add	objptr, #111
0b15c     C8 DC C9 FA | 	rdbyte	local03, objptr wz
0b160     6F 90 85 F1 | 	sub	objptr, #111
0b164     00 D8 0D A2 |  if_e	cmp	local01, #0 wz
0b168     D8 01 90 5D |  if_ne	jmp	#LR__1339
0b16c                 | '                         ret0 := text.GetCurrentColumns
0b16c     01 02 00 FF 
0b170     8C 90 05 F1 | 	add	objptr, ##262796
0b174                 | '     cols := video.getCurrentColumns(@display, @region)
0b174     C8 C2 01 F6 | 	mov	arg01, objptr
0b178     30 C2 05 F1 | 	add	arg01, #48
0b17c     C8 C4 01 F6 | 	mov	arg02, objptr
0b180     CC 15 B0 FD | 	call	#_p2videodrv_getCurrentColumns
0b184     D3 DC 01 F6 | 	mov	local03, result1
0b188     01 02 00 FF 
0b18c     1B 90 85 F1 | 	sub	objptr, ##262683
0b190     C8 DC 41 FC | 	wrbyte	local03, objptr
0b194                 | '                         ret1 := text.GetCurrentRows
0b194     01 02 00 FF 
0b198     1B 90 05 F1 | 	add	objptr, ##262683
0b19c                 | '     rows := video.getCurrentRows(@display, @region)
0b19c     C8 C2 01 F6 | 	mov	arg01, objptr
0b1a0     30 C2 05 F1 | 	add	arg01, #48
0b1a4     C8 C4 01 F6 | 	mov	arg02, objptr
0b1a8     44 15 B0 FD | 	call	#_p2videodrv_getCurrentRows
0b1ac     01 02 00 FF 
0b1b0     1A 90 85 F1 | 	sub	objptr, ##262682
0b1b4     C8 A6 41 FC | 	wrbyte	result1, objptr
0b1b8                 | '                         readState := 1
0b1b8     06 90 85 F1 | 	sub	objptr, #6
0b1bc     C8 02 48 FC | 	wrbyte	#1, objptr
0b1c0     6C 90 85 F1 | 	sub	objptr, #108
0b1c4     7C 01 90 FD | 	jmp	#LR__1339
0b1c8                 | LR__1335
0b1c8                 | '                 $F0:
0b1c8                 | '                     ' fill
0b1c8                 | '                     wordfill(text.GetScreenBuffer, ((color & $F) << 4) | (color & $F) | param0, text.GetCurrentRows * text.GetCurrentColumns)
0b1c8     01 02 00 FF 
0b1cc     8C 90 05 F1 | 	add	objptr, ##262796
0b1d0                 | '     addr := @screenbuf
0b1d0     C8 DC 01 F6 | 	mov	local03, objptr
0b1d4     03 00 00 FF 
0b1d8     F8 DD 05 F1 | 	add	local03, ##2040
0b1dc     01 02 00 FF 
0b1e0     1C 90 85 F1 | 	sub	objptr, ##262684
0b1e4     C8 DA C1 FA | 	rdbyte	local02, objptr
0b1e8     ED D8 41 F8 | 	getnib	local01, local02, #0
0b1ec     04 D8 65 F0 | 	shl	local01, #4
0b1f0     ED DA 41 F8 | 	getnib	local02, local02, #0
0b1f4     ED D8 41 F5 | 	or	local01, local02
0b1f8     01 90 85 F1 | 	sub	objptr, #1
0b1fc     C8 DA C1 FA | 	rdbyte	local02, objptr
0b200     ED D8 41 F5 | 	or	local01, local02
0b204     01 02 00 FF 
0b208     1D 90 05 F1 | 	add	objptr, ##262685
0b20c                 | '     rows := video.getCurrentRows(@display, @region)
0b20c     C8 C2 01 F6 | 	mov	arg01, objptr
0b210     30 C2 05 F1 | 	add	arg01, #48
0b214     C8 C4 01 F6 | 	mov	arg02, objptr
0b218     D4 14 B0 FD | 	call	#_p2videodrv_getCurrentRows
0b21c     D3 DA 01 F6 | 	mov	local02, result1
0b220                 | '     cols := video.getCurrentColumns(@display, @region)
0b220     C8 C2 01 F6 | 	mov	arg01, objptr
0b224     30 C2 05 F1 | 	add	arg01, #48
0b228     C8 C4 01 F6 | 	mov	arg02, objptr
0b22c     20 15 B0 FD | 	call	#_p2videodrv_getCurrentColumns
0b230     D3 DA 01 FD | 	qmul	local02, result1
0b234     01 02 00 FF 
0b238     8C 90 85 F1 | 	sub	objptr, ##262796
0b23c     EE C2 01 F6 | 	mov	arg01, local03
0b240     EC C4 01 F6 | 	mov	arg02, local01
0b244     18 C6 61 FD | 	getqx	arg03
0b248     9C 00 A0 FD | 	call	#\builtin_wordfill_
0b24c     F4 00 90 FD | 	jmp	#LR__1339
0b250                 | LR__1336
0b250                 | '                 $F1:
0b250                 | '                     ' move cursor
0b250                 | '                     text.SetTextPos(c, param0)
0b250     6F 90 05 F1 | 	add	objptr, #111
0b254     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0b258     EC C2 01 F6 | 	mov	arg01, local01
0b25c     01 02 00 FF 
0b260     1D 90 05 F1 | 	add	objptr, ##262685
0b264     FC 0A B0 FD | 	call	#_p2textdrv_setTextPos
0b268     01 02 00 FF 
0b26c     8C 90 85 F1 | 	sub	objptr, ##262796
0b270     D0 00 90 FD | 	jmp	#LR__1339
0b274                 | LR__1337
0b274                 | '                 $F2:
0b274                 | '                     ' set color
0b274                 | '                     text.SetTextColours(param0 >> 4, param0 & $F)
0b274     6F 90 05 F1 | 	add	objptr, #111
0b278     C8 C4 C1 FA | 	rdbyte	arg02, objptr
0b27c     E2 C2 01 F6 | 	mov	arg01, arg02
0b280     04 C2 45 F0 | 	shr	arg01, #4
0b284     E2 C4 41 F8 | 	getnib	arg02, arg02, #0
0b288     01 02 00 FF 
0b28c     1D 90 05 F1 | 	add	objptr, ##262685
0b290                 | '     video.setTextColours(fg, bg)
0b290     C4 19 B0 FD | 	call	#_p2videodrv_setTextColours
0b294                 | '                     color := param0
0b294     01 02 00 FF 
0b298     1D 90 85 F1 | 	sub	objptr, ##262685
0b29c     C8 DC C1 FA | 	rdbyte	local03, objptr
0b2a0     01 90 05 F1 | 	add	objptr, #1
0b2a4     C8 DC 41 FC | 	wrbyte	local03, objptr
0b2a8     70 90 85 F1 | 	sub	objptr, #112
0b2ac     94 00 90 FD | 	jmp	#LR__1339
0b2b0                 | LR__1338
0b2b0                 | '                 $F3:
0b2b0                 | '                     ' fill line
0b2b0                 | '                     row, col := text.GetTextPos()
0b2b0     01 02 00 FF 
0b2b4     8C 90 05 F1 | 	add	objptr, ##262796
0b2b8                 | '     return video.getTextPos()
0b2b8     48 1A B0 FD | 	call	#_p2videodrv_getTextPos
0b2bc     D3 DC 01 F6 | 	mov	local03, result1
0b2c0                 | '                     col := 0
0b2c0                 | '                     wordfill(text.GetScreenBuffer + 2 * (row * text.GetCurrentColumns + col), ((color & $F) << 4) | (color & $F) | param0, text.GetCurrentColumns - col)
0b2c0                 | '     addr := @screenbuf
0b2c0     C8 DA 01 F6 | 	mov	local02, objptr
0b2c4     03 00 00 FF 
0b2c8     F8 DB 05 F1 | 	add	local02, ##2040
0b2cc                 | '     cols := video.getCurrentColumns(@display, @region)
0b2cc     C8 C2 01 F6 | 	mov	arg01, objptr
0b2d0     30 C2 05 F1 | 	add	arg01, #48
0b2d4     C8 C4 01 F6 | 	mov	arg02, objptr
0b2d8     74 14 B0 FD | 	call	#_p2videodrv_getCurrentColumns
0b2dc     D3 DC 01 FD | 	qmul	local03, result1
0b2e0     01 02 00 FF 
0b2e4     1C 90 85 F1 | 	sub	objptr, ##262684
0b2e8     C8 DC C1 FA | 	rdbyte	local03, objptr
0b2ec     EE D8 41 F8 | 	getnib	local01, local03, #0
0b2f0     04 D8 65 F0 | 	shl	local01, #4
0b2f4     EE DC 41 F8 | 	getnib	local03, local03, #0
0b2f8     EE D8 41 F5 | 	or	local01, local03
0b2fc     01 90 85 F1 | 	sub	objptr, #1
0b300     C8 DC C1 FA | 	rdbyte	local03, objptr
0b304     EE D8 41 F5 | 	or	local01, local03
0b308     01 02 00 FF 
0b30c     1D 90 05 F1 | 	add	objptr, ##262685
0b310                 | '     cols := video.getCurrentColumns(@display, @region)
0b310     C8 C2 01 F6 | 	mov	arg01, objptr
0b314     30 C2 05 F1 | 	add	arg01, #48
0b318     C8 C4 01 F6 | 	mov	arg02, objptr
0b31c     18 DC 61 FD | 	getqx	local03
0b320     01 DC 65 F0 | 	shl	local03, #1
0b324     EE DA 01 F1 | 	add	local02, local03
0b328     24 14 B0 FD | 	call	#_p2videodrv_getCurrentColumns
0b32c     01 02 00 FF 
0b330     8C 90 85 F1 | 	sub	objptr, ##262796
0b334     D3 C6 01 F6 | 	mov	arg03, result1
0b338     ED C2 01 F6 | 	mov	arg01, local02
0b33c     EC C4 01 F6 | 	mov	arg02, local01
0b340     9C 00 A0 FD | 	call	#\builtin_wordfill_
0b344                 | LR__1339
0b344                 | '             printState := 0
0b344     6D 90 05 F1 | 	add	objptr, #109
0b348     C8 00 48 FC | 	wrbyte	#0, objptr
0b34c     6D 90 85 F1 | 	sub	objptr, #109
0b350     58 00 90 FD | 	jmp	#LR__1346
0b354                 | LR__1340
0b354                 | '         0:
0b354                 | '             case c
0b354     EC DE 01 F6 | 	mov	local04, local01
0b358     EE DE 0D F2 | 	cmp	local04, #238 wz
0b35c     F0 DE 55 52 |  if_ne	cmps	local04, #240 wc
0b360     08 00 90 4D |  if_c_and_nz	jmp	#LR__1341
0b364     F4 DE 55 52 |  if_ne	cmps	local04, #244 wc
0b368     18 00 90 ED |  if_be	jmp	#LR__1342
0b36c                 | LR__1341
0b36c     8A DE 0D F2 | 	cmp	local04, #138 wz
0b370     28 00 90 AD |  if_e	jmp	#LR__1343
0b374     FE DE 0D F2 | 	cmp	local04, #254 wz
0b378     FF DE 0D 52 |  if_ne	cmp	local04, #255 wz
0b37c     24 00 90 5D |  if_ne	jmp	#LR__1344
0b380     28 00 90 FD | 	jmp	#LR__1345
0b384                 | LR__1342
0b384                 | '                 $EE, $F0..$F3:
0b384                 | '                     printMode := c
0b384     6E 90 05 F1 | 	add	objptr, #110
0b388     C8 D8 41 FC | 	wrbyte	local01, objptr
0b38c                 | '                     printState := 1
0b38c     01 90 85 F1 | 	sub	objptr, #1
0b390     C8 02 48 FC | 	wrbyte	#1, objptr
0b394     6D 90 85 F1 | 	sub	objptr, #109
0b398     10 00 90 FD | 	jmp	#LR__1345
0b39c                 | LR__1343
0b39c                 | '                 $8A: return $B1
0b39c     B1 A6 05 F6 | 	mov	result1, #177
0b3a0     0C 00 90 FD | 	jmp	#LR__1347
0b3a4                 | LR__1344
0b3a4                 | '                 $FE, $FF: ' ignore
0b3a4                 | '                 other: return c
0b3a4     EC A6 01 F6 | 	mov	result1, local01
0b3a8     04 00 90 FD | 	jmp	#LR__1347
0b3ac                 | LR__1345
0b3ac                 | LR__1346
0b3ac                 | '     return 0
0b3ac     00 A6 05 F6 | 	mov	result1, #0
0b3b0                 | LR__1347
0b3b0     A7 F0 03 F6 | 	mov	ptra, fp
0b3b4     B2 00 A0 FD | 	call	#popregs_
0b3b8                 | _bus_ConvertChar_ret
0b3b8     2D 00 64 FD | 	ret
0b3bc                 | 
0b3bc                 | ' 
0b3bc                 | ' PUB Scan2Ascii(event): r | shifted, scancode
0b3bc                 | _bus_Scan2Ascii
0b3bc     07 4A 05 F6 | 	mov	COUNT_, #7
0b3c0     A8 00 A0 FD | 	call	#pushregs_
0b3c4     E1 D8 01 F6 | 	mov	local01, arg01
0b3c8                 | '     if event <= 0
0b3c8     01 D8 55 F2 | 	cmps	local01, #1 wc
0b3cc                 | '         return 0 ' No event or release event
0b3cc     00 A6 05 C6 |  if_b	mov	result1, #0
0b3d0     48 03 90 CD |  if_b	jmp	#LR__1373
0b3d4                 | '     shifted := (event.[8+1] || event.[8+5]) ^^ event.[17]
0b3d4     00 DA 05 F6 | 	mov	local02, #0
0b3d8     00 DC 05 F6 | 	mov	local03, #0
0b3dc     09 D8 2D F4 | 	testbn	local01, #9 wz
0b3e0     EC DE 01 A6 |  if_e	mov	local04, local01
0b3e4     0D DE 45 A0 |  if_e	shr	local04, #13
0b3e8     01 DE CD A7 |  if_e	test	local04, #1 wz
0b3ec     00 DC 25 56 |  if_ne	not	local03, #0
0b3f0     00 DC 0D F2 | 	cmp	local03, #0 wz
0b3f4     00 DA 25 56 |  if_ne	not	local02, #0
0b3f8     00 E0 05 F6 | 	mov	local05, #0
0b3fc     11 D8 2D F4 | 	testbn	local01, #17 wz
0b400     01 E0 65 56 |  if_ne	neg	local05, #1
0b404     F0 DA 61 F5 | 	xor	local02, local05
0b408                 | '     scancode := event & 255
0b408     EC E2 E1 F8 | 	getbyte	local06, local01, #0
0b40c                 | '     case scancode
0b40c     F1 E4 01 F6 | 	mov	local07, local06
0b410     04 E4 85 F1 | 	sub	local07, #4
0b414     5F E4 25 F3 | 	fle	local07, #95
0b418     30 E4 61 FD | 	jmprel	local07
0b41c                 | LR__1350
0b41c     7C 01 90 FD | 	jmp	#LR__1351
0b420     78 01 90 FD | 	jmp	#LR__1351
0b424     74 01 90 FD | 	jmp	#LR__1351
0b428     70 01 90 FD | 	jmp	#LR__1351
0b42c     6C 01 90 FD | 	jmp	#LR__1351
0b430     68 01 90 FD | 	jmp	#LR__1351
0b434     64 01 90 FD | 	jmp	#LR__1351
0b438     60 01 90 FD | 	jmp	#LR__1351
0b43c     5C 01 90 FD | 	jmp	#LR__1351
0b440     58 01 90 FD | 	jmp	#LR__1351
0b444     54 01 90 FD | 	jmp	#LR__1351
0b448     50 01 90 FD | 	jmp	#LR__1351
0b44c     4C 01 90 FD | 	jmp	#LR__1351
0b450     48 01 90 FD | 	jmp	#LR__1351
0b454     44 01 90 FD | 	jmp	#LR__1351
0b458     40 01 90 FD | 	jmp	#LR__1351
0b45c     3C 01 90 FD | 	jmp	#LR__1351
0b460     38 01 90 FD | 	jmp	#LR__1351
0b464     34 01 90 FD | 	jmp	#LR__1351
0b468     30 01 90 FD | 	jmp	#LR__1351
0b46c     2C 01 90 FD | 	jmp	#LR__1351
0b470     28 01 90 FD | 	jmp	#LR__1351
0b474     24 01 90 FD | 	jmp	#LR__1351
0b478     20 01 90 FD | 	jmp	#LR__1351
0b47c     1C 01 90 FD | 	jmp	#LR__1351
0b480     18 01 90 FD | 	jmp	#LR__1351
0b484     30 01 90 FD | 	jmp	#LR__1352
0b488     2C 01 90 FD | 	jmp	#LR__1352
0b48c     28 01 90 FD | 	jmp	#LR__1352
0b490     24 01 90 FD | 	jmp	#LR__1352
0b494     20 01 90 FD | 	jmp	#LR__1352
0b498     1C 01 90 FD | 	jmp	#LR__1352
0b49c     18 01 90 FD | 	jmp	#LR__1352
0b4a0     14 01 90 FD | 	jmp	#LR__1352
0b4a4     10 01 90 FD | 	jmp	#LR__1352
0b4a8     0C 01 90 FD | 	jmp	#LR__1352
0b4ac     44 02 90 FD | 	jmp	#LR__1368
0b4b0     48 02 90 FD | 	jmp	#LR__1369
0b4b4     34 02 90 FD | 	jmp	#LR__1367
0b4b8     5C 02 90 FD | 	jmp	#LR__1372
0b4bc     24 02 90 FD | 	jmp	#LR__1366
0b4c0     30 01 90 FD | 	jmp	#LR__1354
0b4c4     40 01 90 FD | 	jmp	#LR__1355
0b4c8     50 01 90 FD | 	jmp	#LR__1356
0b4cc     60 01 90 FD | 	jmp	#LR__1357
0b4d0     70 01 90 FD | 	jmp	#LR__1358
0b4d4     80 01 90 FD | 	jmp	#LR__1359
0b4d8     90 01 90 FD | 	jmp	#LR__1360
0b4dc     A0 01 90 FD | 	jmp	#LR__1361
0b4e0     B0 01 90 FD | 	jmp	#LR__1362
0b4e4     C0 01 90 FD | 	jmp	#LR__1363
0b4e8     D0 01 90 FD | 	jmp	#LR__1364
0b4ec     E0 01 90 FD | 	jmp	#LR__1365
0b4f0     24 02 90 FD | 	jmp	#LR__1372
0b4f4     20 02 90 FD | 	jmp	#LR__1372
0b4f8     1C 02 90 FD | 	jmp	#LR__1372
0b4fc     18 02 90 FD | 	jmp	#LR__1372
0b500     14 02 90 FD | 	jmp	#LR__1372
0b504     10 02 90 FD | 	jmp	#LR__1372
0b508     0C 02 90 FD | 	jmp	#LR__1372
0b50c     08 02 90 FD | 	jmp	#LR__1372
0b510     04 02 90 FD | 	jmp	#LR__1372
0b514     00 02 90 FD | 	jmp	#LR__1372
0b518     FC 01 90 FD | 	jmp	#LR__1372
0b51c     F8 01 90 FD | 	jmp	#LR__1372
0b520     F4 01 90 FD | 	jmp	#LR__1372
0b524     F0 01 90 FD | 	jmp	#LR__1372
0b528     EC 01 90 FD | 	jmp	#LR__1372
0b52c     E8 01 90 FD | 	jmp	#LR__1372
0b530     E4 01 90 FD | 	jmp	#LR__1372
0b534     E0 01 90 FD | 	jmp	#LR__1372
0b538     DC 01 90 FD | 	jmp	#LR__1372
0b53c     D8 01 90 FD | 	jmp	#LR__1372
0b540     D4 01 90 FD | 	jmp	#LR__1372
0b544     D0 01 90 FD | 	jmp	#LR__1372
0b548     CC 01 90 FD | 	jmp	#LR__1372
0b54c     C8 01 90 FD | 	jmp	#LR__1372
0b550     C4 01 90 FD | 	jmp	#LR__1372
0b554     C0 01 90 FD | 	jmp	#LR__1372
0b558     BC 01 90 FD | 	jmp	#LR__1372
0b55c     B8 01 90 FD | 	jmp	#LR__1372
0b560     B4 01 90 FD | 	jmp	#LR__1372
0b564     B0 01 90 FD | 	jmp	#LR__1372
0b568     AC 01 90 FD | 	jmp	#LR__1372
0b56c     A8 01 90 FD | 	jmp	#LR__1372
0b570     98 01 90 FD | 	jmp	#LR__1371
0b574     94 01 90 FD | 	jmp	#LR__1371
0b578     90 01 90 FD | 	jmp	#LR__1371
0b57c     8C 01 90 FD | 	jmp	#LR__1371
0b580     88 01 90 FD | 	jmp	#LR__1371
0b584     84 01 90 FD | 	jmp	#LR__1371
0b588     80 01 90 FD | 	jmp	#LR__1371
0b58c     7C 01 90 FD | 	jmp	#LR__1371
0b590     78 01 90 FD | 	jmp	#LR__1371
0b594     6C 01 90 FD | 	jmp	#LR__1370
0b598     7C 01 90 FD | 	jmp	#LR__1372
0b59c                 | LR__1351
0b59c                 | '         usb.KEY_A..usb.KEY_Z:
0b59c                 | '             if shifted
0b59c     00 DA 0D F2 | 	cmp	local02, #0 wz
0b5a0                 | '                 return (scancode - usb.KEY_A) + "A"
0b5a0     3D E2 05 51 |  if_ne	add	local06, #61
0b5a4     F1 A6 01 56 |  if_ne	mov	result1, local06
0b5a8     70 01 90 5D |  if_ne	jmp	#LR__1373
0b5ac                 | '             else
0b5ac                 | '                 return (scancode - usb.KEY_A) + "a"
0b5ac     F1 A6 01 F6 | 	mov	result1, local06
0b5b0     5D A6 05 F1 | 	add	result1, #93
0b5b4     64 01 90 FD | 	jmp	#LR__1373
0b5b8                 | LR__1352
0b5b8                 | '         usb.KEY_1..usb.KEY_0:
0b5b8                 | '             if shifted
0b5b8     00 DA 0D F2 | 	cmp	local02, #0 wz
0b5bc     1C 00 90 AD |  if_e	jmp	#LR__1353
0b5c0                 | '                 return lookupz(scancode-usb.KEY_1 : "!","@","#","$","%","^","&","*","(",")")
0b5c0     1E E2 85 F1 | 	sub	local06, #30
0b5c4     CA C6 01 F6 | 	mov	arg03, ptr__bus_dat__
0b5c8     F1 C2 01 F6 | 	mov	arg01, local06
0b5cc     00 C4 05 F6 | 	mov	arg02, #0
0b5d0     0A C8 05 F6 | 	mov	arg04, #10
0b5d4     A8 2E B0 FD | 	call	#__system___lookup
0b5d8     40 01 90 FD | 	jmp	#LR__1373
0b5dc                 | LR__1353
0b5dc                 | '             elseif scancode == usb.KEY_0
0b5dc     27 E2 0D F2 | 	cmp	local06, #39 wz
0b5e0                 | '                 return "0"
0b5e0     30 A6 05 A6 |  if_e	mov	result1, #48
0b5e4     34 01 90 AD |  if_e	jmp	#LR__1373
0b5e8                 | '             else
0b5e8                 | '                 return (scancode - usb.KEY_1) + "1"
0b5e8     F1 A6 01 F6 | 	mov	result1, local06
0b5ec     13 A6 05 F1 | 	add	result1, #19
0b5f0     28 01 90 FD | 	jmp	#LR__1373
0b5f4                 | LR__1354
0b5f4                 | '         usb.KEY_MINUS:
0b5f4                 | '             ifnot shifted
0b5f4     00 DA 0D F2 | 	cmp	local02, #0 wz
0b5f8                 | '                 return "-"
0b5f8     2D A6 05 A6 |  if_e	mov	result1, #45
0b5fc     1C 01 90 AD |  if_e	jmp	#LR__1373
0b600                 | '             else
0b600                 | '                 return "_"
0b600     5F A6 05 F6 | 	mov	result1, #95
0b604     14 01 90 FD | 	jmp	#LR__1373
0b608                 | LR__1355
0b608                 | '         usb.KEY_EQUAL:
0b608                 | '             ifnot shifted
0b608     00 DA 0D F2 | 	cmp	local02, #0 wz
0b60c                 | '                 return "="
0b60c     3D A6 05 A6 |  if_e	mov	result1, #61
0b610     08 01 90 AD |  if_e	jmp	#LR__1373
0b614                 | '             else
0b614                 | '                 return "+"
0b614     2B A6 05 F6 | 	mov	result1, #43
0b618     00 01 90 FD | 	jmp	#LR__1373
0b61c                 | LR__1356
0b61c                 | '         usb.KEY_LBRACE:
0b61c                 | '             ifnot shifted
0b61c     00 DA 0D F2 | 	cmp	local02, #0 wz
0b620                 | '                 return "["
0b620     5B A6 05 A6 |  if_e	mov	result1, #91
0b624     F4 00 90 AD |  if_e	jmp	#LR__1373
0b628                 | '             else
0b628                 | '                 return "{"
0b628     7B A6 05 F6 | 	mov	result1, #123
0b62c     EC 00 90 FD | 	jmp	#LR__1373
0b630                 | LR__1357
0b630                 | '         usb.KEY_RBRACE:
0b630                 | '             ifnot shifted
0b630     00 DA 0D F2 | 	cmp	local02, #0 wz
0b634                 | '                 return "]"
0b634     5D A6 05 A6 |  if_e	mov	result1, #93
0b638     E0 00 90 AD |  if_e	jmp	#LR__1373
0b63c                 | '             else
0b63c                 | '                 return "}"
0b63c     7D A6 05 F6 | 	mov	result1, #125
0b640     D8 00 90 FD | 	jmp	#LR__1373
0b644                 | LR__1358
0b644                 | '         usb.KEY_BACKSLASH:
0b644                 | '             ifnot shifted
0b644     00 DA 0D F2 | 	cmp	local02, #0 wz
0b648                 | '                 return "\"
0b648     5C A6 05 A6 |  if_e	mov	result1, #92
0b64c     CC 00 90 AD |  if_e	jmp	#LR__1373
0b650                 | '             else
0b650                 | '                 return "|"
0b650     7C A6 05 F6 | 	mov	result1, #124
0b654     C4 00 90 FD | 	jmp	#LR__1373
0b658                 | LR__1359
0b658                 | '         usb.KEY_HASHTILDE:
0b658                 | '             ifnot shifted
0b658     00 DA 0D F2 | 	cmp	local02, #0 wz
0b65c                 | '                 return "`"
0b65c     60 A6 05 A6 |  if_e	mov	result1, #96
0b660     B8 00 90 AD |  if_e	jmp	#LR__1373
0b664                 | '             else
0b664                 | '                 return "~"
0b664     7E A6 05 F6 | 	mov	result1, #126
0b668     B0 00 90 FD | 	jmp	#LR__1373
0b66c                 | LR__1360
0b66c                 | '         usb.KEY_SEMICOLON:
0b66c                 | '             ifnot shifted
0b66c     00 DA 0D F2 | 	cmp	local02, #0 wz
0b670                 | '                 return ";"
0b670     3B A6 05 A6 |  if_e	mov	result1, #59
0b674     A4 00 90 AD |  if_e	jmp	#LR__1373
0b678                 | '             else
0b678                 | '                 return ":"
0b678     3A A6 05 F6 | 	mov	result1, #58
0b67c     9C 00 90 FD | 	jmp	#LR__1373
0b680                 | LR__1361
0b680                 | '         usb.KEY_APOST:
0b680                 | '             ifnot shifted
0b680     00 DA 0D F2 | 	cmp	local02, #0 wz
0b684                 | '                 return "'"
0b684     27 A6 05 A6 |  if_e	mov	result1, #39
0b688     90 00 90 AD |  if_e	jmp	#LR__1373
0b68c                 | '             else
0b68c                 | '                 return 34
0b68c     22 A6 05 F6 | 	mov	result1, #34
0b690     88 00 90 FD | 	jmp	#LR__1373
0b694                 | LR__1362
0b694                 | '         usb.KEY_GRAVE:
0b694                 | '             ifnot shifted
0b694     00 DA 0D F2 | 	cmp	local02, #0 wz
0b698                 | '                 return "`"
0b698     60 A6 05 A6 |  if_e	mov	result1, #96
0b69c     7C 00 90 AD |  if_e	jmp	#LR__1373
0b6a0                 | '             else
0b6a0                 | '                 return "~"
0b6a0     7E A6 05 F6 | 	mov	result1, #126
0b6a4     74 00 90 FD | 	jmp	#LR__1373
0b6a8                 | LR__1363
0b6a8                 | '         usb.KEY_COMMA:
0b6a8                 | '             ifnot shifted
0b6a8     00 DA 0D F2 | 	cmp	local02, #0 wz
0b6ac                 | '                 return ","
0b6ac     2C A6 05 A6 |  if_e	mov	result1, #44
0b6b0     68 00 90 AD |  if_e	jmp	#LR__1373
0b6b4                 | '             else
0b6b4                 | '                 return "<"
0b6b4     3C A6 05 F6 | 	mov	result1, #60
0b6b8     60 00 90 FD | 	jmp	#LR__1373
0b6bc                 | LR__1364
0b6bc                 | '         usb.KEY_DOT:
0b6bc                 | '             ifnot shifted
0b6bc     00 DA 0D F2 | 	cmp	local02, #0 wz
0b6c0                 | '                 return "."
0b6c0     2E A6 05 A6 |  if_e	mov	result1, #46
0b6c4     54 00 90 AD |  if_e	jmp	#LR__1373
0b6c8                 | '             else
0b6c8                 | '                 return ">"
0b6c8     3E A6 05 F6 | 	mov	result1, #62
0b6cc     4C 00 90 FD | 	jmp	#LR__1373
0b6d0                 | LR__1365
0b6d0                 | '         usb.KEY_SLASH:
0b6d0                 | '             ifnot shifted
0b6d0     00 DA 0D F2 | 	cmp	local02, #0 wz
0b6d4                 | '                 return "/"
0b6d4     2F A6 05 A6 |  if_e	mov	result1, #47
0b6d8     40 00 90 AD |  if_e	jmp	#LR__1373
0b6dc                 | '             else
0b6dc                 | '                 return "?"
0b6dc     3F A6 05 F6 | 	mov	result1, #63
0b6e0     38 00 90 FD | 	jmp	#LR__1373
0b6e4                 | LR__1366
0b6e4                 | '         usb.KEY_SPACE: return " "
0b6e4     20 A6 05 F6 | 	mov	result1, #32
0b6e8     30 00 90 FD | 	jmp	#LR__1373
0b6ec                 | LR__1367
0b6ec                 | '         usb.KEY_BACKSPACE: return 8
0b6ec     08 A6 05 F6 | 	mov	result1, #8
0b6f0     28 00 90 FD | 	jmp	#LR__1373
0b6f4                 | LR__1368
0b6f4                 | '         usb.KEY_ENTER: return 10
0b6f4     0A A6 05 F6 | 	mov	result1, #10
0b6f8     20 00 90 FD | 	jmp	#LR__1373
0b6fc                 | LR__1369
0b6fc                 | '         usb.KEY_ESC: return 27
0b6fc     1B A6 05 F6 | 	mov	result1, #27
0b700     18 00 90 FD | 	jmp	#LR__1373
0b704                 | LR__1370
0b704                 | '         usb.KEY_NUM0: return "0"
0b704     30 A6 05 F6 | 	mov	result1, #48
0b708     10 00 90 FD | 	jmp	#LR__1373
0b70c                 | LR__1371
0b70c                 | '         usb.KEY_NUM1..usb.KEY_NUM9: return (scancode - usb.KEY_NUM1) + "1"
0b70c     28 E2 85 F1 | 	sub	local06, #40
0b710     F1 A6 01 F6 | 	mov	result1, local06
0b714     04 00 90 FD | 	jmp	#LR__1373
0b718                 | LR__1372
0b718                 | '         other:
0b718                 | '             return 0
0b718     00 A6 05 F6 | 	mov	result1, #0
0b71c                 | LR__1373
0b71c     A7 F0 03 F6 | 	mov	ptra, fp
0b720     B2 00 A0 FD | 	call	#popregs_
0b724                 | _bus_Scan2Ascii_ret
0b724     2D 00 64 FD | 	ret
0b728                 | 
0b728                 | ' 
0b728                 | ' PUB Initialize
0b728                 | _disk_Initialize
0b728                 | '     image[0] := c.fopen(@"/sd/disk0.img", @"r+b")
0b728     7D 00 00 FF 
0b72c     3E C2 05 F6 | 	mov	arg01, ##@LR__2117
0b730     7D 00 00 FF 
0b734     4C C4 05 F6 | 	mov	arg02, ##@LR__2118
0b738     01 00 00 FF 
0b73c     10 90 05 F1 | 	add	objptr, ##528
0b740     E8 52 BF FD | 	call	#_libc_a_fopen
0b744     01 00 00 FF 
0b748     10 90 85 F1 | 	sub	objptr, ##528
0b74c     C8 A6 61 FC | 	wrlong	result1, objptr
0b750                 | '     image[1] := c.fopen(@"/sd/disk1.img", @"r+b")
0b750     7D 00 00 FF 
0b754     50 C2 05 F6 | 	mov	arg01, ##@LR__2119
0b758     7D 00 00 FF 
0b75c     5E C4 05 F6 | 	mov	arg02, ##@LR__2120
0b760     01 00 00 FF 
0b764     10 90 05 F1 | 	add	objptr, ##528
0b768     C0 52 BF FD | 	call	#_libc_a_fopen
0b76c     01 00 00 FF 
0b770     0C 90 85 F1 | 	sub	objptr, ##524
0b774     C8 A6 61 FC | 	wrlong	result1, objptr
0b778                 | '     image[2] := c.fopen(@"/sd/disk2.img", @"r+b")
0b778     7D 00 00 FF 
0b77c     62 C2 05 F6 | 	mov	arg01, ##@LR__2121
0b780     7D 00 00 FF 
0b784     70 C4 05 F6 | 	mov	arg02, ##@LR__2122
0b788     01 00 00 FF 
0b78c     0C 90 05 F1 | 	add	objptr, ##524
0b790     98 52 BF FD | 	call	#_libc_a_fopen
0b794     01 00 00 FF 
0b798     08 90 85 F1 | 	sub	objptr, ##520
0b79c     C8 A6 61 FC | 	wrlong	result1, objptr
0b7a0                 | '     image[3] := c.fopen(@"/sd/disk3.img", @"r+b")
0b7a0     7D 00 00 FF 
0b7a4     74 C2 05 F6 | 	mov	arg01, ##@LR__2123
0b7a8     7D 00 00 FF 
0b7ac     82 C4 05 F6 | 	mov	arg02, ##@LR__2124
0b7b0     01 00 00 FF 
0b7b4     08 90 05 F1 | 	add	objptr, ##520
0b7b8     70 52 BF FD | 	call	#_libc_a_fopen
0b7bc     01 00 00 FF 
0b7c0     04 90 85 F1 | 	sub	objptr, ##516
0b7c4     C8 A6 61 FC | 	wrlong	result1, objptr
0b7c8     0C 90 85 F1 | 	sub	objptr, #12
0b7cc                 | _disk_Initialize_ret
0b7cc     2D 00 64 FD | 	ret
0b7d0                 | 
0b7d0                 | ' 
0b7d0                 | ' PUB Seek(id, sector)
0b7d0                 | _disk_Seek
0b7d0                 | '     c.fseek(image[id], sector * 512, c#SEEK_SET)
0b7d0     02 C2 65 F0 | 	shl	arg01, #2
0b7d4     C8 C2 01 F1 | 	add	arg01, objptr
0b7d8     E1 C2 01 FB | 	rdlong	arg01, arg01
0b7dc     09 C4 65 F0 | 	shl	arg02, #9
0b7e0     00 C6 05 F6 | 	mov	arg03, #0
0b7e4     01 00 00 FF 
0b7e8     10 90 05 F1 | 	add	objptr, ##528
0b7ec     84 52 BF FD | 	call	#_libc_a_fseek
0b7f0     01 00 00 FF 
0b7f4     10 90 85 F1 | 	sub	objptr, ##528
0b7f8                 | _disk_Seek_ret
0b7f8     2D 00 64 FD | 	ret
0b7fc                 | 
0b7fc                 | ' 
0b7fc                 | ' PUB Size(id)
0b7fc                 | _disk_Size
0b7fc     02 4A 05 F6 | 	mov	COUNT_, #2
0b800     A8 00 A0 FD | 	call	#pushregs_
0b804     E1 D8 01 F6 | 	mov	local01, arg01
0b808                 | '     if image[id] == 0
0b808     EC C6 01 F6 | 	mov	arg03, local01
0b80c     02 C6 65 F0 | 	shl	arg03, #2
0b810     C8 C6 01 F1 | 	add	arg03, objptr
0b814     E3 C6 09 FB | 	rdlong	arg03, arg03 wz
0b818                 | '         return 0
0b818     00 A6 05 A6 |  if_e	mov	result1, #0
0b81c     80 00 90 AD |  if_e	jmp	#LR__1380
0b820                 | '     c.fseek(image[id], 0, c#SEEK_END)
0b820     EC C6 01 F6 | 	mov	arg03, local01
0b824     02 C6 65 F0 | 	shl	arg03, #2
0b828     C8 C6 01 F1 | 	add	arg03, objptr
0b82c     E3 C2 01 FB | 	rdlong	arg01, arg03
0b830     00 C4 05 F6 | 	mov	arg02, #0
0b834     02 C6 05 F6 | 	mov	arg03, #2
0b838     01 00 00 FF 
0b83c     10 90 05 F1 | 	add	objptr, ##528
0b840     30 52 BF FD | 	call	#_libc_a_fseek
0b844     01 00 00 FF 
0b848     10 90 85 F1 | 	sub	objptr, ##528
0b84c                 | '     result := c.ftell(image[id])
0b84c     EC C6 01 F6 | 	mov	arg03, local01
0b850     02 C6 65 F0 | 	shl	arg03, #2
0b854     C8 C6 01 F1 | 	add	arg03, objptr
0b858     E3 C2 01 FB | 	rdlong	arg01, arg03
0b85c     01 00 00 FF 
0b860     10 90 05 F1 | 	add	objptr, ##528
0b864     70 52 BF FD | 	call	#_libc_a_ftell
0b868     01 00 00 FF 
0b86c     10 90 85 F1 | 	sub	objptr, ##528
0b870     D3 DA 01 F6 | 	mov	local02, result1
0b874                 | '     c.fseek(image[id], 0, c#SEEK_SET)
0b874     02 D8 65 F0 | 	shl	local01, #2
0b878     C8 D8 01 F1 | 	add	local01, objptr
0b87c     EC C2 01 FB | 	rdlong	arg01, local01
0b880     00 C4 05 F6 | 	mov	arg02, #0
0b884     00 C6 05 F6 | 	mov	arg03, #0
0b888     01 00 00 FF 
0b88c     10 90 05 F1 | 	add	objptr, ##528
0b890     E0 51 BF FD | 	call	#_libc_a_fseek
0b894     01 00 00 FF 
0b898     10 90 85 F1 | 	sub	objptr, ##528
0b89c     ED A6 01 F6 | 	mov	result1, local02
0b8a0                 | LR__1380
0b8a0     A7 F0 03 F6 | 	mov	ptra, fp
0b8a4     B2 00 A0 FD | 	call	#popregs_
0b8a8                 | _disk_Size_ret
0b8a8     2D 00 64 FD | 	ret
0b8ac                 | 
0b8ac                 | ' 
0b8ac                 | ' PUB Read(id)
0b8ac                 | _disk_Read
0b8ac                 | '     c.fread(@buffer, 1, 512, image[id])
0b8ac     C8 C6 01 F6 | 	mov	arg03, objptr
0b8b0     10 C6 05 F1 | 	add	arg03, #16
0b8b4     02 C2 65 F0 | 	shl	arg01, #2
0b8b8     C8 C2 01 F1 | 	add	arg01, objptr
0b8bc     E1 C8 01 FB | 	rdlong	arg04, arg01
0b8c0     E3 C2 01 F6 | 	mov	arg01, arg03
0b8c4     01 C4 05 F6 | 	mov	arg02, #1
0b8c8     09 C6 C5 F9 | 	decod	arg03, #9
0b8cc     01 00 00 FF 
0b8d0     10 90 05 F1 | 	add	objptr, ##528
0b8d4     94 52 BF FD | 	call	#_libc_a_fread
0b8d8                 | '     return @buffer
0b8d8     01 00 00 FF 
0b8dc     00 90 85 F1 | 	sub	objptr, ##512
0b8e0     C8 A6 01 F6 | 	mov	result1, objptr
0b8e4     10 90 85 F1 | 	sub	objptr, #16
0b8e8                 | _disk_Read_ret
0b8e8     2D 00 64 FD | 	ret
0b8ec                 | 
0b8ec                 | ' 
0b8ec                 | ' PUB Write(id)
0b8ec                 | _disk_Write
0b8ec                 | '     c.fwrite(@buffer, 1, 512, image[id])
0b8ec     C8 C6 01 F6 | 	mov	arg03, objptr
0b8f0     10 C6 05 F1 | 	add	arg03, #16
0b8f4     02 C2 65 F0 | 	shl	arg01, #2
0b8f8     C8 C2 01 F1 | 	add	arg01, objptr
0b8fc     E1 C8 01 FB | 	rdlong	arg04, arg01
0b900     E3 C2 01 F6 | 	mov	arg01, arg03
0b904     01 C4 05 F6 | 	mov	arg02, #1
0b908     09 C6 C5 F9 | 	decod	arg03, #9
0b90c     01 00 00 FF 
0b910     10 90 05 F1 | 	add	objptr, ##528
0b914     18 52 BF FD | 	call	#_libc_a_fwrite
0b918     01 00 00 FF 
0b91c     10 90 85 F1 | 	sub	objptr, ##528
0b920                 | _disk_Write_ret
0b920     2D 00 64 FD | 	ret
0b924                 | 
0b924                 | ' 
0b924                 | ' PUB ReadByte(address)
0b924                 | _memory_ReadByte
0b924     05 4A 05 F6 | 	mov	COUNT_, #5
0b928     A8 00 A0 FD | 	call	#pushregs_
0b92c     E1 D8 01 F6 | 	mov	local01, arg01
0b930                 | '     if (umath.ge(address, 0) and umath.lt(address, MEMORY_RAM))
0b930     00 DA 05 F6 | 	mov	local02, #0
0b934     EC C2 01 F6 | 	mov	arg01, local01
0b938     00 C4 05 F6 | 	mov	arg02, #0
0b93c                 | ' 
0b93c                 | ' '' Return true if x => y unsigned.
0b93c                 | ' 
0b93c                 | '   return cpr(x,y) & constant(UGT | EQ) <> 0
0b93c     00 DC 05 F6 | 	mov	local03, #0
0b940     C4 03 B0 FD | 	call	#_umath_cpr
0b944     06 A6 CD F7 | 	test	result1, #6 wz
0b948     00 DC 25 56 |  if_ne	not	local03, #0
0b94c     00 DC 0D F2 | 	cmp	local03, #0 wz
0b950     00 DA 25 56 |  if_ne	not	local02, #0
0b954     00 DE 05 F6 | 	mov	local04, #0
0b958     EC C2 01 F6 | 	mov	arg01, local01
0b95c     12 C4 C5 F9 | 	decod	arg02, #18
0b960                 | ' 
0b960                 | ' '' Return true if x < y unsigned.
0b960                 | ' 
0b960                 | '   return cpr(x,y) & ULT <> 0
0b960     00 E0 05 F6 | 	mov	local05, #0
0b964     A0 03 B0 FD | 	call	#_umath_cpr
0b968     01 A6 CD F7 | 	test	result1, #1 wz
0b96c     00 E0 25 56 |  if_ne	not	local05, #0
0b970     F0 A6 09 F6 | 	mov	result1, local05 wz
0b974     00 DE 25 56 |  if_ne	not	local04, #0
0b978     EF DA C9 F7 | 	test	local02, local04 wz
0b97c                 | '         return ram[address]
0b97c     C8 D8 01 51 |  if_ne	add	local01, objptr
0b980     EC A6 C1 5A |  if_ne	rdbyte	result1, local01
0b984     E4 01 90 5D |  if_ne	jmp	#LR__1393
0b988                 | '     else
0b988                 | '         if (umath.ge(address, constant(MEMORY_ROM_START + $40000)) and umath.lt(address, constant(MEMORY_ROM_START + $40FFF)))
0b988     00 DA 05 F6 | 	mov	local02, #0
0b98c     EC C2 01 F6 | 	mov	arg01, local01
0b990     00 02 78 FF 
0b994     00 C4 05 F6 | 	mov	arg02, ##-268173312
0b998                 | ' 
0b998                 | ' '' Return true if x => y unsigned.
0b998                 | ' 
0b998                 | '   return cpr(x,y) & constant(UGT | EQ) <> 0
0b998     00 DC 05 F6 | 	mov	local03, #0
0b99c     68 03 B0 FD | 	call	#_umath_cpr
0b9a0     06 A6 CD F7 | 	test	result1, #6 wz
0b9a4     00 DC 25 56 |  if_ne	not	local03, #0
0b9a8     00 DC 0D F2 | 	cmp	local03, #0 wz
0b9ac     00 DA 25 56 |  if_ne	not	local02, #0
0b9b0     00 DE 05 F6 | 	mov	local04, #0
0b9b4     EC C2 01 F6 | 	mov	arg01, local01
0b9b8     07 02 78 FF 
0b9bc     FF C5 05 F6 | 	mov	arg02, ##-268169217
0b9c0                 | ' 
0b9c0                 | ' '' Return true if x < y unsigned.
0b9c0                 | ' 
0b9c0                 | '   return cpr(x,y) & ULT <> 0
0b9c0     00 E0 05 F6 | 	mov	local05, #0
0b9c4     40 03 B0 FD | 	call	#_umath_cpr
0b9c8     01 A6 CD F7 | 	test	result1, #1 wz
0b9cc     00 E0 25 56 |  if_ne	not	local05, #0
0b9d0     00 E0 0D F2 | 	cmp	local05, #0 wz
0b9d4     00 DE 25 56 |  if_ne	not	local04, #0
0b9d8     EF DA C9 F7 | 	test	local02, local04 wz
0b9dc                 | '             address -= constant($40000 - $3000)
0b9dc     E8 01 00 5F 
0b9e0     00 D8 85 51 |  if_ne	sub	local01, ##249856
0b9e4     1C 01 90 5D |  if_ne	jmp	#LR__1392
0b9e8                 | '         elseif (umath.ge(address, constant(MEMORY_ROM_START + $45000)) and umath.lt(address, constant(MEMORY_ROM_START + $45FFF)))
0b9e8     00 DA 05 F6 | 	mov	local02, #0
0b9ec     EC C2 01 F6 | 	mov	arg01, local01
0b9f0     28 02 78 FF 
0b9f4     00 C4 05 F6 | 	mov	arg02, ##-268152832
0b9f8                 | ' 
0b9f8                 | ' '' Return true if x => y unsigned.
0b9f8                 | ' 
0b9f8                 | '   return cpr(x,y) & constant(UGT | EQ) <> 0
0b9f8     00 DC 05 F6 | 	mov	local03, #0
0b9fc     08 03 B0 FD | 	call	#_umath_cpr
0ba00     06 A6 CD F7 | 	test	result1, #6 wz
0ba04     00 DC 25 56 |  if_ne	not	local03, #0
0ba08     00 DC 0D F2 | 	cmp	local03, #0 wz
0ba0c     00 DA 25 56 |  if_ne	not	local02, #0
0ba10     00 DE 05 F6 | 	mov	local04, #0
0ba14     EC C2 01 F6 | 	mov	arg01, local01
0ba18     2F 02 78 FF 
0ba1c     FF C5 05 F6 | 	mov	arg02, ##-268148737
0ba20                 | ' 
0ba20                 | ' '' Return true if x < y unsigned.
0ba20                 | ' 
0ba20                 | '   return cpr(x,y) & ULT <> 0
0ba20     00 E0 05 F6 | 	mov	local05, #0
0ba24     E0 02 B0 FD | 	call	#_umath_cpr
0ba28     01 A6 CD F7 | 	test	result1, #1 wz
0ba2c     00 E0 25 56 |  if_ne	not	local05, #0
0ba30     00 E0 0D F2 | 	cmp	local05, #0 wz
0ba34     00 DE 25 56 |  if_ne	not	local04, #0
0ba38     EF DA C9 F7 | 	test	local02, local04 wz
0ba3c                 | '             address -= constant($45000 - $3100)
0ba3c     0F 02 00 5F 
0ba40     00 D9 85 51 |  if_ne	sub	local01, ##270080
0ba44     BC 00 90 5D |  if_ne	jmp	#LR__1391
0ba48                 | '         elseif (umath.ge(address, constant(MEMORY_ROM_START + $46000)) and umath.lt(address, constant(MEMORY_ROM_START + $46FFF)))
0ba48     00 DA 05 F6 | 	mov	local02, #0
0ba4c     EC C2 01 F6 | 	mov	arg01, local01
0ba50     30 02 78 FF 
0ba54     00 C4 05 F6 | 	mov	arg02, ##-268148736
0ba58                 | ' 
0ba58                 | ' '' Return true if x => y unsigned.
0ba58                 | ' 
0ba58                 | '   return cpr(x,y) & constant(UGT | EQ) <> 0
0ba58     00 DC 05 F6 | 	mov	local03, #0
0ba5c     A8 02 B0 FD | 	call	#_umath_cpr
0ba60     06 A6 CD F7 | 	test	result1, #6 wz
0ba64     00 DC 25 56 |  if_ne	not	local03, #0
0ba68     00 DC 0D F2 | 	cmp	local03, #0 wz
0ba6c     00 DA 25 56 |  if_ne	not	local02, #0
0ba70     00 DE 05 F6 | 	mov	local04, #0
0ba74     EC C2 01 F6 | 	mov	arg01, local01
0ba78     37 02 78 FF 
0ba7c     FF C5 05 F6 | 	mov	arg02, ##-268144641
0ba80                 | ' 
0ba80                 | ' '' Return true if x < y unsigned.
0ba80                 | ' 
0ba80                 | '   return cpr(x,y) & ULT <> 0
0ba80     00 E0 05 F6 | 	mov	local05, #0
0ba84     80 02 B0 FD | 	call	#_umath_cpr
0ba88     01 A6 CD F7 | 	test	result1, #1 wz
0ba8c     00 E0 25 56 |  if_ne	not	local05, #0
0ba90     00 E0 0D F2 | 	cmp	local05, #0 wz
0ba94     00 DE 25 56 |  if_ne	not	local04, #0
0ba98     EF DA C9 F7 | 	test	local02, local04 wz
0ba9c                 | '             address -= constant($46000 - $3200)
0ba9c     17 02 00 5F 
0baa0     00 D8 85 51 |  if_ne	sub	local01, ##273920
0baa4     5C 00 90 5D |  if_ne	jmp	#LR__1390
0baa8                 | '         elseif (umath.ge(address, constant(MEMORY_ROM_START + $47000)) and umath.lt(address, constant(MEMORY_ROM_START + $47FFF)))
0baa8     00 DA 05 F6 | 	mov	local02, #0
0baac     EC C2 01 F6 | 	mov	arg01, local01
0bab0     38 02 78 FF 
0bab4     00 C4 05 F6 | 	mov	arg02, ##-268144640
0bab8                 | ' 
0bab8                 | ' '' Return true if x => y unsigned.
0bab8                 | ' 
0bab8                 | '   return cpr(x,y) & constant(UGT | EQ) <> 0
0bab8     00 DC 05 F6 | 	mov	local03, #0
0babc     48 02 B0 FD | 	call	#_umath_cpr
0bac0     06 A6 CD F7 | 	test	result1, #6 wz
0bac4     00 DC 25 56 |  if_ne	not	local03, #0
0bac8     00 DC 0D F2 | 	cmp	local03, #0 wz
0bacc     00 DA 25 56 |  if_ne	not	local02, #0
0bad0     00 DE 05 F6 | 	mov	local04, #0
0bad4     EC C2 01 F6 | 	mov	arg01, local01
0bad8     3F 02 78 FF 
0badc     FF C5 05 F6 | 	mov	arg02, ##-268140545
0bae0                 | ' 
0bae0                 | ' '' Return true if x < y unsigned.
0bae0                 | ' 
0bae0                 | '   return cpr(x,y) & ULT <> 0
0bae0     00 E0 05 F6 | 	mov	local05, #0
0bae4     20 02 B0 FD | 	call	#_umath_cpr
0bae8     01 A6 CD F7 | 	test	result1, #1 wz
0baec     00 E0 25 56 |  if_ne	not	local05, #0
0baf0     00 E0 0D F2 | 	cmp	local05, #0 wz
0baf4     00 DE 25 56 |  if_ne	not	local04, #0
0baf8     EF DA C9 F7 | 	test	local02, local04 wz
0bafc                 | '             address -= constant($47000 - $3300)
0bafc     1E 02 00 5F 
0bb00     00 D9 85 51 |  if_ne	sub	local01, ##277760
0bb04                 | LR__1390
0bb04                 | LR__1391
0bb04                 | LR__1392
0bb04                 | ' 
0bb04                 | '         if (umath.ge(address, MEMORY_ROM_START) and umath.lt(address, constant(MEMORY_ROM_START + MEMORY_ROM)))
0bb04     00 DA 05 F6 | 	mov	local02, #0
0bb08     EC C2 01 F6 | 	mov	arg01, local01
0bb0c     00 00 78 FF 
0bb10     00 C4 05 F6 | 	mov	arg02, ##-268435456
0bb14                 | ' 
0bb14                 | ' '' Return true if x => y unsigned.
0bb14                 | ' 
0bb14                 | '   return cpr(x,y) & constant(UGT | EQ) <> 0
0bb14     00 DC 05 F6 | 	mov	local03, #0
0bb18     EC 01 B0 FD | 	call	#_umath_cpr
0bb1c     06 A6 CD F7 | 	test	result1, #6 wz
0bb20     00 DC 25 56 |  if_ne	not	local03, #0
0bb24     00 DC 4D F2 | 	cmps	local03, #0 wz
0bb28     00 DA 25 56 |  if_ne	not	local02, #0
0bb2c     00 DE 05 F6 | 	mov	local04, #0
0bb30     EC C2 01 F6 | 	mov	arg01, local01
0bb34     20 00 78 FF 
0bb38     00 C4 05 F6 | 	mov	arg02, ##-268419072
0bb3c                 | ' 
0bb3c                 | ' '' Return true if x < y unsigned.
0bb3c                 | ' 
0bb3c                 | '   return cpr(x,y) & ULT <> 0
0bb3c     00 E0 05 F6 | 	mov	local05, #0
0bb40     C4 01 B0 FD | 	call	#_umath_cpr
0bb44     01 A6 CD F7 | 	test	result1, #1 wz
0bb48     00 E0 25 56 |  if_ne	not	local05, #0
0bb4c     F0 A6 09 F6 | 	mov	result1, local05 wz
0bb50     00 DE 25 56 |  if_ne	not	local04, #0
0bb54     EF DA 09 F5 | 	and	local02, local04 wz
0bb58                 | '             address &= $00007FFF
0bb58     0E D8 45 57 |  if_ne	zerox	local01, #14
0bb5c                 | '             return rom[address]
0bb5c     EC DA 01 56 |  if_ne	mov	local02, local01
0bb60     CE DA 01 51 |  if_ne	add	local02, ptr__memory_dat__
0bb64     ED A6 C1 5A |  if_ne	rdbyte	result1, local02
0bb68                 | '         else
0bb68                 | '             return 0
0bb68     00 A6 05 A6 |  if_e	mov	result1, #0
0bb6c                 | LR__1393
0bb6c     A7 F0 03 F6 | 	mov	ptra, fp
0bb70     B2 00 A0 FD | 	call	#popregs_
0bb74                 | _memory_ReadByte_ret
0bb74     2D 00 64 FD | 	ret
0bb78                 | 
0bb78                 | ' 
0bb78                 | ' PUB ReadHalf(address)
0bb78                 | _memory_ReadHalf
0bb78     02 4A 05 F6 | 	mov	COUNT_, #2
0bb7c     A8 00 A0 FD | 	call	#pushregs_
0bb80                 | '     result := ReadByte(address)
0bb80     E1 D8 01 F6 | 	mov	local01, arg01
0bb84     9C FD BF FD | 	call	#_memory_ReadByte
0bb88     D3 DA 01 F6 | 	mov	local02, result1
0bb8c                 | '     result |= ReadByte(address + 1) << 8
0bb8c     01 D8 05 F1 | 	add	local01, #1
0bb90     EC C2 01 F6 | 	mov	arg01, local01
0bb94     8C FD BF FD | 	call	#_memory_ReadByte
0bb98     08 A6 65 F0 | 	shl	result1, #8
0bb9c     ED A6 41 F5 | 	or	result1, local02
0bba0     A7 F0 03 F6 | 	mov	ptra, fp
0bba4     B2 00 A0 FD | 	call	#popregs_
0bba8                 | _memory_ReadHalf_ret
0bba8     2D 00 64 FD | 	ret
0bbac                 | 
0bbac                 | ' 
0bbac                 | ' PUB ReadWord(address)
0bbac                 | _memory_ReadWord
0bbac     02 4A 05 F6 | 	mov	COUNT_, #2
0bbb0     A8 00 A0 FD | 	call	#pushregs_
0bbb4                 | '     result := ReadByte(address)
0bbb4     E1 D8 01 F6 | 	mov	local01, arg01
0bbb8     68 FD BF FD | 	call	#_memory_ReadByte
0bbbc     D3 DA 01 F6 | 	mov	local02, result1
0bbc0                 | '     result |= ReadByte(address + 1) << 8
0bbc0     EC C2 01 F6 | 	mov	arg01, local01
0bbc4     01 C2 05 F1 | 	add	arg01, #1
0bbc8     58 FD BF FD | 	call	#_memory_ReadByte
0bbcc     08 A6 65 F0 | 	shl	result1, #8
0bbd0     D3 DA 41 F5 | 	or	local02, result1
0bbd4                 | '     result |= ReadByte(address + 2) << 16
0bbd4     EC C2 01 F6 | 	mov	arg01, local01
0bbd8     02 C2 05 F1 | 	add	arg01, #2
0bbdc     44 FD BF FD | 	call	#_memory_ReadByte
0bbe0     10 A6 65 F0 | 	shl	result1, #16
0bbe4     D3 DA 41 F5 | 	or	local02, result1
0bbe8                 | '     result |= ReadByte(address + 3) << 24
0bbe8     03 D8 05 F1 | 	add	local01, #3
0bbec     EC C2 01 F6 | 	mov	arg01, local01
0bbf0     30 FD BF FD | 	call	#_memory_ReadByte
0bbf4     18 A6 65 F0 | 	shl	result1, #24
0bbf8     ED A6 41 F5 | 	or	result1, local02
0bbfc     A7 F0 03 F6 | 	mov	ptra, fp
0bc00     B2 00 A0 FD | 	call	#popregs_
0bc04                 | _memory_ReadWord_ret
0bc04     2D 00 64 FD | 	ret
0bc08                 | 
0bc08                 | ' 
0bc08                 | ' PUB WriteByte(address, value)
0bc08                 | _memory_WriteByte
0bc08     03 4A 05 F6 | 	mov	COUNT_, #3
0bc0c     A8 00 A0 FD | 	call	#pushregs_
0bc10     E1 D8 01 F6 | 	mov	local01, arg01
0bc14     E2 DA 01 F6 | 	mov	local02, arg02
0bc18                 | '     if (umath.lt(address, MEMORY_RAM))
0bc18     EC C2 01 F6 | 	mov	arg01, local01
0bc1c     12 C4 C5 F9 | 	decod	arg02, #18
0bc20                 | ' 
0bc20                 | ' '' Return true if x < y unsigned.
0bc20                 | ' 
0bc20                 | '   return cpr(x,y) & ULT <> 0
0bc20     00 DC 05 F6 | 	mov	local03, #0
0bc24     E0 00 B0 FD | 	call	#_umath_cpr
0bc28     01 A6 CD F7 | 	test	result1, #1 wz
0bc2c     00 DC 25 56 |  if_ne	not	local03, #0
0bc30     00 DC 0D F2 | 	cmp	local03, #0 wz
0bc34                 | '         ram[address] := value
0bc34     C8 D8 01 51 |  if_ne	add	local01, objptr
0bc38     EC DA 41 5C |  if_ne	wrbyte	local02, local01
0bc3c     A7 F0 03 F6 | 	mov	ptra, fp
0bc40     B2 00 A0 FD | 	call	#popregs_
0bc44                 | _memory_WriteByte_ret
0bc44     2D 00 64 FD | 	ret
0bc48                 | 
0bc48                 | ' 
0bc48                 | ' PUB WriteHalf(address, value)
0bc48                 | _memory_WriteHalf
0bc48     02 4A 05 F6 | 	mov	COUNT_, #2
0bc4c     A8 00 A0 FD | 	call	#pushregs_
0bc50     E1 D8 01 F6 | 	mov	local01, arg01
0bc54                 | '     WriteByte(address, value & $000000FF)
0bc54     E2 DA 01 F6 | 	mov	local02, arg02
0bc58     E2 C4 E1 F8 | 	getbyte	arg02, arg02, #0
0bc5c     EC C2 01 F6 | 	mov	arg01, local01
0bc60     A4 FF BF FD | 	call	#_memory_WriteByte
0bc64                 | '     WriteByte(address + 1, (value & $0000FF00) >> 8)
0bc64     01 D8 05 F1 | 	add	local01, #1
0bc68     7F 00 00 FF 
0bc6c     00 DB 05 F5 | 	and	local02, ##65280
0bc70     08 DA 45 F0 | 	shr	local02, #8
0bc74     EC C2 01 F6 | 	mov	arg01, local01
0bc78     ED C4 01 F6 | 	mov	arg02, local02
0bc7c     88 FF BF FD | 	call	#_memory_WriteByte
0bc80     A7 F0 03 F6 | 	mov	ptra, fp
0bc84     B2 00 A0 FD | 	call	#popregs_
0bc88                 | _memory_WriteHalf_ret
0bc88     2D 00 64 FD | 	ret
0bc8c                 | 
0bc8c                 | ' 
0bc8c                 | ' PUB WriteWord(address, value)
0bc8c                 | _memory_WriteWord
0bc8c     02 4A 05 F6 | 	mov	COUNT_, #2
0bc90     A8 00 A0 FD | 	call	#pushregs_
0bc94     E1 D8 01 F6 | 	mov	local01, arg01
0bc98                 | '     WriteByte(address, value & $000000FF)
0bc98     E2 DA 01 F6 | 	mov	local02, arg02
0bc9c     E2 C4 E1 F8 | 	getbyte	arg02, arg02, #0
0bca0     EC C2 01 F6 | 	mov	arg01, local01
0bca4     60 FF BF FD | 	call	#_memory_WriteByte
0bca8                 | '     WriteByte(address + 1, (value & $0000FF00) >> 8)
0bca8     EC C2 01 F6 | 	mov	arg01, local01
0bcac     01 C2 05 F1 | 	add	arg01, #1
0bcb0     ED C4 01 F6 | 	mov	arg02, local02
0bcb4     7F 00 00 FF 
0bcb8     00 C5 05 F5 | 	and	arg02, ##65280
0bcbc     08 C4 45 F0 | 	shr	arg02, #8
0bcc0     44 FF BF FD | 	call	#_memory_WriteByte
0bcc4                 | '     WriteByte(address + 2, (value & $00FF0000) >> 16)
0bcc4     EC C2 01 F6 | 	mov	arg01, local01
0bcc8     02 C2 05 F1 | 	add	arg01, #2
0bccc     ED C4 01 F6 | 	mov	arg02, local02
0bcd0     80 7F 00 FF 
0bcd4     00 C4 05 F5 | 	and	arg02, ##16711680
0bcd8     10 C4 45 F0 | 	shr	arg02, #16
0bcdc     28 FF BF FD | 	call	#_memory_WriteByte
0bce0                 | '     WriteByte(address + 3, (value & $FF000000) >> 24)
0bce0     03 D8 05 F1 | 	add	local01, #3
0bce4     00 80 7F FF 
0bce8     00 DA 05 F5 | 	and	local02, ##-16777216
0bcec     18 DA 45 F0 | 	shr	local02, #24
0bcf0     EC C2 01 F6 | 	mov	arg01, local01
0bcf4     ED C4 01 F6 | 	mov	arg02, local02
0bcf8     0C FF BF FD | 	call	#_memory_WriteByte
0bcfc     A7 F0 03 F6 | 	mov	ptra, fp
0bd00     B2 00 A0 FD | 	call	#popregs_
0bd04                 | _memory_WriteWord_ret
0bd04     2D 00 64 FD | 	ret
0bd08                 | 
0bd08                 | ' 
0bd08                 | ' PRI cpr(x, y)
0bd08                 | _umath_cpr
0bd08                 | ' 
0bd08                 | '   if (x == y)
0bd08     E2 C2 09 F2 | 	cmp	arg01, arg02 wz
0bd0c                 | '     return EQ
0bd0c     02 A6 05 A6 |  if_e	mov	result1, #2
0bd10     14 00 90 AD |  if_e	jmp	#_umath_cpr_ret
0bd14                 | '   elseif (x ^ $8000_0000 > y ^ $8000_0000)
0bd14     1F C2 E5 F4 | 	bitnot	arg01, #31
0bd18     1F C4 E5 F4 | 	bitnot	arg02, #31
0bd1c     E2 C2 59 F2 | 	cmps	arg01, arg02 wcz
0bd20                 | '     return UGT
0bd20     04 A6 05 16 |  if_a	mov	result1, #4
0bd24                 | '   else
0bd24                 | '     return ULT
0bd24     01 A6 05 E6 |  if_be	mov	result1, #1
0bd28                 | _umath_cpr_ret
0bd28     2D 00 64 FD | 	ret
0bd2c                 | 
0bd2c                 | ' 
0bd2c                 | ' ' text screen and video driver initialization methods
0bd2c                 | ' ' screen will be filled with default background colour and cursor hidden until enabled
0bd2c                 | ' PUB initVga(cog, basePin, vsyncPin, flags, resolution) : r 
0bd2c                 | _p2textdrv_initVga
0bd2c     02 4A 05 F6 | 	mov	COUNT_, #2
0bd30     A8 00 A0 FD | 	call	#pushregs_
0bd34                 | '     return init(cog, basePin, vsyncPin, video.VGA, flags, video.getTiming(resolution))
0bd34     E1 D8 01 F6 | 	mov	local01, arg01
0bd38     E4 DA 01 F6 | 	mov	local02, arg04
0bd3c     E5 C2 01 F6 | 	mov	arg01, arg05
0bd40     A8 08 B0 FD | 	call	#_p2videodrv_getTiming
0bd44     D3 CC 01 F6 | 	mov	arg06, result1
0bd48     EC C2 01 F6 | 	mov	arg01, local01
0bd4c     00 C8 05 F6 | 	mov	arg04, #0
0bd50     ED CA 01 F6 | 	mov	arg05, local02
0bd54     28 01 B0 FD | 	call	#_p2textdrv_init
0bd58     A7 F0 03 F6 | 	mov	ptra, fp
0bd5c     B2 00 A0 FD | 	call	#popregs_
0bd60                 | _p2textdrv_initVga_ret
0bd60     2D 00 64 FD | 	ret
0bd64                 | 
0bd64                 | ' 
0bd64                 | ' PUB setTextPos(row, col)
0bd64                 | _p2textdrv_setTextPos
0bd64     05 4A 05 F6 | 	mov	COUNT_, #5
0bd68     A8 00 A0 FD | 	call	#pushregs_
0bd6c     E1 D8 01 F6 | 	mov	local01, arg01
0bd70     E2 DA 01 F6 | 	mov	local02, arg02
0bd74                 | '     if (row +< getCurrentRows()) AND (col +< getCurrentColumns())
0bd74     00 DC 05 F6 | 	mov	local03, #0
0bd78     00 DE 05 F6 | 	mov	local04, #0
0bd7c                 | '     rows := video.getCurrentRows(@display, @region)
0bd7c     C8 C2 01 F6 | 	mov	arg01, objptr
0bd80     30 C2 05 F1 | 	add	arg01, #48
0bd84     C8 C4 01 F6 | 	mov	arg02, objptr
0bd88     64 09 B0 FD | 	call	#_p2videodrv_getCurrentRows
0bd8c     D3 D8 11 F2 | 	cmp	local01, result1 wc
0bd90     00 DE 25 C6 |  if_b	not	local04, #0
0bd94     00 DE 0D F2 | 	cmp	local04, #0 wz
0bd98     00 DC 25 56 |  if_ne	not	local03, #0
0bd9c     00 DE 05 F6 | 	mov	local04, #0
0bda0     00 E0 05 F6 | 	mov	local05, #0
0bda4                 | '     cols := video.getCurrentColumns(@display, @region)
0bda4     C8 C2 01 F6 | 	mov	arg01, objptr
0bda8     30 C2 05 F1 | 	add	arg01, #48
0bdac     C8 C4 01 F6 | 	mov	arg02, objptr
0bdb0     9C 09 B0 FD | 	call	#_p2videodrv_getCurrentColumns
0bdb4     D3 DA 11 F2 | 	cmp	local02, result1 wc
0bdb8     00 E0 25 C6 |  if_b	not	local05, #0
0bdbc     00 E0 0D F2 | 	cmp	local05, #0 wz
0bdc0     00 DE 25 56 |  if_ne	not	local04, #0
0bdc4     EF DC C9 F7 | 	test	local03, local04 wz
0bdc8                 | '         video.setTextPos(row, col)
0bdc8     EC C2 01 56 |  if_ne	mov	arg01, local01
0bdcc     ED C4 01 56 |  if_ne	mov	arg02, local02
0bdd0     B8 0E B0 5D |  if_ne	call	#_p2videodrv_setTextPos
0bdd4     A7 F0 03 F6 | 	mov	ptra, fp
0bdd8     B2 00 A0 FD | 	call	#popregs_
0bddc                 | _p2textdrv_setTextPos_ret
0bddc     2D 00 64 FD | 	ret
0bde0                 | 
0bde0                 | ' 
0bde0                 | ' ' font control methods
0bde0                 | ' 
0bde0                 | ' ' sets address and size of font. Warning: be sure to have enough screen buffer memory!
0bde0                 | ' PUB setFont(fontAddr, size) | lines
0bde0                 | _p2textdrv_setFont
0bde0     02 4A 05 F6 | 	mov	COUNT_, #2
0bde4     A8 00 A0 FD | 	call	#pushregs_
0bde8     E1 C6 01 F6 | 	mov	arg03, arg01
0bdec     E2 D8 01 F6 | 	mov	local01, arg02
0bdf0                 | '     if size +> 0
0bdf0     01 D8 15 F2 | 	cmp	local01, #1 wc
0bdf4     7C 00 90 CD |  if_b	jmp	#LR__1400
0bdf8                 | '         lines := video.getActiveLines(@display)
0bdf8     C8 C2 01 F6 | 	mov	arg01, objptr
0bdfc                 | '     return (long[long[display][1]][3] & $7ff)
0bdfc     34 C2 05 F1 | 	add	arg01, #52
0be00     E1 A6 01 FB | 	rdlong	result1, arg01
0be04     0C A6 05 F1 | 	add	result1, #12
0be08     D3 DA 01 FB | 	rdlong	local02, result1
0be0c     0A DA 45 F7 | 	zerox	local02, #10
0be10                 | '         video.setFont(@region, fontAddr, size)
0be10     C8 C2 01 F6 | 	mov	arg01, objptr
0be14     E3 C4 01 F6 | 	mov	arg02, arg03
0be18     EC C6 01 F6 | 	mov	arg03, local01
0be1c                 | '     long[region][4] := ((fontsize-1) << 24) + (fontBase & $fffff)
0be1c     01 C6 85 F1 | 	sub	arg03, #1
0be20     18 C6 65 F0 | 	shl	arg03, #24
0be24     74 C5 05 F4 | 	bitl	arg02, #372
0be28     E2 C6 01 F1 | 	add	arg03, arg02
0be2c     10 C2 05 F1 | 	add	arg01, #16
0be30     E1 C6 61 FC | 	wrlong	arg03, arg01
0be34                 | '         if video.getFlags(@region) & video.DOUBLE_HIGH
0be34     C8 C2 01 F6 | 	mov	arg01, objptr
0be38                 | '     return byte[region][5]
0be38     05 C2 05 F1 | 	add	arg01, #5
0be3c     E1 A6 C1 FA | 	rdbyte	result1, arg01
0be40     08 A6 CD F7 | 	test	result1, #8 wz
0be44                 | '             size := size * 2
0be44     01 D8 65 50 |  if_ne	shl	local01, #1
0be48                 | '         if lines // size ' truncate to keep complete rows visible
0be48     ED 24 02 F6 | 	mov	muldiva_, local02
0be4c     EC 26 02 F6 | 	mov	muldivb_, local01
0be50     BA 00 A0 FD | 	call	#divide_
0be54     00 24 0E F2 | 	cmp	muldiva_, #0 wz
0be58                 | '             video.setSize(@region, lines - (lines // size))
0be58     C8 C2 01 56 |  if_ne	mov	arg01, objptr
0be5c     12 DB 81 51 |  if_ne	sub	local02, muldiva_
0be60                 | '     word[region][3] := size
0be60     06 C2 05 51 |  if_ne	add	arg01, #6
0be64     E1 DA 51 5C |  if_ne	wrword	local02, arg01
0be68                 | '         else
0be68                 | '             video.setSize(@region, 0) ' text region consumes all scan lines
0be68     C8 C2 01 A6 |  if_e	mov	arg01, objptr
0be6c                 | '     word[region][3] := size
0be6c     06 C2 05 A1 |  if_e	add	arg01, #6
0be70     E1 00 58 AC |  if_e	wrword	#0, arg01
0be74                 | LR__1400
0be74     A7 F0 03 F6 | 	mov	ptra, fp
0be78     B2 00 A0 FD | 	call	#popregs_
0be7c                 | _p2textdrv_setFont_ret
0be7c     2D 00 64 FD | 	ret
0be80                 | 
0be80                 | ' 
0be80                 | ' ' ----------------------------------------------------------------------------
0be80                 | ' 
0be80                 | ' ' internal initialization method, sets up region and display information for video driver
0be80                 | ' 
0be80                 | ' PRI init(cog, basePin, vsyncPin, output, flags, timing) : id | displayFlags
0be80                 | _p2textdrv_init
0be80     08 4A 05 F6 | 	mov	COUNT_, #8
0be84     A8 00 A0 FD | 	call	#pushregs_
0be88     E1 D8 01 F6 | 	mov	local01, arg01
0be8c     E2 DA 01 F6 | 	mov	local02, arg02
0be90     E3 DC 01 F6 | 	mov	local03, arg03
0be94     E4 DE 01 F6 | 	mov	local04, arg04
0be98     E5 E0 01 F6 | 	mov	local05, arg05
0be9c     E6 E2 01 F6 | 	mov	local06, arg06
0bea0                 | '     if output == video.DVI
0bea0     01 DE 0D F2 | 	cmp	local04, #1 wz
0bea4     14 00 90 5D |  if_ne	jmp	#LR__1410
0bea8                 | '         displayFlags := vsyncPin ? video.DVI_REVERSED : 0 ' flag passed in vsyncPin argument
0bea8     00 DC 0D F2 | 	cmp	local03, #0 wz
0beac     01 E4 05 56 |  if_ne	mov	local07, #1
0beb0     00 E4 05 A6 |  if_e	mov	local07, #0
0beb4     F2 E6 01 F6 | 	mov	local08, local07
0beb8     04 00 90 FD | 	jmp	#LR__1411
0bebc                 | LR__1410
0bebc                 | '     else ' assume VGA RGBHV for now, but other sync modes are possible
0bebc                 | '         displayFlags := video.RGBHV
0bebc     00 E6 05 F6 | 	mov	local08, #0
0bec0                 | LR__1411
0bec0                 | ' 
0bec0                 | '     ' load the default palette
0bec0                 | '     longmove(@palette, @vgapalette, 16)
0bec0     C8 C2 01 F6 | 	mov	arg01, objptr
0bec4     BF 00 00 FF 
0bec8     F8 C2 05 F1 | 	add	arg01, ##98040
0becc     CF C4 01 F6 | 	mov	arg02, ptr__p2textdrv_dat__
0bed0     10 C6 05 F6 | 	mov	arg03, #16
0bed4     14 25 B0 FD | 	call	#__system__longmove
0bed8                 | ' 
0bed8                 | ' ' start a VGA display output, pointing it to the first (and only) region for its display list, and auto allocate it a COG
0bed8                 | '     id := video.initDisplay(cog,        { the cogid to use (-1 = auto-allocate)
0bed8     30 90 05 F1 | 	add	objptr, #48
0bedc     C8 E4 01 F6 | 	mov	local07, objptr
0bee0     48 90 05 F1 | 	add	objptr, #72
0bee4     C8 D4 01 F6 | 	mov	arg10, objptr
0bee8     78 90 85 F1 | 	sub	objptr, #120
0beec     C8 C2 01 F6 | 	mov	arg01, objptr
0bef0     F0 C8 01 F6 | 	mov	arg04, local05
0bef4     BF 00 00 FF 
0bef8     F8 90 05 F1 | 	add	objptr, ##98040
0befc     C8 CA 01 F6 | 	mov	arg05, objptr
0bf00     CF CC 01 F6 | 	mov	arg06, ptr__p2textdrv_dat__
0bf04     40 CC 05 F1 | 	add	arg06, #64
0bf08     BB 00 00 FF 
0bf0c     00 91 85 F1 | 	sub	objptr, ##96000
0bf10     C8 D0 01 F6 | 	mov	arg08, objptr
0bf14     03 00 00 FF 
0bf18     F8 91 85 F1 | 	sub	objptr, ##2040
0bf1c     01 C4 65 F6 | 	neg	arg02, #1
0bf20     00 C6 05 F6 | 	mov	arg03, #0
0bf24     10 CE 05 F6 | 	mov	arg07, #16
0bf28     00 D2 05 F6 | 	mov	arg09, #0
0bf2c     20 06 B0 FD | 	call	#_p2videodrv_initRegion
0bf30     D3 D6 01 F6 | 	mov	arg11, result1
0bf34     EC C2 01 F6 | 	mov	arg01, local01
0bf38     F2 C4 01 F6 | 	mov	arg02, local07
0bf3c     EF C6 01 F6 | 	mov	arg03, local04
0bf40     ED C8 01 F6 | 	mov	arg04, local02
0bf44     EE CA 01 F6 | 	mov	arg05, local03
0bf48     F3 CC 01 F6 | 	mov	arg06, local08
0bf4c     EA CE 01 F6 | 	mov	arg07, arg10
0bf50     01 00 00 FF 
0bf54     C0 D1 05 F6 | 	mov	arg08, ##960
0bf58     F1 D2 01 F6 | 	mov	arg09, local06
0bf5c     00 D4 05 F6 | 	mov	arg10, #0
0bf60     60 00 B0 FD | 	call	#_p2videodrv_initDisplay
0bf64     D3 E6 01 F6 | 	mov	local08, result1
0bf68                 | ' 
0bf68                 | ' ' force a recomputation of displayed scan lines in the region based on font size and region flags
0bf68                 | '   setFont(@font, FONTHEIGHT)
0bf68     CF C2 01 F6 | 	mov	arg01, ptr__p2textdrv_dat__
0bf6c     40 C2 05 F1 | 	add	arg01, #64
0bf70     10 C4 05 F6 | 	mov	arg02, #16
0bf74     68 FE BF FD | 	call	#_p2textdrv_setFont
0bf78                 | ' 
0bf78                 | ' ' setup a text output context for the text region and then use it by default when printing
0bf78                 | '   video.initTextOutput(@context, @display, @region, FOREGROUND, BACKGROUND, 1, 1)   'also erase region
0bf78     68 90 05 F1 | 	add	objptr, #104
0bf7c     C8 C2 01 F6 | 	mov	arg01, objptr
0bf80     38 90 85 F1 | 	sub	objptr, #56
0bf84     C8 C4 01 F6 | 	mov	arg02, objptr
0bf88     30 90 85 F1 | 	sub	objptr, #48
0bf8c     C8 C6 01 F6 | 	mov	arg03, objptr
0bf90     02 C8 05 F6 | 	mov	arg04, #2
0bf94     00 CA 05 F6 | 	mov	arg05, #0
0bf98     01 CC 05 F6 | 	mov	arg06, #1
0bf9c     01 CE 05 F6 | 	mov	arg07, #1
0bfa0     BF 00 00 FF 
0bfa4     54 91 05 F1 | 	add	objptr, ##98132
0bfa8     38 0B B0 FD | 	call	#_p2videodrv_initTextOutput
0bfac     BF 00 00 FF 
0bfb0     54 91 85 F1 | 	sub	objptr, ##98132
0bfb4     F3 A6 01 F6 | 	mov	result1, local08
0bfb8     A7 F0 03 F6 | 	mov	ptra, fp
0bfbc     B2 00 A0 FD | 	call	#popregs_
0bfc0                 | _p2textdrv_init_ret
0bfc0     2D 00 64 FD | 	ret
0bfc4                 | 
0bfc4                 | ' 
0bfc4                 | ' '----------------------------------------------------------------------------------
0bfc4                 | ' ' initialization methods
0bfc4                 | ' '----------------------------------------------------------------------------------
0bfc4                 | ' 
0bfc4                 | ' 'initDisplay spawns driver COG returns cogid, display starts up blank until a region is attached
0bfc4                 | ' 'cog - id of COG to use for driver (-1 to auto-allocate)
0bfc4                 | ' 'display - indicates address of where display data is to be stored
0bfc4                 | ' 'output - indicates type of output - VGA, DVI, COMPONENT_HDTV etc
0bfc4                 | ' 'basePin - pin number of starting pin or group of pins
0bfc4                 | ' 'syncPin - used for vertical sync output in VGA RGBHV mode
0bfc4                 | ' 'flags - indicates if interlaced/progessive, PAL/NTSC, forced mono text etc
0bfc4                 | ' 'lineBuf - hub address of two scanline working buffer
0bfc4                 | ' 'maxLineSize - size of each scanline in the line buffer
0bfc4                 | ' 'userTiming - when non-zero points to timing structure to be used to setup display
0bfc4                 | ' 'mbox - pointer to start of external memort driver mailboxes
0bfc4                 | ' 'firstRegion - points to first region in display list (or 0 if no regions yet)
0bfc4                 | ' 
0bfc4                 | ' PUB initDisplay(cog, display, output, basePin, syncPin, flags, lineBuf, maxLineSize, userTiming, mbox, firstRegion) : id | syncFlags, pin, timing, newfreq, newmode
0bfc4                 | _p2videodrv_initDisplay
0bfc4     09 4A 05 F6 | 	mov	COUNT_, #9
0bfc8     A8 00 A0 FD | 	call	#pushregs_
0bfcc     E1 D8 01 F6 | 	mov	local01, arg01
0bfd0     E2 DA 01 F6 | 	mov	local02, arg02
0bfd4     00 DC 05 F6 | 	mov	local03, #0
0bfd8                 | '     pin := basePin/4 & $f ' get 4 pin group start
0bfd8     E4 DE 51 F6 | 	abs	local04, arg04 wc
0bfdc     02 DE 45 F0 | 	shr	local04, #2
0bfe0     EF DE 81 F6 | 	negc	local04, local04
0bfe4     EF E0 01 F6 | 	mov	local05, local04
0bfe8                 | '     if output == VGA
0bfe8     00 C6 0D F2 | 	cmp	arg03, #0 wz
0bfec     58 00 90 5D |  if_ne	jmp	#LR__1420
0bff0                 | '         syncFlags := %0_0_000000
0bff0     00 E2 05 F6 | 	mov	local06, #0
0bff4                 | '         if flags & 3 == RGBHV ' 5 pin VGA
0bff4     03 CC CD F7 | 	test	arg06, #3 wz
0bff8                 | '             syncFlags |= syncPin & $3f
0bff8     E5 E2 01 A6 |  if_e	mov	local06, arg05
0bffc     3F E2 05 A5 |  if_e	and	local06, #63
0c000                 | '         if flags & 3 == RGBS ' 4 pin VGA
0c000     E6 DE 01 F6 | 	mov	local04, arg06
0c004     03 DE 05 F5 | 	and	local04, #3
0c008     01 DE 0D F2 | 	cmp	local04, #1 wz
0c00c                 | '             syncFlags |= pin*4
0c00c     F0 E4 01 A6 |  if_e	mov	local07, local05
0c010     02 E4 65 A0 |  if_e	shl	local07, #2
0c014     F2 E2 41 A5 |  if_e	or	local06, local07
0c018                 | '         if flags & 3 == RGB_SOG ' 3 pin VGA
0c018     E6 DE 01 F6 | 	mov	local04, arg06
0c01c     03 DE 05 F5 | 	and	local04, #3
0c020     02 DE 0D F2 | 	cmp	local04, #2 wz
0c024                 | '             syncFlags |= pin*4 + 2 ' sync on green
0c024     F0 E6 01 A6 |  if_e	mov	local08, local05
0c028     02 E6 65 A0 |  if_e	shl	local08, #2
0c02c     F3 E4 01 A6 |  if_e	mov	local07, local08
0c030     02 E4 05 A1 |  if_e	add	local07, #2
0c034     F2 E2 41 A5 |  if_e	or	local06, local07
0c038                 | '         timing := @vga_timing ' default to 640x480
0c038     D0 E8 01 F6 | 	mov	local09, ptr__p2videodrv_dat__
0c03c     07 00 00 FF 
0c040     90 E9 05 F1 | 	add	local09, ##3984
0c044     34 01 90 FD | 	jmp	#LR__1432
0c048                 | LR__1420
0c048                 | '     elseif output == DVI
0c048     01 C6 0D F2 | 	cmp	arg03, #1 wz
0c04c     28 00 90 5D |  if_ne	jmp	#LR__1421
0c050                 | '         syncFlags := %1_0000000
0c050     80 E2 05 F6 | 	mov	local06, #128
0c054                 | '         pin := basePin/8
0c054     E4 DE 51 F6 | 	abs	local04, arg04 wc
0c058     03 DE 45 F0 | 	shr	local04, #3
0c05c     EF E0 81 F6 | 	negc	local05, local04
0c060                 | '         if flags & DVI_REVERSED
0c060     01 CC CD F7 | 	test	arg06, #1 wz
0c064                 | '             pin |= 8
0c064     08 E0 45 55 |  if_ne	or	local05, #8
0c068                 | '         timing := @dvi_timing ' default to 640x480
0c068     D0 E8 01 F6 | 	mov	local09, ptr__p2videodrv_dat__
0c06c     07 00 00 FF 
0c070     AC E9 05 F1 | 	add	local09, ##4012
0c074     04 01 90 FD | 	jmp	#LR__1431
0c078                 | LR__1421
0c078                 | '     else
0c078                 | '         syncFlags := %0_1_000000
0c078     40 E2 05 F6 | 	mov	local06, #64
0c07c                 | '         if output == COMPONENT_HDTV
0c07c     06 C6 0D F2 | 	cmp	arg03, #6 wz
0c080     40 00 90 5D |  if_ne	jmp	#LR__1422
0c084                 | '             syncFlags |= %0_0_100010
0c084     62 E2 05 F6 | 	mov	local06, #98
0c088                 | '             if flags & INTERLACED <> 0
0c088     01 CC CD F7 | 	test	arg06, #1 wz
0c08c                 | '                 syncFlags |= %0_0_010000
0c08c     72 E2 05 56 |  if_ne	mov	local06, #114
0c090                 | '                 timing := @hdint_timing ' 1080i60 default, TODO add 50Hz variant
0c090     D0 E8 01 56 |  if_ne	mov	local09, ptr__p2videodrv_dat__
0c094     08 00 00 5F 
0c098     34 E9 05 51 |  if_ne	add	local09, ##4404
0c09c     DC 00 90 5D |  if_ne	jmp	#LR__1430
0c0a0                 | '             else
0c0a0                 | '                 if flags & PAL
0c0a0     02 CC CD F7 | 	test	arg06, #2 wz
0c0a4                 | '                     timing := @hd50_timing '720p50
0c0a4     D0 E8 01 56 |  if_ne	mov	local09, ptr__p2videodrv_dat__
0c0a8     08 00 00 5F 
0c0ac     E0 E8 05 51 |  if_ne	add	local09, ##4320
0c0b0     C8 00 90 5D |  if_ne	jmp	#LR__1430
0c0b4                 | '                 else
0c0b4                 | '                     timing := @hd60_timing '720p60
0c0b4     D0 E8 01 F6 | 	mov	local09, ptr__p2videodrv_dat__
0c0b8     08 00 00 FF 
0c0bc     C4 E8 05 F1 | 	add	local09, ##4292
0c0c0     B8 00 90 FD | 	jmp	#LR__1430
0c0c4                 | LR__1422
0c0c4                 | '         else
0c0c4                 | '             if output == COMPONENT_SDTV
0c0c4     05 C6 0D F2 | 	cmp	arg03, #5 wz
0c0c8                 | '                 syncFlags |= %0_0_000111
0c0c8     07 E2 45 A5 |  if_e	or	local06, #7
0c0cc     28 00 90 AD |  if_e	jmp	#LR__1425
0c0d0                 | '             elseif output == CVBS
0c0d0     02 C6 0D F2 | 	cmp	arg03, #2 wz
0c0d4                 | '                 syncFlags |= basePin & 3
0c0d4     E4 E4 01 A6 |  if_e	mov	local07, arg04
0c0d8     03 E4 05 A5 |  if_e	and	local07, #3
0c0dc     F2 E2 41 A5 |  if_e	or	local06, local07
0c0e0     14 00 90 AD |  if_e	jmp	#LR__1424
0c0e4                 | '             elseif output == SVIDEO
0c0e4     03 C6 0D F2 | 	cmp	arg03, #3 wz
0c0e8                 | '                 syncFlags |= %0_0_000100
0c0e8     04 E2 45 A5 |  if_e	or	local06, #4
0c0ec     08 00 90 AD |  if_e	jmp	#LR__1423
0c0f0                 | '             elseif output == SVIDEO_CVBS
0c0f0     04 C6 0D F2 | 	cmp	arg03, #4 wz
0c0f4                 | '                 syncFlags |= %0_0_000101
0c0f4     05 E2 45 A5 |  if_e	or	local06, #5
0c0f8                 | LR__1423
0c0f8                 | LR__1424
0c0f8                 | LR__1425
0c0f8                 | ' 
0c0f8                 | '             if flags & INTERLACED <> 0
0c0f8     01 CC CD F7 | 	test	arg06, #1 wz
0c0fc     2C 00 90 AD |  if_e	jmp	#LR__1426
0c100                 | '                 syncFlags |= %0_0_010000
0c100     10 E2 45 F5 | 	or	local06, #16
0c104                 | '                 if flags & PAL <> 0
0c104     02 CC CD F7 | 	test	arg06, #2 wz
0c108                 | '                     syncFlags |= %0_0_001000
0c108     08 E2 45 55 |  if_ne	or	local06, #8
0c10c                 | '                     timing := @int576_timing
0c10c     D0 E8 01 56 |  if_ne	mov	local09, ptr__p2videodrv_dat__
0c110     07 00 00 5F 
0c114     3C E9 05 51 |  if_ne	add	local09, ##3900
0c118     60 00 90 5D |  if_ne	jmp	#LR__1429
0c11c                 | '                 else
0c11c                 | '                     timing := @int480_timing
0c11c     D0 E8 01 F6 | 	mov	local09, ptr__p2videodrv_dat__
0c120     07 00 00 FF 
0c124     20 E9 05 F1 | 	add	local09, ##3872
0c128     50 00 90 FD | 	jmp	#LR__1429
0c12c                 | LR__1426
0c12c                 | '             else ' progressive
0c12c                 | '                 if output == COMPONENT_SDTV
0c12c     05 C6 0D F2 | 	cmp	arg03, #5 wz
0c130     28 00 90 5D |  if_ne	jmp	#LR__1427
0c134                 | '                     if flags & PAL <> 0
0c134     02 CC CD F7 | 	test	arg06, #2 wz
0c138                 | '                         syncFlags |= %0_0_001000
0c138     08 E2 45 55 |  if_ne	or	local06, #8
0c13c                 | '                         timing := @prog576_timing
0c13c     D0 E8 01 56 |  if_ne	mov	local09, ptr__p2videodrv_dat__
0c140     07 00 00 5F 
0c144     74 E9 05 51 |  if_ne	add	local09, ##3956
0c148     30 00 90 5D |  if_ne	jmp	#LR__1428
0c14c                 | '                     else
0c14c                 | '                         timing := @prog480_timing
0c14c     D0 E8 01 F6 | 	mov	local09, ptr__p2videodrv_dat__
0c150     07 00 00 FF 
0c154     58 E9 05 F1 | 	add	local09, ##3928
0c158     20 00 90 FD | 	jmp	#LR__1428
0c15c                 | LR__1427
0c15c                 | '                 else ' CVBS/S-video
0c15c                 | '                     if flags & PAL <> 0
0c15c     02 CC CD F7 | 	test	arg06, #2 wz
0c160                 | '                         syncFlags |= %0_0_001000
0c160     08 E2 45 55 |  if_ne	or	local06, #8
0c164                 | '                         timing := @prog288_timing
0c164     D0 E8 01 56 |  if_ne	mov	local09, ptr__p2videodrv_dat__
0c168     07 00 00 5F 
0c16c     04 E9 05 51 |  if_ne	add	local09, ##3844
0c170                 | '                     else
0c170                 | '                         timing := @prog240_timing
0c170     D0 E8 01 A6 |  if_e	mov	local09, ptr__p2videodrv_dat__
0c174     07 00 00 AF 
0c178     E8 E8 05 A1 |  if_e	add	local09, ##3816
0c17c                 | LR__1428
0c17c                 | LR__1429
0c17c                 | LR__1430
0c17c                 | LR__1431
0c17c                 | LR__1432
0c17c                 | ' 
0c17c                 | '     ' override with custom timing if specified
0c17c                 | '     if userTiming <> 0
0c17c     00 D2 0D F2 | 	cmp	arg09, #0 wz
0c180                 | '         timing := userTiming
0c180     E9 E8 01 56 |  if_ne	mov	local09, arg09
0c184                 | ' 
0c184                 | '     ' Optional PLL adjustment logic:
0c184                 | '     ' This code attempts to be flexible in that you can choose to have this driver setup the P2 PLL
0c184                 | '     ' for the pixel frequency setup and optional clock mode indicated in the timing structure,
0c184                 | '     ' or leave the clock alone and have it configured elsewhere.
0c184                 | '     '
0c184                 | '     ' Two longs are part of the timing structure: the new optional clock mode, and the new P2 frequency.
0c184                 | '     ' These are used to determine what to do and one of these three cases will be handled:
0c184                 | '     '
0c184                 | '     ' (a) If the new P2 frequency is 0 or equal to the current P2 clock frequency nothing will be changed.
0c184                 | '     '
0c184                 | '     ' (b) If the new P2 frequency is non-zero and the clock mode is non-zero, then that clock mode and
0c184                 | '     ' frequency will be used in a CLKSET operation called by this driver.
0c184                 | '     '
0c184                 | '     ' (c) If the new P2 frequency is non-zero and the clock mode is 0, an attempt is made to auto-configure
0c184                 | '     ' the PLL based on the specified new frequency.  The crystal or input clock frequency are required to
0c184                 | '     ' be specified as well as the tolerance in Hz.  The closest PLL settings are computed based on these
0c184                 | '     ' criteria and will be used in CLKSET.  If the tolerance is not met then no PLL timing will be changed.
0c184                 | '     ' Take that into consideration when setting up the tolerance and don't set values that are unachievable.
0c184                 | ' 
0c184                 | '     newmode := long[timing][0] ' get new clock mode
0c184     F4 E6 01 FB | 	rdlong	local08, local09
0c188                 | '     newfreq := long[timing][1] ' get desired frequency
0c188     04 E8 05 F1 | 	add	local09, #4
0c18c     F4 E4 09 FB | 	rdlong	local07, local09 wz
0c190     04 E8 85 F1 | 	sub	local09, #4
0c194                 | '     if newfreq and (clkfreq <> newfreq)
0c194     14 DE 05 5B |  if_ne	rdlong	local04, #20
0c198     F2 DE 09 52 |  if_ne	cmp	local04, local07 wz
0c19c     24 00 90 AD |  if_e	jmp	#LR__1434
0c1a0                 | '         if newmode == 0
0c1a0     00 E6 0D F2 | 	cmp	local08, #0 wz
0c1a4     0C 00 90 5D |  if_ne	jmp	#LR__1433
0c1a8                 | '             newmode := computeClockMode(newfreq)
0c1a8     F2 C2 01 F6 | 	mov	arg01, local07
0c1ac     F0 01 B0 FD | 	call	#_p2videodrv_computeClockMode
0c1b0     D3 E6 01 F6 | 	mov	local08, result1
0c1b4                 | LR__1433
0c1b4                 | '         if newmode
0c1b4     00 E6 0D F2 | 	cmp	local08, #0 wz
0c1b8                 | '             CLKSET(newmode, newfreq)
0c1b8     F3 C2 01 56 |  if_ne	mov	arg01, local08
0c1bc     F2 C4 01 56 |  if_ne	mov	arg02, local07
0c1c0     30 1F B0 5D |  if_ne	call	#__system___clkset
0c1c4                 | LR__1434
0c1c4                 | ' 
0c1c4                 | '     long[display][1] := (syncFlags << 24) + (pin << 20) + timing
0c1c4     18 E2 65 F0 | 	shl	local06, #24
0c1c8     14 E0 65 F0 | 	shl	local05, #20
0c1cc     F0 E2 01 F1 | 	add	local06, local05
0c1d0     F4 E2 01 F1 | 	add	local06, local09
0c1d4     04 DA 05 F1 | 	add	local02, #4
0c1d8     ED E2 61 FC | 	wrlong	local06, local02
0c1dc                 | '     long[display][2] := 0 'reserved
0c1dc     04 DA 05 F1 | 	add	local02, #4
0c1e0     ED 00 68 FC | 	wrlong	#0, local02
0c1e4     08 DA 85 F1 | 	sub	local02, #8
0c1e8                 | '     if mbox
0c1e8     00 D4 0D F2 | 	cmp	arg10, #0 wz
0c1ec     18 00 90 AD |  if_e	jmp	#LR__1435
0c1f0                 | '         long[display][3] := (mbox & $fffff) | $0C00_0000  'external memory is supported
0c1f0     74 D5 05 F4 | 	bitl	arg10, #372
0c1f4     3A D4 25 F4 | 	bith	arg10, #58
0c1f8     0C DA 05 F1 | 	add	local02, #12
0c1fc     ED D4 61 FC | 	wrlong	arg10, local02
0c200     0C DA 85 F1 | 	sub	local02, #12
0c204     0C 00 90 FD | 	jmp	#LR__1436
0c208                 | LR__1435
0c208                 | '     else
0c208                 | '         long[display][3] := 0 ' no external memory
0c208     0C DA 05 F1 | 	add	local02, #12
0c20c     ED 00 68 FC | 	wrlong	#0, local02
0c210     0C DA 85 F1 | 	sub	local02, #12
0c214                 | LR__1436
0c214                 | '     long[display][4] := lineBuf
0c214     10 DA 05 F1 | 	add	local02, #16
0c218     ED CE 61 FC | 	wrlong	arg07, local02
0c21c                 | '     long[display][5] := lineBuf + maxLineSize
0c21c     E8 CE 01 F1 | 	add	arg07, arg08
0c220     04 DA 05 F1 | 	add	local02, #4
0c224     ED CE 61 FC | 	wrlong	arg07, local02
0c228                 | '     long[display][6] := 0 'reserved
0c228     04 DA 05 F1 | 	add	local02, #4
0c22c     ED 00 68 FC | 	wrlong	#0, local02
0c230                 | '     long[display][7] := -1 ' global mouse offscreen
0c230     04 DA 05 F1 | 	add	local02, #4
0c234     FF FF FF FF 
0c238     ED FE 6B FC | 	wrlong	##-1, local02
0c23c                 | '     long[display][8] := 0 ' no borders
0c23c     04 DA 05 F1 | 	add	local02, #4
0c240     ED 00 68 FC | 	wrlong	#0, local02
0c244                 | '     long[display][9] := 0 ' border colour (black)
0c244     04 DA 05 F1 | 	add	local02, #4
0c248     ED 00 68 FC | 	wrlong	#0, local02
0c24c                 | '     long[display][10] := firstRegion ' first region if non-zero
0c24c     04 DA 05 F1 | 	add	local02, #4
0c250     ED D6 61 FC | 	wrlong	arg11, local02
0c254     28 DA 85 F1 | 	sub	local02, #40
0c258                 | '     if output == VGA
0c258     00 C6 0D F2 | 	cmp	arg03, #0 wz
0c25c     2C 00 90 5D |  if_ne	jmp	#LR__1437
0c260                 | '         long[display][11] := CQ_VGA
0c260     2C DA 05 F1 | 	add	local02, #44
0c264     2D 00 80 FF 
0c268     ED 72 68 FC | 	wrlong	##23097, local02
0c26c                 | '         long[display][12] := CY_VGA
0c26c     04 DA 05 F1 | 	add	local02, #4
0c270     00 00 AD FF 
0c274     ED 72 68 FC | 	wrlong	##1509949497, local02
0c278                 | '         long[display][13] := CI_VGA
0c278     04 DA 05 F1 | 	add	local02, #4
0c27c     00 2D 80 FF 
0c280     ED 72 68 FC | 	wrlong	##5898297, local02
0c284     34 DA 85 F1 | 	sub	local02, #52
0c288     D0 00 90 FD | 	jmp	#LR__1444
0c28c                 | LR__1437
0c28c                 | '     elseif output == COMPONENT_SDTV
0c28c     05 C6 0D F2 | 	cmp	arg03, #5 wz
0c290     2C 00 90 5D |  if_ne	jmp	#LR__1438
0c294                 | '         long[display][11]:= CQ_COMP_SDTV
0c294     2C DA 05 F1 | 	add	local02, #44
0c298     7C ED 96 FF 
0c29c     ED 00 6B FC | 	wrlong	##769325440, local02
0c2a0                 | '         long[display][12]:= CI_COMP_SDTV
0c2a0     04 DA 05 F1 | 	add	local02, #4
0c2a4     16 F1 F8 FF 
0c2a8     ED 00 6B FC | 	wrlong	##-236835456, local02
0c2ac                 | '         long[display][13]:= CY_COMP_SDTV ' Y on green output
0c2ac     04 DA 05 F1 | 	add	local02, #4
0c2b0     85 9A 8D FF 
0c2b4     ED 72 68 FC | 	wrlong	##456460857, local02
0c2b8     34 DA 85 F1 | 	sub	local02, #52
0c2bc     9C 00 90 FD | 	jmp	#LR__1443
0c2c0                 | LR__1438
0c2c0                 | '     elseif output == COMPONENT_HDTV
0c2c0     06 C6 0D F2 | 	cmp	arg03, #6 wz
0c2c4     2C 00 90 5D |  if_ne	jmp	#LR__1439
0c2c8                 | '         long[display][11]:= CQ_COMP_HDTV
0c2c8     2C DA 05 F1 | 	add	local02, #44
0c2cc     0F F5 FC FF 
0c2d0     ED 00 69 FC | 	wrlong	##-102097280, local02
0c2d4                 | '         long[display][12]:= CI_COMP_HDTV
0c2d4     04 DA 05 F1 | 	add	local02, #4
0c2d8     FF 72 8F FF 
0c2dc     ED 00 69 FC | 	wrlong	##518389376, local02
0c2e0                 | '         long[display][13]:= CY_COMP_HDTV ' Y on green output
0c2e0     04 DA 05 F1 | 	add	local02, #4
0c2e4     82 15 86 FF 
0c2e8     ED A0 68 FC | 	wrlong	##204145744, local02
0c2ec     34 DA 85 F1 | 	sub	local02, #52
0c2f0     68 00 90 FD | 	jmp	#LR__1442
0c2f4                 | LR__1439
0c2f4                 | '     else ' assume SDTV
0c2f4                 | '         if flags & PAL <> 0
0c2f4     02 CC CD F7 | 	test	arg06, #2 wz
0c2f8     38 00 90 AD |  if_e	jmp	#LR__1440
0c2fc                 | '             long[display][6]:= CV_PAL_EVEN ^ CV_PAL_ODD
0c2fc     18 DA 05 F1 | 	add	local02, #24
0c300     7F 70 FE FF 
0c304     ED 00 68 FC | 	wrlong	##-52363776, local02
0c308                 | '             long[display][11]:= CV_PAL_EVEN
0c308     14 DA 05 F1 | 	add	local02, #20
0c30c     04 18 E3 FF 
0c310     ED 00 6B FC | 	wrlong	##-969930368, local02
0c314                 | '             long[display][12]:= CY_PAL
0c314     04 DA 05 F1 | 	add	local02, #4
0c318     84 94 8A FF 
0c31c     ED 72 68 FC | 	wrlong	##355010617, local02
0c320                 | '             long[display][13]:= CU_PAL
0c320     04 DA 05 F1 | 	add	local02, #4
0c324     94 72 F9 FF 
0c328     ED 72 6A FC | 	wrlong	##-219862727, local02
0c32c     34 DA 85 F1 | 	sub	local02, #52
0c330     28 00 90 FD | 	jmp	#LR__1441
0c334                 | LR__1440
0c334                 | '         else
0c334                 | '             long[display][11]:= CQ_CVBS_SDTV
0c334     2C DA 05 F1 | 	add	local02, #44
0c338     8E 67 8A FF 
0c33c     ED 00 6B FC | 	wrlong	##349117824, local02
0c340                 | '             long[display][12]:= CY_CVBS_SDTV
0c340     04 DA 05 F1 | 	add	local02, #4
0c344     84 94 8A FF 
0c348     ED 72 68 FC | 	wrlong	##355010617, local02
0c34c                 | '             long[display][13]:= CI_CVBS_SDTV
0c34c     04 DA 05 F1 | 	add	local02, #4
0c350     71 73 9C FF 
0c354     ED 72 68 FC | 	wrlong	##954655289, local02
0c358     34 DA 85 F1 | 	sub	local02, #52
0c35c                 | LR__1441
0c35c                 | LR__1442
0c35c                 | LR__1443
0c35c                 | LR__1444
0c35c                 | '     if flags & FORCE_MONO_TEXT
0c35c     14 CC 2D F4 | 	testbn	arg06, #20 wz
0c360                 | '         display |= FORCE_MONO_TEXT
0c360     14 DA 25 54 |  if_ne	bith	local02, #20
0c364                 | '     else
0c364                 | '         display &= !FORCE_MONO_TEXT
0c364     14 DA 05 A4 |  if_e	bitl	local02, #20
0c368                 | ' 
0c368                 | '     if flags & WAIT_ATN_START
0c368     15 CC 2D F4 | 	testbn	arg06, #21 wz
0c36c                 | '         display |= WAIT_ATN_START
0c36c     15 DA 25 54 |  if_ne	bith	local02, #21
0c370                 | '     else
0c370                 | '         display &= !WAIT_ATN_START
0c370     15 DA 05 A4 |  if_e	bitl	local02, #21
0c374                 | ' 
0c374                 | '     if cog +> MAXCOGS-1
0c374     08 D8 15 F2 | 	cmp	local01, #8 wc
0c378                 | '         cog := 16
0c378     10 D8 05 36 |  if_ae	mov	local01, #16
0c37c                 | ' 
0c37c                 | '     return coginit(cog, @videodriver, display)
0c37c     D0 C4 01 F6 | 	mov	arg02, ptr__p2videodrv_dat__
0c380     20 C4 05 F1 | 	add	arg02, #32
0c384     28 DA 61 FD | 	setq	local02
0c388     E2 D8 F1 FC | 	coginit	local01, arg02 wc
0c38c     01 D8 65 C6 |  if_b	neg	local01, #1
0c390     EC A6 01 F6 | 	mov	result1, local01
0c394     A7 F0 03 F6 | 	mov	ptra, fp
0c398     B2 00 A0 FD | 	call	#popregs_
0c39c                 | _p2videodrv_initDisplay_ret
0c39c     2D 00 64 FD | 	ret
0c3a0                 | 
0c3a0                 | ' 
0c3a0                 | ' 
0c3a0                 | ' PRI computeClockMode(desiredHz) : mode | vco, finput, f, p, div, m, error, bestError
0c3a0                 | _p2videodrv_computeClockMode
0c3a0     00 AA 05 F6 | 	mov	_var01, #0
0c3a4                 | '     bestError := -1
0c3a4     01 AC 65 F6 | 	neg	_var02, #1
0c3a8                 | '     repeat p from 0 to 30 step 2
0c3a8     00 AE 05 F6 | 	mov	_var03, #0
0c3ac     97 C6 48 FB | 	callpa	#(@LR__1459-@LR__1450)>>2,fcache_load_ptr_
0c3b0                 | LR__1450
0c3b0                 | '         ' compute the ideal VCO frequency f at this value of P
0c3b0                 | '         if p <> 0
0c3b0     00 AE 0D F2 | 	cmp	_var03, #0 wz
0c3b4     28 00 90 AD |  if_e	jmp	#LR__1451
0c3b8     D7 26 52 F6 | 	abs	muldivb_, _var03 wc
0c3bc     49 6E 8A FF 
0c3c0     13 01 1B FD | 	qdiv	##350000000, muldivb_
0c3c4                 | '             if desiredHz > MAXVCO_HZ/p ' test it like this to not overflow
0c3c4                 | '                 quit
0c3c4     18 26 62 FD | 	getqx	muldivb_
0c3c8     13 27 82 F6 | 	negc	muldivb_, muldivb_
0c3cc     13 C3 59 F2 | 	cmps	arg01, muldivb_ wcz
0c3d0     68 01 90 1D |  if_a	jmp	#LR__1460
0c3d4     D7 C2 01 FD | 	qmul	arg01, _var03
0c3d8                 | '             f := desiredHz * p
0c3d8     18 B0 61 FD | 	getqx	_var04
0c3dc     10 00 90 FD | 	jmp	#LR__1452
0c3e0                 | LR__1451
0c3e0                 | '         else
0c3e0                 | '             f := desiredHz
0c3e0     E1 B0 01 F6 | 	mov	_var04, arg01
0c3e4                 | '             if f > MAXVCO_HZ
0c3e4     49 6E 0A FF 
0c3e8     81 B1 55 F2 | 	cmps	_var04, ##350000001 wc
0c3ec                 | '                 quit
0c3ec     4C 01 90 3D |  if_ae	jmp	#LR__1460
0c3f0                 | LR__1452
0c3f0                 | '         ' scan through D values, and find best M, retain best case
0c3f0                 | '         repeat div from 1 to 64
0c3f0     01 B2 05 F6 | 	mov	_var05, #1
0c3f4                 | LR__1453
0c3f4     D9 A6 51 F6 | 	abs	result1, _var05 wc
0c3f8     96 98 80 FF 
0c3fc     D3 00 1A FD | 	qdiv	##20000000, result1
0c400                 | '             'compute the PLL input frequency from the crystal through the divider
0c400                 | '             finput := CLKIN_HZ/div
0c400                 | '             if finput < MINPLLIN_HZ ' input getting too low, and only gets lower so quit now
0c400                 | '                 quit
0c400     18 A6 61 FD | 	getqx	result1
0c404     D3 B4 81 F6 | 	negc	_var06, result1
0c408     D0 03 00 FF 
0c40c     20 B5 55 F2 | 	cmps	_var06, ##500000 wc
0c410     18 01 90 CD |  if_b	jmp	#LR__1458
0c414                 | ' 
0c414                 | '             ' determine M value needed for this ideal VCO frequency and input frequency
0c414                 | '             m := f / finput
0c414     D8 24 02 F6 | 	mov	muldiva_, _var04
0c418     DA 26 02 F6 | 	mov	muldivb_, _var06
0c41c     BA 00 A0 FD | 	call	#divide_
0c420     13 B7 01 F6 | 	mov	_var07, muldivb_
0c424                 | ' 
0c424                 | '             ' check for the out of divider range case
0c424                 | '             if m +> 1024
0c424     02 00 00 FF 
0c428     01 B6 15 F2 | 	cmp	_var07, ##1025 wc
0c42c                 | '                 quit
0c42c     FC 00 90 3D |  if_ae	jmp	#LR__1458
0c430     00 B6 0D F2 | 	cmp	_var07, #0 wz
0c434     DB B8 01 A6 |  if_e	mov	_var08, _var07
0c438     01 B8 05 A1 |  if_e	add	_var08, #1
0c43c     DC B6 01 A6 |  if_e	mov	_var07, _var08
0c440     DB B4 01 FD | 	qmul	_var06, _var07
0c444                 | ' 
0c444                 | '             ' zero is special and gets a second chance
0c444                 | '             if m == 0
0c444                 | '                 m++
0c444                 | ' 
0c444                 | '             ' compute the actual VCO frequency at this particular M, D setting
0c444                 | '             vco := finput * m
0c444                 | '             if vco +< MINVCO_HZ
0c444                 | '                 quit
0c444     18 BA 61 FD | 	getqx	_var09
0c448     F0 FA 02 FF 
0c44c     00 BB 15 F2 | 	cmp	_var09, ##100000000 wc
0c450     D8 00 90 CD |  if_b	jmp	#LR__1458
0c454                 | '             if vco +> MAXVCO_HZ
0c454     49 6E 0A FF 
0c458     81 BB 15 F2 | 	cmp	_var09, ##350000001 wc
0c45c                 | '                 next
0c45c     B8 00 90 3D |  if_ae	jmp	#LR__1457
0c460                 | ' 
0c460                 | '             ' compute the error and check next higher M value if possible, it may be closer
0c460                 | '             error := abs(f - vco)
0c460     D8 BC 01 F6 | 	mov	_var10, _var04
0c464     DD BC 81 F1 | 	sub	_var10, _var09
0c468     DE BC 41 F6 | 	abs	_var10, _var10
0c46c     DE BE 01 F6 | 	mov	_var11, _var10
0c470                 | '             if m < 1024 and (vco + finput) +< MAXVCO_HZ
0c470     02 00 00 FF 
0c474     00 B6 55 F2 | 	cmps	_var07, ##1024 wc
0c478     DD BC 01 C6 |  if_b	mov	_var10, _var09
0c47c     DA BC 01 C1 |  if_b	add	_var10, _var06
0c480     49 6E 0A CF 
0c484     80 BD 15 C2 |  if_b	cmp	_var10, ##350000000 wc
0c488     38 00 90 3D |  if_ae	jmp	#LR__1455
0c48c                 | '                 if error > abs(f - (vco + finput))
0c48c     D8 BC 01 F6 | 	mov	_var10, _var04
0c490     DD B8 01 F6 | 	mov	_var08, _var09
0c494     DA B8 01 F1 | 	add	_var08, _var06
0c498     DC BC 81 F1 | 	sub	_var10, _var08
0c49c     DE BC 41 F6 | 	abs	_var10, _var10
0c4a0     DE BE 59 F2 | 	cmps	_var11, _var10 wcz
0c4a4     1C 00 90 ED |  if_be	jmp	#LR__1454
0c4a8                 | '                     error := abs(f - (vco + finput))
0c4a8     D8 BC 01 F6 | 	mov	_var10, _var04
0c4ac     DA BA 01 F1 | 	add	_var09, _var06
0c4b0     DD BC 81 F1 | 	sub	_var10, _var09
0c4b4     DE BE 41 F6 | 	abs	_var11, _var10
0c4b8                 | '                     m++
0c4b8     DB B8 01 F6 | 	mov	_var08, _var07
0c4bc     01 B8 05 F1 | 	add	_var08, #1
0c4c0     DC B6 01 F6 | 	mov	_var07, _var08
0c4c4                 | LR__1454
0c4c4                 | LR__1455
0c4c4                 | ' 
0c4c4                 | '             ' retain best allowed frequency error and divider bits found so far
0c4c4                 | '             if error +< bestError and error +< TOLERANCE_HZ+1
0c4c4     D6 BE 11 F2 | 	cmp	_var11, _var02 wc
0c4c8     D0 03 00 CF 
0c4cc     21 BF 15 C2 |  if_b	cmp	_var11, ##500001 wc
0c4d0     3C 00 90 3D |  if_ae	jmp	#LR__1456
0c4d4                 | '                 bestError := error
0c4d4     DF AC 01 F6 | 	mov	_var02, _var11
0c4d8                 | '                 mode := ((div-1) << 18) + ((m-1) << 8) + (((p/2 - 1) & $f) << 4)
0c4d8     D9 AA 01 F6 | 	mov	_var01, _var05
0c4dc     01 AA 85 F1 | 	sub	_var01, #1
0c4e0     12 AA 65 F0 | 	shl	_var01, #18
0c4e4     DB B8 01 F6 | 	mov	_var08, _var07
0c4e8     01 B8 85 F1 | 	sub	_var08, #1
0c4ec     08 B8 65 F0 | 	shl	_var08, #8
0c4f0     DC AA 01 F1 | 	add	_var01, _var08
0c4f4     D7 C0 51 F6 | 	abs	_var12, _var03 wc
0c4f8     01 C0 45 F0 | 	shr	_var12, #1
0c4fc     E0 C0 81 F6 | 	negc	_var12, _var12
0c500     01 C0 85 F1 | 	sub	_var12, #1
0c504     E0 C0 41 F8 | 	getnib	_var12, _var12, #0
0c508     04 C0 65 F0 | 	shl	_var12, #4
0c50c     E0 AA 01 F1 | 	add	_var01, _var12
0c510                 | LR__1456
0c510                 | ' 
0c510                 | '             ' quit whenever perfect match found
0c510                 | '             if bestError == 0
0c510     00 AC 0D F2 | 	cmp	_var02, #0 wz
0c514                 | '                 quit
0c514     14 00 90 AD |  if_e	jmp	#LR__1458
0c518                 | LR__1457
0c518     D9 B8 01 F6 | 	mov	_var08, _var05
0c51c     01 B8 05 F1 | 	add	_var08, #1
0c520     DC B2 01 F6 | 	mov	_var05, _var08
0c524     41 B2 15 F2 | 	cmp	_var05, #65 wc
0c528     C8 FE 9F CD |  if_b	jmp	#LR__1453
0c52c                 | LR__1458
0c52c                 | ' 
0c52c                 | '         if bestError == 0
0c52c     00 AC 0D F2 | 	cmp	_var02, #0 wz
0c530                 | '             quit
0c530     02 AE 05 51 |  if_ne	add	_var03, #2
0c534     1F AE 55 52 |  if_ne	cmps	_var03, #31 wc
0c538     74 FE 9F 4D |  if_c_and_nz	jmp	#LR__1450
0c53c                 | LR__1459
0c53c                 | LR__1460
0c53c                 | ' 
0c53c                 | '     ' final clock mode format is this #%0000_000E_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS
0c53c                 | '     if mode
0c53c     00 AA 0D F2 | 	cmp	_var01, #0 wz
0c540                 | '         ' also set 15 or 30pF capacitor loading based on input crystal frequency
0c540                 | '         mode |= (1<<24) ' enable PLL
0c540                 | '         if (CLKSRC == CLKSRC_XTAL) ' enable oscillator and caps for crystal
0c540                 | '             mode |= (CLKIN_HZ < 16000000) ? %1111 : %1011
0c540     00 80 00 5F 
0c544     0B AA 45 55 |  if_ne	or	_var01, ##16777227
0c548     D5 A6 01 F6 | 	mov	result1, _var01
0c54c                 | _p2videodrv_computeClockMode_ret
0c54c     2D 00 64 FD | 	ret
0c550                 | 
0c550                 | ' 
0c550                 | ' 
0c550                 | ' 
0c550                 | ' PUB initRegion(region, gfxMode, size, regionFlags, palette, fontBase, fontSize, screenBuf, nextRegion) : r
0c550                 | _p2videodrv_initRegion
0c550                 | ' ' sets up a region
0c550                 | ' ' optionally links it to a next region if that argument is non-zero
0c550                 | ' 
0c550                 | '     long[region][0]  := nextRegion
0c550     E1 D2 61 FC | 	wrlong	arg09, arg01
0c554                 | '     if (gfxMode > -1)
0c554     00 C4 55 F2 | 	cmps	arg02, #0 wc
0c558                 | '         regionFlags := regionFlags | GRAPHICS_MODE
0c558     02 C8 45 35 |  if_ae	or	arg04, #2
0c55c                 | '     long[region][1]  := (size << 16) + ((regionFlags & $ff) << 8) + (gfxMode & $f)
0c55c     10 C6 65 F0 | 	shl	arg03, #16
0c560     E4 C8 E1 F8 | 	getbyte	arg04, arg04, #0
0c564     08 C8 65 F0 | 	shl	arg04, #8
0c568     E4 C6 01 F1 | 	add	arg03, arg04
0c56c     E2 C4 41 F8 | 	getnib	arg02, arg02, #0
0c570     E2 C6 01 F1 | 	add	arg03, arg02
0c574     04 C2 05 F1 | 	add	arg01, #4
0c578     E1 C6 61 FC | 	wrlong	arg03, arg01
0c57c                 | '     long[region][2]  := screenBuf
0c57c     04 C2 05 F1 | 	add	arg01, #4
0c580     E1 D0 61 FC | 	wrlong	arg08, arg01
0c584                 | '     long[region][3]  := screenBuf ' no wrap set yet
0c584     04 C2 05 F1 | 	add	arg01, #4
0c588     E1 D0 61 FC | 	wrlong	arg08, arg01
0c58c                 | '     long[region][4]  := (((fontSize-1) & $ff) << 24) + fontBase
0c58c     01 CE 85 F1 | 	sub	arg07, #1
0c590     E7 CE E1 F8 | 	getbyte	arg07, arg07, #0
0c594     18 CE 65 F0 | 	shl	arg07, #24
0c598     E6 CE 01 F1 | 	add	arg07, arg06
0c59c     04 C2 05 F1 | 	add	arg01, #4
0c5a0     E1 CE 61 FC | 	wrlong	arg07, arg01
0c5a4                 | '     long[region][5]  := palette
0c5a4     04 C2 05 F1 | 	add	arg01, #4
0c5a8     E1 CA 61 FC | 	wrlong	arg05, arg01
0c5ac                 | '     long[region][6]  := 0 ' cursor 1 off until enabled
0c5ac     04 C2 05 F1 | 	add	arg01, #4
0c5b0     E1 00 68 FC | 	wrlong	#0, arg01
0c5b4                 | '     long[region][7]  := 0 ' cursor 2 off until enabled
0c5b4     04 C2 05 F1 | 	add	arg01, #4
0c5b8     E1 00 68 FC | 	wrlong	#0, arg01
0c5bc                 | '     long[region][8]  := -1 ' region mouse offscreen
0c5bc     04 C2 05 F1 | 	add	arg01, #4
0c5c0     FF FF FF FF 
0c5c4     E1 FE 6B FC | 	wrlong	##-1, arg01
0c5c8                 | '     long[region][9]  := 0 ' mouse image
0c5c8     04 C2 05 F1 | 	add	arg01, #4
0c5cc     E1 00 68 FC | 	wrlong	#0, arg01
0c5d0                 | '     long[region][10] := 0 ' no wrap
0c5d0     04 C2 05 F1 | 	add	arg01, #4
0c5d4     E1 00 68 FC | 	wrlong	#0, arg01
0c5d8                 | '     long[region][11] := 0 ' no skew
0c5d8     04 C2 05 F1 | 	add	arg01, #4
0c5dc     E1 00 68 FC | 	wrlong	#0, arg01
0c5e0     2C C2 85 F1 | 	sub	arg01, #44
0c5e4                 | '     return region
0c5e4     E1 A6 01 F6 | 	mov	result1, arg01
0c5e8                 | _p2videodrv_initRegion_ret
0c5e8     2D 00 64 FD | 	ret
0c5ec                 | 
0c5ec                 | ' 
0c5ec                 | ' PUB getTiming(resolution) : r
0c5ec                 | _p2videodrv_getTiming
0c5ec     00 AA 05 F6 | 	mov	_var01, #0
0c5f0                 | ' ' returns pre-defined timings for common video resolutions
0c5f0                 | '     if (resolution == RES_640x350)
0c5f0     00 C2 0D F2 | 	cmp	arg01, #0 wz
0c5f4                 | '         return @ega_timing
0c5f4     D0 A6 01 A6 |  if_e	mov	result1, ptr__p2videodrv_dat__
0c5f8     08 00 00 AF 
0c5fc     00 A6 05 A1 |  if_e	add	result1, ##4096
0c600     A8 00 90 AD |  if_e	jmp	#_p2videodrv_getTiming_ret
0c604                 | '     if (resolution == RES_800x480_DVI)
0c604     02 C2 0D F2 | 	cmp	arg01, #2 wz
0c608                 | '         return @wvga_dvi_timing
0c608     D0 A6 01 A6 |  if_e	mov	result1, ptr__p2videodrv_dat__
0c60c     07 00 00 AF 
0c610     E4 A7 05 A1 |  if_e	add	result1, ##4068
0c614     94 00 90 AD |  if_e	jmp	#_p2videodrv_getTiming_ret
0c618                 | '     if (resolution == RES_800x600)
0c618     03 C2 0D F2 | 	cmp	arg01, #3 wz
0c61c                 | '         return @svga_timing
0c61c     D0 A6 01 A6 |  if_e	mov	result1, ptr__p2videodrv_dat__
0c620     08 00 00 AF 
0c624     1C A6 05 A1 |  if_e	add	result1, ##4124
0c628     80 00 90 AD |  if_e	jmp	#_p2videodrv_getTiming_ret
0c62c                 | '     if (resolution == RES_800x600_DVI)
0c62c     04 C2 0D F2 | 	cmp	arg01, #4 wz
0c630                 | '         return @svga_dvi_timing
0c630     D0 A6 01 A6 |  if_e	mov	result1, ptr__p2videodrv_dat__
0c634     08 00 00 AF 
0c638     38 A6 05 A1 |  if_e	add	result1, ##4152
0c63c     6C 00 90 AD |  if_e	jmp	#_p2videodrv_getTiming_ret
0c640                 | '     if (resolution == RES_1024x768)
0c640     05 C2 0D F2 | 	cmp	arg01, #5 wz
0c644                 | '         return @xga_timing
0c644     D0 A6 01 A6 |  if_e	mov	result1, ptr__p2videodrv_dat__
0c648     08 00 00 AF 
0c64c     54 A6 05 A1 |  if_e	add	result1, ##4180
0c650     58 00 90 AD |  if_e	jmp	#_p2videodrv_getTiming_ret
0c654                 | '     if (resolution == RES_1280x1024)
0c654     06 C2 0D F2 | 	cmp	arg01, #6 wz
0c658                 | '         return @sxga_timing
0c658     D0 A6 01 A6 |  if_e	mov	result1, ptr__p2videodrv_dat__
0c65c     08 00 00 AF 
0c660     70 A6 05 A1 |  if_e	add	result1, ##4208
0c664     44 00 90 AD |  if_e	jmp	#_p2videodrv_getTiming_ret
0c668                 | '     if (resolution == RES_1600x1200)
0c668     07 C2 0D F2 | 	cmp	arg01, #7 wz
0c66c                 | '         return @uxga_timing
0c66c     D0 A6 01 A6 |  if_e	mov	result1, ptr__p2videodrv_dat__
0c670     08 00 00 AF 
0c674     8C A6 05 A1 |  if_e	add	result1, ##4236
0c678     30 00 90 AD |  if_e	jmp	#_p2videodrv_getTiming_ret
0c67c                 | '     if (resolution == RES_1920x1080)
0c67c     08 C2 0D F2 | 	cmp	arg01, #8 wz
0c680                 | '         return @fullhd_timing
0c680     D0 A6 01 A6 |  if_e	mov	result1, ptr__p2videodrv_dat__
0c684     08 00 00 AF 
0c688     FC A6 05 A1 |  if_e	add	result1, ##4348
0c68c     1C 00 90 AD |  if_e	jmp	#_p2videodrv_getTiming_ret
0c690                 | '     if (resolution == RES_1920x1200)
0c690     09 C2 0D F2 | 	cmp	arg01, #9 wz
0c694                 | '         return @wuxga_timing
0c694     D0 A6 01 A6 |  if_e	mov	result1, ptr__p2videodrv_dat__
0c698     08 00 00 AF 
0c69c     A8 A6 05 A1 |  if_e	add	result1, ##4264
0c6a0                 | '     return @vga_timing ' default to VGA resolution
0c6a0     D0 A6 01 56 |  if_ne	mov	result1, ptr__p2videodrv_dat__
0c6a4     07 00 00 5F 
0c6a8     90 A7 05 51 |  if_ne	add	result1, ##3984
0c6ac                 | _p2videodrv_getTiming_ret
0c6ac     2D 00 64 FD | 	ret
0c6b0                 | 
0c6b0                 | ' 
0c6b0                 | ' PUB setCursorPos(region, cursid, rowpos, colpos)
0c6b0                 | _p2videodrv_setCursorPos
0c6b0                 | '     if (cursid == 0)
0c6b0     00 C4 0D F2 | 	cmp	arg02, #0 wz
0c6b4     1C 00 90 5D |  if_ne	jmp	#LR__1470
0c6b8                 | '         word[region][13] := ((rowpos & $ff) << 8) + (colpos & $ff)
0c6b8     E3 C6 E1 F8 | 	getbyte	arg03, arg03, #0
0c6bc     08 C6 65 F0 | 	shl	arg03, #8
0c6c0     E4 C8 E1 F8 | 	getbyte	arg04, arg04, #0
0c6c4     E4 C6 01 F1 | 	add	arg03, arg04
0c6c8     1A C2 05 F1 | 	add	arg01, #26
0c6cc     E1 C6 51 FC | 	wrword	arg03, arg01
0c6d0     18 00 90 FD | 	jmp	#LR__1471
0c6d4                 | LR__1470
0c6d4                 | '     else
0c6d4                 | '         word[region][15] := ((rowpos & $ff) << 8) + (colpos & $ff)
0c6d4     E3 C6 E1 F8 | 	getbyte	arg03, arg03, #0
0c6d8     08 C6 65 F0 | 	shl	arg03, #8
0c6dc     E4 C8 E1 F8 | 	getbyte	arg04, arg04, #0
0c6e0     E4 C6 01 F1 | 	add	arg03, arg04
0c6e4     1E C2 05 F1 | 	add	arg01, #30
0c6e8     E1 C6 51 FC | 	wrword	arg03, arg01
0c6ec                 | LR__1471
0c6ec                 | _p2videodrv_setCursorPos_ret
0c6ec     2D 00 64 FD | 	ret
0c6f0                 | 
0c6f0                 | ' 
0c6f0                 | ' PUB getCurrentRows(display, region) : r | height
0c6f0                 | _p2videodrv_getCurrentRows
0c6f0     02 4A 05 F6 | 	mov	COUNT_, #2
0c6f4     A8 00 A0 FD | 	call	#pushregs_
0c6f8                 | '     height := byte[region][19]+1
0c6f8     13 C4 05 F1 | 	add	arg02, #19
0c6fc     E2 D8 C1 FA | 	rdbyte	local01, arg02
0c700     01 D8 05 F1 | 	add	local01, #1
0c704                 | '     if byte[region][5] & DOUBLE_HIGH
0c704     0E C4 85 F1 | 	sub	arg02, #14
0c708     E2 26 C2 FA | 	rdbyte	muldivb_, arg02
0c70c     08 26 CE F7 | 	test	muldivb_, #8 wz
0c710                 | '         height *= 2
0c710     01 D8 65 50 |  if_ne	shl	local01, #1
0c714                 | '     r := word[region][3]
0c714     01 C4 05 F1 | 	add	arg02, #1
0c718     E2 DA E9 FA | 	rdword	local02, arg02 wz
0c71c     06 C4 85 F1 | 	sub	arg02, #6
0c720                 | '     if r == 0
0c720     08 00 90 5D |  if_ne	jmp	#LR__1480
0c724                 | '         r := findRegionSize(display, region)
0c724     0C 06 B0 FD | 	call	#_p2videodrv_findRegionSize
0c728     D3 DA 01 F6 | 	mov	local02, result1
0c72c                 | LR__1480
0c72c                 | '     return (r + height - 1) / height ' round up
0c72c     EC DA 01 F1 | 	add	local02, local01
0c730     01 DA 85 F1 | 	sub	local02, #1
0c734     ED 24 02 F6 | 	mov	muldiva_, local02
0c738     EC 26 02 F6 | 	mov	muldivb_, local01
0c73c     BA 00 A0 FD | 	call	#divide_
0c740     13 A7 01 F6 | 	mov	result1, muldivb_
0c744     A7 F0 03 F6 | 	mov	ptra, fp
0c748     B2 00 A0 FD | 	call	#popregs_
0c74c                 | _p2videodrv_getCurrentRows_ret
0c74c     2D 00 64 FD | 	ret
0c750                 | 
0c750                 | ' 
0c750                 | ' PUB getCurrentColumns(display, region) : r | size, width
0c750                 | _p2videodrv_getCurrentColumns
0c750     01 4A 05 F6 | 	mov	COUNT_, #1
0c754     A8 00 A0 FD | 	call	#pushregs_
0c758                 | '     width := 8
0c758     08 D8 05 F6 | 	mov	local01, #8
0c75c                 | '     if byte[region][5] & DOUBLE_WIDE
0c75c     05 C4 05 F1 | 	add	arg02, #5
0c760     E2 26 C2 FA | 	rdbyte	muldivb_, arg02
0c764     04 26 CE F7 | 	test	muldivb_, #4 wz
0c768                 | '         width *= 2
0c768     10 D8 05 56 |  if_ne	mov	local01, #16
0c76c                 | '     return (getActivePixels(display) + width - 1) / width ' round up
0c76c                 | '     return ((long[long[display][1]][2] & $ff) << 3)
0c76c     04 C2 05 F1 | 	add	arg01, #4
0c770     E1 A6 01 FB | 	rdlong	result1, arg01
0c774     08 A6 05 F1 | 	add	result1, #8
0c778     D3 A6 01 FB | 	rdlong	result1, result1
0c77c     D3 24 E2 F8 | 	getbyte	muldiva_, result1, #0
0c780     03 24 66 F0 | 	shl	muldiva_, #3
0c784     EC 24 02 F1 | 	add	muldiva_, local01
0c788     01 24 86 F1 | 	sub	muldiva_, #1
0c78c     EC 26 02 F6 | 	mov	muldivb_, local01
0c790     BA 00 A0 FD | 	call	#divide_
0c794     13 A7 01 F6 | 	mov	result1, muldivb_
0c798     A7 F0 03 F6 | 	mov	ptra, fp
0c79c     B2 00 A0 FD | 	call	#popregs_
0c7a0                 | _p2videodrv_getCurrentColumns_ret
0c7a0     2D 00 64 FD | 	ret
0c7a4                 | 
0c7a4                 | ' 
0c7a4                 | ' '----------------------------------------------------------------------------------
0c7a4                 | ' '  text printing related methods
0c7a4                 | ' '----------------------------------------------------------------------------------
0c7a4                 | ' 
0c7a4                 | ' PUB out(char) | src, size, fontsize, rowpos, colpos, rows, columns, ctx, currpos, region, colours, cursid
0c7a4                 | _p2videodrv_out
0c7a4     10 4A 05 F6 | 	mov	COUNT_, #16
0c7a8     A8 00 A0 FD | 	call	#pushregs_
0c7ac     E1 D8 01 F6 | 	mov	local01, arg01
0c7b0                 | '     ' get printing context for this COG and check if it's been setup already
0c7b0                 | '     if (ctx := context[cogid()]) == 0
0c7b0     00 A6 05 F6 | 	mov	result1, #0
0c7b4     01 A6 61 FD | 	cogid	result1
0c7b8     D3 26 02 F6 | 	mov	muldivb_, result1
0c7bc     02 26 66 F0 | 	shl	muldivb_, #2
0c7c0     D0 26 02 F1 | 	add	muldivb_, ptr__p2videodrv_dat__
0c7c4     13 DB 09 FB | 	rdlong	local02, muldivb_ wz
0c7c8     ED DC 01 F6 | 	mov	local03, local02
0c7cc                 | '         return
0c7cc     C0 02 90 AD |  if_e	jmp	#LR__1502
0c7d0                 | ' 
0c7d0                 | '     ' text output is supported only in text regions in hub (for now)
0c7d0                 | '     region := long[ctx][1]
0c7d0     04 DC 05 F1 | 	add	local03, #4
0c7d4     EE DE 01 FB | 	rdlong	local04, local03
0c7d8     04 DC 85 F1 | 	sub	local03, #4
0c7dc                 | '     src := long[region][2]
0c7dc     08 DE 05 F1 | 	add	local04, #8
0c7e0     EF E0 01 FB | 	rdlong	local05, local04
0c7e4                 | '     if (byte[region][5] & GRAPHICS_MODE <> 0) OR (src & $f0000000)
0c7e4     03 DE 85 F1 | 	sub	local04, #3
0c7e8     EF 26 C2 FA | 	rdbyte	muldivb_, local04
0c7ec     05 DE 85 F1 | 	sub	local04, #5
0c7f0     02 26 CE F7 | 	test	muldivb_, #2 wz
0c7f4     00 00 78 AF 
0c7f8     00 E0 CD A7 |  if_e	test	local05, ##-268435456 wz
0c7fc                 | '         return
0c7fc     90 02 90 5D |  if_ne	jmp	#LR__1502
0c800                 | ' 
0c800                 | '     ' get current text position and colours
0c800                 | '     currpos := word[ctx][4]  'current row, col position (read together atomically)
0c800     08 DC 05 F1 | 	add	local03, #8
0c804     EE E2 E1 FA | 	rdword	local06, local03
0c808                 | '     rowpos := currpos >> 8   'extract row
0c808     F1 E4 01 F6 | 	mov	local07, local06
0c80c     08 E4 45 F0 | 	shr	local07, #8
0c810                 | '     colpos := currpos & $ff  'and column
0c810     F1 E6 E1 F8 | 	getbyte	local08, local06, #0
0c814                 | '     colours := byte[ctx][10] 'extract text fg & bg colours
0c814     02 DC 05 F1 | 	add	local03, #2
0c818     EE E8 C1 FA | 	rdbyte	local09, local03
0c81c                 | '     cursid := byte[ctx][11]  'get optional HW cursor id to manage (0=none, or HW cursor 1, 2)
0c81c     01 DC 05 F1 | 	add	local03, #1
0c820     EE EA C1 FA | 	rdbyte	local10, local03
0c824     0B DC 85 F1 | 	sub	local03, #11
0c828                 | ' 
0c828                 | '     ' compute total rows and columns from region settings & active pixel width
0c828                 | '     fontsize := byte[region][19]+1
0c828     13 DE 05 F1 | 	add	local04, #19
0c82c     EF EC C1 FA | 	rdbyte	local11, local04
0c830     01 EC 05 F1 | 	add	local11, #1
0c834                 | '     if byte[region][5] & DOUBLE_HIGH
0c834     0E DE 85 F1 | 	sub	local04, #14
0c838     EF EE C1 FA | 	rdbyte	local12, local04
0c83c     08 EE CD F7 | 	test	local12, #8 wz
0c840                 | '         fontsize *= 2
0c840     01 EC 65 50 |  if_ne	shl	local11, #1
0c844                 | '     ' start with number of scan lines in region
0c844                 | '     rows := word[region][3]
0c844     01 DE 05 F1 | 	add	local04, #1
0c848     EF F0 E9 FA | 	rdword	local13, local04 wz
0c84c     06 DE 85 F1 | 	sub	local04, #6
0c850                 | '     if rows == 0 ' region has been auto-sized to end of screen
0c850     10 00 90 5D |  if_ne	jmp	#LR__1490
0c854                 | '         rows := findRegionSize(long[ctx][0], region)
0c854     EE C2 01 FB | 	rdlong	arg01, local03
0c858     EF C4 01 F6 | 	mov	arg02, local04
0c85c     D4 04 B0 FD | 	call	#_p2videodrv_findRegionSize
0c860     D3 F0 01 F6 | 	mov	local13, result1
0c864                 | LR__1490
0c864                 | ' 
0c864                 | '     ' do no damage if region size was not found or height was somehow corrupted in memory
0c864                 | '     if rows == 0 or fontsize == 0
0c864     00 F0 0D F2 | 	cmp	local13, #0 wz
0c868     00 EC 0D 52 |  if_ne	cmp	local11, #0 wz
0c86c                 | '         return
0c86c     20 02 90 AD |  if_e	jmp	#LR__1502
0c870                 | ' 
0c870                 | '     ' divide scanlines by font size and round up to compute character rows
0c870                 | '     rows := (rows + fontsize - 1) / fontsize
0c870     F6 F0 01 F1 | 	add	local13, local11
0c874     01 F0 85 F1 | 	sub	local13, #1
0c878     F8 24 02 F6 | 	mov	muldiva_, local13
0c87c     F6 26 02 F6 | 	mov	muldivb_, local11
0c880     BA 00 A0 FD | 	call	#divide_
0c884     13 F1 01 F6 | 	mov	local13, muldivb_
0c888                 | ' 
0c888                 | '     ' compute columns
0c888                 | '     columns := (byte[region][5] & DOUBLE_WIDE) ? 16 : 8
0c888     05 DE 05 F1 | 	add	local04, #5
0c88c     EF 26 C2 FA | 	rdbyte	muldivb_, local04
0c890     05 DE 85 F1 | 	sub	local04, #5
0c894     04 26 CE F7 | 	test	muldivb_, #4 wz
0c898     10 EE 05 56 |  if_ne	mov	local12, #16
0c89c     08 EE 05 A6 |  if_e	mov	local12, #8
0c8a0     F7 26 02 F6 | 	mov	muldivb_, local12
0c8a4                 | '     columns := (word[ctx][6] + columns - 1) / columns ' round up
0c8a4     0C DC 05 F1 | 	add	local03, #12
0c8a8     EE F2 E1 FA | 	rdword	local14, local03
0c8ac     0C DC 85 F1 | 	sub	local03, #12
0c8b0     F9 EE 01 F6 | 	mov	local12, local14
0c8b4     13 EF 01 F1 | 	add	local12, muldivb_
0c8b8     01 EE 85 F1 | 	sub	local12, #1
0c8bc     F7 24 02 F6 | 	mov	muldiva_, local12
0c8c0     BA 00 A0 FD | 	call	#divide_
0c8c4     13 F5 01 F6 | 	mov	local15, muldivb_
0c8c8     FA F6 01 F6 | 	mov	local16, local15
0c8cc                 | '     ' ensure we can still write to the screen if the width or height changes dynamically
0c8cc                 | '     if rowpos +>= rows
0c8cc     F8 E4 11 F2 | 	cmp	local07, local13 wc
0c8d0                 | '         rowpos := rows-1
0c8d0     F8 EE 01 36 |  if_ae	mov	local12, local13
0c8d4     01 EE 85 31 |  if_ae	sub	local12, #1
0c8d8     F7 E4 01 36 |  if_ae	mov	local07, local12
0c8dc                 | '     if colpos +>= columns
0c8dc     FB E6 11 F2 | 	cmp	local08, local16 wc
0c8e0                 | '         colpos := columns - 1
0c8e0     FB EE 01 36 |  if_ae	mov	local12, local16
0c8e4     01 EE 85 31 |  if_ae	sub	local12, #1
0c8e8     F7 E6 01 36 |  if_ae	mov	local08, local12
0c8ec                 | ' 
0c8ec                 | '     ' process char
0c8ec                 | '     if char == 8  ' BACKSPACE
0c8ec     08 D8 0D F2 | 	cmp	local01, #8 wz
0c8f0     30 00 90 5D |  if_ne	jmp	#LR__1491
0c8f4                 | '         if colpos
0c8f4     00 E6 0D F2 | 	cmp	local08, #0 wz
0c8f8     54 01 90 AD |  if_e	jmp	#LR__1500
0c8fc     FB E4 01 FD | 	qmul	local07, local16
0c900                 | '             colpos--
0c900     01 E6 85 F1 | 	sub	local08, #1
0c904                 | '             word[src][rowpos * columns + colpos] := (colours << 8) + 32
0c904     08 E8 65 F0 | 	shl	local09, #8
0c908     20 E8 05 F1 | 	add	local09, #32
0c90c     18 F6 61 FD | 	getqx	local16
0c910     F3 F6 01 F1 | 	add	local16, local08
0c914     01 F6 65 F0 | 	shl	local16, #1
0c918     F0 F6 01 F1 | 	add	local16, local05
0c91c     FB E8 51 FC | 	wrword	local09, local16
0c920     2C 01 90 FD | 	jmp	#LR__1500
0c924                 | LR__1491
0c924                 | '     elseif char == 9 ' TAB
0c924     09 D8 0D F2 | 	cmp	local01, #9 wz
0c928     20 00 90 5D |  if_ne	jmp	#LR__1492
0c92c                 | '         if colpos < columns - 8
0c92c     08 F6 85 F1 | 	sub	local16, #8
0c930     FB E6 51 F2 | 	cmps	local08, local16 wc
0c934                 | '             colpos += 8 - (colpos & 7)
0c934     F3 F4 01 C6 |  if_b	mov	local15, local08
0c938     07 F4 05 C5 |  if_b	and	local15, #7
0c93c     08 F2 05 C6 |  if_b	mov	local14, #8
0c940     FA F2 81 C1 |  if_b	sub	local14, local15
0c944     F9 E6 01 C1 |  if_b	add	local08, local14
0c948     04 01 90 FD | 	jmp	#LR__1499
0c94c                 | LR__1492
0c94c                 | '     elseif char == 13 ' CR
0c94c     0D D8 0D F2 | 	cmp	local01, #13 wz
0c950                 | '         byte[ctx][15] := colpos ' save this original CR position for LF use later
0c950     0F DC 05 A1 |  if_e	add	local03, #15
0c954     EE E6 41 AC |  if_e	wrbyte	local08, local03
0c958     0F DC 85 A1 |  if_e	sub	local03, #15
0c95c                 | '         colpos := 0
0c95c     00 E6 05 A6 |  if_e	mov	local08, #0
0c960     EC 00 90 AD |  if_e	jmp	#LR__1498
0c964                 | '     elseif char == 12 ' FF
0c964     0C D8 0D F2 | 	cmp	local01, #12 wz
0c968     08 00 90 5D |  if_ne	jmp	#LR__1493
0c96c                 | '         clear()
0c96c     34 02 B0 FD | 	call	#_p2videodrv_clear
0c970                 | '         return
0c970     1C 01 90 FD | 	jmp	#LR__1502
0c974                 | LR__1493
0c974                 | '     else
0c974                 | '         ' update the screen if a printable character
0c974                 | '         if (char > 31)
0c974     20 D8 55 F2 | 	cmps	local01, #32 wc
0c978     2C 00 90 CD |  if_b	jmp	#LR__1494
0c97c     FB E4 01 FD | 	qmul	local07, local16
0c980                 | '             word[src][rowpos * columns + colpos] := (colours << 8) + (char & $ff)
0c980     F4 EE 01 F6 | 	mov	local12, local09
0c984     08 EE 65 F0 | 	shl	local12, #8
0c988     EC F2 E1 F8 | 	getbyte	local14, local01, #0
0c98c     F9 EE 01 F1 | 	add	local12, local14
0c990                 | '             colpos++
0c990     18 F4 61 FD | 	getqx	local15
0c994     F3 F4 01 F1 | 	add	local15, local08
0c998     01 F4 65 F0 | 	shl	local15, #1
0c99c     F0 F4 01 F1 | 	add	local15, local05
0c9a0     FA EE 51 FC | 	wrword	local12, local15
0c9a4     01 E6 05 F1 | 	add	local08, #1
0c9a8                 | LR__1494
0c9a8                 | '         ' handle line wrap if required
0c9a8                 | '         if colpos == columns OR char == 10
0c9a8     FB E6 09 F2 | 	cmp	local08, local16 wz
0c9ac     0A D8 0D 52 |  if_ne	cmp	local01, #10 wz
0c9b0     9C 00 90 5D |  if_ne	jmp	#LR__1497
0c9b4                 | '              ' if a LF before end of line is reached, also clear to end of line
0c9b4                 | '              if (colpos < columns)
0c9b4     FB E6 51 F2 | 	cmps	local08, local16 wc
0c9b8     18 00 90 3D |  if_ae	jmp	#LR__1495
0c9bc                 | '                 if byte[ctx][14] == 13 ' if LF followed a CR, only clear from original CR position
0c9bc     0E DC 05 F1 | 	add	local03, #14
0c9c0     EE F2 C1 FA | 	rdbyte	local14, local03
0c9c4     0E DC 85 F1 | 	sub	local03, #14
0c9c8     0D F2 0D F2 | 	cmp	local14, #13 wz
0c9cc                 | '                     colpos := byte[ctx][15]
0c9cc     0F DC 05 A1 |  if_e	add	local03, #15
0c9d0     0F DC 85 A1 |  if_e	sub	local03, #15
0c9d4                 | LR__1495
0c9d4                 | '                 'wordfill(src + (rowpos * columns + colpos) * 2, (colours << 8) + 32, columns - colpos)
0c9d4                 | '                 ' RY EDIT: commented out above line
0c9d4                 | ' 
0c9d4                 | '             colpos := 0
0c9d4     00 E6 05 F6 | 	mov	local08, #0
0c9d8                 | '             ' scroll the region if needed
0c9d8                 | '             if ++rowpos == rows
0c9d8     01 E4 05 F1 | 	add	local07, #1
0c9dc     F8 E4 09 F2 | 	cmp	local07, local13 wz
0c9e0     6C 00 90 5D |  if_ne	jmp	#LR__1496
0c9e4     2C DE 05 F1 | 	add	local04, #44
0c9e8     EF F4 01 FB | 	rdlong	local15, local04
0c9ec     00 F4 55 F3 | 	fges	local15, #0 wc
0c9f0     FB F2 01 F6 | 	mov	local14, local16
0c9f4     01 F2 65 F0 | 	shl	local14, #1
0c9f8     F9 F4 01 F1 | 	add	local15, local14
0c9fc     01 F0 85 F1 | 	sub	local13, #1
0ca00     F8 F4 01 FD | 	qmul	local15, local13
0ca04                 | '                 rowpos-- ' back up a row
0ca04     01 E4 85 F1 | 	sub	local07, #1
0ca08                 | '                 ' determine size of a row including any skew
0ca08                 | '                 size := long[region][11]
0ca08     2C DE 85 F1 | 	sub	local04, #44
0ca0c                 | '                 if size < 0 ' negative skews are incompatible with text scrolling and will be ignored
0ca0c                 | '                     size := 0
0ca0c                 | '                 size += columns * 2
0ca0c                 | ' 
0ca0c                 | '                 ' scroll up
0ca0c                 | '                 bytemove(src, src + size, size * (rows - 1))
0ca0c     F0 C4 01 F6 | 	mov	arg02, local05
0ca10     FA C4 01 F1 | 	add	arg02, local15
0ca14     F0 C2 01 F6 | 	mov	arg01, local05
0ca18     18 C6 61 FD | 	getqx	arg03
0ca1c     38 19 B0 FD | 	call	#__system____builtin_memmove
0ca20     FB E4 01 FD | 	qmul	local07, local16
0ca24                 | '                 ' clear bottom row
0ca24                 | '                 wordfill(src + rowpos * columns * 2, (colours & $ff) << 8 + 32, size/2)
0ca24     F4 C4 E1 F8 | 	getbyte	arg02, local09, #0
0ca28     08 C4 65 F0 | 	shl	arg02, #8
0ca2c     20 C4 05 F1 | 	add	arg02, #32
0ca30     FA F6 51 F6 | 	abs	local16, local15 wc
0ca34     01 F6 45 F0 | 	shr	local16, #1
0ca38     FB C6 81 F6 | 	negc	arg03, local16
0ca3c     18 F6 61 FD | 	getqx	local16
0ca40     01 F6 65 F0 | 	shl	local16, #1
0ca44     FB E0 01 F1 | 	add	local05, local16
0ca48     F0 C2 01 F6 | 	mov	arg01, local05
0ca4c     9C 00 A0 FD | 	call	#\builtin_wordfill_
0ca50                 | LR__1496
0ca50                 | LR__1497
0ca50                 | LR__1498
0ca50                 | LR__1499
0ca50                 | LR__1500
0ca50                 | ' 
0ca50                 | '     ' if a HW cursor is applied to the text region, then also update its position
0ca50                 | '     if cursid
0ca50     00 EA 0D F2 | 	cmp	local10, #0 wz
0ca54     1C 00 90 AD |  if_e	jmp	#LR__1501
0ca58                 | '         setCursorPos(region, ((cursid & $f) - 1) & 1, rowpos, colpos)
0ca58     F5 C4 41 F8 | 	getnib	arg02, local10, #0
0ca5c     01 C4 85 F1 | 	sub	arg02, #1
0ca60     01 C4 05 F5 | 	and	arg02, #1
0ca64     EF C2 01 F6 | 	mov	arg01, local04
0ca68     F2 C6 01 F6 | 	mov	arg03, local07
0ca6c     F3 C8 01 F6 | 	mov	arg04, local08
0ca70     3C FC BF FD | 	call	#_p2videodrv_setCursorPos
0ca74                 | LR__1501
0ca74                 | ' 
0ca74                 | '     ' save last position and last char
0ca74                 | '     word[ctx][4] := (rowpos << 8) + (colpos & $ff)
0ca74     08 E4 65 F0 | 	shl	local07, #8
0ca78     F3 E6 E1 F8 | 	getbyte	local08, local08, #0
0ca7c     F3 E4 01 F1 | 	add	local07, local08
0ca80     08 DC 05 F1 | 	add	local03, #8
0ca84     EE E4 51 FC | 	wrword	local07, local03
0ca88                 | '     byte[ctx][14] := char
0ca88     06 DC 05 F1 | 	add	local03, #6
0ca8c     EE D8 41 FC | 	wrbyte	local01, local03
0ca90                 | LR__1502
0ca90     A7 F0 03 F6 | 	mov	ptra, fp
0ca94     B2 00 A0 FD | 	call	#popregs_
0ca98                 | _p2videodrv_out_ret
0ca98     2D 00 64 FD | 	ret
0ca9c                 | 
0ca9c                 | ' 
0ca9c                 | ' 
0ca9c                 | ' PUB printStr(str) : len
0ca9c                 | _p2videodrv_printStr
0ca9c     02 4A 05 F6 | 	mov	COUNT_, #2
0caa0     A8 00 A0 FD | 	call	#pushregs_
0caa4     E1 D8 01 F6 | 	mov	local01, arg01
0caa8     00 DA 05 F6 | 	mov	local02, #0
0caac                 | '     repeat until byte[str][len] == 0
0caac                 | LR__1510
0caac     ED C2 01 F6 | 	mov	arg01, local02
0cab0     EC C2 01 F1 | 	add	arg01, local01
0cab4     E1 C2 C9 FA | 	rdbyte	arg01, arg01 wz
0cab8     18 00 90 AD |  if_e	jmp	#LR__1511
0cabc                 | '         out(byte[str][len++])
0cabc     ED C2 01 F6 | 	mov	arg01, local02
0cac0     EC C2 01 F1 | 	add	arg01, local01
0cac4     E1 C2 C1 FA | 	rdbyte	arg01, arg01
0cac8     01 DA 05 F1 | 	add	local02, #1
0cacc     D4 FC BF FD | 	call	#_p2videodrv_out
0cad0     D8 FF 9F FD | 	jmp	#LR__1510
0cad4                 | LR__1511
0cad4     ED A6 01 F6 | 	mov	result1, local02
0cad8     A7 F0 03 F6 | 	mov	ptra, fp
0cadc     B2 00 A0 FD | 	call	#popregs_
0cae0                 | _p2videodrv_printStr_ret
0cae0     2D 00 64 FD | 	ret
0cae4                 | 
0cae4                 | ' 
0cae4                 | ' PUB initTextOutput(ctx, display, region, fg, bg, hwcursor, clearscreen)
0cae4                 | _p2videodrv_initTextOutput
0cae4     03 4A 05 F6 | 	mov	COUNT_, #3
0cae8     A8 00 A0 FD | 	call	#pushregs_
0caec     E1 D8 01 F6 | 	mov	local01, arg01
0caf0     E6 DA 09 F6 | 	mov	local02, arg06 wz
0caf4     E7 DC 01 F6 | 	mov	local03, arg07
0caf8                 | '     ' init the text region's context data
0caf8                 | '     long[ctx][0] := display
0caf8     EC C4 61 FC | 	wrlong	arg02, local01
0cafc                 | '     long[ctx][1] := region
0cafc     04 D8 05 F1 | 	add	local01, #4
0cb00     EC C6 61 FC | 	wrlong	arg03, local01
0cb04                 | '     long[ctx][2] := ((hwcursor & $ff) << 24) + ((((bg & $f) << 4) | (fg & $f)) << 16)  ' home row,col to 0,0
0cb04     ED C2 E1 F8 | 	getbyte	arg01, local02, #0
0cb08     18 C2 65 F0 | 	shl	arg01, #24
0cb0c     E5 A6 41 F8 | 	getnib	result1, arg05, #0
0cb10     04 A6 65 F0 | 	shl	result1, #4
0cb14     E4 C8 41 F8 | 	getnib	arg04, arg04, #0
0cb18     E4 A6 41 F5 | 	or	result1, arg04
0cb1c     10 A6 65 F0 | 	shl	result1, #16
0cb20     D3 C2 01 F1 | 	add	arg01, result1
0cb24     04 D8 05 F1 | 	add	local01, #4
0cb28     EC C2 61 FC | 	wrlong	arg01, local01
0cb2c                 | '     word[ctx][4] := 0
0cb2c     EC 00 58 FC | 	wrword	#0, local01
0cb30                 | '     word[ctx][6] := getActivePixels(display)
0cb30                 | '     return ((long[long[display][1]][2] & $ff) << 3)
0cb30     04 C4 05 F1 | 	add	arg02, #4
0cb34     E2 A6 01 FB | 	rdlong	result1, arg02
0cb38     08 A6 05 F1 | 	add	result1, #8
0cb3c     D3 A6 01 FB | 	rdlong	result1, result1
0cb40     D3 A6 E1 F8 | 	getbyte	result1, result1, #0
0cb44     03 A6 65 F0 | 	shl	result1, #3
0cb48     04 D8 05 F1 | 	add	local01, #4
0cb4c     EC A6 51 FC | 	wrword	result1, local01
0cb50                 | '     word[ctx][7] := 0
0cb50     02 D8 05 F1 | 	add	local01, #2
0cb54     EC 00 58 FC | 	wrword	#0, local01
0cb58     0E D8 85 F1 | 	sub	local01, #14
0cb5c                 | '     ' init the HW cursor if enabled, and optionally clear the screen
0cb5c                 | '     if hwcursor
0cb5c     1C 00 90 AD |  if_e	jmp	#LR__1520
0cb60                 | '         setCursorPos(region, (hwcursor - 1) & 1, 0, 0)
0cb60     01 DA 85 F1 | 	sub	local02, #1
0cb64     01 DA 05 F5 | 	and	local02, #1
0cb68     E3 C2 01 F6 | 	mov	arg01, arg03
0cb6c     ED C4 01 F6 | 	mov	arg02, local02
0cb70     00 C6 05 F6 | 	mov	arg03, #0
0cb74     00 C8 05 F6 | 	mov	arg04, #0
0cb78     34 FB BF FD | 	call	#_p2videodrv_setCursorPos
0cb7c                 | LR__1520
0cb7c                 | '     context[cogid()] := ctx
0cb7c     00 DA 05 F6 | 	mov	local02, #0
0cb80     01 DA 61 FD | 	cogid	local02
0cb84     02 DA 65 F0 | 	shl	local02, #2
0cb88     D0 DA 01 F1 | 	add	local02, ptr__p2videodrv_dat__
0cb8c     ED D8 61 FC | 	wrlong	local01, local02
0cb90                 | '     if clearscreen
0cb90     00 DC 0D F2 | 	cmp	local03, #0 wz
0cb94                 | '         clear()
0cb94     0C 00 B0 5D |  if_ne	call	#_p2videodrv_clear
0cb98     A7 F0 03 F6 | 	mov	ptra, fp
0cb9c     B2 00 A0 FD | 	call	#popregs_
0cba0                 | _p2videodrv_initTextOutput_ret
0cba0     2D 00 64 FD | 	ret
0cba4                 | 
0cba4                 | ' 
0cba4                 | ' ' clears text region
0cba4                 | ' PUB clear() | ctx, region, display, cursid
0cba4                 | _p2videodrv_clear
0cba4     06 4A 05 F6 | 	mov	COUNT_, #6
0cba8     A8 00 A0 FD | 	call	#pushregs_
0cbac                 | '     if (ctx := context[cogid()])
0cbac     00 C8 05 F6 | 	mov	arg04, #0
0cbb0     01 C8 61 FD | 	cogid	arg04
0cbb4     02 C8 65 F0 | 	shl	arg04, #2
0cbb8     D0 C8 01 F1 | 	add	arg04, ptr__p2videodrv_dat__
0cbbc     E4 D8 09 FB | 	rdlong	local01, arg04 wz
0cbc0     88 00 90 AD |  if_e	jmp	#LR__1531
0cbc4                 | '         display := long[ctx][0]
0cbc4     EC DA 01 FB | 	rdlong	local02, local01
0cbc8                 | '         region  := long[ctx][1]
0cbc8     04 D8 05 F1 | 	add	local01, #4
0cbcc     EC DC 01 FB | 	rdlong	local03, local01
0cbd0                 | '         wordfill(getSource(region), (byte[ctx][10] << 8) + 32, getCurrentRows(display, region)*getCurrentColumns(display, region))
0cbd0     EE C2 01 F6 | 	mov	arg01, local03
0cbd4                 | '     return long[region][2]
0cbd4     08 C2 05 F1 | 	add	arg01, #8
0cbd8     E1 DE 01 FB | 	rdlong	local04, arg01
0cbdc     06 D8 05 F1 | 	add	local01, #6
0cbe0     EC E0 C1 FA | 	rdbyte	local05, local01
0cbe4     08 E0 65 F0 | 	shl	local05, #8
0cbe8     20 E0 05 F1 | 	add	local05, #32
0cbec     ED C2 01 F6 | 	mov	arg01, local02
0cbf0     EE C4 01 F6 | 	mov	arg02, local03
0cbf4     F8 FA BF FD | 	call	#_p2videodrv_getCurrentRows
0cbf8     D3 E2 01 F6 | 	mov	local06, result1
0cbfc     ED C2 01 F6 | 	mov	arg01, local02
0cc00     EE C4 01 F6 | 	mov	arg02, local03
0cc04     48 FB BF FD | 	call	#_p2videodrv_getCurrentColumns
0cc08     D3 E2 01 FD | 	qmul	local06, result1
0cc0c     EF C2 01 F6 | 	mov	arg01, local04
0cc10     F0 C4 01 F6 | 	mov	arg02, local05
0cc14     18 C6 61 FD | 	getqx	arg03
0cc18     9C 00 A0 FD | 	call	#\builtin_wordfill_
0cc1c                 | '         word[ctx][4] := 0 ' home the row & column to 0
0cc1c     02 D8 85 F1 | 	sub	local01, #2
0cc20     EC 00 58 FC | 	wrword	#0, local01
0cc24                 | '         cursid := byte[ctx][11]
0cc24     03 D8 05 F1 | 	add	local01, #3
0cc28     EC C8 C9 FA | 	rdbyte	arg04, local01 wz
0cc2c                 | '         if cursid ' set HW cursor if enabled
0cc2c     1C 00 90 AD |  if_e	jmp	#LR__1530
0cc30                 | '             setCursorPos(region, (cursid - 1) & 1, 0, 0)
0cc30     01 C8 85 F1 | 	sub	arg04, #1
0cc34     01 C8 05 F5 | 	and	arg04, #1
0cc38     EE C2 01 F6 | 	mov	arg01, local03
0cc3c     E4 C4 01 F6 | 	mov	arg02, arg04
0cc40     00 C6 05 F6 | 	mov	arg03, #0
0cc44     00 C8 05 F6 | 	mov	arg04, #0
0cc48     64 FA BF FD | 	call	#_p2videodrv_setCursorPos
0cc4c                 | LR__1530
0cc4c                 | LR__1531
0cc4c     A7 F0 03 F6 | 	mov	ptra, fp
0cc50     B2 00 A0 FD | 	call	#popregs_
0cc54                 | _p2videodrv_clear_ret
0cc54     2D 00 64 FD | 	ret
0cc58                 | 
0cc58                 | ' 
0cc58                 | ' ' sets colours or attributes of text
0cc58                 | ' ' colour text: fgcolour, bgcolour are colour indexes 0-F for foreground and background colours
0cc58                 | ' ' mono text: attributes fgcolour bit0 = INVERSE, bgcolour bit3 = FLASH
0cc58                 | ' PUB setTextColours(fgcolour, bgcolour) | ctx
0cc58                 | _p2videodrv_setTextColours
0cc58                 | '     if (ctx := context[cogid()])
0cc58     00 A6 05 F6 | 	mov	result1, #0
0cc5c     01 A6 61 FD | 	cogid	result1
0cc60     02 A6 65 F0 | 	shl	result1, #2
0cc64     D0 A6 01 F1 | 	add	result1, ptr__p2videodrv_dat__
0cc68     D3 A6 09 FB | 	rdlong	result1, result1 wz
0cc6c     18 00 90 AD |  if_e	jmp	#LR__1540
0cc70                 | '         byte[ctx][10] := ((bgcolour & $f) << 4) | (fgcolour & $f)
0cc70     E2 C4 41 F8 | 	getnib	arg02, arg02, #0
0cc74     04 C4 65 F0 | 	shl	arg02, #4
0cc78     E1 C2 41 F8 | 	getnib	arg01, arg01, #0
0cc7c     E1 C4 41 F5 | 	or	arg02, arg01
0cc80     0A A6 05 F1 | 	add	result1, #10
0cc84     D3 C4 41 FC | 	wrbyte	arg02, result1
0cc88                 | LR__1540
0cc88                 | _p2videodrv_setTextColours_ret
0cc88     2D 00 64 FD | 	ret
0cc8c                 | 
0cc8c                 | ' 
0cc8c                 | ' PUB setTextPos(curs_row, curs_col) | cursid, ctx
0cc8c                 | _p2videodrv_setTextPos
0cc8c     02 4A 05 F6 | 	mov	COUNT_, #2
0cc90     A8 00 A0 FD | 	call	#pushregs_
0cc94                 | '     if (ctx := context[cogid()])
0cc94     00 A6 05 F6 | 	mov	result1, #0
0cc98     01 A6 61 FD | 	cogid	result1
0cc9c     02 A6 65 F0 | 	shl	result1, #2
0cca0     D0 A6 01 F1 | 	add	result1, ptr__p2videodrv_dat__
0cca4     D3 C8 09 FB | 	rdlong	arg04, result1 wz
0cca8     4C 00 90 AD |  if_e	jmp	#LR__1551
0ccac                 | '         word[ctx][4] := ((curs_row & $ff) << 8) + (curs_col & $ff)
0ccac     E1 C6 E1 F8 | 	getbyte	arg03, arg01, #0
0ccb0     08 C6 65 F0 | 	shl	arg03, #8
0ccb4     E2 A6 E1 F8 | 	getbyte	result1, arg02, #0
0ccb8     D3 C6 01 F1 | 	add	arg03, result1
0ccbc     08 C8 05 F1 | 	add	arg04, #8
0ccc0     E4 C6 51 FC | 	wrword	arg03, arg04
0ccc4                 | '         cursid := byte[ctx][11]
0ccc4     03 C8 05 F1 | 	add	arg04, #3
0ccc8     E4 D8 C9 FA | 	rdbyte	local01, arg04 wz
0cccc     0B C8 85 F1 | 	sub	arg04, #11
0ccd0                 | '         if cursid
0ccd0     24 00 90 AD |  if_e	jmp	#LR__1550
0ccd4                 | '             setCursorPos(long[ctx][1], (cursid - 1) & 1, curs_row, curs_col)
0ccd4     04 C8 05 F1 | 	add	arg04, #4
0ccd8     E4 DA 01 FB | 	rdlong	local02, arg04
0ccdc     01 D8 85 F1 | 	sub	local01, #1
0cce0     01 D8 05 F5 | 	and	local01, #1
0cce4     E1 C6 01 F6 | 	mov	arg03, arg01
0cce8     E2 C8 01 F6 | 	mov	arg04, arg02
0ccec     ED C2 01 F6 | 	mov	arg01, local02
0ccf0     EC C4 01 F6 | 	mov	arg02, local01
0ccf4     B8 F9 BF FD | 	call	#_p2videodrv_setCursorPos
0ccf8                 | LR__1550
0ccf8                 | LR__1551
0ccf8     A7 F0 03 F6 | 	mov	ptra, fp
0ccfc     B2 00 A0 FD | 	call	#popregs_
0cd00                 | _p2videodrv_setTextPos_ret
0cd00     2D 00 64 FD | 	ret
0cd04                 | 
0cd04                 | ' 
0cd04                 | ' PUB getTextPos() : curs_row, curs_col | ctx
0cd04                 | _p2videodrv_getTextPos
0cd04                 | '     if (ctx := context[cogid()]) == 0
0cd04     00 A6 05 F6 | 	mov	result1, #0
0cd08     01 A6 61 FD | 	cogid	result1
0cd0c     02 A6 65 F0 | 	shl	result1, #2
0cd10     D0 A6 01 F1 | 	add	result1, ptr__p2videodrv_dat__
0cd14     D3 AA 09 FB | 	rdlong	_var01, result1 wz
0cd18                 | '         return
0cd18     00 A8 05 A6 |  if_e	mov	result2, #0
0cd1c     00 A6 05 A6 |  if_e	mov	result1, #0
0cd20                 | '     curs_col := byte[ctx][8]
0cd20     08 AA 05 51 |  if_ne	add	_var01, #8
0cd24     D5 A8 C1 5A |  if_ne	rdbyte	result2, _var01
0cd28                 | '     curs_row := byte[ctx][9]
0cd28     01 AA 05 51 |  if_ne	add	_var01, #1
0cd2c     D5 A6 C1 5A |  if_ne	rdbyte	result1, _var01
0cd30                 | _p2videodrv_getTextPos_ret
0cd30     2D 00 64 FD | 	ret
0cd34                 | 
0cd34                 | ' 
0cd34                 | ' PRI findRegionSize(display, region) : size | ptr
0cd34                 | _p2videodrv_findRegionSize
0cd34     E1 AA 01 F6 | 	mov	_var01, arg01
0cd38                 | '     ptr := long[display][10]
0cd38     28 AA 05 F1 | 	add	_var01, #40
0cd3c     D5 AC 09 FB | 	rdlong	_var02, _var01 wz
0cd40     28 AA 85 F1 | 	sub	_var01, #40
0cd44                 | '     size := getActiveLines(display) - word[display][16]
0cd44     D5 C2 01 F6 | 	mov	arg01, _var01
0cd48                 | '     return (long[long[display][1]][3] & $7ff)
0cd48     04 C2 05 F1 | 	add	arg01, #4
0cd4c     E1 A6 01 FB | 	rdlong	result1, arg01
0cd50     0C A6 05 F1 | 	add	result1, #12
0cd54     D3 A6 01 FB | 	rdlong	result1, result1
0cd58     0A A6 45 F7 | 	zerox	result1, #10
0cd5c     D3 C2 01 F6 | 	mov	arg01, result1
0cd60     20 AA 05 F1 | 	add	_var01, #32
0cd64     D5 AA E1 FA | 	rdword	_var01, _var01
0cd68     D5 C2 81 F1 | 	sub	arg01, _var01
0cd6c                 | '     repeat while ptr <> 0 and ptr <> region and size > 0
0cd6c     2C 00 90 AD |  if_e	jmp	#LR__1562
0cd70     97 14 48 FB | 	callpa	#(@LR__1561-@LR__1560)>>2,fcache_load_ptr_
0cd74                 | LR__1560
0cd74     E2 AC 09 F2 | 	cmp	_var02, arg02 wz
0cd78     20 00 90 AD |  if_e	jmp	#LR__1562
0cd7c     01 C2 55 F2 | 	cmps	arg01, #1 wc
0cd80     18 00 90 CD |  if_b	jmp	#LR__1562
0cd84                 | '         size -= word[ptr][3]
0cd84     06 AC 05 F1 | 	add	_var02, #6
0cd88     D6 AA E1 FA | 	rdword	_var01, _var02
0cd8c     06 AC 85 F1 | 	sub	_var02, #6
0cd90     D5 C2 81 F1 | 	sub	arg01, _var01
0cd94                 | '         ptr := long[ptr][0]
0cd94     D6 AC 09 FB | 	rdlong	_var02, _var02 wz
0cd98     D8 FF 9F 5D |  if_ne	jmp	#LR__1560
0cd9c                 | LR__1561
0cd9c                 | LR__1562
0cd9c                 | '     if (ptr == region) and (size > 0)
0cd9c     E2 AC 09 F2 | 	cmp	_var02, arg02 wz
0cda0     01 C2 55 A2 |  if_e	cmps	arg01, #1 wc
0cda4                 | '         return
0cda4     E1 A6 01 26 |  if_nc_and_z	mov	result1, arg01
0cda8                 | '     return 0
0cda8     00 A6 05 D6 |  if_c_or_nz	mov	result1, #0
0cdac                 | _p2videodrv_findRegionSize_ret
0cdac     2D 00 64 FD | 	ret
0cdb0                 | 
0cdb0                 | ' 
0cdb0                 | ' 
0cdb0                 | ' PUB hex(value, digits)
0cdb0                 | _p2videodrv_hex
0cdb0     03 4A 05 F6 | 	mov	COUNT_, #3
0cdb4     A8 00 A0 FD | 	call	#pushregs_
0cdb8     E2 D8 09 F6 | 	mov	local01, arg02 wz
0cdbc                 | ' ' Print a hexadecimal number
0cdbc                 | '   value <<= (8 - digits) << 2
0cdbc     E1 DA 01 F6 | 	mov	local02, arg01
0cdc0     08 DC 05 F6 | 	mov	local03, #8
0cdc4     EC DC 81 F1 | 	sub	local03, local01
0cdc8     02 DC 65 F0 | 	shl	local03, #2
0cdcc     EE DA 61 F0 | 	shl	local02, local03
0cdd0                 | '   repeat digits
0cdd0     2C 00 90 AD |  if_e	jmp	#LR__1571
0cdd4                 | LR__1570
0cdd4                 | '     value ROL= 4
0cdd4     04 DA 25 F0 | 	rol	local02, #4
0cdd8                 | '     tx(lookupz(value & $F : "0".."9", "A".."F"))
0cdd8     ED C2 41 F8 | 	getnib	arg01, local02, #0
0cddc     D0 C6 01 F6 | 	mov	arg03, ptr__p2videodrv_dat__
0cde0     08 00 00 FF 
0cde4     50 C7 05 F1 | 	add	arg03, ##4432
0cde8     00 C4 05 F6 | 	mov	arg02, #0
0cdec     10 C8 05 F6 | 	mov	arg04, #16
0cdf0     8C 16 B0 FD | 	call	#__system___lookup
0cdf4     D3 C2 01 F6 | 	mov	arg01, result1
0cdf8                 | '     out(ch)
0cdf8     A8 F9 BF FD | 	call	#_p2videodrv_out
0cdfc     F5 D9 6D FB | 	djnz	local01, #LR__1570
0ce00                 | LR__1571
0ce00     A7 F0 03 F6 | 	mov	ptra, fp
0ce04     B2 00 A0 FD | 	call	#popregs_
0ce08                 | _p2videodrv_hex_ret
0ce08     2D 00 64 FD | 	ret
0ce0c                 | 
0ce0c                 | ' 
0ce0c                 | ' PUB start() : r
0ce0c                 | _usbnew_0016_start
0ce0c     00 AA 05 F6 | 	mov	_var01, #0
0ce10                 | '   ifnot driver_cog
0ce10     0F 00 00 FF 
0ce14     CB A2 05 F1 | 	add	ptr__usbnew_0016_dat__, ##7883
0ce18     D1 AC C9 FA | 	rdbyte	_var02, ptr__usbnew_0016_dat__ wz
0ce1c     0F 00 00 FF 
0ce20     CB A2 85 F1 | 	sub	ptr__usbnew_0016_dat__, ##7883
0ce24     38 00 90 5D |  if_ne	jmp	#LR__1580
0ce28                 | '     r := coginit(COGEXEC_NEW,@usb_host_start,0)
0ce28     D1 C4 01 F6 | 	mov	arg02, ptr__usbnew_0016_dat__
0ce2c     10 AA 05 F6 | 	mov	_var01, #16
0ce30     00 C6 05 F6 | 	mov	arg03, #0
0ce34     28 C6 61 FD | 	setq	arg03
0ce38     E2 AA F1 FC | 	coginit	_var01, arg02 wc
0ce3c     01 AA 65 C6 |  if_b	neg	_var01, #1
0ce40                 | '     if r >= 0
0ce40     00 AA 55 F2 | 	cmps	_var01, #0 wc
0ce44                 | '       driver_cog := r+1
0ce44     D5 AC 01 36 |  if_ae	mov	_var02, _var01
0ce48     01 AC 05 31 |  if_ae	add	_var02, #1
0ce4c     0F 00 00 3F 
0ce50     CB A2 05 31 |  if_ae	add	ptr__usbnew_0016_dat__, ##7883
0ce54     D1 AC 41 3C |  if_ae	wrbyte	_var02, ptr__usbnew_0016_dat__
0ce58     0F 00 00 3F 
0ce5c     CB A2 85 31 |  if_ae	sub	ptr__usbnew_0016_dat__, ##7883
0ce60                 | LR__1580
0ce60     D5 A6 01 F6 | 	mov	result1, _var01
0ce64                 | _usbnew_0016_start_ret
0ce64     2D 00 64 FD | 	ret
0ce68                 | 
0ce68                 | '     '' Set KEYQUEUE_SIZE to enable (recommended value: 32)
0ce68                 | ' 
0ce68                 | ' '' Return key event from buffer if there is one
0ce68                 | ' PUB get_key() : r | tail
0ce68                 | _usbnew_0016_get_key
0ce68                 | '   tail := keyq_tail
0ce68     0A 00 00 FF 
0ce6c     8D A3 05 F1 | 	add	ptr__usbnew_0016_dat__, ##5517
0ce70     D1 AA C1 FA | 	rdbyte	_var01, ptr__usbnew_0016_dat__
0ce74                 | '   if keyq_head == tail
0ce74     01 A2 85 F1 | 	sub	ptr__usbnew_0016_dat__, #1
0ce78     D1 AC C1 FA | 	rdbyte	_var02, ptr__usbnew_0016_dat__
0ce7c     0A 00 00 FF 
0ce80     8C A3 85 F1 | 	sub	ptr__usbnew_0016_dat__, ##5516
0ce84     D5 AC 09 F2 | 	cmp	_var02, _var01 wz
0ce88                 | '     return 0 ' No event
0ce88     00 A6 05 A6 |  if_e	mov	result1, #0
0ce8c     3C 00 90 AD |  if_e	jmp	#_usbnew_0016_get_key_ret
0ce90                 | '   r := keyq_data[tail]
0ce90     D5 AC 01 F6 | 	mov	_var02, _var01
0ce94     02 AC 65 F0 | 	shl	_var02, #2
0ce98     D1 A6 01 F6 | 	mov	result1, ptr__usbnew_0016_dat__
0ce9c     0A 00 00 FF 
0cea0     8E A7 05 F1 | 	add	result1, ##5518
0cea4     D3 AC 01 F1 | 	add	_var02, result1
0cea8     D6 A6 01 FB | 	rdlong	result1, _var02
0ceac                 | '   if ++tail == KEYQUEUE_SIZE
0ceac     01 AA 05 F1 | 	add	_var01, #1
0ceb0     20 AA 0D F2 | 	cmp	_var01, #32 wz
0ceb4                 | '     tail := 0
0ceb4     00 AA 05 A6 |  if_e	mov	_var01, #0
0ceb8                 | '   keyq_tail := tail
0ceb8     0A 00 00 FF 
0cebc     8D A3 05 F1 | 	add	ptr__usbnew_0016_dat__, ##5517
0cec0     D1 AA 41 FC | 	wrbyte	_var01, ptr__usbnew_0016_dat__
0cec4     0A 00 00 FF 
0cec8     8D A3 85 F1 | 	sub	ptr__usbnew_0016_dat__, ##5517
0cecc                 | _usbnew_0016_get_key_ret
0cecc     2D 00 64 FD | 	ret
0ced0                 | 
0ced0                 | ' 
0ced0                 | ' PUB GetDiskFromHost | r
0ced0                 | _hostfs_GetDiskFromHost
0ced0     01 4A 05 F6 | 	mov	COUNT_, #1
0ced4     A8 00 A0 FD | 	call	#pushregs_
0ced8                 | '     ser.start(63, 62, 0, 921_600)
0ced8     3F C2 05 F6 | 	mov	arg01, #63
0cedc     3E C4 05 F6 | 	mov	arg02, #62
0cee0     00 C6 05 F6 | 	mov	arg03, #0
0cee4     08 07 00 FF 
0cee8     00 C8 05 F6 | 	mov	arg04, ##921600
0ceec     02 00 00 FF 
0cef0     14 90 05 F1 | 	add	objptr, ##1044
0cef4                 | '   if txpin == -99
0cef4                 | '      baudrate := rxpin
0cef4                 | '      rxpin := 63
0cef4                 | '      txpin := 62
0cef4                 | '      
0cef4                 | '   startx(rxpin, txpin, mode, baudrate)
0cef4     78 04 B0 FD | 	call	#_SmartSerial_startx
0cef8                 | '     ser.printf("Updating disk0.img from host...")
0cef8     7D 00 00 FF 
0cefc     86 C2 05 F6 | 	mov	arg01, ##@LR__2125
0cf00     00 C4 05 F6 | 	mov	arg02, #0
0cf04     00 C6 05 F6 | 	mov	arg03, #0
0cf08     00 C8 05 F6 | 	mov	arg04, #0
0cf0c     00 CA 05 F6 | 	mov	arg05, #0
0cf10     00 CC 05 F6 | 	mov	arg06, #0
0cf14     00 CE 05 F6 | 	mov	arg07, #0
0cf18     8C 06 B0 FD | 	call	#_SmartSerial_printf
0cf1c     02 00 00 FF 
0cf20     14 90 85 F1 | 	sub	objptr, ##1044
0cf24                 | '     r := fs.fs_init(@sendrecv)
0cf24     C8 C2 01 F6 | 	mov	arg01, objptr
0cf28     02 00 00 FF 
0cf2c     3C 90 05 F1 | 	add	objptr, ##1084
0cf30     88 09 B0 FD | 	call	#_fs9p_cc_fs_init
0cf34     02 00 00 FF 
0cf38     3C 90 85 F1 | 	sub	objptr, ##1084
0cf3c                 | '     if r < 0
0cf3c     00 A6 55 F2 | 	cmps	result1, #0 wc
0cf40     38 00 90 3D |  if_ae	jmp	#LR__1590
0cf44                 | '         ser.printf(" fs_init returned error %d\n", r)
0cf44     7D 00 00 FF 
0cf48     A6 C2 05 F6 | 	mov	arg01, ##@LR__2126
0cf4c     D3 C4 01 F6 | 	mov	arg02, result1
0cf50     00 C6 05 F6 | 	mov	arg03, #0
0cf54     00 C8 05 F6 | 	mov	arg04, #0
0cf58     00 CA 05 F6 | 	mov	arg05, #0
0cf5c     00 CC 05 F6 | 	mov	arg06, #0
0cf60     00 CE 05 F6 | 	mov	arg07, #0
0cf64     02 00 00 FF 
0cf68     14 90 05 F1 | 	add	objptr, ##1044
0cf6c     38 06 B0 FD | 	call	#_SmartSerial_printf
0cf70     02 00 00 FF 
0cf74     14 90 85 F1 | 	sub	objptr, ##1044
0cf78                 | '         return
0cf78     B8 02 90 FD | 	jmp	#LR__1594
0cf7c                 | LR__1590
0cf7c                 | '     r := fs.fs_open(@myfd, @"disk0.img", 0)
0cf7c     7D 00 00 FF 
0cf80     C3 C4 05 F6 | 	mov	arg02, ##@LR__2127
0cf84     C8 C2 01 F6 | 	mov	arg01, objptr
0cf88     00 C6 05 F6 | 	mov	arg03, #0
0cf8c     02 00 00 FF 
0cf90     3C 90 05 F1 | 	add	objptr, ##1084
0cf94     E0 0E B0 FD | 	call	#_fs9p_cc_fs_open
0cf98     02 00 00 FF 
0cf9c     3C 90 85 F1 | 	sub	objptr, ##1084
0cfa0                 | '     if r < 0
0cfa0     00 A6 55 F2 | 	cmps	result1, #0 wc
0cfa4     38 00 90 3D |  if_ae	jmp	#LR__1591
0cfa8                 | '         ser.printf(" fs_open returned error %d\n", r)
0cfa8     7D 00 00 FF 
0cfac     CD C2 05 F6 | 	mov	arg01, ##@LR__2128
0cfb0     D3 C4 01 F6 | 	mov	arg02, result1
0cfb4     00 C6 05 F6 | 	mov	arg03, #0
0cfb8     00 C8 05 F6 | 	mov	arg04, #0
0cfbc     00 CA 05 F6 | 	mov	arg05, #0
0cfc0     00 CC 05 F6 | 	mov	arg06, #0
0cfc4     00 CE 05 F6 | 	mov	arg07, #0
0cfc8     02 00 00 FF 
0cfcc     14 90 05 F1 | 	add	objptr, ##1044
0cfd0     D4 05 B0 FD | 	call	#_SmartSerial_printf
0cfd4     02 00 00 FF 
0cfd8     14 90 85 F1 | 	sub	objptr, ##1044
0cfdc                 | '         return
0cfdc     54 02 90 FD | 	jmp	#LR__1594
0cfe0                 | LR__1591
0cfe0                 | '     image := c.fopen(@"/sd/disk0.img", @"wb")
0cfe0     7D 00 00 FF 
0cfe4     EA C2 05 F6 | 	mov	arg01, ##@LR__2129
0cfe8     7D 00 00 FF 
0cfec     F8 C4 05 F6 | 	mov	arg02, ##@LR__2130
0cff0     02 00 00 FF 
0cff4     14 90 05 F1 | 	add	objptr, ##1044
0cff8     30 3A BF FD | 	call	#_libc_a_fopen
0cffc     D3 D8 01 F6 | 	mov	local01, result1
0d000     02 00 00 FF 
0d004     04 90 85 F1 | 	sub	objptr, ##1028
0d008     C8 D8 61 FC | 	wrlong	local01, objptr
0d00c     10 90 85 F1 | 	sub	objptr, #16
0d010                 | '     repeat
0d010                 | LR__1592
0d010                 | '         r := fs.fs_read(@myfd, @buf, 1024)
0d010     C8 C2 01 F6 | 	mov	arg01, objptr
0d014     14 90 05 F1 | 	add	objptr, #20
0d018     C8 C4 01 F6 | 	mov	arg02, objptr
0d01c     0A C6 C5 F9 | 	decod	arg03, #10
0d020     02 00 00 FF 
0d024     28 90 05 F1 | 	add	objptr, ##1064
0d028     28 0F B0 FD | 	call	#_fs9p_cc_fs_read
0d02c     D3 D8 01 F6 | 	mov	local01, result1
0d030                 | '         c.fwrite(@buf, 1, 1024, image)
0d030     02 00 00 FF 
0d034     28 90 85 F1 | 	sub	objptr, ##1064
0d038     C8 C2 01 F6 | 	mov	arg01, objptr
0d03c     04 90 85 F1 | 	sub	objptr, #4
0d040     C8 C8 01 FB | 	rdlong	arg04, objptr
0d044     01 C4 05 F6 | 	mov	arg02, #1
0d048     0A C6 C5 F9 | 	decod	arg03, #10
0d04c     02 00 00 FF 
0d050     04 90 05 F1 | 	add	objptr, ##1028
0d054     D8 3A BF FD | 	call	#_libc_a_fwrite
0d058                 | '         ser.printf(".")
0d058     7D 00 00 FF 
0d05c     FB C2 05 F6 | 	mov	arg01, ##@LR__2131
0d060     00 C4 05 F6 | 	mov	arg02, #0
0d064     00 C6 05 F6 | 	mov	arg03, #0
0d068     00 C8 05 F6 | 	mov	arg04, #0
0d06c     00 CA 05 F6 | 	mov	arg05, #0
0d070     00 CC 05 F6 | 	mov	arg06, #0
0d074     00 CE 05 F6 | 	mov	arg07, #0
0d078     2C 05 B0 FD | 	call	#_SmartSerial_printf
0d07c     02 00 00 FF 
0d080     14 90 85 F1 | 	sub	objptr, ##1044
0d084     01 D8 55 F2 | 	cmps	local01, #1 wc
0d088     84 FF 9F 3D |  if_ae	jmp	#LR__1592
0d08c                 | '     until r =< 0
0d08c                 | '     fs.fs_close(@myfd)
0d08c     C8 C2 01 F6 | 	mov	arg01, objptr
0d090     02 00 00 FF 
0d094     3C 90 05 F1 | 	add	objptr, ##1084
0d098     10 0E B0 FD | 	call	#_fs9p_cc_fs_close
0d09c                 | '     c.fclose(image)
0d09c     02 00 00 FF 
0d0a0     2C 90 85 F1 | 	sub	objptr, ##1068
0d0a4     C8 C2 01 FB | 	rdlong	arg01, objptr
0d0a8     02 00 00 FF 
0d0ac     04 90 05 F1 | 	add	objptr, ##1028
0d0b0                 | ' {
0d0b0                 | '     return _closeraw(f);
0d0b0     78 3E BF FD | 	call	#_libc_a__closeraw
0d0b4                 | '     ser.printf(" done!\n")
0d0b4     7D 00 00 FF 
0d0b8     FD C2 05 F6 | 	mov	arg01, ##@LR__2132
0d0bc     00 C4 05 F6 | 	mov	arg02, #0
0d0c0     00 C6 05 F6 | 	mov	arg03, #0
0d0c4     00 C8 05 F6 | 	mov	arg04, #0
0d0c8     00 CA 05 F6 | 	mov	arg05, #0
0d0cc     00 CC 05 F6 | 	mov	arg06, #0
0d0d0     00 CE 05 F6 | 	mov	arg07, #0
0d0d4     D0 04 B0 FD | 	call	#_SmartSerial_printf
0d0d8     02 00 00 FF 
0d0dc     14 90 85 F1 | 	sub	objptr, ##1044
0d0e0                 | ' 
0d0e0                 | '     r := fs.fs_open(@myfd, @"disk1.img", 0)
0d0e0     7D 00 00 FF 
0d0e4     06 C5 05 F6 | 	mov	arg02, ##@LR__2133
0d0e8     C8 C2 01 F6 | 	mov	arg01, objptr
0d0ec     00 C6 05 F6 | 	mov	arg03, #0
0d0f0     02 00 00 FF 
0d0f4     3C 90 05 F1 | 	add	objptr, ##1084
0d0f8     7C 0D B0 FD | 	call	#_fs9p_cc_fs_open
0d0fc     02 00 00 FF 
0d100     3C 90 85 F1 | 	sub	objptr, ##1084
0d104     D3 D8 01 F6 | 	mov	local01, result1
0d108                 | '     if r < 0
0d108     00 D8 55 F2 | 	cmps	local01, #0 wc
0d10c                 | '         return
0d10c     24 01 90 CD |  if_b	jmp	#LR__1594
0d110                 | '     ser.printf("Updating disk1.img from host...")
0d110     7D 00 00 FF 
0d114     10 C3 05 F6 | 	mov	arg01, ##@LR__2134
0d118     00 C4 05 F6 | 	mov	arg02, #0
0d11c     00 C6 05 F6 | 	mov	arg03, #0
0d120     00 C8 05 F6 | 	mov	arg04, #0
0d124     00 CA 05 F6 | 	mov	arg05, #0
0d128     00 CC 05 F6 | 	mov	arg06, #0
0d12c     00 CE 05 F6 | 	mov	arg07, #0
0d130     02 00 00 FF 
0d134     14 90 05 F1 | 	add	objptr, ##1044
0d138     6C 04 B0 FD | 	call	#_SmartSerial_printf
0d13c                 | '     image := c.fopen(@"/sd/disk1.img", @"wb")
0d13c     7D 00 00 FF 
0d140     30 C3 05 F6 | 	mov	arg01, ##@LR__2135
0d144     7D 00 00 FF 
0d148     3E C5 05 F6 | 	mov	arg02, ##@LR__2136
0d14c     DC 38 BF FD | 	call	#_libc_a_fopen
0d150     D3 D8 01 F6 | 	mov	local01, result1
0d154     02 00 00 FF 
0d158     04 90 85 F1 | 	sub	objptr, ##1028
0d15c     C8 D8 61 FC | 	wrlong	local01, objptr
0d160     10 90 85 F1 | 	sub	objptr, #16
0d164                 | '     repeat
0d164                 | LR__1593
0d164                 | '         r := fs.fs_read(@myfd, @buf, 1024)
0d164     C8 C2 01 F6 | 	mov	arg01, objptr
0d168     14 90 05 F1 | 	add	objptr, #20
0d16c     C8 C4 01 F6 | 	mov	arg02, objptr
0d170     0A C6 C5 F9 | 	decod	arg03, #10
0d174     02 00 00 FF 
0d178     28 90 05 F1 | 	add	objptr, ##1064
0d17c     D4 0D B0 FD | 	call	#_fs9p_cc_fs_read
0d180     D3 D8 01 F6 | 	mov	local01, result1
0d184                 | '         c.fwrite(@buf, 1, 1024, image)
0d184     02 00 00 FF 
0d188     28 90 85 F1 | 	sub	objptr, ##1064
0d18c     C8 C2 01 F6 | 	mov	arg01, objptr
0d190     04 90 85 F1 | 	sub	objptr, #4
0d194     C8 C8 01 FB | 	rdlong	arg04, objptr
0d198     01 C4 05 F6 | 	mov	arg02, #1
0d19c     0A C6 C5 F9 | 	decod	arg03, #10
0d1a0     02 00 00 FF 
0d1a4     04 90 05 F1 | 	add	objptr, ##1028
0d1a8     84 39 BF FD | 	call	#_libc_a_fwrite
0d1ac                 | '         ser.printf(".")
0d1ac     7D 00 00 FF 
0d1b0     41 C3 05 F6 | 	mov	arg01, ##@LR__2137
0d1b4     00 C4 05 F6 | 	mov	arg02, #0
0d1b8     00 C6 05 F6 | 	mov	arg03, #0
0d1bc     00 C8 05 F6 | 	mov	arg04, #0
0d1c0     00 CA 05 F6 | 	mov	arg05, #0
0d1c4     00 CC 05 F6 | 	mov	arg06, #0
0d1c8     00 CE 05 F6 | 	mov	arg07, #0
0d1cc     D8 03 B0 FD | 	call	#_SmartSerial_printf
0d1d0     02 00 00 FF 
0d1d4     14 90 85 F1 | 	sub	objptr, ##1044
0d1d8     01 D8 55 F2 | 	cmps	local01, #1 wc
0d1dc     84 FF 9F 3D |  if_ae	jmp	#LR__1593
0d1e0                 | '     until r =< 0
0d1e0                 | '     fs.fs_close(@myfd)
0d1e0     C8 C2 01 F6 | 	mov	arg01, objptr
0d1e4     02 00 00 FF 
0d1e8     3C 90 05 F1 | 	add	objptr, ##1084
0d1ec     BC 0C B0 FD | 	call	#_fs9p_cc_fs_close
0d1f0                 | '     c.fclose(image)
0d1f0     02 00 00 FF 
0d1f4     2C 90 85 F1 | 	sub	objptr, ##1068
0d1f8     C8 C2 01 FB | 	rdlong	arg01, objptr
0d1fc     02 00 00 FF 
0d200     04 90 05 F1 | 	add	objptr, ##1028
0d204                 | ' {
0d204                 | '     return _closeraw(f);
0d204     24 3D BF FD | 	call	#_libc_a__closeraw
0d208                 | '     ser.printf(" done!\n")
0d208     7D 00 00 FF 
0d20c     43 C3 05 F6 | 	mov	arg01, ##@LR__2138
0d210     00 C4 05 F6 | 	mov	arg02, #0
0d214     00 C6 05 F6 | 	mov	arg03, #0
0d218     00 C8 05 F6 | 	mov	arg04, #0
0d21c     00 CA 05 F6 | 	mov	arg05, #0
0d220     00 CC 05 F6 | 	mov	arg06, #0
0d224     00 CE 05 F6 | 	mov	arg07, #0
0d228     7C 03 B0 FD | 	call	#_SmartSerial_printf
0d22c     02 00 00 FF 
0d230     14 90 85 F1 | 	sub	objptr, ##1044
0d234                 | LR__1594
0d234     A7 F0 03 F6 | 	mov	ptra, fp
0d238     B2 00 A0 FD | 	call	#popregs_
0d23c                 | _hostfs_GetDiskFromHost_ret
0d23c     2D 00 64 FD | 	ret
0d240                 | 
0d240                 | ' 
0d240                 | ' '' routine for transmitting and receiving 9P protocol buffers
0d240                 | ' 
0d240                 | ' PUB sendrecv(startbuf, endbuf, maxlen) | len, buf, i, left
0d240                 | _hostfs_sendrecv
0d240     03 4A 05 F6 | 	mov	COUNT_, #3
0d244     A8 00 A0 FD | 	call	#pushregs_
0d248     E1 D8 01 F6 | 	mov	local01, arg01
0d24c                 | '     len := endbuf - startbuf
0d24c     EC C4 81 F1 | 	sub	arg02, local01
0d250     E2 DA 01 F6 | 	mov	local02, arg02
0d254                 | '     buf := startbuf
0d254     EC DC 01 F6 | 	mov	local03, local01
0d258                 | '     long[startbuf] := len
0d258     EC DA 61 FC | 	wrlong	local02, local01
0d25c                 | ' 
0d25c                 | '     '' transmit magic sequence for loadp2
0d25c                 | '     ser.tx($FF)
0d25c     FF C2 05 F6 | 	mov	arg01, #255
0d260     02 00 00 FF 
0d264     14 90 05 F1 | 	add	objptr, ##1044
0d268     58 01 B0 FD | 	call	#_SmartSerial_tx
0d26c                 | '     ser.tx($01)
0d26c     01 C2 05 F6 | 	mov	arg01, #1
0d270     50 01 B0 FD | 	call	#_SmartSerial_tx
0d274     02 00 00 FF 
0d278     14 90 85 F1 | 	sub	objptr, ##1044
0d27c                 | '     repeat while len > 0
0d27c                 | LR__1600
0d27c     01 DA 55 F2 | 	cmps	local02, #1 wc
0d280     24 00 90 CD |  if_b	jmp	#LR__1601
0d284                 | '         ser.tx(byte[buf++])
0d284     EE C2 C1 FA | 	rdbyte	arg01, local03
0d288     02 00 00 FF 
0d28c     14 90 05 F1 | 	add	objptr, ##1044
0d290     01 DC 05 F1 | 	add	local03, #1
0d294     2C 01 B0 FD | 	call	#_SmartSerial_tx
0d298     02 00 00 FF 
0d29c     14 90 85 F1 | 	sub	objptr, ##1044
0d2a0                 | '         len--
0d2a0     01 DA 85 F1 | 	sub	local02, #1
0d2a4     D4 FF 9F FD | 	jmp	#LR__1600
0d2a8                 | LR__1601
0d2a8                 | ' 
0d2a8                 | '     ' now get response
0d2a8                 | '     buf := startbuf
0d2a8     EC DC 01 F6 | 	mov	local03, local01
0d2ac                 | '     byte[buf++] := ser.rx
0d2ac     02 00 00 FF 
0d2b0     14 90 05 F1 | 	add	objptr, ##1044
0d2b4                 | '   repeat
0d2b4                 | LR__1602
0d2b4                 | '     v := rxcheck()
0d2b4     58 01 B0 FD | 	call	#_SmartSerial_rxcheck
0d2b8     FF FF 7F FF 
0d2bc     FF A7 0D F2 | 	cmp	result1, ##-1 wz
0d2c0     F0 FF 9F AD |  if_e	jmp	#LR__1602
0d2c4     EE A6 41 FC | 	wrbyte	result1, local03
0d2c8                 | '     byte[buf++] := ser.rx
0d2c8     01 DC 05 F1 | 	add	local03, #1
0d2cc                 | '   repeat
0d2cc                 | LR__1603
0d2cc                 | '     v := rxcheck()
0d2cc     40 01 B0 FD | 	call	#_SmartSerial_rxcheck
0d2d0     FF FF 7F FF 
0d2d4     FF A7 0D F2 | 	cmp	result1, ##-1 wz
0d2d8     F0 FF 9F AD |  if_e	jmp	#LR__1603
0d2dc     EE A6 41 FC | 	wrbyte	result1, local03
0d2e0                 | '     byte[buf++] := ser.rx
0d2e0     01 DC 05 F1 | 	add	local03, #1
0d2e4                 | '   repeat
0d2e4                 | LR__1604
0d2e4                 | '     v := rxcheck()
0d2e4     28 01 B0 FD | 	call	#_SmartSerial_rxcheck
0d2e8     FF FF 7F FF 
0d2ec     FF A7 0D F2 | 	cmp	result1, ##-1 wz
0d2f0     F0 FF 9F AD |  if_e	jmp	#LR__1604
0d2f4     EE A6 41 FC | 	wrbyte	result1, local03
0d2f8                 | '     byte[buf++] := ser.rx
0d2f8     01 DC 05 F1 | 	add	local03, #1
0d2fc                 | '   repeat
0d2fc                 | LR__1605
0d2fc                 | '     v := rxcheck()
0d2fc     10 01 B0 FD | 	call	#_SmartSerial_rxcheck
0d300     FF FF 7F FF 
0d304     FF A7 0D F2 | 	cmp	result1, ##-1 wz
0d308     F0 FF 9F AD |  if_e	jmp	#LR__1605
0d30c     02 00 00 FF 
0d310     14 90 85 F1 | 	sub	objptr, ##1044
0d314     EE A6 41 FC | 	wrbyte	result1, local03
0d318     01 DC 05 F1 | 	add	local03, #1
0d31c                 | '     len := long[startbuf]
0d31c     EC DA 01 FB | 	rdlong	local02, local01
0d320                 | '     left := len - 4
0d320     ED D8 01 F6 | 	mov	local01, local02
0d324     04 D8 85 F1 | 	sub	local01, #4
0d328                 | '     repeat while left > 0
0d328                 | LR__1606
0d328     01 D8 55 F2 | 	cmps	local01, #1 wc
0d32c     30 00 90 CD |  if_b	jmp	#LR__1608
0d330                 | '         byte[buf++] := ser.rx
0d330     02 00 00 FF 
0d334     14 90 05 F1 | 	add	objptr, ##1044
0d338                 | '   repeat
0d338                 | LR__1607
0d338                 | '     v := rxcheck()
0d338     D4 00 B0 FD | 	call	#_SmartSerial_rxcheck
0d33c     FF FF 7F FF 
0d340     FF A7 0D F2 | 	cmp	result1, ##-1 wz
0d344     F0 FF 9F AD |  if_e	jmp	#LR__1607
0d348     02 00 00 FF 
0d34c     14 90 85 F1 | 	sub	objptr, ##1044
0d350     EE A6 41 FC | 	wrbyte	result1, local03
0d354                 | '         --left
0d354     01 D8 85 F1 | 	sub	local01, #1
0d358     01 DC 05 F1 | 	add	local03, #1
0d35c     C8 FF 9F FD | 	jmp	#LR__1606
0d360                 | LR__1608
0d360                 | '     return len
0d360     ED A6 01 F6 | 	mov	result1, local02
0d364     A7 F0 03 F6 | 	mov	ptra, fp
0d368     B2 00 A0 FD | 	call	#popregs_
0d36c                 | _hostfs_sendrecv_ret
0d36c     2D 00 64 FD | 	ret
0d370                 | 
0d370                 | ' 
0d370                 | ' pub startx(rxpin, txpin, mode, baudrate) | bitperiod, bit_mode
0d370                 | _SmartSerial_startx
0d370                 | '   bitperiod := (clkfreq / baudrate)
0d370     14 24 06 FB | 	rdlong	muldiva_, #20
0d374     E4 26 02 F6 | 	mov	muldivb_, arg04
0d378     BA 00 A0 FD | 	call	#divide_
0d37c                 | ' 
0d37c                 | '   ' save parameters in the object
0d37c                 | '   rx_pin := rxpin
0d37c     C8 C2 61 FC | 	wrlong	arg01, objptr
0d380                 | '   tx_pin := txpin
0d380     04 90 05 F1 | 	add	objptr, #4
0d384     C8 C4 61 FC | 	wrlong	arg02, objptr
0d388     04 90 85 F1 | 	sub	objptr, #4
0d38c                 | ' 
0d38c                 | '   ' calculate smartpin mode for 8 bits per character
0d38c                 | '   bit_mode := 7 + (bitperiod << 16)
0d38c     10 26 66 F0 | 	shl	muldivb_, #16
0d390     07 C8 05 F6 | 	mov	arg04, #7
0d394     13 C9 01 F1 | 	add	arg04, muldivb_
0d398                 | ' 
0d398                 | '   ' set up the transmit pin
0d398                 | '   if txpin => 0
0d398     00 C4 55 F2 | 	cmps	arg02, #0 wc
0d39c                 | '     pinf(txpin)
0d39c     50 C4 61 3D |  if_ae	fltl	arg02
0d3a0                 | '     wrpin(txpin, _txmode)
0d3a0     E2 F8 08 3C |  if_ae	wrpin	#124, arg02
0d3a4                 | '     wxpin(txpin, bit_mode)
0d3a4     E2 C8 11 3C |  if_ae	wxpin	arg04, arg02
0d3a8                 | '     pinl(txpin)	' turn smartpin on by making the pin an output
0d3a8     58 C4 61 3D |  if_ae	drvl	arg02
0d3ac                 | ' 
0d3ac                 | '   ' set up the receive pin
0d3ac                 | '   if rxpin => 0
0d3ac     00 C2 55 F2 | 	cmps	arg01, #0 wc
0d3b0                 | '     pinf(rxpin)
0d3b0     50 C2 61 3D |  if_ae	fltl	arg01
0d3b4                 | '     wrpin(rxpin, _rxmode)
0d3b4     E1 7C 08 3C |  if_ae	wrpin	#62, arg01
0d3b8                 | '     wxpin(rxpin, bit_mode)
0d3b8     E1 C8 11 3C |  if_ae	wxpin	arg04, arg01
0d3bc                 | '     pinl(rxpin)  ' turn smartpin on
0d3bc     58 C2 61 3D |  if_ae	drvl	arg01
0d3c0                 | _SmartSerial_startx_ret
0d3c0     2D 00 64 FD | 	ret
0d3c4                 | 
0d3c4                 | ' 
0d3c4                 | ' ' transmit the 8 bit value "val"
0d3c4                 | ' pub tx(val)
0d3c4                 | _SmartSerial_tx
0d3c4                 | '   if tx_pin => 0
0d3c4     04 90 05 F1 | 	add	objptr, #4
0d3c8     C8 C4 01 FB | 	rdlong	arg02, objptr
0d3cc     04 90 85 F1 | 	sub	objptr, #4
0d3d0     00 C4 55 F2 | 	cmps	arg02, #0 wc
0d3d4     34 00 90 CD |  if_b	jmp	#LR__1612
0d3d8                 | '     wypin(tx_pin, val)
0d3d8     04 90 05 F1 | 	add	objptr, #4
0d3dc     C8 C4 01 FB | 	rdlong	arg02, objptr
0d3e0     E2 C2 21 FC | 	wypin	arg01, arg02
0d3e4     97 10 48 FB | 	callpa	#(@LR__1611-@LR__1610)>>2,fcache_load_ptr_
0d3e8                 | '     txflush()
0d3e8                 | '   repeat
0d3e8                 | LR__1610
0d3e8                 | '     z := pinr(tx_pin)
0d3e8     C8 C2 01 FB | 	rdlong	arg01, objptr
0d3ec     20 C2 CD F7 | 	test	arg01, #32 wz
0d3f0     FF A7 01 56 |  if_ne	mov	result1, inb
0d3f4     FE A7 01 A6 |  if_e	mov	result1, ina
0d3f8     E1 A6 41 F0 | 	shr	result1, arg01
0d3fc     06 C2 45 F0 | 	shr	arg01, #6
0d400     E1 A6 49 F7 | 	zerox	result1, arg01 wz
0d404     E0 FF 9F AD |  if_e	jmp	#LR__1610
0d408                 | LR__1611
0d408     04 90 85 F1 | 	sub	objptr, #4
0d40c                 | LR__1612
0d40c                 | _SmartSerial_tx_ret
0d40c     2D 00 64 FD | 	ret
0d410                 | 
0d410                 | '   while z == 0
0d410                 | '   
0d410                 | ' ' check if byte received (never waits)
0d410                 | ' ' returns -1 if no byte, otherwise byte
0d410                 | ' 
0d410                 | ' pub rxcheck() : rxbyte | rxpin, z
0d410                 | _SmartSerial_rxcheck
0d410                 | '   rxbyte := -1
0d410     01 AA 65 F6 | 	neg	_var01, #1
0d414                 | '   rxpin := rx_pin
0d414     C8 AC 01 FB | 	rdlong	_var02, objptr
0d418                 | '   if rxpin => 0
0d418     00 AC 55 F2 | 	cmps	_var02, #0 wc
0d41c     24 00 90 CD |  if_b	jmp	#LR__1620
0d420                 | '     z := pinr(rxpin)
0d420     D6 C2 01 F6 | 	mov	arg01, _var02
0d424     20 C2 CD F7 | 	test	arg01, #32 wz
0d428     FF A7 01 56 |  if_ne	mov	result1, inb
0d42c     FE A7 01 A6 |  if_e	mov	result1, ina
0d430     E1 A6 41 F0 | 	shr	result1, arg01
0d434     06 C2 45 F0 | 	shr	arg01, #6
0d438     E1 A6 49 F7 | 	zerox	result1, arg01 wz
0d43c                 | '     if z
0d43c                 | '       rxbyte := rdpin(rxpin)>>24
0d43c     D6 AA 89 5A |  if_ne	rdpin	_var01, _var02
0d440     18 AA 45 50 |  if_ne	shr	_var01, #24
0d444                 | LR__1620
0d444     D5 A6 01 F6 | 	mov	result1, _var01
0d448                 | _SmartSerial_rxcheck_ret
0d448     2D 00 64 FD | 	ret
0d44c                 | 
0d44c                 | ' 
0d44c                 | ' pub num(val, base, signflag, digitsNeeded) | i, digit, r1, q1
0d44c                 | _SmartSerial_num
0d44c     08 4A 05 F6 | 	mov	COUNT_, #8
0d450     A8 00 A0 FD | 	call	#pushregs_
0d454     E1 D8 01 F6 | 	mov	local01, arg01
0d458     E2 DA 01 F6 | 	mov	local02, arg02
0d45c     E3 DC 09 F6 | 	mov	local03, arg03 wz
0d460     E4 DE 01 F6 | 	mov	local04, arg04
0d464                 | ' 
0d464                 | '   '' if signflag is nonzero, it indicates we should treat
0d464                 | '   '' val as signed; if it is > 1, it is a character we should
0d464                 | '   '' print for positive numbers (typically "+")
0d464                 | '   
0d464                 | '   if (signflag)
0d464                 | '       if (val < 0)
0d464     00 D8 55 52 |  if_ne	cmps	local01, #0 wc
0d468                 | '         signflag := "-"
0d468     2D DC 05 46 |  if_c_and_nz	mov	local03, #45
0d46c                 | '         val := -val
0d46c     EC D8 61 46 |  if_c_and_nz	neg	local01, local01
0d470                 | '         
0d470                 | '   '' make sure we will not overflow our buffer
0d470                 | '   if (digitsNeeded > 32)
0d470     20 DE 75 F3 | 	fles	local04, #32 wc
0d474                 | '     digitsNeeded := 32
0d474                 | ' 
0d474                 | '   '' accumulate the digits
0d474                 | '   i := 0
0d474     00 E0 05 F6 | 	mov	local05, #0
0d478     97 4E 48 FB | 	callpa	#(@LR__1635-@LR__1630)>>2,fcache_load_ptr_
0d47c                 | '   repeat
0d47c                 | LR__1630
0d47c                 | '     if (val < 0)
0d47c     00 D8 55 F2 | 	cmps	local01, #0 wc
0d480     38 00 90 3D |  if_ae	jmp	#LR__1631
0d484                 | '       ' synthesize unsigned division from signed
0d484                 | '       ' basically shift val right by 2 to make it positive
0d484                 | '       ' then adjust the result afterwards by the bit we
0d484                 | '       ' shifted out
0d484                 | '       r1 := val&1  ' capture low bit
0d484     EC E2 01 F6 | 	mov	local06, local01
0d488     01 E2 05 F5 | 	and	local06, #1
0d48c                 | '       q1 := val>>1 ' divide val by 2
0d48c     01 D8 45 F0 | 	shr	local01, #1
0d490                 | '       digit := r1 + 2*(q1 // base)
0d490     EC 24 02 F6 | 	mov	muldiva_, local01
0d494     ED 26 02 F6 | 	mov	muldivb_, local02
0d498     BA 00 A0 FD | 	call	#divide_
0d49c     01 24 66 F0 | 	shl	muldiva_, #1
0d4a0     12 E3 01 F1 | 	add	local06, muldiva_
0d4a4                 | '       val := 2*(q1 / base)
0d4a4     01 26 66 F0 | 	shl	muldivb_, #1
0d4a8     13 D9 01 F6 | 	mov	local01, muldivb_
0d4ac                 | '       if (digit => base)
0d4ac     ED E2 51 F2 | 	cmps	local06, local02 wc
0d4b0                 | '         val++
0d4b0     01 D8 05 31 |  if_ae	add	local01, #1
0d4b4                 | '         digit -= base
0d4b4     ED E2 81 31 |  if_ae	sub	local06, local02
0d4b8     14 00 90 FD | 	jmp	#LR__1632
0d4bc                 | LR__1631
0d4bc                 | '     else
0d4bc                 | '       digit := val // base
0d4bc     EC 24 02 F6 | 	mov	muldiva_, local01
0d4c0     ED 26 02 F6 | 	mov	muldivb_, local02
0d4c4     BA 00 A0 FD | 	call	#divide_
0d4c8     12 E3 01 F6 | 	mov	local06, muldiva_
0d4cc                 | '       val := val / base
0d4cc     13 D9 01 F6 | 	mov	local01, muldivb_
0d4d0                 | LR__1632
0d4d0                 | ' 
0d4d0                 | '     if (digit => 0 and digit =< 9)
0d4d0     00 E2 55 F2 | 	cmps	local06, #0 wc
0d4d4     0C 00 90 CD |  if_b	jmp	#LR__1633
0d4d8     0A E2 55 F2 | 	cmps	local06, #10 wc
0d4dc                 | '        digit += "0"
0d4dc     30 E2 05 C1 |  if_b	add	local06, #48
0d4e0     04 00 90 CD |  if_b	jmp	#LR__1634
0d4e4                 | LR__1633
0d4e4                 | '     else
0d4e4                 | '        digit := (digit - 10) + "A"
0d4e4     37 E2 05 F1 | 	add	local06, #55
0d4e8                 | LR__1634
0d4e8                 | '     buf[i++] := digit
0d4e8     F0 E4 01 F6 | 	mov	local07, local05
0d4ec     C8 E6 01 F6 | 	mov	local08, objptr
0d4f0     08 E6 05 F1 | 	add	local08, #8
0d4f4     F3 E4 01 F1 | 	add	local07, local08
0d4f8     F2 E2 41 FC | 	wrbyte	local06, local07
0d4fc                 | '     --digitsNeeded
0d4fc     01 DE 85 F1 | 	sub	local04, #1
0d500     00 D8 0D F2 | 	cmp	local01, #0 wz
0d504     01 E0 05 F1 | 	add	local05, #1
0d508     01 DE 55 A2 |  if_e	cmps	local04, #1 wc
0d50c     08 00 90 8D |  if_c_and_z	jmp	#LR__1636
0d510     20 E0 55 F2 | 	cmps	local05, #32 wc
0d514     64 FF 9F CD |  if_b	jmp	#LR__1630
0d518                 | LR__1635
0d518                 | LR__1636
0d518                 | '   while (val <> 0 or digitsNeeded > 0) and (i < 32)
0d518                 | '   if (signflag > 1)
0d518     02 DC 55 F2 | 	cmps	local03, #2 wc
0d51c                 | '     tx(signflag)
0d51c     EE C2 01 36 |  if_ae	mov	arg01, local03
0d520     A0 FE BF 3D |  if_ae	call	#_SmartSerial_tx
0d524                 | '     
0d524                 | '   '' now print the digits in reverse order
0d524                 | '   repeat while (i > 0)
0d524                 | LR__1637
0d524     01 E0 55 F2 | 	cmps	local05, #1 wc
0d528     20 00 90 CD |  if_b	jmp	#LR__1638
0d52c                 | '     tx(buf[--i])
0d52c     01 E0 85 F1 | 	sub	local05, #1
0d530     F0 E4 01 F6 | 	mov	local07, local05
0d534     C8 E6 01 F6 | 	mov	local08, objptr
0d538     08 E6 05 F1 | 	add	local08, #8
0d53c     F3 E4 01 F1 | 	add	local07, local08
0d540     F2 C2 C1 FA | 	rdbyte	arg01, local07
0d544     7C FE BF FD | 	call	#_SmartSerial_tx
0d548     D8 FF 9F FD | 	jmp	#LR__1637
0d54c                 | LR__1638
0d54c     A7 F0 03 F6 | 	mov	ptra, fp
0d550     B2 00 A0 FD | 	call	#popregs_
0d554                 | _SmartSerial_num_ret
0d554     2D 00 64 FD | 	ret
0d558                 | 
0d558                 | ' 
0d558                 | ' '' print a hex number with the specified number
0d558                 | ' '' of digits; 0 means just use as many as we need
0d558                 | ' pub hex(val, digits = 8) | mask
0d558                 | _SmartSerial_hex
0d558     04 4A 05 F6 | 	mov	COUNT_, #4
0d55c     A8 00 A0 FD | 	call	#pushregs_
0d560     E1 D8 01 F6 | 	mov	local01, arg01
0d564     E2 DA 01 F6 | 	mov	local02, arg02
0d568                 | '   if digits > 0 and digits < 8
0d568     01 DA 55 F2 | 	cmps	local02, #1 wc
0d56c     18 00 90 CD |  if_b	jmp	#LR__1640
0d570     08 DA 55 F2 | 	cmps	local02, #8 wc
0d574                 | '     mask := (|< (4*digits)) - 1
0d574     ED DC 01 C6 |  if_b	mov	local03, local02
0d578     02 DC 65 C0 |  if_b	shl	local03, #2
0d57c     EE DE C1 C9 |  if_b	decod	local04, local03
0d580     01 DE 85 C1 |  if_b	sub	local04, #1
0d584                 | '     val &= mask
0d584     EF D8 01 C5 |  if_b	and	local01, local04
0d588                 | LR__1640
0d588                 | '   num(val, 16, 0, digits)
0d588     EC C2 01 F6 | 	mov	arg01, local01
0d58c     10 C4 05 F6 | 	mov	arg02, #16
0d590     00 C6 05 F6 | 	mov	arg03, #0
0d594     ED C8 01 F6 | 	mov	arg04, local02
0d598     B0 FE BF FD | 	call	#_SmartSerial_num
0d59c     A7 F0 03 F6 | 	mov	ptra, fp
0d5a0     B2 00 A0 FD | 	call	#popregs_
0d5a4                 | _SmartSerial_hex_ret
0d5a4     2D 00 64 FD | 	ret
0d5a8                 | 
0d5a8                 | ' 
0d5a8                 | ' ''
0d5a8                 | ' '' C like formatted print
0d5a8                 | ' ''
0d5a8                 | ' pub printf(fmt = string(""), an=0, bn=0, cn=0, dn=0, en=0, fn=0) | c, valptr, val
0d5a8                 | _SmartSerial_printf
0d5a8     06 4A 05 F6 | 	mov	COUNT_, #6
0d5ac     A8 00 A0 FD | 	call	#pushregs_
0d5b0     30 F0 07 F1 | 	add	ptra, #48
0d5b4     A7 C2 61 FC | 	wrlong	arg01, fp
0d5b8     04 4E 05 F1 | 	add	fp, #4
0d5bc     A7 C4 61 FC | 	wrlong	arg02, fp
0d5c0     04 4E 05 F1 | 	add	fp, #4
0d5c4     A7 C6 61 FC | 	wrlong	arg03, fp
0d5c8     04 4E 05 F1 | 	add	fp, #4
0d5cc     A7 C8 61 FC | 	wrlong	arg04, fp
0d5d0     04 4E 05 F1 | 	add	fp, #4
0d5d4     A7 CA 61 FC | 	wrlong	arg05, fp
0d5d8     04 4E 05 F1 | 	add	fp, #4
0d5dc     A7 CC 61 FC | 	wrlong	arg06, fp
0d5e0     04 4E 05 F1 | 	add	fp, #4
0d5e4     A7 CE 61 FC | 	wrlong	arg07, fp
0d5e8                 | '   valptr := @an
0d5e8     14 4E 85 F1 | 	sub	fp, #20
0d5ec     A7 D8 01 F6 | 	mov	local01, fp
0d5f0     1C 4E 05 F1 | 	add	fp, #28
0d5f4     A7 D8 61 FC | 	wrlong	local01, fp
0d5f8     20 4E 85 F1 | 	sub	fp, #32
0d5fc                 | '   repeat
0d5fc                 | LR__1650
0d5fc                 | '     c := byte[fmt++]
0d5fc     A7 D8 01 FB | 	rdlong	local01, fp
0d600     EC CE 01 F6 | 	mov	arg07, local01
0d604     01 CE 05 F1 | 	add	arg07, #1
0d608     A7 CE 61 FC | 	wrlong	arg07, fp
0d60c     EC D8 C9 FA | 	rdbyte	local01, local01 wz
0d610     1C 4E 05 F1 | 	add	fp, #28
0d614     A7 D8 61 FC | 	wrlong	local01, fp
0d618                 | '     if (c == 0)
0d618     1C 4E 85 F1 | 	sub	fp, #28
0d61c                 | '       quit
0d61c     FC 01 90 AD |  if_e	jmp	#LR__1664
0d620                 | '     if c == "%"
0d620     1C 4E 05 F1 | 	add	fp, #28
0d624     A7 D8 01 FB | 	rdlong	local01, fp
0d628     1C 4E 85 F1 | 	sub	fp, #28
0d62c     25 D8 0D F2 | 	cmp	local01, #37 wz
0d630     34 01 90 5D |  if_ne	jmp	#LR__1658
0d634                 | '       c := byte[fmt++]
0d634     A7 D8 01 FB | 	rdlong	local01, fp
0d638     EC CE 01 F6 | 	mov	arg07, local01
0d63c     01 CE 05 F1 | 	add	arg07, #1
0d640     A7 CE 61 FC | 	wrlong	arg07, fp
0d644     EC D8 C9 FA | 	rdbyte	local01, local01 wz
0d648     1C 4E 05 F1 | 	add	fp, #28
0d64c     A7 D8 61 FC | 	wrlong	local01, fp
0d650                 | '       if (c == 0)
0d650     1C 4E 85 F1 | 	sub	fp, #28
0d654                 | '         quit
0d654     C4 01 90 AD |  if_e	jmp	#LR__1664
0d658                 | '       if (c == "%")
0d658     1C 4E 05 F1 | 	add	fp, #28
0d65c     A7 D8 01 FB | 	rdlong	local01, fp
0d660     1C 4E 85 F1 | 	sub	fp, #28
0d664     25 D8 0D F2 | 	cmp	local01, #37 wz
0d668     14 00 90 5D |  if_ne	jmp	#LR__1651
0d66c                 | '         tx(c)
0d66c     1C 4E 05 F1 | 	add	fp, #28
0d670     A7 C2 01 FB | 	rdlong	arg01, fp
0d674     1C 4E 85 F1 | 	sub	fp, #28
0d678     48 FD BF FD | 	call	#_SmartSerial_tx
0d67c                 | '         next
0d67c     7C FF 9F FD | 	jmp	#LR__1650
0d680                 | LR__1651
0d680                 | '       val := long[valptr]
0d680     20 4E 05 F1 | 	add	fp, #32
0d684     A7 D8 01 FB | 	rdlong	local01, fp
0d688     EC DA 01 FB | 	rdlong	local02, local01
0d68c     04 4E 05 F1 | 	add	fp, #4
0d690     A7 DA 61 FC | 	wrlong	local02, fp
0d694                 | '       valptr += 4
0d694     04 4E 85 F1 | 	sub	fp, #4
0d698     A7 D8 01 FB | 	rdlong	local01, fp
0d69c     04 D8 05 F1 | 	add	local01, #4
0d6a0     A7 D8 61 FC | 	wrlong	local01, fp
0d6a4                 | '       case c
0d6a4     04 4E 85 F1 | 	sub	fp, #4
0d6a8     A7 DC 01 FB | 	rdlong	local03, fp
0d6ac     1C 4E 85 F1 | 	sub	fp, #28
0d6b0     64 DC 0D F2 | 	cmp	local03, #100 wz
0d6b4     24 00 90 AD |  if_e	jmp	#LR__1652
0d6b8     75 DC 0D F2 | 	cmp	local03, #117 wz
0d6bc     3C 00 90 AD |  if_e	jmp	#LR__1653
0d6c0     78 DC 0D F2 | 	cmp	local03, #120 wz
0d6c4     54 00 90 AD |  if_e	jmp	#LR__1654
0d6c8     73 DC 0D F2 | 	cmp	local03, #115 wz
0d6cc     64 00 90 AD |  if_e	jmp	#LR__1655
0d6d0     63 DC 0D F2 | 	cmp	local03, #99 wz
0d6d4     7C 00 90 AD |  if_e	jmp	#LR__1657
0d6d8     20 FF 9F FD | 	jmp	#LR__1650
0d6dc                 | LR__1652
0d6dc                 | '         "d": dec(val)
0d6dc     24 4E 05 F1 | 	add	fp, #36
0d6e0     A7 C2 01 FB | 	rdlong	arg01, fp
0d6e4     24 4E 85 F1 | 	sub	fp, #36
0d6e8                 | '   num(val, 10, 1, 0)
0d6e8     0A C4 05 F6 | 	mov	arg02, #10
0d6ec     01 C6 05 F6 | 	mov	arg03, #1
0d6f0     00 C8 05 F6 | 	mov	arg04, #0
0d6f4     54 FD BF FD | 	call	#_SmartSerial_num
0d6f8     00 FF 9F FD | 	jmp	#LR__1650
0d6fc                 | LR__1653
0d6fc                 | '         "u": decuns(val)
0d6fc     24 4E 05 F1 | 	add	fp, #36
0d700     A7 C2 01 FB | 	rdlong	arg01, fp
0d704     24 4E 85 F1 | 	sub	fp, #36
0d708                 | '   num(val, 10, 0, digits)
0d708     00 C8 05 F6 | 	mov	arg04, #0
0d70c     0A C4 05 F6 | 	mov	arg02, #10
0d710     00 C6 05 F6 | 	mov	arg03, #0
0d714     34 FD BF FD | 	call	#_SmartSerial_num
0d718     E0 FE 9F FD | 	jmp	#LR__1650
0d71c                 | LR__1654
0d71c                 | '         "x": hex(val)
0d71c     24 4E 05 F1 | 	add	fp, #36
0d720     A7 C2 01 FB | 	rdlong	arg01, fp
0d724     24 4E 85 F1 | 	sub	fp, #36
0d728     08 C4 05 F6 | 	mov	arg02, #8
0d72c     28 FE BF FD | 	call	#_SmartSerial_hex
0d730     C8 FE 9F FD | 	jmp	#LR__1650
0d734                 | LR__1655
0d734                 | '         "s": str(val)
0d734     24 4E 05 F1 | 	add	fp, #36
0d738     A7 DE 01 FB | 	rdlong	local04, fp
0d73c     24 4E 85 F1 | 	sub	fp, #36
0d740                 | '   repeat while ((c := byte[s++]) <> 0)
0d740                 | LR__1656
0d740     EF C2 C9 FA | 	rdbyte	arg01, local04 wz
0d744     01 DE 05 F1 | 	add	local04, #1
0d748     B0 FE 9F AD |  if_e	jmp	#LR__1650
0d74c                 | '     tx(c)
0d74c     74 FC BF FD | 	call	#_SmartSerial_tx
0d750     EC FF 9F FD | 	jmp	#LR__1656
0d754                 | LR__1657
0d754                 | '         "c": tx(val)
0d754     24 4E 05 F1 | 	add	fp, #36
0d758     A7 C2 01 FB | 	rdlong	arg01, fp
0d75c     24 4E 85 F1 | 	sub	fp, #36
0d760     60 FC BF FD | 	call	#_SmartSerial_tx
0d764     94 FE 9F FD | 	jmp	#LR__1650
0d768                 | LR__1658
0d768                 | '     elseif c == "\"
0d768     1C 4E 05 F1 | 	add	fp, #28
0d76c     A7 D8 01 FB | 	rdlong	local01, fp
0d770     1C 4E 85 F1 | 	sub	fp, #28
0d774     5C D8 0D F2 | 	cmp	local01, #92 wz
0d778     8C 00 90 5D |  if_ne	jmp	#LR__1663
0d77c                 | '       c := byte[fmt++]
0d77c     A7 D8 01 FB | 	rdlong	local01, fp
0d780     EC E0 01 F6 | 	mov	local05, local01
0d784     01 E0 05 F1 | 	add	local05, #1
0d788     A7 E0 61 FC | 	wrlong	local05, fp
0d78c     EC DA C9 FA | 	rdbyte	local02, local01 wz
0d790     1C 4E 05 F1 | 	add	fp, #28
0d794     A7 DA 61 FC | 	wrlong	local02, fp
0d798                 | '       if c == 0
0d798     1C 4E 85 F1 | 	sub	fp, #28
0d79c                 | '         quit
0d79c     7C 00 90 AD |  if_e	jmp	#LR__1664
0d7a0                 | '       case c
0d7a0     1C 4E 05 F1 | 	add	fp, #28
0d7a4     A7 E2 01 FB | 	rdlong	local06, fp
0d7a8     1C 4E 85 F1 | 	sub	fp, #28
0d7ac     6E E2 0D F2 | 	cmp	local06, #110 wz
0d7b0     14 00 90 AD |  if_e	jmp	#LR__1659
0d7b4     72 E2 0D F2 | 	cmp	local06, #114 wz
0d7b8     20 00 90 AD |  if_e	jmp	#LR__1660
0d7bc     74 E2 0D F2 | 	cmp	local06, #116 wz
0d7c0     24 00 90 AD |  if_e	jmp	#LR__1661
0d7c4     2C 00 90 FD | 	jmp	#LR__1662
0d7c8                 | LR__1659
0d7c8                 | '         "n": nl
0d7c8                 | '   tx(13)
0d7c8     0D C2 05 F6 | 	mov	arg01, #13
0d7cc     F4 FB BF FD | 	call	#_SmartSerial_tx
0d7d0                 | '   tx(10)
0d7d0     0A C2 05 F6 | 	mov	arg01, #10
0d7d4     EC FB BF FD | 	call	#_SmartSerial_tx
0d7d8     20 FE 9F FD | 	jmp	#LR__1650
0d7dc                 | LR__1660
0d7dc                 | '         "r": tx(13)
0d7dc     0D C2 05 F6 | 	mov	arg01, #13
0d7e0     E0 FB BF FD | 	call	#_SmartSerial_tx
0d7e4     14 FE 9F FD | 	jmp	#LR__1650
0d7e8                 | LR__1661
0d7e8                 | '         "t": tx(8)
0d7e8     08 C2 05 F6 | 	mov	arg01, #8
0d7ec     D4 FB BF FD | 	call	#_SmartSerial_tx
0d7f0     08 FE 9F FD | 	jmp	#LR__1650
0d7f4                 | LR__1662
0d7f4                 | '         other: tx(c)
0d7f4     1C 4E 05 F1 | 	add	fp, #28
0d7f8     A7 C2 01 FB | 	rdlong	arg01, fp
0d7fc     1C 4E 85 F1 | 	sub	fp, #28
0d800     C0 FB BF FD | 	call	#_SmartSerial_tx
0d804     F4 FD 9F FD | 	jmp	#LR__1650
0d808                 | LR__1663
0d808                 | '     else
0d808                 | '       tx(c)
0d808     1C 4E 05 F1 | 	add	fp, #28
0d80c     A7 C2 01 FB | 	rdlong	arg01, fp
0d810     1C 4E 85 F1 | 	sub	fp, #28
0d814     AC FB BF FD | 	call	#_SmartSerial_tx
0d818     E0 FD 9F FD | 	jmp	#LR__1650
0d81c                 | LR__1664
0d81c     A7 F0 03 F6 | 	mov	ptra, fp
0d820     B2 00 A0 FD | 	call	#popregs_
0d824                 | _SmartSerial_printf_ret
0d824     2D 00 64 FD | 	ret
0d828                 | 
0d828                 | _fs9p_cc_strncmp
0d828     E1 AA 09 F6 | 	mov	_var01, arg01 wz
0d82c     14 00 90 5D |  if_ne	jmp	#LR__1670
0d830                 | ' 		return scan2 ? -1 : 0;
0d830     00 C4 0D F2 | 	cmp	arg02, #0 wz
0d834     01 AC 65 56 |  if_ne	neg	_var02, #1
0d838     00 AC 05 A6 |  if_e	mov	_var02, #0
0d83c     D6 A6 01 F6 | 	mov	result1, _var02
0d840     74 00 90 FD | 	jmp	#_fs9p_cc_strncmp_ret
0d844                 | LR__1670
0d844     00 C4 0D F2 | 	cmp	arg02, #0 wz
0d848     01 A6 05 A6 |  if_e	mov	result1, #1
0d84c     68 00 90 AD |  if_e	jmp	#_fs9p_cc_strncmp_ret
0d850     E3 AE 01 F6 | 	mov	_var03, arg03
0d854     97 16 48 FB | 	callpa	#(@LR__1672-@LR__1671)>>2,fcache_load_ptr_
0d858                 | ' 	count = n;
0d858                 | ' 	do {
0d858                 | LR__1671
0d858     D5 B0 C1 FA | 	rdbyte	_var04, _var01
0d85c     E2 B2 01 F6 | 	mov	_var05, arg02
0d860     D9 B4 C1 FA | 	rdbyte	_var06, _var05
0d864     01 AE 85 F1 | 	sub	_var03, #1
0d868     00 AE 55 F2 | 	cmps	_var03, #0 wc
0d86c     01 AA 05 F1 | 	add	_var01, #1
0d870     01 C4 05 F1 | 	add	arg02, #1
0d874     00 B0 0D 32 |  if_ae	cmp	_var04, #0 wz
0d878     08 00 90 2D |  if_nc_and_z	jmp	#LR__1673
0d87c     DA B0 09 32 |  if_ae	cmp	_var04, _var06 wz
0d880     D4 FF 9F 2D |  if_nc_and_z	jmp	#LR__1671
0d884                 | LR__1672
0d884                 | LR__1673
0d884     00 AE 55 F2 | 	cmps	_var03, #0 wc
0d888                 | ' 		return(0);
0d888     00 A6 05 C6 |  if_b	mov	result1, #0
0d88c     28 00 90 CD |  if_b	jmp	#_fs9p_cc_strncmp_ret
0d890     DA B0 09 F2 | 	cmp	_var04, _var06 wz
0d894                 | ' 		return(0);
0d894     00 A6 05 A6 |  if_e	mov	result1, #0
0d898     1C 00 90 AD |  if_e	jmp	#_fs9p_cc_strncmp_ret
0d89c     00 B0 0D F2 | 	cmp	_var04, #0 wz
0d8a0                 | ' 		return(-1);
0d8a0     01 A6 65 A6 |  if_e	neg	result1, #1
0d8a4     10 00 90 AD |  if_e	jmp	#_fs9p_cc_strncmp_ret
0d8a8     00 B4 0D F2 | 	cmp	_var06, #0 wz
0d8ac                 | ' 		return(1);
0d8ac     01 A6 05 A6 |  if_e	mov	result1, #1
0d8b0                 | ' 		return(c1 - c2);
0d8b0     D8 A6 01 56 |  if_ne	mov	result1, _var04
0d8b4     DA A6 81 51 |  if_ne	sub	result1, _var06
0d8b8                 | _fs9p_cc_strncmp_ret
0d8b8     2D 00 64 FD | 	ret
0d8bc                 | 
0d8bc                 | _fs9p_cc_fs_init
0d8bc     04 4A 05 F6 | 	mov	COUNT_, #4
0d8c0     A8 00 A0 FD | 	call	#pushregs_
0d8c4     E1 D8 01 F6 | 	mov	local01, arg01
0d8c8     08 90 05 F1 | 	add	objptr, #8
0d8cc     C8 D8 61 FC | 	wrlong	local01, objptr
0d8d0     08 90 85 F1 | 	sub	objptr, #8
0d8d4     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0d8d8     04 C2 05 F1 | 	add	arg01, #4
0d8dc     00 C4 05 F6 | 	mov	arg02, #0
0d8e0     04 02 B0 FD | 	call	#_fs9p_cc_doPut4_0246
0d8e4     D3 C8 48 FC | 	wrbyte	#100, result1
0d8e8                 | '     *ptr++ = x;
0d8e8                 | '     return ptr;
0d8e8     01 A6 05 F1 | 	add	result1, #1
0d8ec     0F C4 CD F9 | 	bmask	arg02, #15
0d8f0     E2 C4 E1 F8 | 	getbyte	arg02, arg02, #0
0d8f4     D3 C4 41 FC | 	wrbyte	arg02, result1
0d8f8                 | '     *ptr++ = x;
0d8f8                 | '     return ptr;
0d8f8     01 A6 05 F1 | 	add	result1, #1
0d8fc     D3 FE 49 FC | 	wrbyte	#255, result1
0d900                 | '     *ptr++ = x;
0d900                 | '     return ptr;
0d900     01 A6 05 F1 | 	add	result1, #1
0d904                 | '     ptr = doPut1(ptr, x & 0xff);
0d904                 | '     ptr = doPut1(ptr, (x>>8) & 0xff);
0d904                 | '     return ptr;
0d904     D3 C2 01 F6 | 	mov	arg01, result1
0d908     02 00 00 FF 
0d90c     18 C4 05 F6 | 	mov	arg02, ##1048
0d910     D4 01 B0 FD | 	call	#_fs9p_cc_doPut4_0246
0d914     D3 C2 01 F6 | 	mov	arg01, result1
0d918     7D 00 00 FF 
0d91c     4C C5 05 F6 | 	mov	arg02, ##@LR__2139
0d920     00 02 B0 FD | 	call	#_fs9p_cc_doPutStr_0249
0d924     D3 C4 01 F6 | 	mov	arg02, result1
0d928     EC DA 01 F6 | 	mov	local02, local01
0d92c     13 D8 45 F7 | 	zerox	local01, #19
0d930     14 DA 45 F0 | 	shr	local02, #20
0d934     02 DA 65 F0 | 	shl	local02, #2
0d938     C5 DA 01 F1 | 	add	local02, __methods__
0d93c     ED DA 01 FB | 	rdlong	local02, local02
0d940     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0d944     04 C2 05 F1 | 	add	arg01, #4
0d948     02 00 00 FF 
0d94c     18 C6 05 F6 | 	mov	arg03, ##1048
0d950     C8 DC 01 F6 | 	mov	local03, objptr
0d954     EC 90 01 F6 | 	mov	objptr, local01
0d958     2D DA 61 FD | 	call	local02
0d95c     EE 90 01 F6 | 	mov	objptr, local03
0d960     CC DC 01 F6 | 	mov	local03, ptr__fs9p_cc_dat__
0d964     08 DC 05 F1 | 	add	local03, #8
0d968     EE DA C1 FA | 	rdbyte	local02, local03
0d96c     65 DA 0D F2 | 	cmp	local02, #101 wz
0d970                 | '         return -1;
0d970     01 A6 65 56 |  if_ne	neg	result1, #1
0d974     40 01 90 5D |  if_ne	jmp	#LR__1684
0d978                 | '     r = b[0];
0d978                 | '     r |= (b[1]<<8);
0d978                 | '     return r;
0d978     EE C2 01 F6 | 	mov	arg01, local03
0d97c     03 C2 05 F1 | 	add	arg01, #3
0d980     18 02 B0 FD | 	call	#_fs9p_cc_FETCH4_0253
0d984     D3 DE 01 F6 | 	mov	local04, result1
0d988     EE C2 01 F6 | 	mov	arg01, local03
0d98c     07 C2 05 F1 | 	add	arg01, #7
0d990     E1 A6 C1 FA | 	rdbyte	result1, arg01
0d994     01 C2 05 F1 | 	add	arg01, #1
0d998     E1 C2 C1 FA | 	rdbyte	arg01, arg01
0d99c     08 C2 65 F0 | 	shl	arg01, #8
0d9a0     E1 A6 41 F5 | 	or	result1, arg01
0d9a4                 | '     r = b[0];
0d9a4                 | '     r |= (b[1]<<8);
0d9a4                 | '     return r;
0d9a4     06 A6 0D F2 | 	cmp	result1, #6 wz
0d9a8     20 00 90 5D |  if_ne	jmp	#LR__1680
0d9ac     09 DC 05 F1 | 	add	local03, #9
0d9b0     7D 00 00 FF 
0d9b4     53 C5 05 F6 | 	mov	arg02, ##@LR__2140
0d9b8     EE C2 01 F6 | 	mov	arg01, local03
0d9bc     06 C6 05 F6 | 	mov	arg03, #6
0d9c0     64 FE BF FD | 	call	#_fs9p_cc_strncmp
0d9c4     00 A6 0D F2 | 	cmp	result1, #0 wz
0d9c8     08 00 90 AD |  if_e	jmp	#LR__1681
0d9cc                 | LR__1680
0d9cc                 | ' 
0d9cc                 | '         return -1;
0d9cc     01 A6 65 F6 | 	neg	result1, #1
0d9d0     E4 00 90 FD | 	jmp	#LR__1684
0d9d4                 | LR__1681
0d9d4     40 DE 15 F2 | 	cmp	local04, #64 wc
0d9d8     0C 00 90 CD |  if_b	jmp	#LR__1682
0d9dc     02 00 00 FF 
0d9e0     19 DE 15 F2 | 	cmp	local04, ##1049 wc
0d9e4     08 00 90 CD |  if_b	jmp	#LR__1683
0d9e8                 | LR__1682
0d9e8                 | ' 
0d9e8                 | '         return -1;
0d9e8     01 A6 65 F6 | 	neg	result1, #1
0d9ec     C8 00 90 FD | 	jmp	#LR__1684
0d9f0                 | LR__1683
0d9f0     CC DE 61 FC | 	wrlong	local04, ptr__fs9p_cc_dat__
0d9f4     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0d9f8     04 C2 05 F1 | 	add	arg01, #4
0d9fc     00 C4 05 F6 | 	mov	arg02, #0
0da00     E4 00 B0 FD | 	call	#_fs9p_cc_doPut4_0246
0da04     D3 D0 48 FC | 	wrbyte	#104, result1
0da08                 | '     *ptr++ = x;
0da08                 | '     return ptr;
0da08     01 A6 05 F1 | 	add	result1, #1
0da0c     0F C4 CD F9 | 	bmask	arg02, #15
0da10     E2 C4 E1 F8 | 	getbyte	arg02, arg02, #0
0da14     D3 C4 41 FC | 	wrbyte	arg02, result1
0da18                 | '     *ptr++ = x;
0da18                 | '     return ptr;
0da18     01 A6 05 F1 | 	add	result1, #1
0da1c     D3 FE 49 FC | 	wrbyte	#255, result1
0da20                 | '     *ptr++ = x;
0da20                 | '     return ptr;
0da20     01 A6 05 F1 | 	add	result1, #1
0da24                 | '     ptr = doPut1(ptr, x & 0xff);
0da24                 | '     ptr = doPut1(ptr, (x>>8) & 0xff);
0da24                 | '     return ptr;
0da24     D3 C2 01 F6 | 	mov	arg01, result1
0da28     C8 C4 01 F6 | 	mov	arg02, objptr
0da2c     B8 00 B0 FD | 	call	#_fs9p_cc_doPut4_0246
0da30     D3 C2 01 F6 | 	mov	arg01, result1
0da34     01 C4 65 F6 | 	neg	arg02, #1
0da38     AC 00 B0 FD | 	call	#_fs9p_cc_doPut4_0246
0da3c     D3 C2 01 F6 | 	mov	arg01, result1
0da40     7D 00 00 FF 
0da44     5A C5 05 F6 | 	mov	arg02, ##@LR__2141
0da48     D8 00 B0 FD | 	call	#_fs9p_cc_doPutStr_0249
0da4c     D3 C2 01 F6 | 	mov	arg01, result1
0da50     7D 00 00 FF 
0da54     5F C5 05 F6 | 	mov	arg02, ##@LR__2142
0da58     C8 00 B0 FD | 	call	#_fs9p_cc_doPutStr_0249
0da5c     D3 C4 01 F6 | 	mov	arg02, result1
0da60     08 90 05 F1 | 	add	objptr, #8
0da64     C8 DA 01 FB | 	rdlong	local02, objptr
0da68     ED DE 01 F6 | 	mov	local04, local02
0da6c     08 90 85 F1 | 	sub	objptr, #8
0da70     13 DE 45 F7 | 	zerox	local04, #19
0da74     14 DA 45 F0 | 	shr	local02, #20
0da78     02 DA 65 F0 | 	shl	local02, #2
0da7c     C5 DA 01 F1 | 	add	local02, __methods__
0da80     ED DA 01 FB | 	rdlong	local02, local02
0da84     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0da88     04 C2 05 F1 | 	add	arg01, #4
0da8c     CC C6 01 FB | 	rdlong	arg03, ptr__fs9p_cc_dat__
0da90     C8 DC 01 F6 | 	mov	local03, objptr
0da94     EF 90 01 F6 | 	mov	objptr, local04
0da98     2D DA 61 FD | 	call	local02
0da9c     EE 90 01 F6 | 	mov	objptr, local03
0daa0     CC DC 01 F6 | 	mov	local03, ptr__fs9p_cc_dat__
0daa4     08 DC 05 F1 | 	add	local03, #8
0daa8     EE DE C1 FA | 	rdbyte	local04, local03
0daac     69 DE 0D F2 | 	cmp	local04, #105 wz
0dab0                 | ' 
0dab0                 | '         return -1;
0dab0     01 A6 65 56 |  if_ne	neg	result1, #1
0dab4                 | '     }
0dab4                 | '     return 0;
0dab4     00 A6 05 A6 |  if_e	mov	result1, #0
0dab8                 | LR__1684
0dab8     A7 F0 03 F6 | 	mov	ptra, fp
0dabc     B2 00 A0 FD | 	call	#popregs_
0dac0                 | _fs9p_cc_fs_init_ret
0dac0     2D 00 64 FD | 	ret
0dac4                 | 
0dac4                 | _fs9p_cc_doPut2_0245
0dac4     E2 A6 01 F6 | 	mov	result1, arg02
0dac8     E2 C4 E1 F8 | 	getbyte	arg02, arg02, #0
0dacc     E1 C4 41 FC | 	wrbyte	arg02, arg01
0dad0                 | '     *ptr++ = x;
0dad0                 | '     return ptr;
0dad0     01 C2 05 F1 | 	add	arg01, #1
0dad4     D3 C4 E9 F8 | 	getbyte	arg02, result1, #1
0dad8     E1 C4 41 FC | 	wrbyte	arg02, arg01
0dadc                 | '     *ptr++ = x;
0dadc                 | '     return ptr;
0dadc     01 C2 05 F1 | 	add	arg01, #1
0dae0     E1 A6 01 F6 | 	mov	result1, arg01
0dae4                 | '     ptr = doPut1(ptr, x & 0xff);
0dae4                 | '     ptr = doPut1(ptr, (x>>8) & 0xff);
0dae4                 | '     return ptr;
0dae4                 | _fs9p_cc_doPut2_0245_ret
0dae4     2D 00 64 FD | 	ret
0dae8                 | 
0dae8                 | _fs9p_cc_doPut4_0246
0dae8     E2 A6 01 F6 | 	mov	result1, arg02
0daec     E2 C4 E1 F8 | 	getbyte	arg02, arg02, #0
0daf0     E1 C4 41 FC | 	wrbyte	arg02, arg01
0daf4                 | '     *ptr++ = x;
0daf4                 | '     return ptr;
0daf4     01 C2 05 F1 | 	add	arg01, #1
0daf8     D3 C4 E9 F8 | 	getbyte	arg02, result1, #1
0dafc     E1 C4 41 FC | 	wrbyte	arg02, arg01
0db00                 | '     *ptr++ = x;
0db00                 | '     return ptr;
0db00     01 C2 05 F1 | 	add	arg01, #1
0db04     D3 C4 F1 F8 | 	getbyte	arg02, result1, #2
0db08     E1 C4 41 FC | 	wrbyte	arg02, arg01
0db0c                 | '     *ptr++ = x;
0db0c                 | '     return ptr;
0db0c     01 C2 05 F1 | 	add	arg01, #1
0db10     D3 C4 F9 F8 | 	getbyte	arg02, result1, #3
0db14     E1 C4 41 FC | 	wrbyte	arg02, arg01
0db18                 | '     *ptr++ = x;
0db18                 | '     return ptr;
0db18     01 C2 05 F1 | 	add	arg01, #1
0db1c     E1 A6 01 F6 | 	mov	result1, arg01
0db20                 | '     ptr = doPut1(ptr, x & 0xff);
0db20                 | '     ptr = doPut1(ptr, (x>>8) & 0xff);
0db20                 | '     ptr = doPut1(ptr, (x>>16) & 0xff);
0db20                 | '     ptr = doPut1(ptr, (x>>24) & 0xff);
0db20                 | '     return ptr;
0db20                 | _fs9p_cc_doPut4_0246_ret
0db20     2D 00 64 FD | 	ret
0db24                 | 
0db24                 | _fs9p_cc_doPutStr_0249
0db24     04 4A 05 F6 | 	mov	COUNT_, #4
0db28     A8 00 A0 FD | 	call	#pushregs_
0db2c     E1 D8 01 F6 | 	mov	local01, arg01
0db30     E2 DA 01 F6 | 	mov	local02, arg02
0db34     ED C2 01 F6 | 	mov	arg01, local02
0db38     E1 DC 01 F6 | 	mov	local03, arg01
0db3c     97 06 48 FB | 	callpa	#(@LR__1691-@LR__1690)>>2,fcache_load_ptr_
0db40                 | LR__1690
0db40     EE A6 C9 FA | 	rdbyte	result1, local03 wz
0db44     01 DC 05 51 |  if_ne	add	local03, #1
0db48     F4 FF 9F 5D |  if_ne	jmp	#LR__1690
0db4c                 | LR__1691
0db4c     E1 DC 81 F1 | 	sub	local03, arg01
0db50     EE C4 01 F6 | 	mov	arg02, local03
0db54     EC C2 01 F6 | 	mov	arg01, local01
0db58     68 FF BF FD | 	call	#_fs9p_cc_doPut2_0245
0db5c     D3 D8 01 F6 | 	mov	local01, result1
0db60                 | '     ptr = doPut2(ptr, L);
0db60                 | '     for (i = 0; i < L; i++) {
0db60     01 DC 15 F2 | 	cmp	local03, #1 wc
0db64     24 00 90 CD |  if_b	jmp	#LR__1696
0db68     EE DE 01 F6 | 	mov	local04, local03
0db6c     97 0E 48 FB | 	callpa	#(@LR__1694-@LR__1692)>>2,fcache_load_ptr_
0db70                 | LR__1692
0db70     EF 0C D8 FC | 	rep	@LR__1695, local04
0db74                 | LR__1693
0db74     ED DE 01 F6 | 	mov	local04, local02
0db78     01 DE 05 F1 | 	add	local04, #1
0db7c     ED DC C1 FA | 	rdbyte	local03, local02
0db80     EF DA 01 F6 | 	mov	local02, local04
0db84     EC DC 41 FC | 	wrbyte	local03, local01
0db88     01 D8 05 F1 | 	add	local01, #1
0db8c                 | LR__1694
0db8c                 | LR__1695
0db8c                 | LR__1696
0db8c                 | '         *ptr++ = *s++;
0db8c                 | '     }
0db8c                 | '     return ptr;
0db8c     EC A6 01 F6 | 	mov	result1, local01
0db90     A7 F0 03 F6 | 	mov	ptra, fp
0db94     B2 00 A0 FD | 	call	#popregs_
0db98                 | _fs9p_cc_doPutStr_0249_ret
0db98     2D 00 64 FD | 	ret
0db9c                 | 
0db9c                 | _fs9p_cc_FETCH4_0253
0db9c     E1 A6 C1 FA | 	rdbyte	result1, arg01
0dba0     01 C2 05 F1 | 	add	arg01, #1
0dba4     E1 AA C1 FA | 	rdbyte	_var01, arg01
0dba8     08 AA 65 F0 | 	shl	_var01, #8
0dbac     D5 A6 41 F5 | 	or	result1, _var01
0dbb0     01 C2 05 F1 | 	add	arg01, #1
0dbb4     E1 AA C1 FA | 	rdbyte	_var01, arg01
0dbb8     10 AA 65 F0 | 	shl	_var01, #16
0dbbc     D5 A6 41 F5 | 	or	result1, _var01
0dbc0     01 C2 05 F1 | 	add	arg01, #1
0dbc4     E1 AA C1 FA | 	rdbyte	_var01, arg01
0dbc8     18 AA 65 F0 | 	shl	_var01, #24
0dbcc     D5 A6 41 F5 | 	or	result1, _var01
0dbd0                 | '     r = b[0];
0dbd0                 | '     r |= (b[1]<<8);
0dbd0                 | '     r |= (b[2]<<16);
0dbd0                 | '     r |= (b[3]<<24);
0dbd0                 | '     return r;
0dbd0                 | _fs9p_cc_FETCH4_0253_ret
0dbd0     2D 00 64 FD | 	ret
0dbd4                 | 
0dbd4                 | _fs9p_cc_do_fs_walk_0267
0dbd4     09 4A 05 F6 | 	mov	COUNT_, #9
0dbd8     A8 00 A0 FD | 	call	#pushregs_
0dbdc     E1 D8 01 F6 | 	mov	local01, arg01
0dbe0     E2 DA 01 F6 | 	mov	local02, arg02
0dbe4     E3 DC 01 F6 | 	mov	local03, arg03
0dbe8     E4 DE 01 F6 | 	mov	local04, arg04
0dbec     00 E0 05 F6 | 	mov	local05, #0
0dbf0                 | ' 
0dbf0                 | '     do {
0dbf0                 | LR__1700
0dbf0     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0dbf4     04 C2 05 F1 | 	add	arg01, #4
0dbf8     00 C4 05 F6 | 	mov	arg02, #0
0dbfc     E8 FE BF FD | 	call	#_fs9p_cc_doPut4_0246
0dc00     D3 DC 48 FC | 	wrbyte	#110, result1
0dc04                 | '     *ptr++ = x;
0dc04                 | '     return ptr;
0dc04     01 A6 05 F1 | 	add	result1, #1
0dc08     D3 C2 01 F6 | 	mov	arg01, result1
0dc0c     0F C4 CD F9 | 	bmask	arg02, #15
0dc10     B0 FE BF FD | 	call	#_fs9p_cc_doPut2_0245
0dc14     D3 C2 01 F6 | 	mov	arg01, result1
0dc18     EC C4 01 F6 | 	mov	arg02, local01
0dc1c     C8 FE BF FD | 	call	#_fs9p_cc_doPut4_0246
0dc20     D3 C2 01 F6 | 	mov	arg01, result1
0dc24     ED D8 01 F6 | 	mov	local01, local02
0dc28     EC C4 01 F6 | 	mov	arg02, local01
0dc2c     B8 FE BF FD | 	call	#_fs9p_cc_doPut4_0246
0dc30     D3 E2 01 F6 | 	mov	local06, result1
0dc34     97 08 48 FB | 	callpa	#(@LR__1702-@LR__1701)>>2,fcache_load_ptr_
0dc38                 | '         ptr = doPut4(txbuf, 0);
0dc38                 | '         ptr = doPut1(ptr, t_walk);
0dc38                 | '         ptr = doPut2(ptr,  0xffffU );
0dc38                 | '         ptr = doPut4(ptr, curdir);
0dc38                 | '         curdir = (uint32_t)newfile;
0dc38                 | '         ptr = doPut4(ptr, curdir);
0dc38                 | '         while (*path == '/') path++;
0dc38                 | LR__1701
0dc38     EE A6 C1 FA | 	rdbyte	result1, local03
0dc3c     2F A6 0D F2 | 	cmp	result1, #47 wz
0dc40     01 DC 05 A1 |  if_e	add	local03, #1
0dc44     F0 FF 9F AD |  if_e	jmp	#LR__1701
0dc48                 | LR__1702
0dc48     F1 E4 01 F6 | 	mov	local07, local06
0dc4c     CC E6 01 F6 | 	mov	local08, ptr__fs9p_cc_dat__
0dc50     04 E6 05 F1 | 	add	local08, #4
0dc54     F3 E4 81 F1 | 	sub	local07, local08
0dc58     EE C8 C9 FA | 	rdbyte	arg04, local03 wz
0dc5c     B8 00 90 AD |  if_e	jmp	#LR__1707
0dc60     F1 C2 01 F6 | 	mov	arg01, local06
0dc64     01 C4 05 F6 | 	mov	arg02, #1
0dc68     58 FE BF FD | 	call	#_fs9p_cc_doPut2_0245
0dc6c     D3 C2 01 F6 | 	mov	arg01, result1
0dc70     E1 E8 01 F6 | 	mov	local09, arg01
0dc74     00 C4 05 F6 | 	mov	arg02, #0
0dc78     48 FE BF FD | 	call	#_fs9p_cc_doPut2_0245
0dc7c     D3 E2 01 F6 | 	mov	local06, result1
0dc80     97 1E 48 FB | 	callpa	#(@LR__1704-@LR__1703)>>2,fcache_load_ptr_
0dc84                 | '             ptr = doPut2(ptr, 1);
0dc84                 | '             sizeptr = ptr;
0dc84                 | '             ptr = doPut2(ptr, 0);
0dc84                 | '             while (*path && *path != '/' && len < maxlen) {
0dc84                 | LR__1703
0dc84     EE C8 C9 FA | 	rdbyte	arg04, local03 wz
0dc88     E4 E6 01 56 |  if_ne	mov	local08, arg04
0dc8c     2F E6 0D 52 |  if_ne	cmp	local08, #47 wz
0dc90     2C 00 90 AD |  if_e	jmp	#LR__1705
0dc94     CC C8 01 FB | 	rdlong	arg04, ptr__fs9p_cc_dat__
0dc98     E4 E4 51 F2 | 	cmps	local07, arg04 wc
0dc9c     20 00 90 3D |  if_ae	jmp	#LR__1705
0dca0     EE C8 01 F6 | 	mov	arg04, local03
0dca4     01 C8 05 F1 | 	add	arg04, #1
0dca8     EE C6 C1 FA | 	rdbyte	arg03, local03
0dcac     E4 DC 01 F6 | 	mov	local03, arg04
0dcb0     F1 C6 41 FC | 	wrbyte	arg03, local06
0dcb4     01 E4 05 F1 | 	add	local07, #1
0dcb8     01 E2 05 F1 | 	add	local06, #1
0dcbc     C4 FF 9F FD | 	jmp	#LR__1703
0dcc0                 | LR__1704
0dcc0                 | LR__1705
0dcc0     00 DE 0D F2 | 	cmp	local04, #0 wz
0dcc4     34 00 90 AD |  if_e	jmp	#LR__1706
0dcc8     EE E6 C9 FA | 	rdbyte	local08, local03 wz
0dccc     2C 00 90 5D |  if_ne	jmp	#LR__1706
0dcd0     00 E0 0D F2 | 	cmp	local05, #0 wz
0dcd4                 | ' 		return 0;
0dcd4     00 A6 05 56 |  if_ne	mov	result1, #0
0dcd8     B8 00 90 5D |  if_ne	jmp	#LR__1709
0dcdc     F4 C2 01 F6 | 	mov	arg01, local09
0dce0     01 C4 05 F6 | 	mov	arg02, #1
0dce4     DC FD BF FD | 	call	#_fs9p_cc_doPut2_0245
0dce8     02 E8 05 F1 | 	add	local09, #2
0dcec     F4 5C 48 FC | 	wrbyte	#46, local09
0dcf0                 | '     *ptr++ = x;
0dcf0                 | '     return ptr;
0dcf0     01 E8 05 F1 | 	add	local09, #1
0dcf4     F4 E2 01 F6 | 	mov	local06, local09
0dcf8     2C 00 90 FD | 	jmp	#LR__1708
0dcfc                 | LR__1706
0dcfc     F1 C4 01 F6 | 	mov	arg02, local06
0dd00     F4 E6 01 F6 | 	mov	local08, local09
0dd04     02 E6 05 F1 | 	add	local08, #2
0dd08     F3 C4 81 F1 | 	sub	arg02, local08
0dd0c     F4 C2 01 F6 | 	mov	arg01, local09
0dd10     B0 FD BF FD | 	call	#_fs9p_cc_doPut2_0245
0dd14     10 00 90 FD | 	jmp	#LR__1708
0dd18                 | LR__1707
0dd18     F1 C2 01 F6 | 	mov	arg01, local06
0dd1c     00 C4 05 F6 | 	mov	arg02, #0
0dd20     A0 FD BF FD | 	call	#_fs9p_cc_doPut2_0245
0dd24     D3 E2 01 F6 | 	mov	local06, result1
0dd28                 | LR__1708
0dd28     08 90 05 F1 | 	add	objptr, #8
0dd2c     C8 E8 01 FB | 	rdlong	local09, objptr
0dd30     08 90 85 F1 | 	sub	objptr, #8
0dd34     F4 E6 01 F6 | 	mov	local08, local09
0dd38     13 E8 45 F7 | 	zerox	local09, #19
0dd3c     14 E6 45 F0 | 	shr	local08, #20
0dd40     02 E6 65 F0 | 	shl	local08, #2
0dd44     C5 E6 01 F1 | 	add	local08, __methods__
0dd48     F3 E6 01 FB | 	rdlong	local08, local08
0dd4c     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0dd50     04 C2 05 F1 | 	add	arg01, #4
0dd54     CC C6 01 FB | 	rdlong	arg03, ptr__fs9p_cc_dat__
0dd58     F1 C4 01 F6 | 	mov	arg02, local06
0dd5c     C8 E2 01 F6 | 	mov	local06, objptr
0dd60     F4 90 01 F6 | 	mov	objptr, local09
0dd64     2D E6 61 FD | 	call	local08
0dd68     F1 90 01 F6 | 	mov	objptr, local06
0dd6c     01 E0 05 F6 | 	mov	local05, #1
0dd70     08 98 05 F1 | 	add	ptr__fs9p_cc_dat__, #8
0dd74     CC E8 C1 FA | 	rdbyte	local09, ptr__fs9p_cc_dat__
0dd78     08 98 85 F1 | 	sub	ptr__fs9p_cc_dat__, #8
0dd7c     6F E8 0D F2 | 	cmp	local09, #111 wz
0dd80                 | '             return -1;
0dd80     01 A6 65 56 |  if_ne	neg	result1, #1
0dd84     0C 00 90 5D |  if_ne	jmp	#LR__1709
0dd88     EE E8 C9 FA | 	rdbyte	local09, local03 wz
0dd8c     60 FE 9F 5D |  if_ne	jmp	#LR__1700
0dd90                 | '     return 0;
0dd90     00 A6 05 F6 | 	mov	result1, #0
0dd94                 | LR__1709
0dd94     A7 F0 03 F6 | 	mov	ptra, fp
0dd98     B2 00 A0 FD | 	call	#popregs_
0dd9c                 | _fs9p_cc_do_fs_walk_0267_ret
0dd9c     2D 00 64 FD | 	ret
0dda0                 | 
0dda0                 | _fs9p_cc_fs_open_relative
0dda0     04 4A 05 F6 | 	mov	COUNT_, #4
0dda4     A8 00 A0 FD | 	call	#pushregs_
0dda8     E2 D8 01 F6 | 	mov	local01, arg02
0ddac     E4 DA 01 F6 | 	mov	local02, arg04
0ddb0     EC C4 01 F6 | 	mov	arg02, local01
0ddb4                 | ' {
0ddb4                 | '     return do_fs_walk(dir, newfile, path, 0);
0ddb4     00 C8 05 F6 | 	mov	arg04, #0
0ddb8     18 FE BF FD | 	call	#_fs9p_cc_do_fs_walk_0267
0ddbc     00 A6 0D F2 | 	cmp	result1, #0 wz
0ddc0     A8 00 90 5D |  if_ne	jmp	#LR__1710
0ddc4     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0ddc8     04 C2 05 F1 | 	add	arg01, #4
0ddcc     00 C4 05 F6 | 	mov	arg02, #0
0ddd0     14 FD BF FD | 	call	#_fs9p_cc_doPut4_0246
0ddd4     D3 E0 48 FC | 	wrbyte	#112, result1
0ddd8                 | '     *ptr++ = x;
0ddd8                 | '     return ptr;
0ddd8     01 A6 05 F1 | 	add	result1, #1
0dddc     D3 C2 01 F6 | 	mov	arg01, result1
0dde0     0F C4 CD F9 | 	bmask	arg02, #15
0dde4     DC FC BF FD | 	call	#_fs9p_cc_doPut2_0245
0dde8     D3 C2 01 F6 | 	mov	arg01, result1
0ddec     EC C4 01 F6 | 	mov	arg02, local01
0ddf0     F4 FC BF FD | 	call	#_fs9p_cc_doPut4_0246
0ddf4     ED C4 E1 F8 | 	getbyte	arg02, local02, #0
0ddf8     D3 C4 41 FC | 	wrbyte	arg02, result1
0ddfc                 | '     *ptr++ = x;
0ddfc                 | '     return ptr;
0ddfc     01 A6 05 F1 | 	add	result1, #1
0de00     D3 C4 01 F6 | 	mov	arg02, result1
0de04     08 90 05 F1 | 	add	objptr, #8
0de08     C8 DA 01 FB | 	rdlong	local02, objptr
0de0c     ED DC 01 F6 | 	mov	local03, local02
0de10     08 90 85 F1 | 	sub	objptr, #8
0de14     13 DC 45 F7 | 	zerox	local03, #19
0de18     14 DA 45 F0 | 	shr	local02, #20
0de1c     02 DA 65 F0 | 	shl	local02, #2
0de20     C5 DA 01 F1 | 	add	local02, __methods__
0de24     ED DA 01 FB | 	rdlong	local02, local02
0de28     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0de2c     04 C2 05 F1 | 	add	arg01, #4
0de30     CC C6 01 FB | 	rdlong	arg03, ptr__fs9p_cc_dat__
0de34     C8 DE 01 F6 | 	mov	local04, objptr
0de38     EE 90 01 F6 | 	mov	objptr, local03
0de3c     2D DA 61 FD | 	call	local02
0de40     EF 90 01 F6 | 	mov	objptr, local04
0de44     08 98 05 F1 | 	add	ptr__fs9p_cc_dat__, #8
0de48     CC DE C1 FA | 	rdbyte	local04, ptr__fs9p_cc_dat__
0de4c     08 98 85 F1 | 	sub	ptr__fs9p_cc_dat__, #8
0de50     71 DE 0D F2 | 	cmp	local04, #113 wz
0de54                 | '         return -1;
0de54     01 A6 65 56 |  if_ne	neg	result1, #1
0de58     04 D8 05 A1 |  if_e	add	local01, #4
0de5c     EC 00 68 AC |  if_e	wrlong	#0, local01
0de60     04 D8 85 A1 |  if_e	sub	local01, #4
0de64     EC 00 68 AC |  if_e	wrlong	#0, local01
0de68                 | '     }
0de68                 | '     f->offlo = f->offhi = 0;
0de68                 | '     return 0;
0de68     00 A6 05 A6 |  if_e	mov	result1, #0
0de6c                 | LR__1710
0de6c     A7 F0 03 F6 | 	mov	ptra, fp
0de70     B2 00 A0 FD | 	call	#popregs_
0de74                 | _fs9p_cc_fs_open_relative_ret
0de74     2D 00 64 FD | 	ret
0de78                 | 
0de78                 | _fs9p_cc_fs_open
0de78     03 4A 05 F6 | 	mov	COUNT_, #3
0de7c     A8 00 A0 FD | 	call	#pushregs_
0de80                 | ' {
0de80                 | '     return fs_open_relative(&rootdir, f, path, fs_mode);
0de80     C8 D8 01 F6 | 	mov	local01, objptr
0de84     E1 DA 01 F6 | 	mov	local02, arg01
0de88     E2 DC 01 F6 | 	mov	local03, arg02
0de8c     E3 C8 01 F6 | 	mov	arg04, arg03
0de90     EC C2 01 F6 | 	mov	arg01, local01
0de94     ED C4 01 F6 | 	mov	arg02, local02
0de98     EE C6 01 F6 | 	mov	arg03, local03
0de9c     00 FF BF FD | 	call	#_fs9p_cc_fs_open_relative
0dea0     A7 F0 03 F6 | 	mov	ptra, fp
0dea4     B2 00 A0 FD | 	call	#popregs_
0dea8                 | _fs9p_cc_fs_open_ret
0dea8     2D 00 64 FD | 	ret
0deac                 | 
0deac                 | _fs9p_cc_fs_close
0deac     03 4A 05 F6 | 	mov	COUNT_, #3
0deb0     A8 00 A0 FD | 	call	#pushregs_
0deb4     E1 C6 01 F6 | 	mov	arg03, arg01
0deb8     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0debc     04 C2 05 F1 | 	add	arg01, #4
0dec0     00 C4 05 F6 | 	mov	arg02, #0
0dec4     20 FC BF FD | 	call	#_fs9p_cc_doPut4_0246
0dec8     D3 F0 48 FC | 	wrbyte	#120, result1
0decc                 | '     *ptr++ = x;
0decc                 | '     return ptr;
0decc     01 A6 05 F1 | 	add	result1, #1
0ded0     D3 C2 01 F6 | 	mov	arg01, result1
0ded4     0F C4 CD F9 | 	bmask	arg02, #15
0ded8     E8 FB BF FD | 	call	#_fs9p_cc_doPut2_0245
0dedc     D3 C2 01 F6 | 	mov	arg01, result1
0dee0     E3 C4 01 F6 | 	mov	arg02, arg03
0dee4     00 FC BF FD | 	call	#_fs9p_cc_doPut4_0246
0dee8     D3 C4 01 F6 | 	mov	arg02, result1
0deec     08 90 05 F1 | 	add	objptr, #8
0def0     C8 D8 01 FB | 	rdlong	local01, objptr
0def4     EC DA 01 F6 | 	mov	local02, local01
0def8     08 90 85 F1 | 	sub	objptr, #8
0defc     13 DA 45 F7 | 	zerox	local02, #19
0df00     14 D8 45 F0 | 	shr	local01, #20
0df04     02 D8 65 F0 | 	shl	local01, #2
0df08     C5 D8 01 F1 | 	add	local01, __methods__
0df0c     EC D8 01 FB | 	rdlong	local01, local01
0df10     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0df14     04 C2 05 F1 | 	add	arg01, #4
0df18     CC C6 01 FB | 	rdlong	arg03, ptr__fs9p_cc_dat__
0df1c     C8 DC 01 F6 | 	mov	local03, objptr
0df20     ED 90 01 F6 | 	mov	objptr, local02
0df24     2D D8 61 FD | 	call	local01
0df28     EE 90 01 F6 | 	mov	objptr, local03
0df2c     00 A6 55 F2 | 	cmps	result1, #0 wc
0df30     08 98 05 31 |  if_ae	add	ptr__fs9p_cc_dat__, #8
0df34     CC DC C1 3A |  if_ae	rdbyte	local03, ptr__fs9p_cc_dat__
0df38     08 98 85 31 |  if_ae	sub	ptr__fs9p_cc_dat__, #8
0df3c     79 DC 0D 32 |  if_ae	cmp	local03, #121 wz
0df40                 | '         return -1;
0df40     01 A6 65 D6 |  if_c_or_nz	neg	result1, #1
0df44                 | '     }
0df44                 | '     return 0;
0df44     00 A6 05 26 |  if_nc_and_z	mov	result1, #0
0df48     A7 F0 03 F6 | 	mov	ptra, fp
0df4c     B2 00 A0 FD | 	call	#popregs_
0df50                 | _fs9p_cc_fs_close_ret
0df50     2D 00 64 FD | 	ret
0df54                 | 
0df54                 | _fs9p_cc_fs_read
0df54     0A 4A 05 F6 | 	mov	COUNT_, #10
0df58     A8 00 A0 FD | 	call	#pushregs_
0df5c     E1 D8 01 F6 | 	mov	local01, arg01
0df60     E2 DA 01 F6 | 	mov	local02, arg02
0df64     E3 DC 01 F6 | 	mov	local03, arg03
0df68     00 DE 05 F6 | 	mov	local04, #0
0df6c                 | '     uint32_t oldlo;
0df6c                 | '     while (count > 0) {
0df6c                 | LR__1720
0df6c     01 DC 55 F2 | 	cmps	local03, #1 wc
0df70     6C 01 90 CD |  if_b	jmp	#LR__1723
0df74     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0df78     04 C2 05 F1 | 	add	arg01, #4
0df7c     00 C4 05 F6 | 	mov	arg02, #0
0df80     64 FB BF FD | 	call	#_fs9p_cc_doPut4_0246
0df84     D3 E8 48 FC | 	wrbyte	#116, result1
0df88                 | '     *ptr++ = x;
0df88                 | '     return ptr;
0df88     01 A6 05 F1 | 	add	result1, #1
0df8c     D3 C2 01 F6 | 	mov	arg01, result1
0df90     0F C4 CD F9 | 	bmask	arg02, #15
0df94     2C FB BF FD | 	call	#_fs9p_cc_doPut2_0245
0df98     D3 C2 01 F6 | 	mov	arg01, result1
0df9c     EC C4 01 F6 | 	mov	arg02, local01
0dfa0     44 FB BF FD | 	call	#_fs9p_cc_doPut4_0246
0dfa4     D3 C2 01 F6 | 	mov	arg01, result1
0dfa8     EC C4 01 FB | 	rdlong	arg02, local01
0dfac     38 FB BF FD | 	call	#_fs9p_cc_doPut4_0246
0dfb0     D3 C2 01 F6 | 	mov	arg01, result1
0dfb4     04 D8 05 F1 | 	add	local01, #4
0dfb8     EC C4 01 FB | 	rdlong	arg02, local01
0dfbc     04 D8 85 F1 | 	sub	local01, #4
0dfc0     24 FB BF FD | 	call	#_fs9p_cc_doPut4_0246
0dfc4     D3 C2 01 F6 | 	mov	arg01, result1
0dfc8     CC C6 01 FB | 	rdlong	arg03, ptr__fs9p_cc_dat__
0dfcc     E1 C4 01 F6 | 	mov	arg02, arg01
0dfd0     04 C4 05 F1 | 	add	arg02, #4
0dfd4     CC E0 01 F6 | 	mov	local05, ptr__fs9p_cc_dat__
0dfd8     04 E0 05 F1 | 	add	local05, #4
0dfdc     F0 C4 81 F1 | 	sub	arg02, local05
0dfe0     E2 C6 81 F1 | 	sub	arg03, arg02
0dfe4     E3 DC 51 F2 | 	cmps	local03, arg03 wc
0dfe8     EE E2 01 C6 |  if_b	mov	local06, local03
0dfec     E3 E2 01 36 |  if_ae	mov	local06, arg03
0dff0     F1 C4 01 F6 | 	mov	arg02, local06
0dff4     F0 FA BF FD | 	call	#_fs9p_cc_doPut4_0246
0dff8     D3 C4 01 F6 | 	mov	arg02, result1
0dffc     08 90 05 F1 | 	add	objptr, #8
0e000     C8 E4 01 FB | 	rdlong	local07, objptr
0e004     08 90 85 F1 | 	sub	objptr, #8
0e008     F2 E0 01 F6 | 	mov	local05, local07
0e00c     13 E4 45 F7 | 	zerox	local07, #19
0e010     14 E0 45 F0 | 	shr	local05, #20
0e014     02 E0 65 F0 | 	shl	local05, #2
0e018     C5 E0 01 F1 | 	add	local05, __methods__
0e01c     F0 E0 01 FB | 	rdlong	local05, local05
0e020     CC C2 01 F6 | 	mov	arg01, ptr__fs9p_cc_dat__
0e024     04 C2 05 F1 | 	add	arg01, #4
0e028     CC C6 01 FB | 	rdlong	arg03, ptr__fs9p_cc_dat__
0e02c     C8 E6 01 F6 | 	mov	local08, objptr
0e030     F2 90 01 F6 | 	mov	objptr, local07
0e034     2D E0 61 FD | 	call	local05
0e038     F3 90 01 F6 | 	mov	objptr, local08
0e03c     00 A6 55 F2 | 	cmps	result1, #0 wc
0e040     A0 00 90 CD |  if_b	jmp	#LR__1724
0e044     CC E8 01 F6 | 	mov	local09, ptr__fs9p_cc_dat__
0e048     08 E8 05 F1 | 	add	local09, #8
0e04c     F4 E6 C1 FA | 	rdbyte	local08, local09
0e050     75 E6 0D F2 | 	cmp	local08, #117 wz
0e054                 | '             return -1;
0e054     01 E8 05 F1 | 	add	local09, #1
0e058     01 A6 65 56 |  if_ne	neg	result1, #1
0e05c     84 00 90 5D |  if_ne	jmp	#LR__1724
0e060     02 E8 05 F1 | 	add	local09, #2
0e064     F4 C2 01 F6 | 	mov	arg01, local09
0e068     30 FB BF FD | 	call	#_fs9p_cc_FETCH4_0253
0e06c     D3 EA 01 F6 | 	mov	local10, result1
0e070     04 E8 05 F1 | 	add	local09, #4
0e074     00 EA 55 F2 | 	cmps	local10, #0 wc
0e078     08 00 90 CD |  if_b	jmp	#LR__1721
0e07c     F1 EA 59 F2 | 	cmps	local10, local06 wcz
0e080     08 00 90 ED |  if_be	jmp	#LR__1722
0e084                 | LR__1721
0e084                 | '             return -1;
0e084     01 A6 65 F6 | 	neg	result1, #1
0e088     58 00 90 FD | 	jmp	#LR__1724
0e08c                 | LR__1722
0e08c     00 EA 0D F2 | 	cmp	local10, #0 wz
0e090                 | ' 
0e090                 | '             break;
0e090     4C 00 90 AD |  if_e	jmp	#LR__1723
0e094     ED C2 01 F6 | 	mov	arg01, local02
0e098     F4 C4 01 F6 | 	mov	arg02, local09
0e09c     F5 C6 01 F6 | 	mov	arg03, local10
0e0a0     B4 02 B0 FD | 	call	#__system____builtin_memmove
0e0a4     F5 DA 01 F1 | 	add	local02, local10
0e0a8     F5 DE 01 F1 | 	add	local04, local10
0e0ac     F5 DC 81 F1 | 	sub	local03, local10
0e0b0     EC E8 01 FB | 	rdlong	local09, local01
0e0b4     F4 E6 01 F6 | 	mov	local08, local09
0e0b8     F5 E6 01 F1 | 	add	local08, local10
0e0bc     EC E6 61 FC | 	wrlong	local08, local01
0e0c0     F4 E6 11 F2 | 	cmp	local08, local09 wc
0e0c4     A4 FE 9F 3D |  if_ae	jmp	#LR__1720
0e0c8     04 D8 05 F1 | 	add	local01, #4
0e0cc     EC E0 01 FB | 	rdlong	local05, local01
0e0d0     01 E0 05 F1 | 	add	local05, #1
0e0d4     EC E0 61 FC | 	wrlong	local05, local01
0e0d8     04 D8 85 F1 | 	sub	local01, #4
0e0dc     8C FE 9F FD | 	jmp	#LR__1720
0e0e0                 | LR__1723
0e0e0                 | '             f->offhi++;
0e0e0                 | '         }
0e0e0                 | '     }
0e0e0                 | '     return totalread;
0e0e0     EF A6 01 F6 | 	mov	result1, local04
0e0e4                 | LR__1724
0e0e4     A7 F0 03 F6 | 	mov	ptra, fp
0e0e8     B2 00 A0 FD | 	call	#popregs_
0e0ec                 | _fs9p_cc_fs_read_ret
0e0ec     2D 00 64 FD | 	ret
0e0f0                 | hubexit
0e0f0     81 00 80 FD | 	jmp	#cogexit
0e0f4                 | 
0e0f4                 | __system___clkset
0e0f4     E1 AA 01 F6 | 	mov	_var01, arg01
0e0f8     03 AA 0D F5 | 	and	_var01, #3 wz
0e0fc     02 C2 55 A2 |  if_e	cmps	arg01, #2 wc
0e100     03 AA 05 26 |  if_nc_and_z	mov	_var01, #3
0e104     18 AC 05 FB | 	rdlong	_var02, #24
0e108     14 C4 65 FC | 	wrlong	arg02, #20
0e10c     03 AC 25 F5 | 	andn	_var02, #3
0e110     18 C2 65 FC | 	wrlong	arg01, #24
0e114     03 C2 25 F5 | 	andn	arg01, #3
0e118     00 AC 61 FD | 	hubset	_var02
0e11c     00 C2 61 FD | 	hubset	arg01
0e120     86 01 80 FF 
0e124     1F 80 66 FD | 	waitx	##200000
0e128     D5 C2 41 F5 | 	or	arg01, _var01
0e12c     00 C2 61 FD | 	hubset	arg01
0e130     E2 AC 51 F6 | 	abs	_var02, arg02 wc
0e134     01 00 00 FF 
0e138     E8 AD 15 FD | 	qdiv	_var02, ##1000
0e13c     0C 92 05 F1 | 	add	ptr___system__dat__, #12
0e140     18 AC 61 FD | 	getqx	_var02
0e144     D6 AC 81 F6 | 	negc	_var02, _var02
0e148     C9 AC 61 FC | 	wrlong	_var02, ptr___system__dat__
0e14c     E2 AC 51 F6 | 	abs	_var02, arg02 wc
0e150     A1 07 00 FF 
0e154     40 AC 15 FD | 	qdiv	_var02, ##1000000
0e158     04 92 05 F1 | 	add	ptr___system__dat__, #4
0e15c     18 AC 61 FD | 	getqx	_var02
0e160     D6 AC 81 F6 | 	negc	_var02, _var02
0e164     C9 AC 61 FC | 	wrlong	_var02, ptr___system__dat__
0e168     10 92 85 F1 | 	sub	ptr___system__dat__, #16
0e16c     C9 00 68 FC | 	wrlong	#0, ptr___system__dat__
0e170                 | __system___clkset_ret
0e170     2D 00 64 FD | 	ret
0e174                 | 
0e174                 | __system___setbaud
0e174     14 24 06 FB | 	rdlong	muldiva_, #20
0e178     E1 26 02 F6 | 	mov	muldivb_, arg01
0e17c     BA 00 A0 FD | 	call	#divide_
0e180     97 06 48 FB | 	callpa	#(@LR__1731-@LR__1730)>>2,fcache_load_ptr_
0e184                 | LR__1730
0e184     3E A6 9D FA | 	rdpin	result1, #62 wc
0e188     D4 A8 A1 F1 | 	subx	result2, result2
0e18c     F4 FF 9F CD |  if_b	jmp	#LR__1730
0e190                 | LR__1731
0e190     40 7C 64 FD | 	dirl	#62
0e194     40 7E 64 FD | 	dirl	#63
0e198     C9 26 62 FC | 	wrlong	muldivb_, ptr___system__dat__
0e19c     10 26 66 F0 | 	shl	muldivb_, #16
0e1a0     07 C4 05 F6 | 	mov	arg02, #7
0e1a4     13 C5 01 F1 | 	add	arg02, muldivb_
0e1a8     3E F8 0C FC | 	wrpin	#124, #62
0e1ac     3E C4 15 FC | 	wxpin	arg02, #62
0e1b0     3F 7C 0C FC | 	wrpin	#62, #63
0e1b4     14 C4 05 F1 | 	add	arg02, #20
0e1b8     3F C4 15 FC | 	wxpin	arg02, #63
0e1bc     41 7C 64 FD | 	dirh	#62
0e1c0     41 7E 64 FD | 	dirh	#63
0e1c4                 | __system___setbaud_ret
0e1c4     2D 00 64 FD | 	ret
0e1c8                 | 
0e1c8                 | __system___txraw
0e1c8     01 4A 05 F6 | 	mov	COUNT_, #1
0e1cc     A8 00 A0 FD | 	call	#pushregs_
0e1d0     E1 D8 01 F6 | 	mov	local01, arg01
0e1d4     97 06 48 FB | 	callpa	#(@LR__1741-@LR__1740)>>2,fcache_load_ptr_
0e1d8                 | LR__1740
0e1d8     3E A6 9D FA | 	rdpin	result1, #62 wc
0e1dc     D4 A8 A1 F1 | 	subx	result2, result2
0e1e0     F4 FF 9F CD |  if_b	jmp	#LR__1740
0e1e4                 | LR__1741
0e1e4     C9 A6 09 FB | 	rdlong	result1, ptr___system__dat__ wz
0e1e8     08 07 00 AF 
0e1ec     00 C2 05 A6 |  if_e	mov	arg01, ##921600
0e1f0     80 FF BF AD |  if_e	call	#__system___setbaud
0e1f4     58 7C 64 FD | 	drvl	#62
0e1f8     3E D8 25 FC | 	wypin	local01, #62
0e1fc     01 A6 05 F6 | 	mov	result1, #1
0e200     A7 F0 03 F6 | 	mov	ptra, fp
0e204     B2 00 A0 FD | 	call	#popregs_
0e208                 | __system___txraw_ret
0e208     2D 00 64 FD | 	ret
0e20c                 | 
0e20c                 | __system___rxraw
0e20c     0D 4A 05 F6 | 	mov	COUNT_, #13
0e210     A8 00 A0 FD | 	call	#pushregs_
0e214     E1 D8 01 F6 | 	mov	local01, arg01
0e218     C9 DA 09 FB | 	rdlong	local02, ptr___system__dat__ wz
0e21c     08 07 00 AF 
0e220     00 C2 05 A6 |  if_e	mov	arg01, ##921600
0e224     4C FF BF AD |  if_e	call	#__system___setbaud
0e228     00 D8 0D F2 | 	cmp	local01, #0 wz
0e22c     20 00 90 AD |  if_e	jmp	#LR__1750
0e230     14 DC 05 FB | 	rdlong	local03, #20
0e234     0A DC 45 F0 | 	shr	local03, #10
0e238     EE D8 01 FD | 	qmul	local01, local03
0e23c     1A A6 61 FD | 	getct	result1
0e240     18 DE 61 FD | 	getqx	local04
0e244     EF A6 01 F1 | 	add	result1, local04
0e248     D3 E0 01 F6 | 	mov	local05, result1
0e24c     04 00 90 FD | 	jmp	#LR__1751
0e250                 | LR__1750
0e250     00 E0 05 F6 | 	mov	local05, #0
0e254                 | LR__1751
0e254     01 E2 65 F6 | 	neg	local06, #1
0e258     3F E4 05 F6 | 	mov	local07, #63
0e25c     00 E6 05 F6 | 	mov	local08, #0
0e260     04 92 05 F1 | 	add	ptr___system__dat__, #4
0e264     C9 E8 01 FB | 	rdlong	local09, ptr___system__dat__
0e268     04 92 85 F1 | 	sub	ptr___system__dat__, #4
0e26c                 | LR__1752
0e26c     08 E8 15 F4 | 	testb	local09, #8 wc
0e270     09 E8 75 F4 | 	testbn	local09, #9 andc
0e274     0A E8 45 F0 | 	shr	local09, #10
0e278     01 E6 05 C6 |  if_b	mov	local08, #1
0e27c     40 7E 6C 3D |  if_ae	testp	#63 wz
0e280     01 E6 05 26 |  if_nc_and_z	mov	local08, #1
0e284     3F E8 8D 2A |  if_nc_and_z	rdpin	local09, #63
0e288     04 E8 45 20 |  if_nc_and_z	shr	local09, #4
0e28c                 | LR__1753
0e28c     00 DA 05 F6 | 	mov	local02, #0
0e290     00 E6 0D F2 | 	cmp	local08, #0 wz
0e294     01 DA 65 56 |  if_ne	neg	local02, #1
0e298     00 EA 05 F6 | 	mov	local10, #0
0e29c     00 DC 05 F6 | 	mov	local03, #0
0e2a0     00 D8 0D F2 | 	cmp	local01, #0 wz
0e2a4     01 DC 65 56 |  if_ne	neg	local03, #1
0e2a8     00 DE 05 F6 | 	mov	local04, #0
0e2ac     00 EC 05 F6 | 	mov	local11, #0
0e2b0     F0 EE 01 F6 | 	mov	local12, local05
0e2b4     1A A6 61 FD | 	getct	result1
0e2b8     D3 F0 01 F6 | 	mov	local13, result1
0e2bc     F8 EE 81 F1 | 	sub	local12, local13
0e2c0     00 EE 55 F2 | 	cmps	local12, #0 wc
0e2c4     00 EC 25 C6 |  if_b	not	local11, #0
0e2c8     00 EC 0D F2 | 	cmp	local11, #0 wz
0e2cc     00 DE 25 56 |  if_ne	not	local04, #0
0e2d0     EF DC C9 F7 | 	test	local03, local04 wz
0e2d4     00 EA 25 56 |  if_ne	not	local10, #0
0e2d8     F5 DA 49 F5 | 	or	local02, local10 wz
0e2dc     8C FF 9F AD |  if_e	jmp	#LR__1752
0e2e0     00 E6 0D F2 | 	cmp	local08, #0 wz
0e2e4     F4 E2 01 56 |  if_ne	mov	local06, local09
0e2e8     F1 E2 E1 58 |  if_ne	getbyte	local06, local06, #0
0e2ec     04 92 05 F1 | 	add	ptr___system__dat__, #4
0e2f0     C9 E8 61 FC | 	wrlong	local09, ptr___system__dat__
0e2f4     04 92 85 F1 | 	sub	ptr___system__dat__, #4
0e2f8     F1 A6 01 F6 | 	mov	result1, local06
0e2fc     A7 F0 03 F6 | 	mov	ptra, fp
0e300     B2 00 A0 FD | 	call	#popregs_
0e304                 | __system___rxraw_ret
0e304     2D 00 64 FD | 	ret
0e308                 | 
0e308                 | __system___getus
0e308     1A A8 71 FD | 	getct	result2 wc
0e30c     1A AA 61 FD | 	getct	_var01
0e310     10 92 05 F1 | 	add	ptr___system__dat__, #16
0e314     C9 AC 09 FB | 	rdlong	_var02, ptr___system__dat__ wz
0e318     10 92 85 F1 | 	sub	ptr___system__dat__, #16
0e31c     20 00 90 5D |  if_ne	jmp	#LR__1760
0e320     14 AC 05 FB | 	rdlong	_var02, #20
0e324     A1 07 00 FF 
0e328     40 AC 15 FD | 	qdiv	_var02, ##1000000
0e32c     10 92 05 F1 | 	add	ptr___system__dat__, #16
0e330     18 A6 61 FD | 	getqx	result1
0e334     D3 AC 01 F6 | 	mov	_var02, result1
0e338     C9 A6 61 FC | 	wrlong	result1, ptr___system__dat__
0e33c     10 92 85 F1 | 	sub	ptr___system__dat__, #16
0e340                 | LR__1760
0e340     D6 A8 11 FD | 	qdiv	result2, _var02
0e344     19 A8 61 FD | 	getqy	result2
0e348     28 A8 61 FD | 	setq	result2
0e34c     D6 AA 11 FD | 	qdiv	_var01, _var02
0e350     18 A6 61 FD | 	getqx	result1
0e354                 | __system___getus_ret
0e354     2D 00 64 FD | 	ret
0e358                 | 
0e358                 | __system____builtin_memmove
0e358     E1 AA 01 F6 | 	mov	_var01, arg01
0e35c     E2 C2 51 F2 | 	cmps	arg01, arg02 wc
0e360     10 00 90 CD |  if_b	jmp	#LR__1770
0e364     E2 AC 01 F6 | 	mov	_var02, arg02
0e368     E3 AC 01 F1 | 	add	_var02, arg03
0e36c     D6 C2 51 F2 | 	cmps	arg01, _var02 wc
0e370     48 00 90 CD |  if_b	jmp	#LR__1776
0e374                 | LR__1770
0e374     E3 AE 01 F6 | 	mov	_var03, arg03
0e378     02 AE 4D F0 | 	shr	_var03, #2 wz
0e37c     18 00 90 AD |  if_e	jmp	#LR__1775
0e380     97 0A 48 FB | 	callpa	#(@LR__1773-@LR__1771)>>2,fcache_load_ptr_
0e384                 | LR__1771
0e384     D7 08 D8 FC | 	rep	@LR__1774, _var03
0e388                 | LR__1772
0e388     E2 AE 01 FB | 	rdlong	_var03, arg02
0e38c     E1 AE 61 FC | 	wrlong	_var03, arg01
0e390     04 C2 05 F1 | 	add	arg01, #4
0e394     04 C4 05 F1 | 	add	arg02, #4
0e398                 | LR__1773
0e398                 | LR__1774
0e398                 | LR__1775
0e398     02 C6 CD F7 | 	test	arg03, #2 wz
0e39c     E2 AC E1 5A |  if_ne	rdword	_var02, arg02
0e3a0     E1 AC 51 5C |  if_ne	wrword	_var02, arg01
0e3a4     02 C2 05 51 |  if_ne	add	arg01, #2
0e3a8     02 C4 05 51 |  if_ne	add	arg02, #2
0e3ac     01 C6 CD F7 | 	test	arg03, #1 wz
0e3b0     E2 AC C1 5A |  if_ne	rdbyte	_var02, arg02
0e3b4     E1 AC 41 5C |  if_ne	wrbyte	_var02, arg01
0e3b8     28 00 90 FD | 	jmp	#LR__1782
0e3bc                 | LR__1776
0e3bc     E3 C2 01 F1 | 	add	arg01, arg03
0e3c0     E3 C4 01 F1 | 	add	arg02, arg03
0e3c4     E3 B0 09 F6 | 	mov	_var04, arg03 wz
0e3c8     18 00 90 AD |  if_e	jmp	#LR__1781
0e3cc     97 0A 48 FB | 	callpa	#(@LR__1779-@LR__1777)>>2,fcache_load_ptr_
0e3d0                 | LR__1777
0e3d0     D8 08 D8 FC | 	rep	@LR__1780, _var04
0e3d4                 | LR__1778
0e3d4     01 C2 85 F1 | 	sub	arg01, #1
0e3d8     01 C4 85 F1 | 	sub	arg02, #1
0e3dc     E2 AC C1 FA | 	rdbyte	_var02, arg02
0e3e0     E1 AC 41 FC | 	wrbyte	_var02, arg01
0e3e4                 | LR__1779
0e3e4                 | LR__1780
0e3e4                 | LR__1781
0e3e4                 | LR__1782
0e3e4     D5 A6 01 F6 | 	mov	result1, _var01
0e3e8                 | __system____builtin_memmove_ret
0e3e8     2D 00 64 FD | 	ret
0e3ec                 | 
0e3ec                 | __system__longmove
0e3ec     E1 AA 01 F6 | 	mov	_var01, arg01
0e3f0     E2 C2 51 F2 | 	cmps	arg01, arg02 wc
0e3f4     24 00 90 3D |  if_ae	jmp	#LR__1794
0e3f8     E3 AC 09 F6 | 	mov	_var02, arg03 wz
0e3fc     54 00 90 AD |  if_e	jmp	#LR__1800
0e400     97 0A 48 FB | 	callpa	#(@LR__1792-@LR__1790)>>2,fcache_load_ptr_
0e404                 | LR__1790
0e404     D6 08 D8 FC | 	rep	@LR__1793, _var02
0e408                 | LR__1791
0e408     E2 AC 01 FB | 	rdlong	_var02, arg02
0e40c     E1 AC 61 FC | 	wrlong	_var02, arg01
0e410     04 C2 05 F1 | 	add	arg01, #4
0e414     04 C4 05 F1 | 	add	arg02, #4
0e418                 | LR__1792
0e418                 | LR__1793
0e418     38 00 90 FD | 	jmp	#LR__1800
0e41c                 | LR__1794
0e41c     E3 AC 01 F6 | 	mov	_var02, arg03
0e420     02 AC 65 F0 | 	shl	_var02, #2
0e424     D6 C2 01 F1 | 	add	arg01, _var02
0e428     E3 AE 01 F6 | 	mov	_var03, arg03
0e42c     02 AE 65 F0 | 	shl	_var03, #2
0e430     D7 C4 01 F1 | 	add	arg02, _var03
0e434     E3 B0 09 F6 | 	mov	_var04, arg03 wz
0e438     18 00 90 AD |  if_e	jmp	#LR__1799
0e43c     97 0A 48 FB | 	callpa	#(@LR__1797-@LR__1795)>>2,fcache_load_ptr_
0e440                 | LR__1795
0e440     D8 08 D8 FC | 	rep	@LR__1798, _var04
0e444                 | LR__1796
0e444     04 C2 85 F1 | 	sub	arg01, #4
0e448     04 C4 85 F1 | 	sub	arg02, #4
0e44c     E2 B0 01 FB | 	rdlong	_var04, arg02
0e450     E1 B0 61 FC | 	wrlong	_var04, arg01
0e454                 | LR__1797
0e454                 | LR__1798
0e454                 | LR__1799
0e454                 | LR__1800
0e454     D5 A6 01 F6 | 	mov	result1, _var01
0e458                 | __system__longmove_ret
0e458     2D 00 64 FD | 	ret
0e45c                 | 
0e45c                 | __system____builtin_strcpy
0e45c     E1 AA 01 F6 | 	mov	_var01, arg01
0e460     97 0A 48 FB | 	callpa	#(@LR__1811-@LR__1810)>>2,fcache_load_ptr_
0e464                 | LR__1810
0e464     E2 A6 C9 FA | 	rdbyte	result1, arg02 wz
0e468     E1 A6 41 FC | 	wrbyte	result1, arg01
0e46c     01 C4 05 F1 | 	add	arg02, #1
0e470     01 C2 05 F1 | 	add	arg01, #1
0e474     EC FF 9F 5D |  if_ne	jmp	#LR__1810
0e478                 | LR__1811
0e478     D5 A6 01 F6 | 	mov	result1, _var01
0e47c                 | __system____builtin_strcpy_ret
0e47c     2D 00 64 FD | 	ret
0e480                 | 
0e480                 | __system___lookup
0e480     E2 C2 81 F1 | 	sub	arg01, arg02
0e484     00 C2 55 F2 | 	cmps	arg01, #0 wc
0e488     18 00 90 CD |  if_b	jmp	#LR__1820
0e48c     E4 C2 51 F2 | 	cmps	arg01, arg04 wc
0e490     E1 AA 01 C6 |  if_b	mov	_var01, arg01
0e494     02 AA 65 C0 |  if_b	shl	_var01, #2
0e498     E3 AA 01 C1 |  if_b	add	_var01, arg03
0e49c     D5 A6 01 CB |  if_b	rdlong	result1, _var01
0e4a0     04 00 90 CD |  if_b	jmp	#__system___lookup_ret
0e4a4                 | LR__1820
0e4a4     00 A6 05 F6 | 	mov	result1, #0
0e4a8                 | __system___lookup_ret
0e4a8     2D 00 64 FD | 	ret
0e4ac                 | 
0e4ac                 | __system____topofstack
0e4ac     00 4A 05 F6 | 	mov	COUNT_, #0
0e4b0     A8 00 A0 FD | 	call	#pushregs_
0e4b4     08 F0 07 F1 | 	add	ptra, #8
0e4b8     04 4E 05 F1 | 	add	fp, #4
0e4bc     A7 C2 61 FC | 	wrlong	arg01, fp
0e4c0     A7 A6 01 F6 | 	mov	result1, fp
0e4c4     04 4E 85 F1 | 	sub	fp, #4
0e4c8     A7 F0 03 F6 | 	mov	ptra, fp
0e4cc     B2 00 A0 FD | 	call	#popregs_
0e4d0                 | __system____topofstack_ret
0e4d0     2D 00 64 FD | 	ret
0e4d4                 | 
0e4d4                 | __system___lockmem
0e4d4     00 A6 05 F6 | 	mov	result1, #0
0e4d8     01 A6 61 FD | 	cogid	result1
0e4dc     00 A7 05 F1 | 	add	result1, #256
0e4e0                 | LR__1830
0e4e0     E1 AA 09 FB | 	rdlong	_var01, arg01 wz
0e4e4     E1 A6 61 AC |  if_e	wrlong	result1, arg01
0e4e8     E1 AA 01 AB |  if_e	rdlong	_var01, arg01
0e4ec     E1 AA 01 AB |  if_e	rdlong	_var01, arg01
0e4f0     D3 AA 09 F2 | 	cmp	_var01, result1 wz
0e4f4     E8 FF 9F 5D |  if_ne	jmp	#LR__1830
0e4f8                 | __system___lockmem_ret
0e4f8     2D 00 64 FD | 	ret
0e4fc                 | 
0e4fc                 | __system___tx
0e4fc     02 4A 05 F6 | 	mov	COUNT_, #2
0e500     A8 00 A0 FD | 	call	#pushregs_
0e504     E1 D8 01 F6 | 	mov	local01, arg01
0e508     0A D8 0D F2 | 	cmp	local01, #10 wz
0e50c     18 00 90 5D |  if_ne	jmp	#LR__1840
0e510     08 92 05 F1 | 	add	ptr___system__dat__, #8
0e514     C9 DA 01 FB | 	rdlong	local02, ptr___system__dat__
0e518     08 92 85 F1 | 	sub	ptr___system__dat__, #8
0e51c     02 DA CD F7 | 	test	local02, #2 wz
0e520     0D C2 05 56 |  if_ne	mov	arg01, #13
0e524     A0 FC BF 5D |  if_ne	call	#__system___txraw
0e528                 | LR__1840
0e528     EC C2 01 F6 | 	mov	arg01, local01
0e52c     98 FC BF FD | 	call	#__system___txraw
0e530     A7 F0 03 F6 | 	mov	ptra, fp
0e534     B2 00 A0 FD | 	call	#popregs_
0e538                 | __system___tx_ret
0e538     2D 00 64 FD | 	ret
0e53c                 | 
0e53c                 | __system___rx
0e53c     01 4A 05 F6 | 	mov	COUNT_, #1
0e540     A8 00 A0 FD | 	call	#pushregs_
0e544                 | LR__1850
0e544     00 C2 05 F6 | 	mov	arg01, #0
0e548     C0 FC BF FD | 	call	#__system___rxraw
0e54c     D3 D8 01 F6 | 	mov	local01, result1
0e550     FF FF 7F FF 
0e554     FF D9 0D F2 | 	cmp	local01, ##-1 wz
0e558     E8 FF 9F AD |  if_e	jmp	#LR__1850
0e55c     0D D8 0D F2 | 	cmp	local01, #13 wz
0e560     14 00 90 5D |  if_ne	jmp	#LR__1851
0e564     08 92 05 F1 | 	add	ptr___system__dat__, #8
0e568     C9 A6 01 FB | 	rdlong	result1, ptr___system__dat__
0e56c     08 92 85 F1 | 	sub	ptr___system__dat__, #8
0e570     02 A6 CD F7 | 	test	result1, #2 wz
0e574     0A D8 05 56 |  if_ne	mov	local01, #10
0e578                 | LR__1851
0e578     08 92 05 F1 | 	add	ptr___system__dat__, #8
0e57c     C9 C2 01 FB | 	rdlong	arg01, ptr___system__dat__
0e580     08 92 85 F1 | 	sub	ptr___system__dat__, #8
0e584     01 C2 CD F7 | 	test	arg01, #1 wz
0e588     1C 00 90 AD |  if_e	jmp	#LR__1854
0e58c     7F D8 0D F2 | 	cmp	local01, #127 wz
0e590     0C 00 90 5D |  if_ne	jmp	#LR__1852
0e594     08 C2 05 F6 | 	mov	arg01, #8
0e598     60 FF BF FD | 	call	#__system___tx
0e59c     08 00 90 FD | 	jmp	#LR__1853
0e5a0                 | LR__1852
0e5a0     EC C2 01 F6 | 	mov	arg01, local01
0e5a4     54 FF BF FD | 	call	#__system___tx
0e5a8                 | LR__1853
0e5a8                 | LR__1854
0e5a8     EC A6 01 F6 | 	mov	result1, local01
0e5ac     A7 F0 03 F6 | 	mov	ptra, fp
0e5b0     B2 00 A0 FD | 	call	#popregs_
0e5b4                 | __system___rx_ret
0e5b4     2D 00 64 FD | 	ret
0e5b8                 | 
0e5b8                 | __system___waitms
0e5b8     E1 AA 01 F6 | 	mov	_var01, arg01
0e5bc     1A AC 61 FD | 	getct	_var02
0e5c0     14 AE 05 FB | 	rdlong	_var03, #20
0e5c4     97 14 48 FB | 	callpa	#(@LR__1861-@LR__1860)>>2,fcache_load_ptr_
0e5c8                 | LR__1860
0e5c8     01 00 00 FF 
0e5cc     E8 AB 55 F2 | 	cmps	_var01, ##1000 wc
0e5d0     1C 00 90 CD |  if_b	jmp	#LR__1862
0e5d4     D7 AC 01 F1 | 	add	_var02, _var03
0e5d8     D6 C2 01 F6 | 	mov	arg01, _var02
0e5dc     00 C2 65 FA | 	addct1	arg01, #0
0e5e0     24 22 60 FD | 	waitct1
0e5e4     01 00 00 FF 
0e5e8     E8 AB 85 F1 | 	sub	_var01, ##1000
0e5ec     D8 FF 9F FD | 	jmp	#LR__1860
0e5f0                 | LR__1861
0e5f0                 | LR__1862
0e5f0     01 AA 55 F2 | 	cmps	_var01, #1 wc
0e5f4     28 00 90 CD |  if_b	jmp	#LR__1863
0e5f8     D7 AA 01 FD | 	qmul	_var01, _var03
0e5fc     01 00 00 FF 
0e600     E8 C7 05 F6 | 	mov	arg03, ##1000
0e604     19 A6 61 FD | 	getqy	result1
0e608     18 C2 61 FD | 	getqx	arg01
0e60c     28 A6 61 FD | 	setq	result1
0e610     E3 C2 11 FD | 	qdiv	arg01, arg03
0e614     18 C2 61 FD | 	getqx	arg01
0e618     D6 C2 61 FA | 	addct1	arg01, _var02
0e61c     24 22 60 FD | 	waitct1
0e620                 | LR__1863
0e620                 | __system___waitms_ret
0e620     2D 00 64 FD | 	ret
0e624                 | 
0e624                 | __system___waitus
0e624     E1 AA 01 F6 | 	mov	_var01, arg01
0e628     1A AC 61 FD | 	getct	_var02
0e62c     14 AE 05 FB | 	rdlong	_var03, #20
0e630     97 14 48 FB | 	callpa	#(@LR__1871-@LR__1870)>>2,fcache_load_ptr_
0e634                 | LR__1870
0e634     A1 07 00 FF 
0e638     40 AA 55 F2 | 	cmps	_var01, ##1000000 wc
0e63c     1C 00 90 CD |  if_b	jmp	#LR__1872
0e640     D7 AC 01 F1 | 	add	_var02, _var03
0e644     D6 C2 01 F6 | 	mov	arg01, _var02
0e648     00 C2 65 FA | 	addct1	arg01, #0
0e64c     24 22 60 FD | 	waitct1
0e650     A1 07 00 FF 
0e654     40 AA 85 F1 | 	sub	_var01, ##1000000
0e658     D8 FF 9F FD | 	jmp	#LR__1870
0e65c                 | LR__1871
0e65c                 | LR__1872
0e65c     01 AA 55 F2 | 	cmps	_var01, #1 wc
0e660     28 00 90 CD |  if_b	jmp	#LR__1873
0e664     D7 AA 01 FD | 	qmul	_var01, _var03
0e668     A1 07 00 FF 
0e66c     40 C6 05 F6 | 	mov	arg03, ##1000000
0e670     19 A6 61 FD | 	getqy	result1
0e674     18 C2 61 FD | 	getqx	arg01
0e678     28 A6 61 FD | 	setq	result1
0e67c     E3 C2 11 FD | 	qdiv	arg01, arg03
0e680     18 A6 61 FD | 	getqx	result1
0e684     D3 AC 61 FA | 	addct1	_var02, result1
0e688     24 22 60 FD | 	waitct1
0e68c                 | LR__1873
0e68c                 | __system___waitus_ret
0e68c     2D 00 64 FD | 	ret
0e690                 | 
0e690                 | __system___mount
0e690     09 4A 05 F6 | 	mov	COUNT_, #9
0e694     A8 00 A0 FD | 	call	#pushregs_
0e698     E1 D8 01 F6 | 	mov	local01, arg01
0e69c     E2 DA 09 F6 | 	mov	local02, arg02 wz
0e6a0     01 DC 65 F6 | 	neg	local03, #1
0e6a4     01 A6 65 A6 |  if_e	neg	result1, #1
0e6a8     9C 02 90 AD |  if_e	jmp	#LR__1895
0e6ac     EC A6 C1 FA | 	rdbyte	result1, local01
0e6b0     2F A6 0D F2 | 	cmp	result1, #47 wz
0e6b4     28 00 90 5D |  if_ne	jmp	#LR__1882
0e6b8     EC C2 01 F6 | 	mov	arg01, local01
0e6bc     E1 DE 01 F6 | 	mov	local04, arg01
0e6c0     97 06 48 FB | 	callpa	#(@LR__1881-@LR__1880)>>2,fcache_load_ptr_
0e6c4                 | LR__1880
0e6c4     EF A6 C9 FA | 	rdbyte	result1, local04 wz
0e6c8     01 DE 05 51 |  if_ne	add	local04, #1
0e6cc     F4 FF 9F 5D |  if_ne	jmp	#LR__1880
0e6d0                 | LR__1881
0e6d0     E1 DE 81 F1 | 	sub	local04, arg01
0e6d4     EF A6 01 F6 | 	mov	result1, local04
0e6d8     10 A6 55 F2 | 	cmps	result1, #16 wc
0e6dc     14 00 90 CD |  if_b	jmp	#LR__1883
0e6e0                 | LR__1882
0e6e0     20 92 05 F1 | 	add	ptr___system__dat__, #32
0e6e4     C9 14 68 FC | 	wrlong	#10, ptr___system__dat__
0e6e8     20 92 85 F1 | 	sub	ptr___system__dat__, #32
0e6ec     01 A6 65 F6 | 	neg	result1, #1
0e6f0     54 02 90 FD | 	jmp	#LR__1895
0e6f4                 | LR__1883
0e6f4     00 E0 05 F6 | 	mov	local05, #0
0e6f8                 | LR__1884
0e6f8     04 E0 55 F2 | 	cmps	local05, #4 wc
0e6fc     B4 00 90 3D |  if_ae	jmp	#LR__1889
0e700     F0 C2 01 F6 | 	mov	arg01, local05
0e704     02 C2 65 F0 | 	shl	arg01, #2
0e708     C9 A6 01 F6 | 	mov	result1, ptr___system__dat__
0e70c     64 A6 05 F1 | 	add	result1, #100
0e710     D3 C2 01 F1 | 	add	arg01, result1
0e714     E1 A6 09 FB | 	rdlong	result1, arg01 wz
0e718     00 DC 55 A2 |  if_e	cmps	local03, #0 wc
0e71c     F0 DC 01 86 |  if_c_and_z	mov	local03, local05
0e720     88 00 90 8D |  if_c_and_z	jmp	#LR__1888
0e724     F0 C2 01 F6 | 	mov	arg01, local05
0e728     02 C2 65 F0 | 	shl	arg01, #2
0e72c     C9 DE 01 F6 | 	mov	local04, ptr___system__dat__
0e730     64 DE 05 F1 | 	add	local04, #100
0e734     EF C2 01 F1 | 	add	arg01, local04
0e738     E1 C2 01 FB | 	rdlong	arg01, arg01
0e73c     E1 DE 01 F6 | 	mov	local04, arg01
0e740     97 06 48 FB | 	callpa	#(@LR__1886-@LR__1885)>>2,fcache_load_ptr_
0e744                 | LR__1885
0e744     EF A6 C9 FA | 	rdbyte	result1, local04 wz
0e748     01 DE 05 51 |  if_ne	add	local04, #1
0e74c     F4 FF 9F 5D |  if_ne	jmp	#LR__1885
0e750                 | LR__1886
0e750     E1 DE 81 F1 | 	sub	local04, arg01
0e754     EF A6 01 F6 | 	mov	result1, local04
0e758     D3 E2 01 F6 | 	mov	local06, result1
0e75c     F1 C2 01 F6 | 	mov	arg01, local06
0e760     EC C2 01 F1 | 	add	arg01, local01
0e764     E1 DE C1 FA | 	rdbyte	local04, arg01
0e768     2F DE 0D F2 | 	cmp	local04, #47 wz
0e76c     F1 E4 01 56 |  if_ne	mov	local07, local06
0e770     EC E4 01 51 |  if_ne	add	local07, local01
0e774     F2 C2 C9 5A |  if_ne	rdbyte	arg01, local07 wz
0e778     30 00 90 5D |  if_ne	jmp	#LR__1887
0e77c     F0 DE 01 F6 | 	mov	local04, local05
0e780     02 DE 65 F0 | 	shl	local04, #2
0e784     C9 C6 01 F6 | 	mov	arg03, ptr___system__dat__
0e788     64 C6 05 F1 | 	add	arg03, #100
0e78c     E3 DE 01 F1 | 	add	local04, arg03
0e790     EF C4 01 FB | 	rdlong	arg02, local04
0e794     EC C2 01 F6 | 	mov	arg01, local01
0e798     F1 C6 01 F6 | 	mov	arg03, local06
0e79c     7C 0E B0 FD | 	call	#__system__strncmp
0e7a0     00 A6 0D F2 | 	cmp	result1, #0 wz
0e7a4     F0 DC 01 A6 |  if_e	mov	local03, local05
0e7a8     08 00 90 AD |  if_e	jmp	#LR__1889
0e7ac                 | LR__1887
0e7ac                 | LR__1888
0e7ac     01 E0 05 F1 | 	add	local05, #1
0e7b0     44 FF 9F FD | 	jmp	#LR__1884
0e7b4                 | LR__1889
0e7b4     FF FF 7F FF 
0e7b8     FF DD 0D F2 | 	cmp	local03, ##-1 wz
0e7bc     20 92 05 A1 |  if_e	add	ptr___system__dat__, #32
0e7c0     C9 16 68 AC |  if_e	wrlong	#11, ptr___system__dat__
0e7c4     20 92 85 A1 |  if_e	sub	ptr___system__dat__, #32
0e7c8     01 A6 65 A6 |  if_e	neg	result1, #1
0e7cc     78 01 90 AD |  if_e	jmp	#LR__1895
0e7d0     EE E0 01 F6 | 	mov	local05, local03
0e7d4     F0 E4 01 F6 | 	mov	local07, local05
0e7d8     02 E4 65 F0 | 	shl	local07, #2
0e7dc     C9 E2 01 F6 | 	mov	local06, ptr___system__dat__
0e7e0     74 E2 05 F1 | 	add	local06, #116
0e7e4     F1 E4 01 F1 | 	add	local07, local06
0e7e8     F2 E2 09 FB | 	rdlong	local06, local07 wz
0e7ec     58 00 90 AD |  if_e	jmp	#LR__1890
0e7f0     4C E2 05 F1 | 	add	local06, #76
0e7f4     F1 E4 09 FB | 	rdlong	local07, local06 wz
0e7f8     4C E2 85 F1 | 	sub	local06, #76
0e7fc     48 00 90 AD |  if_e	jmp	#LR__1890
0e800     4C E2 05 F1 | 	add	local06, #76
0e804     F1 E4 01 FB | 	rdlong	local07, local06
0e808     F2 DE 01 F6 | 	mov	local04, local07
0e80c     13 E4 45 F7 | 	zerox	local07, #19
0e810     14 DE 45 F0 | 	shr	local04, #20
0e814     02 DE 65 F0 | 	shl	local04, #2
0e818     C5 DE 01 F1 | 	add	local04, __methods__
0e81c     EF DE 01 FB | 	rdlong	local04, local04
0e820     F0 E2 01 F6 | 	mov	local06, local05
0e824     02 E2 65 F0 | 	shl	local06, #2
0e828     C9 DC 01 F6 | 	mov	local03, ptr___system__dat__
0e82c     64 DC 05 F1 | 	add	local03, #100
0e830     EE E2 01 F1 | 	add	local06, local03
0e834     F1 C2 01 FB | 	rdlong	arg01, local06
0e838     C8 E2 01 F6 | 	mov	local06, objptr
0e83c     F2 90 01 F6 | 	mov	objptr, local07
0e840     2D DE 61 FD | 	call	local04
0e844     F1 90 01 F6 | 	mov	objptr, local06
0e848                 | LR__1890
0e848     F0 E2 01 F6 | 	mov	local06, local05
0e84c     02 E2 65 F0 | 	shl	local06, #2
0e850     C9 E4 01 F6 | 	mov	local07, ptr___system__dat__
0e854     74 E4 05 F1 | 	add	local07, #116
0e858     F2 E2 01 F1 | 	add	local06, local07
0e85c     F1 DA 61 FC | 	wrlong	local02, local06
0e860     00 DA 0D F2 | 	cmp	local02, #0 wz
0e864     18 00 90 5D |  if_ne	jmp	#LR__1891
0e868     02 E0 65 F0 | 	shl	local05, #2
0e86c     C9 E4 01 F6 | 	mov	local07, ptr___system__dat__
0e870     64 E4 05 F1 | 	add	local07, #100
0e874     F2 E0 01 F1 | 	add	local05, local07
0e878     F0 00 68 FC | 	wrlong	#0, local05
0e87c     C4 00 90 FD | 	jmp	#LR__1894
0e880                 | LR__1891
0e880     F0 E6 01 F6 | 	mov	local08, local05
0e884     04 E6 65 F0 | 	shl	local08, #4
0e888     C9 E4 01 F6 | 	mov	local07, ptr___system__dat__
0e88c     24 E4 05 F1 | 	add	local07, #36
0e890     F2 E6 01 F1 | 	add	local08, local07
0e894     F3 C2 01 F6 | 	mov	arg01, local08
0e898     EC C4 01 F6 | 	mov	arg02, local01
0e89c     10 C6 05 F6 | 	mov	arg03, #16
0e8a0     BC 0C B0 FD | 	call	#__system__strncpy
0e8a4     48 DA 05 F1 | 	add	local02, #72
0e8a8     ED E4 09 FB | 	rdlong	local07, local02 wz
0e8ac     48 DA 85 F1 | 	sub	local02, #72
0e8b0     7C 00 90 AD |  if_e	jmp	#LR__1893
0e8b4     48 DA 05 F1 | 	add	local02, #72
0e8b8     ED E4 01 FB | 	rdlong	local07, local02
0e8bc     F2 E8 01 F6 | 	mov	local09, local07
0e8c0     13 E4 45 F7 | 	zerox	local07, #19
0e8c4     14 E8 45 F0 | 	shr	local09, #20
0e8c8     02 E8 65 F0 | 	shl	local09, #2
0e8cc     C5 E8 01 F1 | 	add	local09, __methods__
0e8d0     F4 E8 01 FB | 	rdlong	local09, local09
0e8d4     F3 C2 01 F6 | 	mov	arg01, local08
0e8d8     C8 E2 01 F6 | 	mov	local06, objptr
0e8dc     F2 90 01 F6 | 	mov	objptr, local07
0e8e0     2D E8 61 FD | 	call	local09
0e8e4     F1 90 01 F6 | 	mov	objptr, local06
0e8e8     D3 C2 09 F6 | 	mov	arg01, result1 wz
0e8ec     40 00 90 AD |  if_e	jmp	#LR__1892
0e8f0     F0 E6 01 F6 | 	mov	local08, local05
0e8f4     02 E6 65 F0 | 	shl	local08, #2
0e8f8     74 92 05 F1 | 	add	ptr___system__dat__, #116
0e8fc     C9 E6 01 F1 | 	add	local08, ptr___system__dat__
0e900     F3 00 68 FC | 	wrlong	#0, local08
0e904     02 E0 65 F0 | 	shl	local05, #2
0e908     10 92 85 F1 | 	sub	ptr___system__dat__, #16
0e90c     C9 E0 01 F1 | 	add	local05, ptr___system__dat__
0e910     F0 00 68 FC | 	wrlong	#0, local05
0e914     E1 C2 69 F6 | 	neg	arg01, arg01 wz
0e918     44 92 85 F1 | 	sub	ptr___system__dat__, #68
0e91c     C9 C2 61 FC | 	wrlong	arg01, ptr___system__dat__
0e920     20 92 85 F1 | 	sub	ptr___system__dat__, #32
0e924     01 A6 65 56 |  if_ne	neg	result1, #1
0e928     00 A6 05 A6 |  if_e	mov	result1, #0
0e92c     18 00 90 FD | 	jmp	#LR__1895
0e930                 | LR__1892
0e930                 | LR__1893
0e930     02 E0 65 F0 | 	shl	local05, #2
0e934     C9 E4 01 F6 | 	mov	local07, ptr___system__dat__
0e938     64 E4 05 F1 | 	add	local07, #100
0e93c     F2 E0 01 F1 | 	add	local05, local07
0e940     F0 E6 61 FC | 	wrlong	local08, local05
0e944                 | LR__1894
0e944     00 A6 05 F6 | 	mov	result1, #0
0e948                 | LR__1895
0e948     A7 F0 03 F6 | 	mov	ptra, fp
0e94c     B2 00 A0 FD | 	call	#popregs_
0e950                 | __system___mount_ret
0e950     2D 00 64 FD | 	ret
0e954                 | 
0e954                 | __system____getvfsforfile
0e954     0E 4A 05 F6 | 	mov	COUNT_, #14
0e958     A8 00 A0 FD | 	call	#pushregs_
0e95c     E1 D8 01 F6 | 	mov	local01, arg01
0e960     E2 DA 01 F6 | 	mov	local02, arg02
0e964     E3 DC 01 F6 | 	mov	local03, arg03
0e968     97 10 48 FB | 	callpa	#(@LR__1901-@LR__1900)>>2,fcache_load_ptr_
0e96c                 | LR__1900
0e96c     ED A6 C1 FA | 	rdbyte	result1, local02
0e970     2F A6 0D F2 | 	cmp	result1, #47 wz
0e974     01 DA 05 A1 |  if_e	add	local02, #1
0e978     ED DE C1 AA |  if_e	rdbyte	local04, local02
0e97c     01 DA 85 A1 |  if_e	sub	local02, #1
0e980     2F DE 0D A2 |  if_e	cmp	local04, #47 wz
0e984     01 DA 05 A1 |  if_e	add	local02, #1
0e988     E0 FF 9F AD |  if_e	jmp	#LR__1900
0e98c                 | LR__1901
0e98c     ED DE C1 FA | 	rdbyte	local04, local02
0e990     2F DE 0D F2 | 	cmp	local04, #47 wz
0e994     14 00 90 5D |  if_ne	jmp	#LR__1902
0e998     EC C2 01 F6 | 	mov	arg01, local01
0e99c     ED C4 01 F6 | 	mov	arg02, local02
0e9a0     00 C7 05 F6 | 	mov	arg03, #256
0e9a4     B8 0B B0 FD | 	call	#__system__strncpy
0e9a8     78 00 90 FD | 	jmp	#LR__1904
0e9ac                 | LR__1902
0e9ac     C9 C4 01 F6 | 	mov	arg02, ptr___system__dat__
0e9b0     84 C4 05 F1 | 	add	arg02, #132
0e9b4     EC C2 01 F6 | 	mov	arg01, local01
0e9b8     00 C7 05 F6 | 	mov	arg03, #256
0e9bc     A0 0B B0 FD | 	call	#__system__strncpy
0e9c0     ED DE C9 FA | 	rdbyte	local04, local02 wz
0e9c4     5C 00 90 AD |  if_e	jmp	#LR__1903
0e9c8     ED DE C1 FA | 	rdbyte	local04, local02
0e9cc     2E DE 0D F2 | 	cmp	local04, #46 wz
0e9d0     01 DA 05 A1 |  if_e	add	local02, #1
0e9d4     ED E0 C1 AA |  if_e	rdbyte	local05, local02
0e9d8     01 DA 85 A1 |  if_e	sub	local02, #1
0e9dc     F0 E2 01 A6 |  if_e	mov	local06, local05
0e9e0     07 E2 4D A7 |  if_e	zerox	local06, #7 wz
0e9e4     3C 00 90 AD |  if_e	jmp	#LR__1903
0e9e8     EC E0 C1 FA | 	rdbyte	local05, local01
0e9ec     2F E0 0D F2 | 	cmp	local05, #47 wz
0e9f0     01 D8 05 A1 |  if_e	add	local01, #1
0e9f4     EC DE C1 AA |  if_e	rdbyte	local04, local01
0e9f8     01 D8 85 A1 |  if_e	sub	local01, #1
0e9fc     00 DE 4D A2 |  if_e	cmps	local04, #0 wz
0ea00     7C 00 00 5F 
0ea04     F4 C4 05 56 |  if_ne	mov	arg02, ##@LR__2090
0ea08     EC C2 01 56 |  if_ne	mov	arg01, local01
0ea0c     00 C7 05 56 |  if_ne	mov	arg03, #256
0ea10     A4 0B B0 5D |  if_ne	call	#__system__strncat
0ea14     EC C2 01 F6 | 	mov	arg01, local01
0ea18     ED C4 01 F6 | 	mov	arg02, local02
0ea1c     00 C7 05 F6 | 	mov	arg03, #256
0ea20     94 0B B0 FD | 	call	#__system__strncat
0ea24                 | LR__1903
0ea24                 | LR__1904
0ea24     EC C2 01 F6 | 	mov	arg01, local01
0ea28     50 0D B0 FD | 	call	#__system___normalizeName
0ea2c     EC DE C9 FA | 	rdbyte	local04, local01 wz
0ea30     1C 00 90 AD |  if_e	jmp	#LR__1905
0ea34     EC DE C1 FA | 	rdbyte	local04, local01
0ea38     2F DE 0D F2 | 	cmp	local04, #47 wz
0ea3c     01 D8 05 A1 |  if_e	add	local01, #1
0ea40     EC E2 C1 AA |  if_e	rdbyte	local06, local01
0ea44     01 D8 85 A1 |  if_e	sub	local01, #1
0ea48     00 E2 4D A2 |  if_e	cmps	local06, #0 wz
0ea4c     10 00 90 5D |  if_ne	jmp	#LR__1906
0ea50                 | LR__1905
0ea50     C9 A6 01 F6 | 	mov	result1, ptr___system__dat__
0ea54     01 00 00 FF 
0ea58     84 A6 05 F1 | 	add	result1, ##644
0ea5c     EC 01 90 FD | 	jmp	#LR__1920
0ea60                 | LR__1906
0ea60     00 E4 05 F6 | 	mov	local07, #0
0ea64                 | LR__1907
0ea64     04 E4 55 F2 | 	cmps	local07, #4 wc
0ea68     CC 01 90 3D |  if_ae	jmp	#LR__1919
0ea6c     F2 E2 01 F6 | 	mov	local06, local07
0ea70     02 E2 65 F0 | 	shl	local06, #2
0ea74     C9 DE 01 F6 | 	mov	local04, ptr___system__dat__
0ea78     64 DE 05 F1 | 	add	local04, #100
0ea7c     EF E2 01 F1 | 	add	local06, local04
0ea80     F1 E2 09 FB | 	rdlong	local06, local06 wz
0ea84     A8 01 90 AD |  if_e	jmp	#LR__1918
0ea88     F2 DE 01 F6 | 	mov	local04, local07
0ea8c     02 DE 65 F0 | 	shl	local04, #2
0ea90     C9 E2 01 F6 | 	mov	local06, ptr___system__dat__
0ea94     64 E2 05 F1 | 	add	local06, #100
0ea98     F1 DE 01 F1 | 	add	local04, local06
0ea9c     EF C2 01 FB | 	rdlong	arg01, local04
0eaa0     E1 E6 01 F6 | 	mov	local08, arg01
0eaa4     97 06 48 FB | 	callpa	#(@LR__1909-@LR__1908)>>2,fcache_load_ptr_
0eaa8                 | LR__1908
0eaa8     F3 A6 C9 FA | 	rdbyte	result1, local08 wz
0eaac     01 E6 05 51 |  if_ne	add	local08, #1
0eab0     F4 FF 9F 5D |  if_ne	jmp	#LR__1908
0eab4                 | LR__1909
0eab4     E1 E6 81 F1 | 	sub	local08, arg01
0eab8     F3 E8 01 F6 | 	mov	local09, local08
0eabc     F4 DE 01 F6 | 	mov	local04, local09
0eac0     EC DE 01 F1 | 	add	local04, local01
0eac4     EF E2 C1 FA | 	rdbyte	local06, local04
0eac8     2F E2 0D F2 | 	cmp	local06, #47 wz
0eacc     F4 EA 01 56 |  if_ne	mov	local10, local09
0ead0     EC EA 01 51 |  if_ne	add	local10, local01
0ead4     F5 E0 C9 5A |  if_ne	rdbyte	local05, local10 wz
0ead8     54 01 90 5D |  if_ne	jmp	#LR__1917
0eadc     F2 DE 01 F6 | 	mov	local04, local07
0eae0     02 DE 65 F0 | 	shl	local04, #2
0eae4     C9 C6 01 F6 | 	mov	arg03, ptr___system__dat__
0eae8     64 C6 05 F1 | 	add	arg03, #100
0eaec     E3 DE 01 F1 | 	add	local04, arg03
0eaf0     EF C4 01 FB | 	rdlong	arg02, local04
0eaf4     F4 C6 01 F6 | 	mov	arg03, local09
0eaf8     EC C2 01 F6 | 	mov	arg01, local01
0eafc     1C 0B B0 FD | 	call	#__system__strncmp
0eb00     00 A6 4D F2 | 	cmps	result1, #0 wz
0eb04     28 01 90 5D |  if_ne	jmp	#LR__1917
0eb08     F2 EC 01 F6 | 	mov	local11, local07
0eb0c     02 EC 65 F0 | 	shl	local11, #2
0eb10     C9 DE 01 F6 | 	mov	local04, ptr___system__dat__
0eb14     74 DE 05 F1 | 	add	local04, #116
0eb18     EF EC 01 F1 | 	add	local11, local04
0eb1c     F6 EE 01 FB | 	rdlong	local12, local11
0eb20     97 22 48 FB | 	callpa	#(@LR__1911-@LR__1910)>>2,fcache_load_ptr_
0eb24                 | LR__1910
0eb24     F4 E2 01 F6 | 	mov	local06, local09
0eb28     01 E2 05 F1 | 	add	local06, #1
0eb2c     EC E2 01 F1 | 	add	local06, local01
0eb30     F1 EC C1 FA | 	rdbyte	local11, local06
0eb34     2E EC 0D F2 | 	cmp	local11, #46 wz
0eb38     2C 00 90 5D |  if_ne	jmp	#LR__1912
0eb3c     F4 EC 01 F6 | 	mov	local11, local09
0eb40     02 EC 05 F1 | 	add	local11, #2
0eb44     EC EC 01 F1 | 	add	local11, local01
0eb48     F6 EA C1 FA | 	rdbyte	local10, local11
0eb4c     2F EA 0D F2 | 	cmp	local10, #47 wz
0eb50     F4 F0 01 56 |  if_ne	mov	local13, local09
0eb54     02 F0 05 51 |  if_ne	add	local13, #2
0eb58     EC F0 01 51 |  if_ne	add	local13, local01
0eb5c     F8 F2 C9 5A |  if_ne	rdbyte	local14, local13 wz
0eb60     01 E8 05 A1 |  if_e	add	local09, #1
0eb64     BC FF 9F AD |  if_e	jmp	#LR__1910
0eb68                 | LR__1911
0eb68                 | LR__1912
0eb68     00 DC 0D F2 | 	cmp	local03, #0 wz
0eb6c     EE C2 01 56 |  if_ne	mov	arg01, local03
0eb70     EC C4 01 56 |  if_ne	mov	arg02, local01
0eb74     00 C7 05 56 |  if_ne	mov	arg03, #256
0eb78     E4 09 B0 5D |  if_ne	call	#__system__strncpy
0eb7c     EC C4 01 F6 | 	mov	arg02, local01
0eb80     F4 C4 01 F1 | 	add	arg02, local09
0eb84     01 C4 05 F1 | 	add	arg02, #1
0eb88     EC C2 01 F6 | 	mov	arg01, local01
0eb8c     CC F8 BF FD | 	call	#__system____builtin_strcpy
0eb90     EC C2 01 F6 | 	mov	arg01, local01
0eb94     E1 E6 01 F6 | 	mov	local08, arg01
0eb98     97 06 48 FB | 	callpa	#(@LR__1914-@LR__1913)>>2,fcache_load_ptr_
0eb9c                 | LR__1913
0eb9c     F3 A6 C9 FA | 	rdbyte	result1, local08 wz
0eba0     01 E6 05 51 |  if_ne	add	local08, #1
0eba4     F4 FF 9F 5D |  if_ne	jmp	#LR__1913
0eba8                 | LR__1914
0eba8     E1 E6 81 F1 | 	sub	local08, arg01
0ebac     F3 E8 01 F6 | 	mov	local09, local08
0ebb0                 | LR__1915
0ebb0     01 E8 55 F2 | 	cmps	local09, #1 wc
0ebb4     70 00 90 CD |  if_b	jmp	#LR__1916
0ebb8     F4 DE 01 F6 | 	mov	local04, local09
0ebbc     EC DE 01 F1 | 	add	local04, local01
0ebc0     EF EC C1 FA | 	rdbyte	local11, local04
0ebc4     2F EC 0D F2 | 	cmp	local11, #47 wz
0ebc8     F4 EC 01 A6 |  if_e	mov	local11, local09
0ebcc     EC EC 01 A1 |  if_e	add	local11, local01
0ebd0     F6 00 48 AC |  if_e	wrbyte	#0, local11
0ebd4     01 E8 85 A1 |  if_e	sub	local09, #1
0ebd8     D4 FF 9F AD |  if_e	jmp	#LR__1915
0ebdc     F4 DE 01 F6 | 	mov	local04, local09
0ebe0     EC DE 01 F1 | 	add	local04, local01
0ebe4     EF EC C1 FA | 	rdbyte	local11, local04
0ebe8     2E EC 0D F2 | 	cmp	local11, #46 wz
0ebec     38 00 90 5D |  if_ne	jmp	#LR__1916
0ebf0     02 E8 55 F2 | 	cmps	local09, #2 wc
0ebf4     30 00 90 CD |  if_b	jmp	#LR__1916
0ebf8     F4 F2 01 F6 | 	mov	local14, local09
0ebfc     01 F2 85 F1 | 	sub	local14, #1
0ec00     EC F2 01 F1 | 	add	local14, local01
0ec04     F9 E0 C1 FA | 	rdbyte	local05, local14
0ec08     2F E0 0D F2 | 	cmp	local05, #47 wz
0ec0c     18 00 90 5D |  if_ne	jmp	#LR__1916
0ec10     F4 DE 01 F6 | 	mov	local04, local09
0ec14     01 DE 85 F1 | 	sub	local04, #1
0ec18     EC DE 01 F1 | 	add	local04, local01
0ec1c     EF 00 48 FC | 	wrbyte	#0, local04
0ec20     02 E8 85 F1 | 	sub	local09, #2
0ec24     88 FF 9F FD | 	jmp	#LR__1915
0ec28                 | LR__1916
0ec28     F7 A6 01 F6 | 	mov	result1, local12
0ec2c     1C 00 90 FD | 	jmp	#LR__1920
0ec30                 | LR__1917
0ec30                 | LR__1918
0ec30     01 E4 05 F1 | 	add	local07, #1
0ec34     2C FE 9F FD | 	jmp	#LR__1907
0ec38                 | LR__1919
0ec38     01 00 00 FF 
0ec3c     D4 92 05 F1 | 	add	ptr___system__dat__, ##724
0ec40     C9 A6 01 FB | 	rdlong	result1, ptr___system__dat__
0ec44     01 00 00 FF 
0ec48     D4 92 85 F1 | 	sub	ptr___system__dat__, ##724
0ec4c                 | LR__1920
0ec4c     A7 F0 03 F6 | 	mov	ptra, fp
0ec50     B2 00 A0 FD | 	call	#popregs_
0ec54                 | __system____getvfsforfile_ret
0ec54     2D 00 64 FD | 	ret
0ec58                 | 
0ec58                 | __system___int64_shl
0ec58     20 C6 CD F7 | 	test	arg03, #32 wz
0ec5c     E1 C4 01 56 |  if_ne	mov	arg02, arg01
0ec60     00 C2 05 56 |  if_ne	mov	arg01, #0
0ec64     1F C6 CD F7 | 	test	arg03, #31 wz
0ec68     18 00 90 AD |  if_e	jmp	#LR__1930
0ec6c     E3 C4 61 F0 | 	shl	arg02, arg03
0ec70     E1 A6 01 F6 | 	mov	result1, arg01
0ec74     E3 A8 61 F6 | 	neg	result2, arg03
0ec78     D4 A6 41 F0 | 	shr	result1, result2
0ec7c     D3 C4 41 F5 | 	or	arg02, result1
0ec80     E3 C2 61 F0 | 	shl	arg01, arg03
0ec84                 | LR__1930
0ec84     E2 A8 01 F6 | 	mov	result2, arg02
0ec88     E1 A6 01 F6 | 	mov	result1, arg01
0ec8c                 | __system___int64_shl_ret
0ec8c     2D 00 64 FD | 	ret
0ec90                 | 
0ec90                 | __system___usepins
0ec90     14 92 05 F1 | 	add	ptr___system__dat__, #20
0ec94     C9 AA 01 FB | 	rdlong	_var01, ptr___system__dat__
0ec98     14 92 85 F1 | 	sub	ptr___system__dat__, #20
0ec9c     D5 C2 C9 F7 | 	test	arg01, _var01 wz
0eca0     18 92 05 A1 |  if_e	add	ptr___system__dat__, #24
0eca4     C9 AC 01 AB |  if_e	rdlong	_var02, ptr___system__dat__
0eca8     18 92 85 A1 |  if_e	sub	ptr___system__dat__, #24
0ecac     D6 C4 C9 A7 |  if_e	test	arg02, _var02 wz
0ecb0     00 A6 05 56 |  if_ne	mov	result1, #0
0ecb4     28 00 90 5D |  if_ne	jmp	#__system___usepins_ret
0ecb8     14 92 05 F1 | 	add	ptr___system__dat__, #20
0ecbc     C9 AC 01 FB | 	rdlong	_var02, ptr___system__dat__
0ecc0     E1 AC 41 F5 | 	or	_var02, arg01
0ecc4     C9 AC 61 FC | 	wrlong	_var02, ptr___system__dat__
0ecc8     04 92 05 F1 | 	add	ptr___system__dat__, #4
0eccc     C9 AC 01 FB | 	rdlong	_var02, ptr___system__dat__
0ecd0     E2 AC 41 F5 | 	or	_var02, arg02
0ecd4     C9 AC 61 FC | 	wrlong	_var02, ptr___system__dat__
0ecd8     18 92 85 F1 | 	sub	ptr___system__dat__, #24
0ecdc     01 A6 65 F6 | 	neg	result1, #1
0ece0                 | __system___usepins_ret
0ece0     2D 00 64 FD | 	ret
0ece4                 | 
0ece4                 | __system___freepins
0ece4     14 92 05 F1 | 	add	ptr___system__dat__, #20
0ece8     C9 AA 01 FB | 	rdlong	_var01, ptr___system__dat__
0ecec     E1 AA 21 F5 | 	andn	_var01, arg01
0ecf0     C9 AA 61 FC | 	wrlong	_var01, ptr___system__dat__
0ecf4     04 92 05 F1 | 	add	ptr___system__dat__, #4
0ecf8     C9 AA 01 FB | 	rdlong	_var01, ptr___system__dat__
0ecfc     E2 AA 21 F5 | 	andn	_var01, arg02
0ed00     C9 AA 61 FC | 	wrlong	_var01, ptr___system__dat__
0ed04     18 92 85 F1 | 	sub	ptr___system__dat__, #24
0ed08                 | __system___freepins_ret
0ed08     2D 00 64 FD | 	ret
0ed0c                 | 
0ed0c                 | __system___gc_ptrs
0ed0c     C4 AA 01 F6 | 	mov	_var01, __heap_ptr
0ed10     D5 AC 01 F6 | 	mov	_var02, _var01
0ed14     0B 00 00 FF 
0ed18     68 AD 05 F1 | 	add	_var02, ##5992
0ed1c     D5 A8 09 FB | 	rdlong	result2, _var01 wz
0ed20     74 00 90 5D |  if_ne	jmp	#LR__1940
0ed24     D6 A8 01 F6 | 	mov	result2, _var02
0ed28     D5 A8 81 F1 | 	sub	result2, _var01
0ed2c     D5 02 58 FC | 	wrword	#1, _var01
0ed30     D5 A6 01 F6 | 	mov	result1, _var01
0ed34     02 A6 05 F1 | 	add	result1, #2
0ed38     36 00 80 FF 
0ed3c     D3 20 59 FC | 	wrword	##27792, result1
0ed40     D5 A6 01 F6 | 	mov	result1, _var01
0ed44     04 A6 05 F1 | 	add	result1, #4
0ed48     D3 00 58 FC | 	wrword	#0, result1
0ed4c     D5 A6 01 F6 | 	mov	result1, _var01
0ed50     06 A6 05 F1 | 	add	result1, #6
0ed54     D3 02 58 FC | 	wrword	#1, result1
0ed58     10 AA 05 F1 | 	add	_var01, #16
0ed5c     D4 A8 51 F6 | 	abs	result2, result2 wc
0ed60     04 A8 45 F0 | 	shr	result2, #4
0ed64     D4 A8 81 F6 | 	negc	result2, result2
0ed68     D5 A8 51 FC | 	wrword	result2, _var01
0ed6c     D5 A8 01 F6 | 	mov	result2, _var01
0ed70     02 A8 05 F1 | 	add	result2, #2
0ed74     36 00 80 FF 
0ed78     D4 1E 59 FC | 	wrword	##27791, result2
0ed7c     D5 A8 01 F6 | 	mov	result2, _var01
0ed80     04 A8 05 F1 | 	add	result2, #4
0ed84     D4 00 58 FC | 	wrword	#0, result2
0ed88     D5 A8 01 F6 | 	mov	result2, _var01
0ed8c     06 A8 05 F1 | 	add	result2, #6
0ed90     D4 00 58 FC | 	wrword	#0, result2
0ed94     10 AA 85 F1 | 	sub	_var01, #16
0ed98                 | LR__1940
0ed98     D5 A6 01 F6 | 	mov	result1, _var01
0ed9c     D6 A8 01 F6 | 	mov	result2, _var02
0eda0                 | __system___gc_ptrs_ret
0eda0     2D 00 64 FD | 	ret
0eda4                 | 
0eda4                 | __system___gc_tryalloc
0eda4     0B 4A 05 F6 | 	mov	COUNT_, #11
0eda8     A8 00 A0 FD | 	call	#pushregs_
0edac     E1 D8 01 F6 | 	mov	local01, arg01
0edb0     E2 DA 01 F6 | 	mov	local02, arg02
0edb4     54 FF BF FD | 	call	#__system___gc_ptrs
0edb8     D3 DC 01 F6 | 	mov	local03, result1
0edbc     D4 DE 01 F6 | 	mov	local04, result2
0edc0     EE E0 01 F6 | 	mov	local05, local03
0edc4     00 E2 05 F6 | 	mov	local06, #0
0edc8     97 1E 48 FB | 	callpa	#(@LR__1951-@LR__1950)>>2,fcache_load_ptr_
0edcc                 | LR__1950
0edcc     F0 E4 01 F6 | 	mov	local07, local05
0edd0     06 E0 05 F1 | 	add	local05, #6
0edd4     F0 C4 E9 FA | 	rdword	arg02, local05 wz
0edd8     EE C2 01 F6 | 	mov	arg01, local03
0eddc     00 A6 05 A6 |  if_e	mov	result1, #0
0ede0     04 C4 65 50 |  if_ne	shl	arg02, #4
0ede4     E2 C2 01 51 |  if_ne	add	arg01, arg02
0ede8     E1 A6 01 56 |  if_ne	mov	result1, arg01
0edec     D3 E0 09 F6 | 	mov	local05, result1 wz
0edf0     F0 E2 E1 5A |  if_ne	rdword	local06, local05
0edf4     00 E0 0D F2 | 	cmp	local05, #0 wz
0edf8     EF E0 51 52 |  if_ne	cmps	local05, local04 wc
0edfc     08 00 90 1D |  if_a	jmp	#LR__1952
0ee00     F1 D8 59 52 |  if_ne	cmps	local01, local06 wcz
0ee04     C4 FF 9F 1D |  if_a	jmp	#LR__1950
0ee08                 | LR__1951
0ee08                 | LR__1952
0ee08     00 E0 0D F2 | 	cmp	local05, #0 wz
0ee0c     F0 A6 01 A6 |  if_e	mov	result1, local05
0ee10     3C 01 90 AD |  if_e	jmp	#LR__1955
0ee14     F0 A8 01 F6 | 	mov	result2, local05
0ee18     06 A8 05 F1 | 	add	result2, #6
0ee1c     D4 E6 E1 FA | 	rdword	local08, result2
0ee20     F1 D8 51 F2 | 	cmps	local01, local06 wc
0ee24     C0 00 90 3D |  if_ae	jmp	#LR__1954
0ee28     F0 D8 51 FC | 	wrword	local01, local05
0ee2c     F0 C2 01 F6 | 	mov	arg01, local05
0ee30     EC E6 01 F6 | 	mov	local08, local01
0ee34     04 E6 65 F0 | 	shl	local08, #4
0ee38     F3 C2 01 F1 | 	add	arg01, local08
0ee3c     EC E2 81 F1 | 	sub	local06, local01
0ee40     E1 E2 51 FC | 	wrword	local06, arg01
0ee44     E1 E6 01 F6 | 	mov	local08, arg01
0ee48     02 E6 05 F1 | 	add	local08, #2
0ee4c     36 00 80 FF 
0ee50     F3 1E 59 FC | 	wrword	##27791, local08
0ee54     F0 C4 09 F6 | 	mov	arg02, local05 wz
0ee58     00 A6 05 A6 |  if_e	mov	result1, #0
0ee5c     EE C4 81 51 |  if_ne	sub	arg02, local03
0ee60     04 C4 45 50 |  if_ne	shr	arg02, #4
0ee64     E2 A6 01 56 |  if_ne	mov	result1, arg02
0ee68     E1 E6 01 F6 | 	mov	local08, arg01
0ee6c     04 E6 05 F1 | 	add	local08, #4
0ee70     F3 A6 51 FC | 	wrword	result1, local08
0ee74     F0 E6 01 F6 | 	mov	local08, local05
0ee78     06 E6 05 F1 | 	add	local08, #6
0ee7c     E1 C4 01 F6 | 	mov	arg02, arg01
0ee80     F3 E6 E1 FA | 	rdword	local08, local08
0ee84     06 C4 05 F1 | 	add	arg02, #6
0ee88     E2 E6 51 FC | 	wrword	local08, arg02
0ee8c     E1 E8 01 F6 | 	mov	local09, arg01
0ee90     F4 C4 09 F6 | 	mov	arg02, local09 wz
0ee94     00 A6 05 A6 |  if_e	mov	result1, #0
0ee98     EE C4 81 51 |  if_ne	sub	arg02, local03
0ee9c     04 C4 45 50 |  if_ne	shr	arg02, #4
0eea0     E2 A6 01 56 |  if_ne	mov	result1, arg02
0eea4     D3 E6 01 F6 | 	mov	local08, result1
0eea8     E1 EA E9 FA | 	rdword	local10, arg01 wz
0eeac     00 A6 05 A6 |  if_e	mov	result1, #0
0eeb0     04 EA 65 50 |  if_ne	shl	local10, #4
0eeb4     F5 C2 01 51 |  if_ne	add	arg01, local10
0eeb8     E1 A6 01 56 |  if_ne	mov	result1, arg01
0eebc     D3 EC 09 F6 | 	mov	local11, result1 wz
0eec0     24 00 90 AD |  if_e	jmp	#LR__1953
0eec4     EF EC 51 F2 | 	cmps	local11, local04 wc
0eec8     1C 00 90 3D |  if_ae	jmp	#LR__1953
0eecc     F4 C4 09 F6 | 	mov	arg02, local09 wz
0eed0     00 A6 05 A6 |  if_e	mov	result1, #0
0eed4     EE C4 81 51 |  if_ne	sub	arg02, local03
0eed8     04 C4 45 50 |  if_ne	shr	arg02, #4
0eedc     E2 A6 01 56 |  if_ne	mov	result1, arg02
0eee0     04 EC 05 F1 | 	add	local11, #4
0eee4     F6 A6 51 FC | 	wrword	result1, local11
0eee8                 | LR__1953
0eee8                 | LR__1954
0eee8     06 E4 05 F1 | 	add	local07, #6
0eeec     F2 E6 51 FC | 	wrword	local08, local07
0eef0     36 00 00 FF 
0eef4     80 E8 05 F6 | 	mov	local09, ##27776
0eef8     ED E8 41 F5 | 	or	local09, local02
0eefc     00 A6 05 F6 | 	mov	result1, #0
0ef00     01 A6 61 FD | 	cogid	result1
0ef04     D3 E8 41 F5 | 	or	local09, result1
0ef08     F0 EC 01 F6 | 	mov	local11, local05
0ef0c     02 EC 05 F1 | 	add	local11, #2
0ef10     F6 E8 51 FC | 	wrword	local09, local11
0ef14     EE E8 01 F6 | 	mov	local09, local03
0ef18     08 E8 05 F1 | 	add	local09, #8
0ef1c     F0 EC 01 F6 | 	mov	local11, local05
0ef20     F4 E8 E1 FA | 	rdword	local09, local09
0ef24     06 EC 05 F1 | 	add	local11, #6
0ef28     F6 E8 51 FC | 	wrword	local09, local11
0ef2c     F0 C4 09 F6 | 	mov	arg02, local05 wz
0ef30     00 A6 05 A6 |  if_e	mov	result1, #0
0ef34     EE C4 81 51 |  if_ne	sub	arg02, local03
0ef38     04 C4 45 50 |  if_ne	shr	arg02, #4
0ef3c     E2 A6 01 56 |  if_ne	mov	result1, arg02
0ef40     08 DC 05 F1 | 	add	local03, #8
0ef44     EE A6 51 FC | 	wrword	result1, local03
0ef48     08 E0 05 F1 | 	add	local05, #8
0ef4c     F0 A6 01 F6 | 	mov	result1, local05
0ef50                 | LR__1955
0ef50     A7 F0 03 F6 | 	mov	ptra, fp
0ef54     B2 00 A0 FD | 	call	#popregs_
0ef58                 | __system___gc_tryalloc_ret
0ef58     2D 00 64 FD | 	ret
0ef5c                 | 
0ef5c                 | __system___gc_alloc_managed
0ef5c     01 4A 05 F6 | 	mov	COUNT_, #1
0ef60     A8 00 A0 FD | 	call	#pushregs_
0ef64     E1 D8 01 F6 | 	mov	local01, arg01
0ef68     00 C4 05 F6 | 	mov	arg02, #0
0ef6c     1C 00 B0 FD | 	call	#__system___gc_doalloc
0ef70     D3 C4 09 F6 | 	mov	arg02, result1 wz
0ef74     01 D8 55 A2 |  if_e	cmps	local01, #1 wc
0ef78     00 A6 05 26 |  if_nc_and_z	mov	result1, #0
0ef7c     E2 A6 01 D6 |  if_c_or_nz	mov	result1, arg02
0ef80     A7 F0 03 F6 | 	mov	ptra, fp
0ef84     B2 00 A0 FD | 	call	#popregs_
0ef88                 | __system___gc_alloc_managed_ret
0ef88     2D 00 64 FD | 	ret
0ef8c                 | 
0ef8c                 | __system___gc_doalloc
0ef8c     06 4A 05 F6 | 	mov	COUNT_, #6
0ef90     A8 00 A0 FD | 	call	#pushregs_
0ef94     E1 D8 09 F6 | 	mov	local01, arg01 wz
0ef98     E2 DA 01 F6 | 	mov	local02, arg02
0ef9c     00 A6 05 A6 |  if_e	mov	result1, #0
0efa0     84 00 90 AD |  if_e	jmp	#LR__1967
0efa4     17 D8 05 F1 | 	add	local01, #23
0efa8     0F D8 25 F5 | 	andn	local01, #15
0efac     04 D8 45 F0 | 	shr	local01, #4
0efb0     C9 C2 01 F6 | 	mov	arg01, ptr___system__dat__
0efb4     1C C2 05 F1 | 	add	arg01, #28
0efb8     18 F5 BF FD | 	call	#__system___lockmem
0efbc     EC C2 01 F6 | 	mov	arg01, local01
0efc0     ED C4 01 F6 | 	mov	arg02, local02
0efc4     DC FD BF FD | 	call	#__system___gc_tryalloc
0efc8     D3 DC 09 F6 | 	mov	local03, result1 wz
0efcc     14 00 90 5D |  if_ne	jmp	#LR__1960
0efd0     64 03 B0 FD | 	call	#__system___gc_docollect
0efd4     EC C2 01 F6 | 	mov	arg01, local01
0efd8     ED C4 01 F6 | 	mov	arg02, local02
0efdc     C4 FD BF FD | 	call	#__system___gc_tryalloc
0efe0     D3 DC 01 F6 | 	mov	local03, result1
0efe4                 | LR__1960
0efe4     C9 C2 01 F6 | 	mov	arg01, ptr___system__dat__
0efe8     1C C2 05 F1 | 	add	arg01, #28
0efec     E1 00 68 FC | 	wrlong	#0, arg01
0eff0     00 DC 0D F2 | 	cmp	local03, #0 wz
0eff4     2C 00 90 AD |  if_e	jmp	#LR__1966
0eff8     04 D8 65 F0 | 	shl	local01, #4
0effc     08 D8 85 F1 | 	sub	local01, #8
0f000     EC DE 51 F6 | 	abs	local04, local01 wc
0f004     02 DE 45 F0 | 	shr	local04, #2
0f008     EF E0 89 F6 | 	negc	local05, local04 wz
0f00c     EE E2 01 F6 | 	mov	local06, local03
0f010     10 00 90 AD |  if_e	jmp	#LR__1965
0f014     97 06 48 FB | 	callpa	#(@LR__1963-@LR__1961)>>2,fcache_load_ptr_
0f018                 | LR__1961
0f018     F0 04 D8 FC | 	rep	@LR__1964, local05
0f01c                 | LR__1962
0f01c     F1 00 68 FC | 	wrlong	#0, local06
0f020     04 E2 05 F1 | 	add	local06, #4
0f024                 | LR__1963
0f024                 | LR__1964
0f024                 | LR__1965
0f024                 | LR__1966
0f024     EE A6 01 F6 | 	mov	result1, local03
0f028                 | LR__1967
0f028     A7 F0 03 F6 | 	mov	ptra, fp
0f02c     B2 00 A0 FD | 	call	#popregs_
0f030                 | __system___gc_doalloc_ret
0f030     2D 00 64 FD | 	ret
0f034                 | 
0f034                 | __system___gc_isvalidptr
0f034     F8 C6 05 F4 | 	bitl	arg03, #248
0f038     08 C6 85 F1 | 	sub	arg03, #8
0f03c     E1 C6 51 F2 | 	cmps	arg03, arg01 wc
0f040     08 00 90 CD |  if_b	jmp	#LR__1970
0f044     E2 C6 51 F2 | 	cmps	arg03, arg02 wc
0f048     08 00 90 CD |  if_b	jmp	#LR__1971
0f04c                 | LR__1970
0f04c     00 A6 05 F6 | 	mov	result1, #0
0f050     38 00 90 FD | 	jmp	#__system___gc_isvalidptr_ret
0f054                 | LR__1971
0f054     E3 AA 01 F6 | 	mov	_var01, arg03
0f058     E1 AA 61 F5 | 	xor	_var01, arg01
0f05c     0F AA CD F7 | 	test	_var01, #15 wz
0f060     00 A6 05 56 |  if_ne	mov	result1, #0
0f064     24 00 90 5D |  if_ne	jmp	#__system___gc_isvalidptr_ret
0f068     E3 AA 01 F6 | 	mov	_var01, arg03
0f06c     02 AA 05 F1 | 	add	_var01, #2
0f070     D5 AA E1 FA | 	rdword	_var01, _var01
0f074     7F 00 00 FF 
0f078     C0 AB 05 F5 | 	and	_var01, ##65472
0f07c     36 00 00 FF 
0f080     80 AA 0D F2 | 	cmp	_var01, ##27776 wz
0f084     00 A6 05 56 |  if_ne	mov	result1, #0
0f088     E3 A6 01 A6 |  if_e	mov	result1, arg03
0f08c                 | __system___gc_isvalidptr_ret
0f08c     2D 00 64 FD | 	ret
0f090                 | 
0f090                 | __system___gc_free
0f090     E1 C6 01 F6 | 	mov	arg03, arg01
0f094     74 FC BF FD | 	call	#__system___gc_ptrs
0f098     D3 C2 01 F6 | 	mov	arg01, result1
0f09c     D4 C4 01 F6 | 	mov	arg02, result2
0f0a0     90 FF BF FD | 	call	#__system___gc_isvalidptr
0f0a4     D3 C4 09 F6 | 	mov	arg02, result1 wz
0f0a8     20 00 90 AD |  if_e	jmp	#LR__1980
0f0ac     C9 C2 01 F6 | 	mov	arg01, ptr___system__dat__
0f0b0     1C C2 05 F1 | 	add	arg01, #28
0f0b4     1C F4 BF FD | 	call	#__system___lockmem
0f0b8     E2 C2 01 F6 | 	mov	arg01, arg02
0f0bc     10 00 B0 FD | 	call	#__system___gc_dofree
0f0c0     C9 C2 01 F6 | 	mov	arg01, ptr___system__dat__
0f0c4     1C C2 05 F1 | 	add	arg01, #28
0f0c8     E1 00 68 FC | 	wrlong	#0, arg01
0f0cc                 | LR__1980
0f0cc                 | __system___gc_free_ret
0f0cc     2D 00 64 FD | 	ret
0f0d0                 | 
0f0d0                 | __system___gc_dofree
0f0d0     06 4A 05 F6 | 	mov	COUNT_, #6
0f0d4     A8 00 A0 FD | 	call	#pushregs_
0f0d8     E1 D8 01 F6 | 	mov	local01, arg01
0f0dc     2C FC BF FD | 	call	#__system___gc_ptrs
0f0e0     D3 DA 01 F6 | 	mov	local02, result1
0f0e4     D4 DC 01 F6 | 	mov	local03, result2
0f0e8     EC C4 01 F6 | 	mov	arg02, local01
0f0ec     02 C4 05 F1 | 	add	arg02, #2
0f0f0     36 00 80 FF 
0f0f4     E2 1E 59 FC | 	wrword	##27791, arg02
0f0f8     EC DE 01 F6 | 	mov	local04, local01
0f0fc     EC C2 01 F6 | 	mov	arg01, local01
0f100     E1 E0 E9 FA | 	rdword	local05, arg01 wz
0f104     00 A6 05 A6 |  if_e	mov	result1, #0
0f108     04 E0 65 50 |  if_ne	shl	local05, #4
0f10c     F0 C2 01 51 |  if_ne	add	arg01, local05
0f110     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f114     D3 E2 01 F6 | 	mov	local06, result1
0f118     97 24 48 FB | 	callpa	#(@LR__1991-@LR__1990)>>2,fcache_load_ptr_
0f11c                 | LR__1990
0f11c     04 DE 05 F1 | 	add	local04, #4
0f120     EF C4 E9 FA | 	rdword	arg02, local04 wz
0f124     ED C2 01 F6 | 	mov	arg01, local02
0f128     00 A6 05 A6 |  if_e	mov	result1, #0
0f12c     04 C4 65 50 |  if_ne	shl	arg02, #4
0f130     E2 C2 01 51 |  if_ne	add	arg01, arg02
0f134     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f138     D3 DE 09 F6 | 	mov	local04, result1 wz
0f13c     24 00 90 AD |  if_e	jmp	#LR__1992
0f140     EF C2 01 F6 | 	mov	arg01, local04
0f144     00 A6 05 F6 | 	mov	result1, #0
0f148     02 C2 05 F1 | 	add	arg01, #2
0f14c     E1 C2 E1 FA | 	rdword	arg01, arg01
0f150     36 00 00 FF 
0f154     8F C2 0D F2 | 	cmp	arg01, ##27791 wz
0f158     01 A6 65 A6 |  if_e	neg	result1, #1
0f15c     00 A6 0D F2 | 	cmp	result1, #0 wz
0f160     B8 FF 9F AD |  if_e	jmp	#LR__1990
0f164                 | LR__1991
0f164                 | LR__1992
0f164     00 DE 0D F2 | 	cmp	local04, #0 wz
0f168     ED DE 01 A6 |  if_e	mov	local04, local02
0f16c     EF C4 01 F6 | 	mov	arg02, local04
0f170     06 C4 05 F1 | 	add	arg02, #6
0f174     EC C2 01 F6 | 	mov	arg01, local01
0f178     E2 C4 E1 FA | 	rdword	arg02, arg02
0f17c     06 C2 05 F1 | 	add	arg01, #6
0f180     E1 C4 51 FC | 	wrword	arg02, arg01
0f184     EC C4 09 F6 | 	mov	arg02, local01 wz
0f188     00 A6 05 A6 |  if_e	mov	result1, #0
0f18c     ED C4 81 51 |  if_ne	sub	arg02, local02
0f190     04 C4 45 50 |  if_ne	shr	arg02, #4
0f194     E2 A6 01 56 |  if_ne	mov	result1, arg02
0f198     EF C4 01 F6 | 	mov	arg02, local04
0f19c     06 C4 05 F1 | 	add	arg02, #6
0f1a0     E2 A6 51 FC | 	wrword	result1, arg02
0f1a4     ED DE 09 F2 | 	cmp	local04, local02 wz
0f1a8     A4 00 90 AD |  if_e	jmp	#LR__1995
0f1ac     EF C2 01 F6 | 	mov	arg01, local04
0f1b0     E1 E0 E9 FA | 	rdword	local05, arg01 wz
0f1b4     00 A6 05 A6 |  if_e	mov	result1, #0
0f1b8     04 E0 65 50 |  if_ne	shl	local05, #4
0f1bc     F0 C2 01 51 |  if_ne	add	arg01, local05
0f1c0     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f1c4     EC A6 09 F2 | 	cmp	result1, local01 wz
0f1c8     84 00 90 5D |  if_ne	jmp	#LR__1994
0f1cc     EF E2 E1 FA | 	rdword	local06, local04
0f1d0     EC C4 E1 FA | 	rdword	arg02, local01
0f1d4     E2 E2 01 F1 | 	add	local06, arg02
0f1d8     EF E2 51 FC | 	wrword	local06, local04
0f1dc     EC E2 01 F6 | 	mov	local06, local01
0f1e0     02 E2 05 F1 | 	add	local06, #2
0f1e4     F1 00 58 FC | 	wrword	#0, local06
0f1e8     EC C2 01 F6 | 	mov	arg01, local01
0f1ec     E1 E0 E9 FA | 	rdword	local05, arg01 wz
0f1f0     00 A6 05 A6 |  if_e	mov	result1, #0
0f1f4     04 E0 65 50 |  if_ne	shl	local05, #4
0f1f8     F0 C2 01 51 |  if_ne	add	arg01, local05
0f1fc     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f200     D3 E2 01 F6 | 	mov	local06, result1
0f204     EE E2 51 F2 | 	cmps	local06, local03 wc
0f208     20 00 90 3D |  if_ae	jmp	#LR__1993
0f20c     EF C4 09 F6 | 	mov	arg02, local04 wz
0f210     00 A6 05 A6 |  if_e	mov	result1, #0
0f214     ED C4 81 51 |  if_ne	sub	arg02, local02
0f218     04 C4 45 50 |  if_ne	shr	arg02, #4
0f21c     E2 A6 01 56 |  if_ne	mov	result1, arg02
0f220     F1 C4 01 F6 | 	mov	arg02, local06
0f224     04 C4 05 F1 | 	add	arg02, #4
0f228     E2 A6 51 FC | 	wrword	result1, arg02
0f22c                 | LR__1993
0f22c     EC C4 01 F6 | 	mov	arg02, local01
0f230     06 C4 05 F1 | 	add	arg02, #6
0f234     EF A8 01 F6 | 	mov	result2, local04
0f238     E2 C4 E1 FA | 	rdword	arg02, arg02
0f23c     06 A8 05 F1 | 	add	result2, #6
0f240     D4 C4 51 FC | 	wrword	arg02, result2
0f244     06 D8 05 F1 | 	add	local01, #6
0f248     EC 00 58 FC | 	wrword	#0, local01
0f24c     EF D8 01 F6 | 	mov	local01, local04
0f250                 | LR__1994
0f250                 | LR__1995
0f250     EC C2 01 F6 | 	mov	arg01, local01
0f254     E1 E0 E9 FA | 	rdword	local05, arg01 wz
0f258     00 A6 05 A6 |  if_e	mov	result1, #0
0f25c     04 E0 65 50 |  if_ne	shl	local05, #4
0f260     F0 C2 01 51 |  if_ne	add	arg01, local05
0f264     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f268     D3 C4 09 F6 | 	mov	arg02, result1 wz
0f26c     B8 00 90 AD |  if_e	jmp	#LR__1997
0f270     EE C4 51 F2 | 	cmps	arg02, local03 wc
0f274     B0 00 90 3D |  if_ae	jmp	#LR__1997
0f278     E2 C2 01 F6 | 	mov	arg01, arg02
0f27c     00 A6 05 F6 | 	mov	result1, #0
0f280     02 C2 05 F1 | 	add	arg01, #2
0f284     E1 C2 E1 FA | 	rdword	arg01, arg01
0f288     36 00 00 FF 
0f28c     8F C2 0D F2 | 	cmp	arg01, ##27791 wz
0f290     01 A6 65 A6 |  if_e	neg	result1, #1
0f294     00 A6 0D F2 | 	cmp	result1, #0 wz
0f298     8C 00 90 AD |  if_e	jmp	#LR__1997
0f29c     EC DE 01 F6 | 	mov	local04, local01
0f2a0     EF E2 E1 FA | 	rdword	local06, local04
0f2a4     E2 C2 01 F6 | 	mov	arg01, arg02
0f2a8     E1 D8 E1 FA | 	rdword	local01, arg01
0f2ac     EC E2 01 F1 | 	add	local06, local01
0f2b0     EF E2 51 FC | 	wrword	local06, local04
0f2b4     E1 E2 01 F6 | 	mov	local06, arg01
0f2b8     06 E2 05 F1 | 	add	local06, #6
0f2bc     EF D8 01 F6 | 	mov	local01, local04
0f2c0     F1 E2 E1 FA | 	rdword	local06, local06
0f2c4     06 D8 05 F1 | 	add	local01, #6
0f2c8     EC E2 51 FC | 	wrword	local06, local01
0f2cc     E1 E2 01 F6 | 	mov	local06, arg01
0f2d0     02 E2 05 F1 | 	add	local06, #2
0f2d4     F1 54 59 FC | 	wrword	#170, local06
0f2d8     E1 E2 01 F6 | 	mov	local06, arg01
0f2dc     06 E2 05 F1 | 	add	local06, #6
0f2e0     F1 00 58 FC | 	wrword	#0, local06
0f2e4     E1 E0 E9 FA | 	rdword	local05, arg01 wz
0f2e8     00 A6 05 A6 |  if_e	mov	result1, #0
0f2ec     04 E0 65 50 |  if_ne	shl	local05, #4
0f2f0     F0 C2 01 51 |  if_ne	add	arg01, local05
0f2f4     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f2f8     D3 E2 09 F6 | 	mov	local06, result1 wz
0f2fc     28 00 90 AD |  if_e	jmp	#LR__1996
0f300     EE E2 51 F2 | 	cmps	local06, local03 wc
0f304     20 00 90 3D |  if_ae	jmp	#LR__1996
0f308     EF C4 09 F6 | 	mov	arg02, local04 wz
0f30c     00 A6 05 A6 |  if_e	mov	result1, #0
0f310     ED C4 81 51 |  if_ne	sub	arg02, local02
0f314     04 C4 45 50 |  if_ne	shr	arg02, #4
0f318     E2 A6 01 56 |  if_ne	mov	result1, arg02
0f31c     F1 DE 01 F6 | 	mov	local04, local06
0f320     04 DE 05 F1 | 	add	local04, #4
0f324     EF A6 51 FC | 	wrword	result1, local04
0f328                 | LR__1996
0f328                 | LR__1997
0f328     F1 A6 01 F6 | 	mov	result1, local06
0f32c     A7 F0 03 F6 | 	mov	ptra, fp
0f330     B2 00 A0 FD | 	call	#popregs_
0f334                 | __system___gc_dofree_ret
0f334     2D 00 64 FD | 	ret
0f338                 | 
0f338                 | __system___gc_docollect
0f338     05 4A 05 F6 | 	mov	COUNT_, #5
0f33c     A8 00 A0 FD | 	call	#pushregs_
0f340     C8 F9 BF FD | 	call	#__system___gc_ptrs
0f344     D4 D8 01 F6 | 	mov	local01, result2
0f348     D3 DA 01 F6 | 	mov	local02, result1
0f34c     ED C2 01 F6 | 	mov	arg01, local02
0f350     E1 DC E9 FA | 	rdword	local03, arg01 wz
0f354     00 A6 05 A6 |  if_e	mov	result1, #0
0f358     04 DC 65 50 |  if_ne	shl	local03, #4
0f35c     EE C2 01 51 |  if_ne	add	arg01, local03
0f360     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f364     D3 DE 09 F6 | 	mov	local04, result1 wz
0f368     00 A6 05 F6 | 	mov	result1, #0
0f36c     01 A6 61 FD | 	cogid	result1
0f370     D3 E0 01 F6 | 	mov	local05, result1
0f374     48 00 90 AD |  if_e	jmp	#LR__2002
0f378     97 22 48 FB | 	callpa	#(@LR__2001-@LR__2000)>>2,fcache_load_ptr_
0f37c                 | LR__2000
0f37c     EC DE 51 F2 | 	cmps	local04, local01 wc
0f380     3C 00 90 3D |  if_ae	jmp	#LR__2002
0f384     EF C4 01 F6 | 	mov	arg02, local04
0f388     02 C4 05 F1 | 	add	arg02, #2
0f38c     E2 C4 E1 FA | 	rdword	arg02, arg02
0f390     20 C4 25 F5 | 	andn	arg02, #32
0f394     EF C2 01 F6 | 	mov	arg01, local04
0f398     02 C2 05 F1 | 	add	arg01, #2
0f39c     E1 C4 51 FC | 	wrword	arg02, arg01
0f3a0     EF C2 01 F6 | 	mov	arg01, local04
0f3a4     E1 DC E9 FA | 	rdword	local03, arg01 wz
0f3a8     00 A6 05 A6 |  if_e	mov	result1, #0
0f3ac     04 DC 65 50 |  if_ne	shl	local03, #4
0f3b0     EE C2 01 51 |  if_ne	add	arg01, local03
0f3b4     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f3b8     D3 DE 09 F6 | 	mov	local04, result1 wz
0f3bc     BC FF 9F 5D |  if_ne	jmp	#LR__2000
0f3c0                 | LR__2001
0f3c0                 | LR__2002
0f3c0     00 DC 05 F6 | 	mov	local03, #0
0f3c4     00 C2 05 F6 | 	mov	arg01, #0
0f3c8     E0 F0 BF FD | 	call	#__system____topofstack
0f3cc     D3 C4 01 F6 | 	mov	arg02, result1
0f3d0     EE C2 01 F6 | 	mov	arg01, local03
0f3d4     90 00 B0 FD | 	call	#__system___gc_markhub
0f3d8     1C 01 B0 FD | 	call	#__system___gc_markcog
0f3dc     ED C2 01 F6 | 	mov	arg01, local02
0f3e0     E1 DC E9 FA | 	rdword	local03, arg01 wz
0f3e4     00 A6 05 A6 |  if_e	mov	result1, #0
0f3e8     04 DC 65 50 |  if_ne	shl	local03, #4
0f3ec     EE C2 01 51 |  if_ne	add	arg01, local03
0f3f0     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f3f4     D3 DA 09 F6 | 	mov	local02, result1 wz
0f3f8     60 00 90 AD |  if_e	jmp	#LR__2006
0f3fc                 | LR__2003
0f3fc     ED DE 01 F6 | 	mov	local04, local02
0f400     EF C2 01 F6 | 	mov	arg01, local04
0f404     E1 DC E9 FA | 	rdword	local03, arg01 wz
0f408     00 A6 05 A6 |  if_e	mov	result1, #0
0f40c     04 DC 65 50 |  if_ne	shl	local03, #4
0f410     EE C2 01 51 |  if_ne	add	arg01, local03
0f414     E1 A6 01 56 |  if_ne	mov	result1, arg01
0f418     D3 DA 01 F6 | 	mov	local02, result1
0f41c     EF C4 01 F6 | 	mov	arg02, local04
0f420     02 C4 05 F1 | 	add	arg02, #2
0f424     E2 C4 E1 FA | 	rdword	arg02, arg02
0f428     20 C4 CD F7 | 	test	arg02, #32 wz
0f42c     10 C4 CD A7 |  if_e	test	arg02, #16 wz
0f430     1C 00 90 5D |  if_ne	jmp	#LR__2005
0f434     E2 C4 41 F8 | 	getnib	arg02, arg02, #0
0f438     F0 C4 09 F2 | 	cmp	arg02, local05 wz
0f43c     0E C4 0D 52 |  if_ne	cmp	arg02, #14 wz
0f440     0C 00 90 5D |  if_ne	jmp	#LR__2004
0f444     EF C2 01 F6 | 	mov	arg01, local04
0f448     84 FC BF FD | 	call	#__system___gc_dofree
0f44c     D3 DA 01 F6 | 	mov	local02, result1
0f450                 | LR__2004
0f450                 | LR__2005
0f450     00 DA 0D F2 | 	cmp	local02, #0 wz
0f454     EC DA 51 52 |  if_ne	cmps	local02, local01 wc
0f458     A0 FF 9F 4D |  if_c_and_nz	jmp	#LR__2003
0f45c                 | LR__2006
0f45c     A7 F0 03 F6 | 	mov	ptra, fp
0f460     B2 00 A0 FD | 	call	#popregs_
0f464                 | __system___gc_docollect_ret
0f464     2D 00 64 FD | 	ret
0f468                 | 
0f468                 | __system___gc_markhub
0f468     04 4A 05 F6 | 	mov	COUNT_, #4
0f46c     A8 00 A0 FD | 	call	#pushregs_
0f470     E1 D8 01 F6 | 	mov	local01, arg01
0f474     E2 DA 01 F6 | 	mov	local02, arg02
0f478     90 F8 BF FD | 	call	#__system___gc_ptrs
0f47c     D3 DC 01 F6 | 	mov	local03, result1
0f480     D4 DE 01 F6 | 	mov	local04, result2
0f484                 | LR__2010
0f484     ED D8 51 F2 | 	cmps	local01, local02 wc
0f488     60 00 90 3D |  if_ae	jmp	#LR__2011
0f48c     EC C6 01 FB | 	rdlong	arg03, local01
0f490     04 D8 05 F1 | 	add	local01, #4
0f494     EF C4 01 F6 | 	mov	arg02, local04
0f498     EE C2 01 F6 | 	mov	arg01, local03
0f49c     94 FB BF FD | 	call	#__system___gc_isvalidptr
0f4a0     D3 C6 09 F6 | 	mov	arg03, result1 wz
0f4a4     DC FF 9F AD |  if_e	jmp	#LR__2010
0f4a8     E3 C2 01 F6 | 	mov	arg01, arg03
0f4ac     00 A6 05 F6 | 	mov	result1, #0
0f4b0     02 C2 05 F1 | 	add	arg01, #2
0f4b4     E1 C2 E1 FA | 	rdword	arg01, arg01
0f4b8     36 00 00 FF 
0f4bc     8F C2 0D F2 | 	cmp	arg01, ##27791 wz
0f4c0     01 A6 65 A6 |  if_e	neg	result1, #1
0f4c4     00 A6 0D F2 | 	cmp	result1, #0 wz
0f4c8     B8 FF 9F 5D |  if_ne	jmp	#LR__2010
0f4cc     E3 A8 01 F6 | 	mov	result2, arg03
0f4d0     02 A8 05 F1 | 	add	result2, #2
0f4d4     D4 A8 E1 FA | 	rdword	result2, result2
0f4d8     0F A8 25 F5 | 	andn	result2, #15
0f4dc     2E A8 45 F5 | 	or	result2, #46
0f4e0     02 C6 05 F1 | 	add	arg03, #2
0f4e4     E3 A8 51 FC | 	wrword	result2, arg03
0f4e8     98 FF 9F FD | 	jmp	#LR__2010
0f4ec                 | LR__2011
0f4ec     A7 F0 03 F6 | 	mov	ptra, fp
0f4f0     B2 00 A0 FD | 	call	#popregs_
0f4f4                 | __system___gc_markhub_ret
0f4f4     2D 00 64 FD | 	ret
0f4f8                 | 
0f4f8                 | __system___gc_markcog
0f4f8     04 4A 05 F6 | 	mov	COUNT_, #4
0f4fc     A8 00 A0 FD | 	call	#pushregs_
0f500     08 F8 BF FD | 	call	#__system___gc_ptrs
0f504     D3 D8 01 F6 | 	mov	local01, result1
0f508     D4 DA 01 F6 | 	mov	local02, result2
0f50c     EF DD 05 F6 | 	mov	local03, #495
0f510                 | LR__2020
0f510                 | 	'.live	local03
0f510     00 DC 95 F9 | 	alts	local03, #0
0f514     EE DE 01 F6 | 	mov	local04, local03
0f518     EC C2 01 F6 | 	mov	arg01, local01
0f51c     ED C4 01 F6 | 	mov	arg02, local02
0f520     EF C6 01 F6 | 	mov	arg03, local04
0f524     0C FB BF FD | 	call	#__system___gc_isvalidptr
0f528     00 A6 0D F2 | 	cmp	result1, #0 wz
0f52c     18 00 90 AD |  if_e	jmp	#LR__2021
0f530     D3 DE 01 F6 | 	mov	local04, result1
0f534     02 DE 05 F1 | 	add	local04, #2
0f538     EF DE E1 FA | 	rdword	local04, local04
0f53c     20 DE 45 F5 | 	or	local04, #32
0f540     02 A6 05 F1 | 	add	result1, #2
0f544     D3 DE 51 FC | 	wrword	local04, result1
0f548                 | LR__2021
0f548     01 DC 85 F1 | 	sub	local03, #1
0f54c     00 DC 55 F2 | 	cmps	local03, #0 wc
0f550     BC FF 9F 3D |  if_ae	jmp	#LR__2020
0f554     A7 F0 03 F6 | 	mov	ptra, fp
0f558     B2 00 A0 FD | 	call	#popregs_
0f55c                 | __system___gc_markcog_ret
0f55c     2D 00 64 FD | 	ret
0f560                 | 
0f560                 | __system__strncpy
0f560     E1 AA 01 F6 | 	mov	_var01, arg01
0f564                 | LR__2030
0f564     01 C6 85 F1 | 	sub	arg03, #1
0f568     00 C6 55 F2 | 	cmps	arg03, #0 wc
0f56c     24 00 90 CD |  if_b	jmp	#LR__2031
0f570     E2 A6 01 F6 | 	mov	result1, arg02
0f574     01 A6 05 F1 | 	add	result1, #1
0f578     E2 AC C1 FA | 	rdbyte	_var02, arg02
0f57c     D3 C4 01 F6 | 	mov	arg02, result1
0f580     D5 AC 41 FC | 	wrbyte	_var02, _var01
0f584     D6 AC E1 F8 | 	getbyte	_var02, _var02, #0
0f588     07 AC 4D F7 | 	zerox	_var02, #7 wz
0f58c     01 AA 05 F1 | 	add	_var01, #1
0f590     D0 FF 9F 5D |  if_ne	jmp	#LR__2030
0f594                 | LR__2031
0f594     97 0C 48 FB | 	callpa	#(@LR__2033-@LR__2032)>>2,fcache_load_ptr_
0f598                 | LR__2032
0f598     01 C6 85 F1 | 	sub	arg03, #1
0f59c     00 C6 55 F2 | 	cmps	arg03, #0 wc
0f5a0     D5 AE 01 36 |  if_ae	mov	_var03, _var01
0f5a4     01 AA 05 31 |  if_ae	add	_var01, #1
0f5a8     D7 00 48 3C |  if_ae	wrbyte	#0, _var03
0f5ac     E8 FF 9F 3D |  if_ae	jmp	#LR__2032
0f5b0                 | LR__2033
0f5b0     E1 A6 01 F6 | 	mov	result1, arg01
0f5b4                 | __system__strncpy_ret
0f5b4     2D 00 64 FD | 	ret
0f5b8                 | 
0f5b8                 | __system__strncat
0f5b8     00 C4 4D F2 | 	cmps	arg02, #0 wz
0f5bc     54 00 90 AD |  if_e	jmp	#LR__2045
0f5c0     01 C6 15 F2 | 	cmp	arg03, #1 wc
0f5c4     4C 00 90 CD |  if_b	jmp	#LR__2045
0f5c8     E1 AA 01 F6 | 	mov	_var01, arg01
0f5cc     97 06 48 FB | 	callpa	#(@LR__2041-@LR__2040)>>2,fcache_load_ptr_
0f5d0                 | LR__2040
0f5d0     D5 A6 C9 FA | 	rdbyte	result1, _var01 wz
0f5d4     01 AA 05 51 |  if_ne	add	_var01, #1
0f5d8     F4 FF 9F 5D |  if_ne	jmp	#LR__2040
0f5dc                 | LR__2041
0f5dc     E3 AC 01 F6 | 	mov	_var02, arg03
0f5e0     97 16 48 FB | 	callpa	#(@LR__2043-@LR__2042)>>2,fcache_load_ptr_
0f5e4                 | LR__2042
0f5e4     E2 AE C1 FA | 	rdbyte	_var03, arg02
0f5e8     D7 B0 01 F6 | 	mov	_var04, _var03
0f5ec     07 B0 4D F7 | 	zerox	_var04, #7 wz
0f5f0     01 C4 05 F1 | 	add	arg02, #1
0f5f4     18 00 90 AD |  if_e	jmp	#LR__2044
0f5f8     01 AC 85 F1 | 	sub	_var02, #1
0f5fc     00 AC 55 F2 | 	cmps	_var02, #0 wc
0f600     D5 B0 01 36 |  if_ae	mov	_var04, _var01
0f604     01 AA 05 31 |  if_ae	add	_var01, #1
0f608     D8 AE 41 3C |  if_ae	wrbyte	_var03, _var04
0f60c     D4 FF 9F 3D |  if_ae	jmp	#LR__2042
0f610                 | LR__2043
0f610                 | LR__2044
0f610     D5 00 48 FC | 	wrbyte	#0, _var01
0f614                 | LR__2045
0f614     E1 A6 01 F6 | 	mov	result1, arg01
0f618                 | __system__strncat_ret
0f618     2D 00 64 FD | 	ret
0f61c                 | 
0f61c                 | __system__strncmp
0f61c     E1 AA 09 F6 | 	mov	_var01, arg01 wz
0f620     14 00 90 5D |  if_ne	jmp	#LR__2050
0f624     00 C4 0D F2 | 	cmp	arg02, #0 wz
0f628     01 AC 65 56 |  if_ne	neg	_var02, #1
0f62c     00 AC 05 A6 |  if_e	mov	_var02, #0
0f630     D6 A6 01 F6 | 	mov	result1, _var02
0f634     74 00 90 FD | 	jmp	#__system__strncmp_ret
0f638                 | LR__2050
0f638     00 C4 0D F2 | 	cmp	arg02, #0 wz
0f63c     01 A6 05 A6 |  if_e	mov	result1, #1
0f640     68 00 90 AD |  if_e	jmp	#__system__strncmp_ret
0f644     E3 AE 01 F6 | 	mov	_var03, arg03
0f648     97 16 48 FB | 	callpa	#(@LR__2052-@LR__2051)>>2,fcache_load_ptr_
0f64c                 | LR__2051
0f64c     D5 B0 C1 FA | 	rdbyte	_var04, _var01
0f650     E2 B2 01 F6 | 	mov	_var05, arg02
0f654     D9 B4 C1 FA | 	rdbyte	_var06, _var05
0f658     01 AE 85 F1 | 	sub	_var03, #1
0f65c     00 AE 55 F2 | 	cmps	_var03, #0 wc
0f660     01 AA 05 F1 | 	add	_var01, #1
0f664     01 C4 05 F1 | 	add	arg02, #1
0f668     00 B0 0D 32 |  if_ae	cmp	_var04, #0 wz
0f66c     08 00 90 2D |  if_nc_and_z	jmp	#LR__2053
0f670     DA B0 09 32 |  if_ae	cmp	_var04, _var06 wz
0f674     D4 FF 9F 2D |  if_nc_and_z	jmp	#LR__2051
0f678                 | LR__2052
0f678                 | LR__2053
0f678     00 AE 55 F2 | 	cmps	_var03, #0 wc
0f67c     00 A6 05 C6 |  if_b	mov	result1, #0
0f680     28 00 90 CD |  if_b	jmp	#__system__strncmp_ret
0f684     DA B0 09 F2 | 	cmp	_var04, _var06 wz
0f688     00 A6 05 A6 |  if_e	mov	result1, #0
0f68c     1C 00 90 AD |  if_e	jmp	#__system__strncmp_ret
0f690     00 B0 0D F2 | 	cmp	_var04, #0 wz
0f694     01 A6 65 A6 |  if_e	neg	result1, #1
0f698     10 00 90 AD |  if_e	jmp	#__system__strncmp_ret
0f69c     00 B4 0D F2 | 	cmp	_var06, #0 wz
0f6a0     01 A6 05 A6 |  if_e	mov	result1, #1
0f6a4     D8 A6 01 56 |  if_ne	mov	result1, _var04
0f6a8     DA A6 81 51 |  if_ne	sub	result1, _var06
0f6ac                 | __system__strncmp_ret
0f6ac     2D 00 64 FD | 	ret
0f6b0                 | 
0f6b0                 | __system____root_opendir
0f6b0     C9 A6 01 F6 | 	mov	result1, ptr___system__dat__
0f6b4     64 A6 05 F1 | 	add	result1, #100
0f6b8     04 C2 05 F1 | 	add	arg01, #4
0f6bc     E1 A6 61 FC | 	wrlong	result1, arg01
0f6c0     00 A6 05 F6 | 	mov	result1, #0
0f6c4                 | __system____root_opendir_ret
0f6c4     2D 00 64 FD | 	ret
0f6c8                 | 
0f6c8                 | __system____root_readdir
0f6c8     03 4A 05 F6 | 	mov	COUNT_, #3
0f6cc     A8 00 A0 FD | 	call	#pushregs_
0f6d0     E1 D8 01 F6 | 	mov	local01, arg01
0f6d4     E2 DA 01 F6 | 	mov	local02, arg02
0f6d8     04 D8 05 F1 | 	add	local01, #4
0f6dc     EC DC 01 FB | 	rdlong	local03, local01
0f6e0     04 D8 85 F1 | 	sub	local01, #4
0f6e4                 | LR__2060
0f6e4     C9 C6 01 F6 | 	mov	arg03, ptr___system__dat__
0f6e8     74 C6 05 F1 | 	add	arg03, #116
0f6ec     E3 DC 09 F2 | 	cmp	local03, arg03 wz
0f6f0     01 A6 65 A6 |  if_e	neg	result1, #1
0f6f4     48 00 90 AD |  if_e	jmp	#LR__2061
0f6f8     EE C6 09 FB | 	rdlong	arg03, local03 wz
0f6fc     04 DC 05 A1 |  if_e	add	local03, #4
0f700     E0 FF 9F AD |  if_e	jmp	#LR__2060
0f704     EE C4 01 FB | 	rdlong	arg02, local03
0f708     01 C4 05 F1 | 	add	arg02, #1
0f70c     ED C2 01 F6 | 	mov	arg01, local02
0f710     40 C6 05 F6 | 	mov	arg03, #64
0f714     48 FE BF FD | 	call	#__system__strncpy
0f718     50 DA 05 F1 | 	add	local02, #80
0f71c     ED 02 48 FC | 	wrbyte	#1, local02
0f720     08 DA 85 F1 | 	sub	local02, #8
0f724     ED 00 68 FC | 	wrlong	#0, local02
0f728     04 DA 05 F1 | 	add	local02, #4
0f72c     ED 00 68 FC | 	wrlong	#0, local02
0f730     04 DC 05 F1 | 	add	local03, #4
0f734     04 D8 05 F1 | 	add	local01, #4
0f738     EC DC 61 FC | 	wrlong	local03, local01
0f73c     00 A6 05 F6 | 	mov	result1, #0
0f740                 | LR__2061
0f740     A7 F0 03 F6 | 	mov	ptra, fp
0f744     B2 00 A0 FD | 	call	#popregs_
0f748                 | __system____root_readdir_ret
0f748     2D 00 64 FD | 	ret
0f74c                 | 
0f74c                 | __system____root_closedir
0f74c     00 A6 05 F6 | 	mov	result1, #0
0f750                 | __system____root_closedir_ret
0f750     2D 00 64 FD | 	ret
0f754                 | 
0f754                 | __system____root_stat
0f754     E2 AA 01 F6 | 	mov	_var01, arg02
0f758     D5 C2 01 F6 | 	mov	arg01, _var01
0f75c     00 C4 05 F6 | 	mov	arg02, #0
0f760     30 C6 05 F6 | 	mov	arg03, #48
0f764     98 00 A0 FD | 	call	#\builtin_bytefill_
0f768     08 AA 05 F1 | 	add	_var01, #8
0f76c     08 00 80 FF 
0f770     D5 FE 6B FC | 	wrlong	##4607, _var01
0f774     00 A6 05 F6 | 	mov	result1, #0
0f778                 | __system____root_stat_ret
0f778     2D 00 64 FD | 	ret
0f77c                 | 
0f77c                 | __system___normalizeName
0f77c     00 AA 05 F6 | 	mov	_var01, #0
0f780     E1 AC 01 F6 | 	mov	_var02, arg01
0f784     D6 AE 01 F6 | 	mov	_var03, _var02
0f788                 | LR__2070
0f788     D6 B0 C9 FA | 	rdbyte	_var04, _var02 wz
0f78c     5C 01 90 AD |  if_e	jmp	#LR__2089
0f790     00 AA 0D F2 | 	cmp	_var01, #0 wz
0f794     D7 B0 01 56 |  if_ne	mov	_var04, _var03
0f798     01 AE 05 51 |  if_ne	add	_var03, #1
0f79c     D8 5E 48 5C |  if_ne	wrbyte	#47, _var04
0f7a0     00 AA 05 56 |  if_ne	mov	_var01, #0
0f7a4     D6 B0 C1 FA | 	rdbyte	_var04, _var02
0f7a8     2E B0 0D F2 | 	cmp	_var04, #46 wz
0f7ac     D8 00 90 5D |  if_ne	jmp	#LR__2082
0f7b0     01 AC 05 F1 | 	add	_var02, #1
0f7b4     D6 B0 C1 FA | 	rdbyte	_var04, _var02
0f7b8     01 AC 85 F1 | 	sub	_var02, #1
0f7bc     2F B0 0D F2 | 	cmp	_var04, #47 wz
0f7c0     18 00 90 AD |  if_e	jmp	#LR__2071
0f7c4     01 AC 05 F1 | 	add	_var02, #1
0f7c8     D6 B2 C1 FA | 	rdbyte	_var05, _var02
0f7cc     01 AC 85 F1 | 	sub	_var02, #1
0f7d0     D9 B4 01 F6 | 	mov	_var06, _var05
0f7d4     07 B4 4D F7 | 	zerox	_var06, #7 wz
0f7d8     10 00 90 5D |  if_ne	jmp	#LR__2072
0f7dc                 | LR__2071
0f7dc     D6 B6 01 F6 | 	mov	_var07, _var02
0f7e0     01 B6 05 F1 | 	add	_var07, #1
0f7e4     DB AC 01 F6 | 	mov	_var02, _var07
0f7e8     E0 00 90 FD | 	jmp	#LR__2086
0f7ec                 | LR__2072
0f7ec     01 AC 05 F1 | 	add	_var02, #1
0f7f0     D6 B6 C1 FA | 	rdbyte	_var07, _var02
0f7f4     01 AC 85 F1 | 	sub	_var02, #1
0f7f8     DB B0 E1 F8 | 	getbyte	_var04, _var07, #0
0f7fc     2E B0 0D F2 | 	cmp	_var04, #46 wz
0f800     84 00 90 5D |  if_ne	jmp	#LR__2081
0f804     02 AC 05 F1 | 	add	_var02, #2
0f808     D6 B6 C1 FA | 	rdbyte	_var07, _var02
0f80c     02 AC 85 F1 | 	sub	_var02, #2
0f810     DB B0 E1 F8 | 	getbyte	_var04, _var07, #0
0f814     2F B0 0D F2 | 	cmp	_var04, #47 wz
0f818     18 00 90 AD |  if_e	jmp	#LR__2073
0f81c     02 AC 05 F1 | 	add	_var02, #2
0f820     D6 B2 C1 FA | 	rdbyte	_var05, _var02
0f824     02 AC 85 F1 | 	sub	_var02, #2
0f828     D9 B4 01 F6 | 	mov	_var06, _var05
0f82c     07 B4 4D F7 | 	zerox	_var06, #7 wz
0f830     54 00 90 5D |  if_ne	jmp	#LR__2080
0f834                 | LR__2073
0f834     02 AC 05 F1 | 	add	_var02, #2
0f838     E1 AE 59 F2 | 	cmps	_var03, arg01 wcz
0f83c     40 00 90 ED |  if_be	jmp	#LR__2079
0f840     D7 B8 01 F6 | 	mov	_var08, _var03
0f844     01 B8 85 F1 | 	sub	_var08, #1
0f848                 | LR__2074
0f848     DC B0 C1 FA | 	rdbyte	_var04, _var08
0f84c     2F B0 0D F2 | 	cmp	_var04, #47 wz
0f850     0C 00 90 5D |  if_ne	jmp	#LR__2075
0f854     E1 B8 59 F2 | 	cmps	_var08, arg01 wcz
0f858     01 B8 85 11 |  if_a	sub	_var08, #1
0f85c     E8 FF 9F 1D |  if_a	jmp	#LR__2074
0f860                 | LR__2075
0f860     97 0C 48 FB | 	callpa	#(@LR__2077-@LR__2076)>>2,fcache_load_ptr_
0f864                 | LR__2076
0f864     E1 B8 59 F2 | 	cmps	_var08, arg01 wcz
0f868     10 00 90 ED |  if_be	jmp	#LR__2078
0f86c     DC B0 C1 FA | 	rdbyte	_var04, _var08
0f870     2F B0 0D F2 | 	cmp	_var04, #47 wz
0f874     01 B8 85 51 |  if_ne	sub	_var08, #1
0f878     E8 FF 9F 5D |  if_ne	jmp	#LR__2076
0f87c                 | LR__2077
0f87c                 | LR__2078
0f87c     DC AE 01 F6 | 	mov	_var03, _var08
0f880                 | LR__2079
0f880     01 AA 05 F6 | 	mov	_var01, #1
0f884     44 00 90 FD | 	jmp	#LR__2086
0f888                 | LR__2080
0f888                 | LR__2081
0f888                 | LR__2082
0f888     97 18 48 FB | 	callpa	#(@LR__2084-@LR__2083)>>2,fcache_load_ptr_
0f88c                 | LR__2083
0f88c     D6 B0 C9 FA | 	rdbyte	_var04, _var02 wz
0f890     D8 B6 01 56 |  if_ne	mov	_var07, _var04
0f894     2F B6 0D 52 |  if_ne	cmp	_var07, #47 wz
0f898     20 00 90 AD |  if_e	jmp	#LR__2085
0f89c     D6 B4 01 F6 | 	mov	_var06, _var02
0f8a0     D6 B2 01 F6 | 	mov	_var05, _var02
0f8a4     01 B2 05 F1 | 	add	_var05, #1
0f8a8     DA BA C1 FA | 	rdbyte	_var09, _var06
0f8ac     D9 AC 01 F6 | 	mov	_var02, _var05
0f8b0     D7 BA 41 FC | 	wrbyte	_var09, _var03
0f8b4     01 AE 05 F1 | 	add	_var03, #1
0f8b8     D0 FF 9F FD | 	jmp	#LR__2083
0f8bc                 | LR__2084
0f8bc                 | LR__2085
0f8bc     D6 B0 C1 FA | 	rdbyte	_var04, _var02
0f8c0     2F B0 0D F2 | 	cmp	_var04, #47 wz
0f8c4     C0 FE 9F 5D |  if_ne	jmp	#LR__2070
0f8c8     01 AA 05 F6 | 	mov	_var01, #1
0f8cc                 | LR__2086
0f8cc     97 0C 48 FB | 	callpa	#(@LR__2088-@LR__2087)>>2,fcache_load_ptr_
0f8d0                 | LR__2087
0f8d0     D6 B0 C1 FA | 	rdbyte	_var04, _var02
0f8d4     2F B0 0D F2 | 	cmp	_var04, #47 wz
0f8d8     D6 B6 01 A6 |  if_e	mov	_var07, _var02
0f8dc     01 B6 05 A1 |  if_e	add	_var07, #1
0f8e0     DB AC 01 A6 |  if_e	mov	_var02, _var07
0f8e4     E8 FF 9F AD |  if_e	jmp	#LR__2087
0f8e8                 | LR__2088
0f8e8     9C FE 9F FD | 	jmp	#LR__2070
0f8ec                 | LR__2089
0f8ec     D7 00 48 FC | 	wrbyte	#0, _var03
0f8f0                 | __system___normalizeName_ret
0f8f0     2D 00 64 FD | 	ret
0f8f4                 | 
0f8f4                 | LR__2090
0f8f4     2F          | 	byte	"/"
0f8f5     00          | 	byte	0
0f8f6                 | LR__2091
0f8f6     20 21 21 21 
0f8fa     20 63 6F 72 
0f8fe     72 75 70 74 
0f902     65 64 20 68 
0f906     65 61 70 3F 
0f90a     3F 3F 20 21 
0f90e     21 21 20    | 	byte	" !!! corrupted heap??? !!! "
0f911     00          | 	byte	0
0f912                 | LR__2092
0f912     20 21 21 21 
0f916     20 6F 75 74 
0f91a     20 6F 66 20 
0f91e     68 65 61 70 
0f922     20 6D 65 6D 
0f926     6F 72 79 20 
0f92a     21 21 21 20 | 	byte	" !!! out of heap memory !!! "
0f92e     00          | 	byte	0
0f92f                 | LR__2093
0f92f     20 21 21 21 
0f933     20 63 6F 72 
0f937     72 75 70 74 
0f93b     65 64 20 68 
0f93f     65 61 70 20 
0f943     21 21 21 20 | 	byte	" !!! corrupted heap !!! "
0f947     00          | 	byte	0
0f948                 | LR__2094
0f948     2F 73 64    | 	byte	"/sd"
0f94b     00          | 	byte	0
0f94c                 | LR__2095
0f94c     00          | 	byte	0
0f94d     00          | 	byte	0
0f94e                 | LR__2096
0f94e     2A 2B 2C 3A 
0f952     3B 3C 3D 3E 
0f956     5B 5D 7C 22 
0f95a     3F 7F       | 	byte	"*+,:;<=>[]|",34,"?",127
0f95c     00          | 	byte	0
0f95d                 | LR__2097
0f95d     46 41 54 33 
0f961     32 20 20 20 | 	byte	"FAT32   "
0f965     00          | 	byte	0
0f966                 | LR__2098
0f966     54 5A       | 	byte	"TZ"
0f968     00          | 	byte	0
0f969                 | LR__2099
0f969     00          | 	byte	0
0f96a     00          | 	byte	0
0f96b                 | LR__2100
0f96b     62 61 64 20 
0f96f     6F 70 63 6F 
0f973     64 65       | 	byte	"bad opcode"
0f975     00          | 	byte	0
0f976                 | LR__2101
0f976     76 6D 20 70 
0f97a     61 6E 69 63 
0f97e     3A 20       | 	byte	"vm panic: "
0f980     00          | 	byte	0
0f981                 | LR__2102
0f981     20          | 	byte	" "
0f982     00          | 	byte	0
0f983                 | LR__2103
0f983     73 74 61 63 
0f987     6B 20 70 6F 
0f98b     69 6E 74 65 
0f98f     72 20 68 61 
0f993     73 20 68 69 
0f997     67 68 20 62 
0f99b     69 74 20 73 
0f99f     65 74 3F 3F 
0f9a3     3F          | 	byte	"stack pointer has high bit set???"
0f9a4     00          | 	byte	0
0f9a5                 | LR__2104
0f9a5     62 61 64 20 
0f9a9     73 69 7A 65 | 	byte	"bad size"
0f9ad     00          | 	byte	0
0f9ae                 | LR__2105
0f9ae     62 61 64 20 
0f9b2     73 69 7A 65 | 	byte	"bad size"
0f9b6     00          | 	byte	0
0f9b7                 | LR__2106
0f9b7     73 74 61 63 
0f9bb     6B 20 70 6F 
0f9bf     69 6E 74 65 
0f9c3     72 20 68 61 
0f9c7     73 20 68 69 
0f9cb     67 68 20 62 
0f9cf     69 74 20 73 
0f9d3     65 74       | 	byte	"stack pointer has high bit set"
0f9d5     00          | 	byte	0
0f9d6                 | LR__2107
0f9d6     62 61 64 20 
0f9da     72 65 67 69 
0f9de     73 74 65 72 | 	byte	"bad register"
0f9e2     00          | 	byte	0
0f9e3                 | LR__2108
0f9e3     62 61 64 20 
0f9e7     72 65 67 69 
0f9eb     73 74 65 72 | 	byte	"bad register"
0f9ef     00          | 	byte	0
0f9f0                 | LR__2109
0f9f0     62 61 64 20 
0f9f4     73 6F 75 72 
0f9f8     63 65       | 	byte	"bad source"
0f9fa     00          | 	byte	0
0f9fb                 | LR__2110
0f9fb     62 61 64 20 
0f9ff     74 61 72 67 
0fa03     65 74       | 	byte	"bad target"
0fa05     00          | 	byte	0
0fa06                 | LR__2111
0fa06     62 61 64 20 
0fa0a     73 69 7A 65 | 	byte	"bad size"
0fa0e     00          | 	byte	0
0fa0f                 | LR__2112
0fa0f     62 61 64 20 
0fa13     73 69 7A 65 | 	byte	"bad size"
0fa17     00          | 	byte	0
0fa18                 | LR__2113
0fa18     62 61 64 20 
0fa1c     73 69 7A 65 | 	byte	"bad size"
0fa20     00          | 	byte	0
0fa21                 | LR__2114
0fa21     62 61 64 20 
0fa25     74 61 72 67 
0fa29     65 74       | 	byte	"bad target"
0fa2b     00          | 	byte	0
0fa2c                 | LR__2115
0fa2c     62 61 64 20 
0fa30     73 69 7A 65 | 	byte	"bad size"
0fa34     00          | 	byte	0
0fa35                 | LR__2116
0fa35     62 61 64 20 
0fa39     73 69 7A 65 | 	byte	"bad size"
0fa3d     00          | 	byte	0
0fa3e                 | LR__2117
0fa3e     2F 73 64 2F 
0fa42     64 69 73 6B 
0fa46     30 2E 69 6D 
0fa4a     67          | 	byte	"/sd/disk0.img"
0fa4b     00          | 	byte	0
0fa4c                 | LR__2118
0fa4c     72 2B 62    | 	byte	"r+b"
0fa4f     00          | 	byte	0
0fa50                 | LR__2119
0fa50     2F 73 64 2F 
0fa54     64 69 73 6B 
0fa58     31 2E 69 6D 
0fa5c     67          | 	byte	"/sd/disk1.img"
0fa5d     00          | 	byte	0
0fa5e                 | LR__2120
0fa5e     72 2B 62    | 	byte	"r+b"
0fa61     00          | 	byte	0
0fa62                 | LR__2121
0fa62     2F 73 64 2F 
0fa66     64 69 73 6B 
0fa6a     32 2E 69 6D 
0fa6e     67          | 	byte	"/sd/disk2.img"
0fa6f     00          | 	byte	0
0fa70                 | LR__2122
0fa70     72 2B 62    | 	byte	"r+b"
0fa73     00          | 	byte	0
0fa74                 | LR__2123
0fa74     2F 73 64 2F 
0fa78     64 69 73 6B 
0fa7c     33 2E 69 6D 
0fa80     67          | 	byte	"/sd/disk3.img"
0fa81     00          | 	byte	0
0fa82                 | LR__2124
0fa82     72 2B 62    | 	byte	"r+b"
0fa85     00          | 	byte	0
0fa86                 | LR__2125
0fa86     55 70 64 61 
0fa8a     74 69 6E 67 
0fa8e     20 64 69 73 
0fa92     6B 30 2E 69 
0fa96     6D 67 20 66 
0fa9a     72 6F 6D 20 
0fa9e     68 6F 73 74 
0faa2     2E 2E 2E    | 	byte	"Updating disk0.img from host..."
0faa5     00          | 	byte	0
0faa6                 | LR__2126
0faa6     20 66 73 5F 
0faaa     69 6E 69 74 
0faae     20 72 65 74 
0fab2     75 72 6E 65 
0fab6     64 20 65 72 
0faba     72 6F 72 20 
0fabe     25 64 5C 6E | 	byte	" fs_init returned error %d\n"
0fac2     00          | 	byte	0
0fac3                 | LR__2127
0fac3     64 69 73 6B 
0fac7     30 2E 69 6D 
0facb     67          | 	byte	"disk0.img"
0facc     00          | 	byte	0
0facd                 | LR__2128
0facd     20 66 73 5F 
0fad1     6F 70 65 6E 
0fad5     20 72 65 74 
0fad9     75 72 6E 65 
0fadd     64 20 65 72 
0fae1     72 6F 72 20 
0fae5     25 64 5C 6E | 	byte	" fs_open returned error %d\n"
0fae9     00          | 	byte	0
0faea                 | LR__2129
0faea     2F 73 64 2F 
0faee     64 69 73 6B 
0faf2     30 2E 69 6D 
0faf6     67          | 	byte	"/sd/disk0.img"
0faf7     00          | 	byte	0
0faf8                 | LR__2130
0faf8     77 62       | 	byte	"wb"
0fafa     00          | 	byte	0
0fafb                 | LR__2131
0fafb     2E          | 	byte	"."
0fafc     00          | 	byte	0
0fafd                 | LR__2132
0fafd     20 64 6F 6E 
0fb01     65 21 5C 6E | 	byte	" done!\n"
0fb05     00          | 	byte	0
0fb06                 | LR__2133
0fb06     64 69 73 6B 
0fb0a     31 2E 69 6D 
0fb0e     67          | 	byte	"disk1.img"
0fb0f     00          | 	byte	0
0fb10                 | LR__2134
0fb10     55 70 64 61 
0fb14     74 69 6E 67 
0fb18     20 64 69 73 
0fb1c     6B 31 2E 69 
0fb20     6D 67 20 66 
0fb24     72 6F 6D 20 
0fb28     68 6F 73 74 
0fb2c     2E 2E 2E    | 	byte	"Updating disk1.img from host..."
0fb2f     00          | 	byte	0
0fb30                 | LR__2135
0fb30     2F 73 64 2F 
0fb34     64 69 73 6B 
0fb38     31 2E 69 6D 
0fb3c     67          | 	byte	"/sd/disk1.img"
0fb3d     00          | 	byte	0
0fb3e                 | LR__2136
0fb3e     77 62       | 	byte	"wb"
0fb40     00          | 	byte	0
0fb41                 | LR__2137
0fb41     2E          | 	byte	"."
0fb42     00          | 	byte	0
0fb43                 | LR__2138
0fb43     20 64 6F 6E 
0fb47     65 21 5C 6E | 	byte	" done!\n"
0fb4b     00          | 	byte	0
0fb4c                 | LR__2139
0fb4c     39 50 32 30 
0fb50     30 30       | 	byte	"9P2000"
0fb52     00          | 	byte	0
0fb53                 | LR__2140
0fb53     39 50 32 30 
0fb57     30 30       | 	byte	"9P2000"
0fb59     00          | 	byte	0
0fb5a                 | LR__2141
0fb5a     75 73 65 72 | 	byte	"user"
0fb5e     00          | 	byte	0
0fb5f                 | LR__2142
0fb5f     00          | 	byte	0
0fb60     00          | 	byte	0
0fb61     00 00 00    | 	alignl
0fb64                 | _libc_a_dat_
0fb64     00 00 00 00 
0fb68     00 00 00 00 
0fb6c     00 00 00 00 | 	byte	$00[12]
0fb70     05 00 00 00 
0fb74     00 00 00 00 
0fb78     00 00 00 00 
0fb7c     00 00 00 00 | 	byte	$05, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0fb80     00 00 00 00 | 	byte	$00, $00, $00, $00
0fb84     00 00 A0 01 | 	long	(26 {__system___tx})<<20
0fb88     00 00 B0 01 | 	long	(27 {__system___rx})<<20
0fb8c     00 00 00 00 | 	byte	$00, $00, $00, $00
0fb90     00 00 C0 01 | 	long	(28 {_libc_a__rxtxioctl_0726})<<20
0fb94     00 00 D0 01 | 	long	(29 {_libc_a___dummy_flush_0727})<<20
0fb98     00 00 00 00 
0fb9c     00 00 00 00 | 	byte	$00[8]
0fba0     01 00 00 00 
0fba4     06 00 00 00 
0fba8     00 00 00 00 
0fbac     00 00 00 00 | 	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0fbb0     00 00 00 00 
0fbb4     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
0fbb8     00 00 A0 01 | 	long	(26 {__system___tx})<<20
0fbbc     00 00 B0 01 | 	long	(27 {__system___rx})<<20
0fbc0     00 00 00 00 | 	byte	$00, $00, $00, $00
0fbc4     00 00 C0 01 | 	long	(28 {_libc_a__rxtxioctl_0726})<<20
0fbc8     00 00 D0 01 | 	long	(29 {_libc_a___dummy_flush_0727})<<20
0fbcc     00 00 00 00 
0fbd0     00 00 00 00 | 	byte	$00[8]
0fbd4     01 00 00 00 
0fbd8     06 00 00 00 
0fbdc     00 00 00 00 
0fbe0     00 00 00 00 | 	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0fbe4     00 00 00 00 
0fbe8     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
0fbec     00 00 A0 01 | 	long	(26 {__system___tx})<<20
0fbf0     00 00 B0 01 | 	long	(27 {__system___rx})<<20
0fbf4     00 00 00 00 | 	byte	$00, $00, $00, $00
0fbf8     00 00 C0 01 | 	long	(28 {_libc_a__rxtxioctl_0726})<<20
0fbfc     00 00 D0 01 | 	long	(29 {_libc_a___dummy_flush_0727})<<20
0fc00     00 00 00 00 
      ...             
0fd68     00 00 00 00 
0fd6c     00 00 00 00 | 	byte	$00[368]
0fd70                 | 	alignl
0fd70                 | _fatfs_cc_dat_
0fd70     43 55 45 41 
0fd74     41 41 41 43 
0fd78     45 45 45 49 
0fd7c     49 49 41 41 | 	byte	$43, $55, $45, $41, $41, $41, $41, $43, $45, $45, $45, $49, $49, $49, $41, $41
0fd80     45 92 92 4F 
0fd84     4F 4F 55 55 
0fd88     59 4F 55 4F 
0fd8c     9C 4F 9E 9F | 	byte	$45, $92, $92, $4f, $4f, $4f, $55, $55, $59, $4f, $55, $4f, $9c, $4f, $9e, $9f
0fd90     41 49 4F 55 
0fd94     A5 A5 A6 A7 
0fd98     A8 A9 AA AB 
0fd9c     AC AD AE AF | 	byte	$41, $49, $4f, $55, $a5, $a5, $a6, $a7, $a8, $a9, $aa, $ab, $ac, $ad, $ae, $af
0fda0     B0 B1 B2 B3 
0fda4     B4 41 41 41 
0fda8     B8 B9 BA BB 
0fdac     BC BD BE BF | 	byte	$b0, $b1, $b2, $b3, $b4, $41, $41, $41, $b8, $b9, $ba, $bb, $bc, $bd, $be, $bf
0fdb0     C0 C1 C2 C3 
0fdb4     C4 C5 41 41 
0fdb8     C8 C9 CA CB 
0fdbc     CC CD CE CF | 	byte	$c0, $c1, $c2, $c3, $c4, $c5, $41, $41, $c8, $c9, $ca, $cb, $cc, $cd, $ce, $cf
0fdc0     D1 D1 45 45 
0fdc4     45 49 49 49 
0fdc8     49 D9 DA DB 
0fdcc     DC DD 49 DF | 	byte	$d1, $d1, $45, $45, $45, $49, $49, $49, $49, $d9, $da, $db, $dc, $dd, $49, $df
0fdd0     4F E1 4F 4F 
0fdd4     4F 4F E6 E8 
0fdd8     E8 55 55 55 
0fddc     59 59 EE EF | 	byte	$4f, $e1, $4f, $4f, $4f, $4f, $e6, $e8, $e8, $55, $55, $55, $59, $59, $ee, $ef
0fde0     F0 F1 F2 F3 
0fde4     F4 F5 F6 F7 
0fde8     F8 F9 FA FB 
0fdec     FC FD FE FF | 	byte	$f0, $f1, $f2, $f3, $f4, $f5, $f6, $f7, $f8, $f9, $fa, $fb, $fc, $fd, $fe, $ff
0fdf0     00 00 00 00 
0fdf4     00 00 00 00 | 	byte	$00[8]
0fdf8     FF FF FF FF 
0fdfc     1F 00 00 00 
0fe00     1C 00 00 00 
0fe04     1F 00 00 00 | 	byte	$ff, $ff, $ff, $ff, $1f, $00, $00, $00, $1c, $00, $00, $00, $1f, $00, $00, $00
0fe08     1E 00 00 00 
0fe0c     1F 00 00 00 
0fe10     1E 00 00 00 
0fe14     1F 00 00 00 | 	byte	$1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00
0fe18     1F 00 00 00 
0fe1c     1E 00 00 00 
0fe20     1F 00 00 00 
0fe24     1E 00 00 00 | 	byte	$1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00
0fe28     1F 00 00 00 
0fe2c     00 00 00 00 
0fe30     1F 00 00 00 
0fe34     3B 00 00 00 | 	byte	$1f, $00, $00, $00, $00, $00, $00, $00, $1f, $00, $00, $00, $3b, $00, $00, $00
0fe38     5A 00 00 00 
0fe3c     78 00 00 00 
0fe40     97 00 00 00 
0fe44     B5 00 00 00 | 	byte	$5a, $00, $00, $00, $78, $00, $00, $00, $97, $00, $00, $00, $b5, $00, $00, $00
0fe48     D4 00 00 00 
0fe4c     F3 00 00 00 
0fe50     11 01 00 00 
0fe54     30 01 00 00 | 	byte	$d4, $00, $00, $00, $f3, $00, $00, $00, $11, $01, $00, $00, $30, $01, $00, $00
0fe58     4E 01 00 00 
0fe5c     6D 01 00 00 
0fe60     FF FF FF FF 
0fe64     00 00 00 00 | 	byte	$4e, $01, $00, $00, $6d, $01, $00, $00, $ff, $ff, $ff, $ff, $00, $00, $00, $00
0fe68     00 00 00 00 
      ...             
0fe80     00 00 00 00 
0fe84     00 00 00 00 | 	byte	$00[32]
0fe88     A6 FE 00 00 | 	long	@@@_fatfs_cc_dat_ + 310
0fe8c     AA FE 00 00 | 	long	@@@_fatfs_cc_dat_ + 314
0fe90     00 00 00 00 
0fe94     00 00 00 00 
0fe98     00 00 00 00 
0fe9c     00 00 00 00 
0fea0     00 00       | 	byte	$00[18]
0fea2     3F 3F 3F 00 
0fea6     55 43 54 00 
0feaa     55 43 54 00 
0feae     00 00 00 00 | 	byte	$3f, $3f, $3f, $00, $55, $43, $54, $00, $55, $43, $54, $00, $00, $00, $00, $00
0feb2     00 00 00 00 
0feb6     00 00 00    | 	byte	$00[7]
0feb9     CA 9A 3B 00 
0febd     00 00 00 01 
0fec1     01 01 01 01 
0fec5     01 01 01 01 | 	byte	$ca, $9a, $3b, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01
0fec9     91 11 11 11 
0fecd     11 01 01 01 
0fed1     01 01 01 01 
0fed5     01 01 01 01 | 	byte	$91, $11, $11, $11, $11, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01
0fed9     01 01 01 01 
0fedd     01 01 01    | 	byte	$01[7]
0fee0     90 20 20 20 
0fee4     20 20 20 20 
0fee8     20 20 20 20 
0feec     20 20 20 20 | 	byte	$90, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
0fef0     42 42 42 42 
0fef4     42 42 42 42 
0fef8     42 42       | 	byte	$42[10]
0fefa     20 20 20 20 
0fefe     20 20 20    | 	byte	$20[7]
0ff01     44 44 44 44 
0ff05     44 44       | 	byte	$44[6]
0ff07     04 04 04 04 
0ff0b     04 04 04 04 
0ff0f     04 04 04 04 
0ff13     04 04 04 04 
0ff17     04 04 04 04 | 	byte	$04[20]
0ff1b     20 20 20 20 
0ff1f     20 20       | 	byte	$20[6]
0ff21     48 48 48 48 
0ff25     48 48       | 	byte	$48[6]
0ff27     08 08 08 08 
0ff2b     08 08 08 08 
0ff2f     08 08 08 08 
0ff33     08 08 08 08 
0ff37     08 08 08 08 | 	byte	$08[20]
0ff3b     20 20 20 20 
0ff3f     01 00 00 00 
0ff43     00          | 	byte	$20, $20, $20, $20, $01, $00, $00, $00, $00
0ff44                 | 	alignl
0ff44                 | _bus_dat_
0ff44     21 00 00 00 
0ff48     40 00 00 00 
0ff4c     23 00 00 00 
0ff50     24 00 00 00 | 	byte	$21, $00, $00, $00, $40, $00, $00, $00, $23, $00, $00, $00, $24, $00, $00, $00
0ff54     25 00 00 00 
0ff58     5E 00 00 00 
0ff5c     26 00 00 00 
0ff60     2A 00 00 00 | 	byte	$25, $00, $00, $00, $5e, $00, $00, $00, $26, $00, $00, $00, $2a, $00, $00, $00
0ff64     28 00 00 00 
0ff68     29 00 00 00 | 	byte	$28, $00, $00, $00, $29, $00, $00, $00
0ff6c                 | 	alignl
0ff6c                 | _memory_dat_
0ff6c     00 9D 02 97 
0ff70     FF FF 00 00 
0ff74     20 0E 97 00 
0ff78     00 00 00 FA | rom file "../smolrom.bin"
0ff7c     FB 03 00 0E 
0ff80     97 00 00 00 
0ff84     00 00 00 00 
0ff88     00 0E 57 00 | 	byte	$fb, $03, $00, $0e, $97, $00, $00, $00, $00, $00, $00, $00, $00, $0e, $57, $00
0ff8c     AA 04 00 00 
0ff90     00 00 8C 02 
0ff94     97 89 00 00 
0ff98     F0 00 02 98 | 	byte	$aa, $04, $00, $00, $00, $00, $8c, $02, $97, $89, $00, $00, $f0, $00, $02, $98
0ff9c     DE 01 00 F0 
0ffa0     02 98 5D 02 
0ffa4     00 F0 02 8B 
0ffa8     00 10 00 80 | 	byte	$de, $01, $00, $f0, $02, $98, $5d, $02, $00, $f0, $02, $8b, $00, $10, $00, $80
0ffac     00 02 87 00 
0ffb0     00 00 00 00 
0ffb4     22 98 92 00 
0ffb8     00 F0 02 88 | 	byte	$00, $02, $87, $00, $00, $00, $00, $00, $22, $98, $92, $00, $00, $f0, $02, $88
0ffbc     34 00 00 F0 
0ffc0     02 97 00 00 
0ffc4     00 00 00 02 
0ffc8     97 08 00 00 | 	byte	$34, $00, $00, $f0, $02, $97, $00, $00, $00, $00, $00, $02, $97, $08, $00, $00
0ffcc     00 01 02 97 
0ffd0     00 00 00 00 
0ffd4     02 00 AA 02 
0ffd8     97 02 00 00 | 	byte	$00, $01, $02, $97, $00, $00, $00, $00, $02, $00, $aa, $02, $97, $02, $00, $00
0ffdc     00 00 00 AA 
0ffe0     02 97 00 00 
0ffe4     01 80 00 02 
0ffe8     27 00 01 00 | 	byte	$00, $00, $00, $aa, $02, $97, $00, $00, $01, $80, $00, $02, $27, $00, $01, $00
0ffec     9B 01 00 02 
0fff0     88 83 00 00 
0fff4     F0 73 6D 6F 
0fff8     6C 72 6F 6D | 	byte	$9b, $01, $00, $02, $88, $83, $00, $00, $f0, $73, $6d, $6f, $6c, $72, $6f, $6d
0fffc     0A 00 02 97 
10000     F0 00 00 F0 
10004     00 02 98 DE 
10008     01 00 F0 02 | 	byte	$0a, $00, $02, $97, $f0, $00, $00, $f0, $00, $02, $98, $de, $01, $00, $f0, $02
1000c     27 00 00 02 
10010     27 00 01 02 
10014     67 00 08 02 
10018     02 98 01 02 | 	byte	$27, $00, $00, $02, $27, $00, $01, $02, $67, $00, $08, $02, $02, $98, $01, $02
1001c     00 F0 0E 87 
10020     4C 33 3C 52 
10024     FC 09 00 00 
10028     20 AA 02 97 | 	byte	$00, $f0, $0e, $87, $4c, $33, $3c, $52, $fc, $09, $00, $00, $20, $aa, $02, $97
1002c     04 01 00 F0 
10030     00 02 98 DE 
10034     01 00 F0 02 
10038     98 5C 01 00 | 	byte	$04, $01, $00, $f0, $00, $02, $98, $de, $01, $00, $f0, $02, $98, $5c, $01, $00
1003c     F0 02 97 FF 
10040     FF 00 00 20 
10044     02 27 00 00 
10048     02 97 00 00 | 	byte	$f0, $02, $97, $ff, $ff, $00, $00, $20, $02, $27, $00, $00, $02, $97, $00, $00
1004c     04 00 01 02 
10050     97 F0 FB 03 
10054     00 02 02 88 
10058     00 08 00 00 | 	byte	$04, $00, $01, $02, $97, $f0, $fb, $03, $00, $02, $02, $88, $00, $08, $00, $00
1005c     72 65 61 64 
10060     20 2D 3E 20 
10064     30 78 30 30 
10068     30 30 30 38 | 	byte	$72, $65, $61, $64, $20, $2d, $3e, $20, $30, $78, $30, $30, $30, $30, $30, $38
1006c     30 30 0A 00 
10070     6A 75 6D 70 
10074     20 2D 3E 20 
10078     30 78 30 30 | 	byte	$30, $30, $0a, $00, $6a, $75, $6d, $70, $20, $2d, $3e, $20, $30, $78, $30, $30
1007c     30 30 30 38 
10080     30 30 0A 00 
10084     02 27 00 00 
10088     02 27 04 01 | 	byte	$30, $30, $30, $38, $30, $30, $0a, $00, $02, $27, $00, $00, $02, $27, $04, $01
1008c     02 67 00 08 
10090     02 02 98 01 
10094     02 00 F0 0E 
10098     87 4C 33 3C | 	byte	$02, $67, $00, $08, $02, $02, $98, $01, $02, $00, $f0, $0e, $87, $4c, $33, $3c
1009c     52 FC 09 00 
100a0     00 20 AA 02 
100a4     98 5C 01 00 
100a8     F0 02 97 FF | 	byte	$52, $fc, $09, $00, $00, $20, $aa, $02, $98, $5c, $01, $00, $f0, $02, $97, $ff
100ac     FF 00 00 20 
100b0     02 27 04 00 
100b4     02 97 00 00 
100b8     04 00 01 02 | 	byte	$ff, $00, $00, $20, $02, $27, $04, $00, $02, $97, $00, $00, $04, $00, $01, $02
100bc     97 F0 FB 03 
100c0     00 02 02 88 
100c4     00 08 00 00 
100c8     02 27 00 00 | 	byte	$97, $f0, $fb, $03, $00, $02, $02, $88, $00, $08, $00, $00, $02, $27, $00, $00
100cc     02 27 00 01 
100d0     02 27 00 02 
100d4     02 27 00 03 
100d8     02 27 00 04 | 	byte	$02, $27, $00, $01, $02, $27, $00, $02, $02, $27, $00, $03, $02, $27, $00, $04
100dc     02 27 00 05 
100e0     02 27 00 06 
100e4     02 27 00 07 
100e8     02 27 00 08 | 	byte	$02, $27, $00, $05, $02, $27, $00, $06, $02, $27, $00, $07, $02, $27, $00, $08
100ec     02 27 00 09 
100f0     02 27 00 0A 
100f4     02 27 00 0B 
100f8     02 27 00 0C | 	byte	$02, $27, $00, $09, $02, $27, $00, $0a, $02, $27, $00, $0b, $02, $27, $00, $0c
100fc     02 27 00 0D 
10100     02 27 00 0E 
10104     02 27 00 0F 
10108     02 27 00 10 | 	byte	$02, $27, $00, $0d, $02, $27, $00, $0e, $02, $27, $00, $0f, $02, $27, $00, $10
1010c     02 27 00 11 
10110     02 27 00 12 
10114     02 27 00 13 
10118     02 27 00 14 | 	byte	$02, $27, $00, $11, $02, $27, $00, $12, $02, $27, $00, $13, $02, $27, $00, $14
1011c     02 27 00 15 
10120     02 27 00 16 
10124     02 27 00 17 
10128     02 27 00 18 | 	byte	$02, $27, $00, $15, $02, $27, $00, $16, $02, $27, $00, $17, $02, $27, $00, $18
1012c     02 27 00 19 
10130     02 27 00 1A 
10134     02 27 00 1B 
10138     02 27 00 1C | 	byte	$02, $27, $00, $19, $02, $27, $00, $1a, $02, $27, $00, $1b, $02, $27, $00, $1c
1013c     02 27 00 1D 
10140     02 27 00 1E 
10144     02 27 00 1F 
10148     00 AA 00 8A | 	byte	$02, $27, $00, $1d, $02, $27, $00, $1e, $02, $27, $00, $1f, $00, $aa, $00, $8a
1014c     00 00 8A 01 
10150     02 27 00 01 
10154     01 9B 00 01 
10158     00 91 00 06 | 	byte	$00, $00, $8a, $01, $02, $27, $00, $01, $01, $9b, $00, $01, $00, $91, $00, $06
1015c     07 00 00 22 
10160     88 E4 01 00 
10164     F0 00 9A 01 
10168     00 9A 00 00 | 	byte	$07, $00, $00, $22, $88, $e4, $01, $00, $f0, $00, $9a, $01, $00, $9a, $00, $00
1016c     AA 00 8A 03 
10170     00 8A 04 02 
10174     97 00 20 00 
10178     80 03 02 97 | 	byte	$aa, $00, $8a, $03, $00, $8a, $04, $02, $97, $00, $20, $00, $80, $03, $02, $97
1017c     00 30 00 80 
10180     04 00 13 01 
10184     04 00 9B 02 
10188     03 00 9B 00 | 	byte	$00, $30, $00, $80, $04, $00, $13, $01, $04, $00, $9b, $02, $03, $00, $9b, $00
1018c     04 00 9A 04 
10190     00 9A 03 00 
10194     AA 00 8A 03 
10198     00 8A 04 02 | 	byte	$04, $00, $9a, $04, $00, $9a, $03, $00, $aa, $00, $8a, $03, $00, $8a, $04, $02
1019c     97 00 20 00 
101a0     80 03 02 97 
101a4     00 40 00 80 
101a8     04 00 13 01 | 	byte	$97, $00, $20, $00, $80, $03, $02, $97, $00, $40, $00, $80, $04, $00, $13, $01
101ac     04 00 9B 02 
101b0     03 00 9B 00 
101b4     04 00 9A 04 
101b8     00 9A 03 00 | 	byte	$04, $00, $9b, $02, $03, $00, $9b, $00, $04, $00, $9a, $04, $00, $9a, $03, $00
101bc     AA 02 88 63 
101c0     02 00 F0 02 
101c4     88 18 03 00 
101c8     F0 02 88 83 | 	byte	$aa, $02, $88, $63, $02, $00, $f0, $02, $88, $18, $03, $00, $f0, $02, $88, $83
101cc     02 00 F0 02 
101d0     98 3A 03 00 
101d4     F0 00 8C 00 
101d8     90 0E 87 FE | 	byte	$02, $00, $f0, $02, $98, $3a, $03, $00, $f0, $00, $8c, $00, $90, $0e, $87, $fe
101dc     FB 03 00 FA 
101e0     FB 03 00 12 
101e4     88 69 02 00 
101e8     F0 02 88 99 | 	byte	$fb, $03, $00, $fa, $fb, $03, $00, $12, $88, $69, $02, $00, $f0, $02, $88, $99
101ec     02 00 F0 02 
101f0     98 3A 03 00 
101f4     F0 0E 87 FE 
101f8     FB 03 00 FA | 	byte	$02, $00, $f0, $02, $98, $3a, $03, $00, $f0, $0e, $87, $fe, $fb, $03, $00, $fa
101fc     FB 03 00 12 
10200     88 50 03 00 
10204     F0 00 9C 00 
10208     8A 08 00 8A | 	byte	$fb, $03, $00, $12, $88, $50, $03, $00, $f0, $00, $9c, $00, $8a, $08, $00, $8a
1020c     09 02 97 FE 
10210     FB 03 00 08 
10214     02 98 75 03 
10218     00 F0 02 97 | 	byte	$09, $02, $97, $fe, $fb, $03, $00, $08, $02, $98, $75, $03, $00, $f0, $02, $97
1021c     DF FF 03 00 
10220     08 02 98 AF 
10224     03 00 F0 02 
10228     97 FE FB 03 | 	byte	$df, $ff, $03, $00, $08, $02, $98, $af, $03, $00, $f0, $02, $97, $fe, $fb, $03
1022c     00 09 02 81 
10230     20 00 00 00 
10234     09 0C 87 09 
10238     FA FB 03 00 | 	byte	$00, $09, $02, $81, $20, $00, $00, $00, $09, $0c, $87, $09, $fa, $fb, $03, $00
1023c     12 88 F7 02 
10240     00 F0 00 97 
10244     09 08 02 98 
10248     75 03 00 F0 | 	byte	$12, $88, $f7, $02, $00, $f0, $00, $97, $09, $08, $02, $98, $75, $03, $00, $f0
1024c     00 97 09 08 
10250     02 A1 20 00 
10254     00 00 08 02 
10258     98 AF 03 00 | 	byte	$00, $97, $09, $08, $02, $a1, $20, $00, $00, $00, $08, $02, $98, $af, $03, $00
1025c     F0 02 88 C2 
10260     02 00 F0 02 
10264     97 DF FF 03 
10268     00 08 02 98 | 	byte	$f0, $02, $88, $c2, $02, $00, $f0, $02, $97, $df, $ff, $03, $00, $08, $02, $98
1026c     75 03 00 F0 
10270     0E A1 20 00 
10274     00 00 FA FB 
10278     03 00 00 9A | 	byte	$75, $03, $00, $f0, $0e, $a1, $20, $00, $00, $00, $fa, $fb, $03, $00, $00, $9a
1027c     09 00 9A 08 
10280     00 8C 00 AA 
10284     02 98 3A 03 
10288     00 F0 00 8A | 	byte	$09, $00, $9a, $08, $00, $8c, $00, $aa, $02, $98, $3a, $03, $00, $f0, $00, $8a
1028c     08 03 97 FA 
10290     FB 03 00 08 
10294     02 98 AF 03 
10298     00 F0 0C 97 | 	byte	$08, $03, $97, $fa, $fb, $03, $00, $08, $02, $98, $af, $03, $00, $f0, $0c, $97
1029c     08 FA FB 03 
102a0     00 00 9A 08 
102a4     00 AA 0E 87 
102a8     00 00 00 00 | 	byte	$08, $fa, $fb, $03, $00, $00, $9a, $08, $00, $aa, $0e, $87, $00, $00, $00, $00
102ac     FA FB 03 00 
102b0     1E 97 FE FB 
102b4     03 00 FA FB 
102b8     03 00 00 AA | 	byte	$fa, $fb, $03, $00, $1e, $97, $fe, $fb, $03, $00, $fa, $fb, $03, $00, $00, $aa
102bc     02 97 FF FF 
102c0     FF FF 00 02 
102c4     27 00 01 02 
102c8     27 00 02 02 | 	byte	$02, $97, $ff, $ff, $ff, $ff, $00, $02, $27, $00, $01, $02, $27, $00, $02, $02
102cc     27 00 03 02 
102d0     27 00 04 02 
102d4     27 00 05 02 
102d8     27 00 06 02 | 	byte	$27, $00, $03, $02, $27, $00, $04, $02, $27, $00, $05, $02, $27, $00, $06, $02
102dc     27 00 07 00 
102e0     AA 01 97 08 
102e4     00 08 91 08 
102e8     01 97 08 01 | 	byte	$27, $00, $07, $00, $aa, $01, $97, $08, $00, $08, $91, $08, $01, $97, $08, $01
102ec     08 91 08 01 
102f0     97 08 02 08 
102f4     91 08 01 97 
102f8     08 03 08 91 | 	byte	$08, $91, $08, $01, $97, $08, $02, $08, $91, $08, $01, $97, $08, $03, $08, $91
102fc     08 01 97 08 
10300     04 08 91 08 
10304     01 97 08 05 
10308     08 91 08 01 | 	byte	$08, $01, $97, $08, $04, $08, $91, $08, $01, $97, $08, $05, $08, $91, $08, $01
1030c     97 08 06 08 
10310     91 08 01 97 
10314     08 07 08 91 
10318     08 00 AA 04 | 	byte	$97, $08, $06, $08, $91, $08, $01, $97, $08, $07, $08, $91, $08, $00, $aa, $04
1031c     97 00 08 08 
10320     91 08 04 97 
10324     01 08 08 91 
10328     08 04 97 02 | 	byte	$97, $00, $08, $08, $91, $08, $04, $97, $01, $08, $08, $91, $08, $04, $97, $02
1032c     08 08 91 08 
10330     04 97 03 08 
10334     08 91 08 04 
10338     97 04 08 08 | 	byte	$08, $08, $91, $08, $04, $97, $03, $08, $08, $91, $08, $04, $97, $04, $08, $08
1033c     91 08 04 97 
10340     05 08 08 91 
10344     08 04 97 06 
10348     08 08 91 08 | 	byte	$91, $08, $04, $97, $05, $08, $08, $91, $08, $04, $97, $06, $08, $08, $91, $08
1034c     04 97 07 08 
10350     08 91 08 00 
10354     AA 00 8A 00 
10358     02 97 02 04 | 	byte	$04, $97, $07, $08, $08, $91, $08, $00, $aa, $00, $8a, $00, $02, $97, $02, $04
1035c     00 F0 00 02 
10360     98 DE 01 00 
10364     F0 00 9A 00 
10368     02 88 79 04 | 	byte	$00, $f0, $00, $02, $98, $de, $01, $00, $f0, $00, $9a, $00, $02, $88, $79, $04
1036c     00 F0 44 69 
10370     76 69 64 65 
10374     20 62 79 20 
10378     7A 65 72 6F | 	byte	$00, $f0, $44, $69, $76, $69, $64, $65, $20, $62, $79, $20, $7a, $65, $72, $6f
1037c     0A 00 00 8A 
10380     00 02 97 2B 
10384     04 00 F0 00 
10388     02 98 DE 01 | 	byte	$0a, $00, $00, $8a, $00, $02, $97, $2b, $04, $00, $f0, $00, $02, $98, $de, $01
1038c     00 F0 00 9A 
10390     00 02 88 79 
10394     04 00 F0 49 
10398     6E 76 61 6C | 	byte	$00, $f0, $00, $9a, $00, $02, $88, $79, $04, $00, $f0, $49, $6e, $76, $61, $6c
1039c     69 64 20 6F 
103a0     70 63 6F 64 
103a4     65 0A 00 00 
103a8     8A 00 02 97 | 	byte	$69, $64, $20, $6f, $70, $63, $6f, $64, $65, $0a, $00, $00, $8a, $00, $02, $97
103ac     57 04 00 F0 
103b0     00 02 98 DE 
103b4     01 00 F0 00 
103b8     9A 00 00 9A | 	byte	$57, $04, $00, $f0, $00, $02, $98, $de, $01, $00, $f0, $00, $9a, $00, $00, $9a
103bc     01 02 88 79 
103c0     04 00 F0 50 
103c4     61 67 65 20 
103c8     66 61 75 6C | 	byte	$01, $02, $88, $79, $04, $00, $f0, $50, $61, $67, $65, $20, $66, $61, $75, $6c
103cc     74 20 61 74 
103d0     20 76 69 72 
103d4     74 75 61 6C 
103d8     20 61 64 64 | 	byte	$74, $20, $61, $74, $20, $76, $69, $72, $74, $75, $61, $6c, $20, $61, $64, $64
103dc     72 65 73 73 
103e0     20 72 31 0A 
103e4     00 08 91 20 
103e8     00 8A 22 00 | 	byte	$72, $65, $73, $73, $20, $72, $31, $0a, $00, $08, $91, $20, $00, $8a, $22, $00
103ec     8A 21 00 8A 
103f0     20 00 8A 1F 
103f4     00 8A 1E 00 
103f8     8A 1D 00 8A | 	byte	$8a, $21, $00, $8a, $20, $00, $8a, $1f, $00, $8a, $1e, $00, $8a, $1d, $00, $8a
103fc     1C 00 8A 1B 
10400     00 8A 1A 00 
10404     8A 19 00 8A 
10408     18 00 8A 17 | 	byte	$1c, $00, $8a, $1b, $00, $8a, $1a, $00, $8a, $19, $00, $8a, $18, $00, $8a, $17
1040c     00 8A 16 00 
10410     8A 15 00 8A 
10414     14 00 8A 13 
10418     00 8A 12 00 | 	byte	$00, $8a, $16, $00, $8a, $15, $00, $8a, $14, $00, $8a, $13, $00, $8a, $12, $00
1041c     8A 11 00 8A 
10420     10 00 8A 0F 
10424     00 8A 0E 00 
10428     8A 0D 00 8A | 	byte	$8a, $11, $00, $8a, $10, $00, $8a, $0f, $00, $8a, $0e, $00, $8a, $0d, $00, $8a
1042c     0C 00 8A 0B 
10430     00 8A 0A 00 
10434     8A 09 00 8A 
10438     08 00 8A 07 | 	byte	$0c, $00, $8a, $0b, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $07
1043c     00 8A 06 00 
10440     8A 05 00 8A 
10444     04 00 8A 03 
10448     00 8A 02 00 | 	byte	$00, $8a, $06, $00, $8a, $05, $00, $8a, $04, $00, $8a, $03, $00, $8a, $02, $00
1044c     8A 01 00 8A 
10450     00 86 81 0D 
10454     00 00 00 20 
10458     80 02 97 62 | 	byte	$8a, $01, $00, $8a, $00, $86, $81, $0d, $00, $00, $00, $20, $80, $02, $97, $62
1045c     05 00 F0 00 
10460     02 98 DE 01 
10464     00 F0 00 9A 
10468     00 00 9A 01 | 	byte	$05, $00, $f0, $00, $02, $98, $de, $01, $00, $f0, $00, $9a, $00, $00, $9a, $01
1046c     00 9A 02 00 
10470     9A 03 00 9A 
10474     04 00 9A 05 
10478     00 9A 06 00 | 	byte	$00, $9a, $02, $00, $9a, $03, $00, $9a, $04, $00, $9a, $05, $00, $9a, $06, $00
1047c     9A 07 00 9A 
10480     08 00 9A 09 
10484     00 9A 0A 00 
10488     9A 0B 00 9A | 	byte	$9a, $07, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $0b, $00, $9a
1048c     0C 00 9A 0D 
10490     00 9A 0E 00 
10494     9A 0F 00 9A 
10498     10 00 9A 11 | 	byte	$0c, $00, $9a, $0d, $00, $9a, $0e, $00, $9a, $0f, $00, $9a, $10, $00, $9a, $11
1049c     00 9A 12 00 
104a0     9A 13 00 9A 
104a4     14 00 9A 15 
104a8     00 9A 16 00 | 	byte	$00, $9a, $12, $00, $9a, $13, $00, $9a, $14, $00, $9a, $15, $00, $9a, $16, $00
104ac     9A 17 00 9A 
104b0     18 00 9A 19 
104b4     00 9A 1A 00 
104b8     9A 1B 00 9A | 	byte	$9a, $17, $00, $9a, $18, $00, $9a, $19, $00, $9a, $1a, $00, $9a, $1b, $00, $9a
104bc     1C 00 9A 1D 
104c0     00 9A 1E 00 
104c4     9A 1F 0C 91 
104c8     20 00 9A 22 | 	byte	$1c, $00, $9a, $1d, $00, $9a, $1e, $00, $9a, $1f, $0c, $91, $20, $00, $9a, $22
104cc     00 BA 42 72 
104d0     65 61 6B 70 
104d4     6F 69 6E 74 
104d8     20 72 65 61 | 	byte	$00, $ba, $42, $72, $65, $61, $6b, $70, $6f, $69, $6e, $74, $20, $72, $65, $61
104dc     63 68 65 64 
104e0     21 0A 00 00 
104e4     8A 02 00 8A 
104e8     03 02 27 00 | 	byte	$63, $68, $65, $64, $21, $0a, $00, $00, $8a, $02, $00, $8a, $03, $02, $27, $00
104ec     03 01 27 00 
104f0     02 00 91 00 
104f4     02 87 00 00 
104f8     00 00 02 12 | 	byte	$03, $01, $27, $00, $02, $00, $91, $00, $02, $87, $00, $00, $00, $00, $02, $12
104fc     88 12 06 00 
10500     F0 02 87 30 
10504     00 00 00 02 
10508     32 88 BC 05 | 	byte	$88, $12, $06, $00, $f0, $02, $87, $30, $00, $00, $00, $02, $32, $88, $bc, $05
1050c     00 F0 02 87 
10510     39 00 00 00 
10514     02 52 88 BC 
10518     05 00 F0 02 | 	byte	$00, $f0, $02, $87, $39, $00, $00, $00, $02, $52, $88, $bc, $05, $00, $f0, $02
1051c     A1 30 00 00 
10520     00 02 02 88 
10524     04 06 00 F0 
10528     02 87 41 00 | 	byte	$a1, $30, $00, $00, $00, $02, $02, $88, $04, $06, $00, $f0, $02, $87, $41, $00
1052c     00 00 02 32 
10530     88 E3 05 00 
10534     F0 02 87 5A 
10538     00 00 00 02 | 	byte	$00, $00, $02, $32, $88, $e3, $05, $00, $f0, $02, $87, $5a, $00, $00, $00, $02
1053c     52 88 E3 05 
10540     00 F0 02 A1 
10544     37 00 00 00 
10548     02 02 88 04 | 	byte	$52, $88, $e3, $05, $00, $f0, $02, $a1, $37, $00, $00, $00, $02, $02, $88, $04
1054c     06 00 F0 02 
10550     87 61 00 00 
10554     00 02 32 88 
10558     81 05 00 F0 | 	byte	$06, $00, $f0, $02, $87, $61, $00, $00, $00, $02, $32, $88, $81, $05, $00, $f0
1055c     02 87 7A 00 
10560     00 00 02 52 
10564     88 81 05 00 
10568     F0 02 A1 57 | 	byte	$02, $87, $7a, $00, $00, $00, $02, $52, $88, $81, $05, $00, $f0, $02, $a1, $57
1056c     00 00 00 02 
10570     00 82 01 03 
10574     00 81 02 03 
10578     02 88 81 05 | 	byte	$00, $00, $00, $02, $00, $82, $01, $03, $00, $81, $02, $03, $02, $88, $81, $05
1057c     00 F0 00 97 
10580     03 00 00 9A 
10584     03 00 9A 02 
10588     00 AA 00 8A | 	byte	$00, $f0, $00, $97, $03, $00, $00, $9a, $03, $00, $9a, $02, $00, $aa, $00, $8a
1058c     00 00 8A 01 
10590     00 8A 1F 00 
10594     97 02 1F 05 
10598     17 00 01 00 | 	byte	$00, $00, $8a, $01, $00, $8a, $1f, $00, $97, $02, $1f, $05, $17, $00, $01, $00
1059c     91 00 00 91 
105a0     01 02 A8 2B 
105a4     06 00 F0 00 
105a8     9A 1F 00 9A | 	byte	$91, $00, $00, $91, $01, $02, $a8, $2b, $06, $00, $f0, $00, $9a, $1f, $00, $9a
105ac     01 00 9A 00 
105b0     00 AA 00 8A 
105b4     00 00 8A 01 
105b8     00 8A 1F 00 | 	byte	$01, $00, $9a, $00, $00, $aa, $00, $8a, $00, $00, $8a, $01, $00, $8a, $1f, $00
105bc     97 02 1F 05 
105c0     97 00 01 08 
105c4     91 00 08 91 
105c8     01 02 A8 53 | 	byte	$97, $02, $1f, $05, $97, $00, $01, $08, $91, $00, $08, $91, $01, $02, $a8, $53
105cc     06 00 F0 00 
105d0     9A 1F 00 9A 
105d4     01 00 9A 00 
105d8     00 AA 00 8A | 	byte	$06, $00, $f0, $00, $9a, $1f, $00, $9a, $01, $00, $9a, $00, $00, $aa, $00, $8a
105dc     00 00 8A 01 
105e0     00 8A 1F 00 
105e4     97 02 1F 05 
105e8     07 00 01 22 | 	byte	$00, $00, $8a, $01, $00, $8a, $1f, $00, $97, $02, $1f, $05, $07, $00, $01, $22
105ec     88 9C 06 00 
105f0     F0 00 91 00 
105f4     00 91 01 02 
105f8     A8 7B 06 00 | 	byte	$88, $9c, $06, $00, $f0, $00, $91, $00, $00, $91, $01, $02, $a8, $7b, $06, $00
105fc     F0 02 27 00 
10600     00 02 87 00 
10604     00 00 00 00 
10608     00 9A 1F 00 | 	byte	$f0, $02, $27, $00, $00, $02, $87, $00, $00, $00, $00, $00, $00, $9a, $1f, $00
1060c     9A 01 00 9A 
10610     00 00 AA 00 
10614     8A 00 00 8A 
10618     01 00 8A 1F | 	byte	$9a, $01, $00, $9a, $00, $00, $aa, $00, $8a, $00, $00, $8a, $01, $00, $8a, $1f
1061c     00 97 02 1F 
10620     05 87 00 01 
10624     22 88 D5 06 
10628     00 F0 08 91 | 	byte	$00, $97, $02, $1f, $05, $87, $00, $01, $22, $88, $d5, $06, $00, $f0, $08, $91
1062c     00 08 91 01 
10630     02 A8 B4 06 
10634     00 F0 02 27 
10638     00 00 02 87 | 	byte	$00, $08, $91, $01, $02, $a8, $b4, $06, $00, $f0, $02, $27, $00, $00, $02, $87
1063c     00 00 00 00 
10640     00 00       | 	byte	$00[6]
10642     9A 1F 00 9A 
10646     01 00 9A 00 
1064a     00 AA 00 8A 
1064e     01 03 97 8E | 	byte	$9a, $1f, $00, $9a, $01, $00, $9a, $00, $00, $aa, $00, $8a, $01, $03, $97, $8e
10652     21 28 02 00 
10656     00 97 00 01 
1065a     02 84 0D 01 
1065e     00 A3 01 00 | 	byte	$21, $28, $02, $00, $00, $97, $00, $01, $02, $84, $0d, $01, $00, $a3, $01, $00
10662     00 97 00 01 
10666     02 95 11 01 
1066a     00 A3 01 00 
1066e     00 97 00 01 | 	byte	$00, $97, $00, $01, $02, $95, $11, $01, $00, $a3, $01, $00, $00, $97, $00, $01
10672     02 84 05 01 
10676     00 A3 01 00 
1067a     0C 97 00 8E 
1067e     21 28 02 00 | 	byte	$02, $84, $05, $01, $00, $a3, $01, $00, $0c, $97, $00, $8e, $21, $28, $02, $00
10682     9A 01 00 AA 
10686     02 98 E0 06 
1068a     00 F0 00 A1 
1068e     01 02 00 B2 | 	byte	$9a, $01, $00, $aa, $02, $98, $e0, $06, $00, $f0, $00, $a1, $01, $02, $00, $b2
10692     02 00 00 81 
10696     01 00 00 AA 
1069a     00 8A 00 00 
1069e     8A 01 00 8A | 	byte	$02, $00, $00, $81, $01, $00, $00, $aa, $00, $8a, $00, $00, $8a, $01, $00, $8a
106a2     02 01 17 00 
106a6     02 04 17 02 
106aa     01 00 91 00 
106ae     00 91 01 02 | 	byte	$02, $01, $17, $00, $02, $04, $17, $02, $01, $00, $91, $00, $00, $91, $01, $02
106b2     07 00 02 22 
106b6     88 37 07 00 
106ba     F0 00 9A 02 
106be     00 9A 01 00 | 	byte	$07, $00, $02, $22, $88, $37, $07, $00, $f0, $00, $9a, $02, $00, $9a, $01, $00
106c2     9A 00 00 AA 
106c6     00 8A 00 00 
106ca     8A 01 05 07 
106ce     01 00 22 88 | 	byte	$9a, $00, $00, $aa, $00, $8a, $00, $00, $8a, $01, $05, $07, $01, $00, $22, $88
106d2     80 07 00 F0 
106d6     06 07 00 00 
106da     12 88 88 07 
106de     00 F0 00 91 | 	byte	$80, $07, $00, $f0, $06, $07, $00, $00, $12, $88, $88, $07, $00, $f0, $00, $91
106e2     00 00 91 01 
106e6     02 88 60 07 
106ea     00 F0 00 9A 
106ee     01 00 9A 00 | 	byte	$00, $00, $91, $01, $02, $88, $60, $07, $00, $f0, $00, $9a, $01, $00, $9a, $00
106f2     00 AA 02 27 
106f6     00 00 02 87 
106fa     00 00 00 00 
106fe     00 00 9A 01 | 	byte	$00, $aa, $02, $27, $00, $00, $02, $87, $00, $00, $00, $00, $00, $00, $9a, $01
10702     00 9A 00 00 
10706     AA 00 8A 01 
1070a     02 27 00 01 
1070e     06 07 00 00 | 	byte	$00, $9a, $00, $00, $aa, $00, $8a, $01, $02, $27, $00, $01, $06, $07, $00, $00
10712     12 88 B8 07 
10716     00 F0 00 91 
1071a     00 00 91 01 
1071e     02 88 A2 07 | 	byte	$12, $88, $b8, $07, $00, $f0, $00, $91, $00, $00, $91, $01, $02, $88, $a2, $07
10722     00 F0 00 97 
10726     01 00 00 9A 
1072a     01 00 AA 02 
1072e     93 00 10 00 | 	byte	$00, $f0, $00, $97, $01, $00, $00, $9a, $01, $00, $aa, $02, $93, $00, $10, $00
10732     80 00 00 8B 
10736     00 00 02 87 
1073a     00 00 00 00 
1073e     00 12 88 DF | 	byte	$80, $00, $00, $8b, $00, $00, $02, $87, $00, $00, $00, $00, $00, $12, $88, $df
10742     07 00 F0 02 
10746     27 01 00 00 
1074a     AA 02 27 00 
1074e     00 00 AA 02 | 	byte	$07, $00, $f0, $02, $27, $01, $00, $00, $aa, $02, $27, $00, $00, $00, $aa, $02
10752     98 6E 06 00 
10756     F0 12 27 01 
1075a     00 22 27 00 
1075e     00 00 AA 00 | 	byte	$98, $6e, $06, $00, $f0, $12, $27, $01, $00, $22, $27, $00, $00, $00, $aa, $00
10762     A0 00 AA 00 
10766     8A 09 00 8A 
1076a     08 00 8A 22 
1076e     0C B1 20 00 | 	byte	$a0, $00, $aa, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $0c, $b1, $20, $00
10772     8A 02 00 8A 
10776     01 00 8A 00 
1077a     00 97 20 22 
1077e     08 B1 22 81 | 	byte	$8a, $02, $00, $8a, $01, $00, $8a, $00, $00, $97, $20, $22, $08, $b1, $22, $81
10782     97 22 08 00 
10786     02 98 C1 07 
1078a     00 F0 00 97 
1078e     00 08 02 87 | 	byte	$97, $22, $08, $00, $02, $98, $c1, $07, $00, $f0, $00, $97, $00, $08, $02, $87
10792     00 00 00 00 
10796     08 12 27 01 
1079a     08 22 27 00 
1079e     08 02 87 00 | 	byte	$00, $00, $00, $00, $08, $12, $27, $01, $08, $22, $27, $00, $08, $02, $87, $00
107a2     00 00 00 08 
107a6     22 88 46 08 
107aa     00 F0 02 88 
107ae     56 08 00 F0 | 	byte	$00, $00, $00, $08, $22, $88, $46, $08, $00, $f0, $02, $88, $56, $08, $00, $f0
107b2     02 27 00 00 
107b6     02 88 60 09 
107ba     00 F0 02 88 
107be     56 08 00 F0 | 	byte	$02, $27, $00, $00, $02, $88, $60, $09, $00, $f0, $02, $88, $56, $08, $00, $f0
107c2     81 97 22 08 
107c6     08 81 97 22 
107ca     0C 09 02 81 
107ce     00 00 00 00 | 	byte	$81, $97, $22, $08, $08, $81, $97, $22, $0c, $09, $02, $81, $00, $00, $00, $00
107d2     09 04 17 08 
107d6     09 02 27 00 
107da     08 81 97 22 
107de     0C 09 02 81 | 	byte	$09, $04, $17, $08, $09, $02, $27, $00, $08, $81, $97, $22, $0c, $09, $02, $81
107e2     03 00 00 00 
107e6     09 04 97 08 
107ea     09 02 27 00 
107ee     08 81 97 22 | 	byte	$03, $00, $00, $00, $09, $04, $97, $08, $09, $02, $27, $00, $08, $81, $97, $22
107f2     0C 09 02 81 
107f6     07 00 00 00 
107fa     09 04 17 08 
107fe     09 02 27 01 | 	byte	$0c, $09, $02, $81, $07, $00, $00, $00, $09, $04, $17, $08, $09, $02, $27, $01
10802     00 81 97 22 
10806     08 01 02 97 
1080a     00 06 00 00 
1080e     02 02 98 01 | 	byte	$00, $81, $97, $22, $08, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01
10812     02 00 F0 02 
10816     97 00 06 00 
1081a     00 08 02 81 
1081e     14 00 00 00 | 	byte	$02, $00, $f0, $02, $97, $00, $06, $00, $00, $08, $02, $81, $14, $00, $00, $00
10822     08 84 97 08 
10826     22 14 02 27 
1082a     1F 08 84 97 
1082e     08 22 10 81 | 	byte	$08, $84, $97, $08, $22, $14, $02, $27, $1f, $08, $84, $97, $08, $22, $10, $81
10832     97 22 10 08 
10836     02 87 00 00 
1083a     00 00 08 12 
1083e     88 56 09 00 | 	byte	$97, $22, $10, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $56, $09, $00
10842     F0 81 97 22 
10846     04 00 81 97 
1084a     22 14 01 02 
1084e     27 0B 02 02 | 	byte	$f0, $81, $97, $22, $04, $00, $81, $97, $22, $14, $01, $02, $27, $0b, $02, $02
10852     98 E5 07 00 
10856     F0 00 97 00 
1085a     08 02 87 00 
1085e     00 00 00 08 | 	byte	$98, $e5, $07, $00, $f0, $00, $97, $00, $08, $02, $87, $00, $00, $00, $00, $08
10862     22 88 02 09 
10866     00 F0 02 88 
1086a     32 09 00 F0 
1086e     81 97 22 14 | 	byte	$22, $88, $02, $09, $00, $f0, $02, $88, $32, $09, $00, $f0, $81, $97, $22, $14
10872     09 08 B1 09 
10876     01 67 09 08 
1087a     81 97 22 0C 
1087e     09 00 91 09 | 	byte	$09, $08, $b1, $09, $01, $67, $09, $08, $81, $97, $22, $0c, $09, $00, $91, $09
10882     04 57 08 09 
10886     81 97 22 0C 
1088a     00 00 91 00 
1088e     01 67 00 00 | 	byte	$04, $57, $08, $09, $81, $97, $22, $0c, $00, $00, $91, $00, $01, $67, $00, $00
10892     02 88 60 09 
10896     00 F0 02 88 
1089a     32 09 00 F0 
1089e     81 97 22 14 | 	byte	$02, $88, $60, $09, $00, $f0, $02, $88, $32, $09, $00, $f0, $81, $97, $22, $14
108a2     08 02 81 10 
108a6     00 00 00 08 
108aa     84 97 08 22 
108ae     14 81 97 22 | 	byte	$08, $02, $81, $10, $00, $00, $00, $08, $84, $97, $08, $22, $14, $81, $97, $22
108b2     10 08 00 B1 
108b6     08 84 97 08 
108ba     22 10 02 88 
108be     C5 08 00 F0 | 	byte	$10, $08, $00, $b1, $08, $84, $97, $08, $22, $10, $02, $88, $c5, $08, $00, $f0
108c2     02 27 00 00 
108c6     02 88 60 09 
108ca     00 F0 08 91 
108ce     20 00 9A 01 | 	byte	$02, $27, $00, $00, $02, $88, $60, $09, $00, $f0, $08, $91, $20, $00, $9a, $01
108d2     00 9A 02 0C 
108d6     91 20 00 9A 
108da     22 00 9A 08 
108de     00 9A 09 00 | 	byte	$00, $9a, $02, $0c, $91, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00
108e2     AA 00 8A 0A 
108e6     00 8A 09 00 
108ea     8A 08 00 8A 
108ee     22 02 A1 18 | 	byte	$aa, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $02, $a1, $18
108f2     00 00 00 20 
108f6     00 8A 03 00 
108fa     8A 02 00 8A 
108fe     01 00 8A 00 | 	byte	$00, $00, $00, $20, $00, $8a, $03, $00, $8a, $02, $00, $8a, $01, $00, $8a, $00
10902     00 97 20 22 
10906     08 B1 22 81 
1090a     97 22 04 00 
1090e     81 97 22 08 | 	byte	$00, $97, $20, $22, $08, $b1, $22, $81, $97, $22, $04, $00, $81, $97, $22, $08
10912     01 81 97 22 
10916     0C 02 02 98 
1091a     F9 07 00 F0 
1091e     00 97 00 08 | 	byte	$01, $81, $97, $22, $0c, $02, $02, $98, $f9, $07, $00, $f0, $00, $97, $00, $08
10922     84 97 08 22 
10926     28 81 97 22 
1092a     28 08 02 87 
1092e     00 00 00 00 | 	byte	$84, $97, $08, $22, $28, $81, $97, $22, $28, $08, $02, $87, $00, $00, $00, $00
10932     08 22 27 01 
10936     08 12 27 00 
1093a     08 02 87 00 
1093e     00 00 00 08 | 	byte	$08, $22, $27, $01, $08, $12, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08
10942     22 88 E2 09 
10946     00 F0 02 88 
1094a     F3 09 00 F0 
1094e     81 97 22 0C | 	byte	$22, $88, $e2, $09, $00, $f0, $02, $88, $f3, $09, $00, $f0, $81, $97, $22, $0c
10952     00 02 98 04 
10956     0D 00 F0 02 
1095a     88 F3 09 00 
1095e     F0 81 97 22 | 	byte	$00, $02, $98, $04, $0d, $00, $f0, $02, $88, $f3, $09, $00, $f0, $81, $97, $22
10962     08 00 02 98 
10966     0F 23 00 F0 
1096a     00 97 00 08 
1096e     84 97 08 22 | 	byte	$08, $00, $02, $98, $0f, $23, $00, $f0, $00, $97, $00, $08, $84, $97, $08, $22
10972     14 81 97 22 
10976     08 00 02 98 
1097a     86 21 00 F0 
1097e     00 97 00 08 | 	byte	$14, $81, $97, $22, $08, $00, $02, $98, $86, $21, $00, $f0, $00, $97, $00, $08
10982     84 97 08 22 
10986     18 81 97 22 
1098a     14 08 02 87 
1098e     00 00 00 00 | 	byte	$84, $97, $08, $22, $18, $81, $97, $22, $14, $08, $02, $87, $00, $00, $00, $00
10992     08 12 27 01 
10996     08 22 27 00 
1099a     08 81 97 22 
1099e     18 09 02 87 | 	byte	$08, $12, $27, $01, $08, $22, $27, $00, $08, $81, $97, $22, $18, $09, $02, $87
109a2     00 00 00 00 
109a6     09 12 27 01 
109aa     09 22 27 00 
109ae     09 00 93 09 | 	byte	$00, $00, $00, $00, $09, $12, $27, $01, $09, $22, $27, $00, $09, $00, $93, $09
109b2     08 02 87 00 
109b6     00 00 00 08 
109ba     22 88 5A 0A 
109be     00 F0 02 88 | 	byte	$08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $5a, $0a, $00, $f0, $02, $88
109c2     6A 0A 00 F0 
109c6     02 27 00 00 
109ca     02 88 E3 0C 
109ce     00 F0 02 88 | 	byte	$6a, $0a, $00, $f0, $02, $27, $00, $00, $02, $88, $e3, $0c, $00, $f0, $02, $88
109d2     6A 0A 00 F0 
109d6     02 27 01 00 
109da     81 97 22 08 
109de     01 02 97 00 | 	byte	$6a, $0a, $00, $f0, $02, $27, $01, $00, $81, $97, $22, $08, $01, $02, $97, $00
109e2     06 00 00 02 
109e6     02 98 01 02 
109ea     00 F0 02 97 
109ee     00 06 00 00 | 	byte	$06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00, $00
109f2     09 81 97 22 
109f6     14 0A 00 81 
109fa     0A 09 81 97 
109fe     22 18 08 04 | 	byte	$09, $81, $97, $22, $14, $0a, $00, $81, $0a, $09, $81, $97, $22, $18, $08, $04
10a02     57 08 09 81 
10a06     97 22 10 00 
10a0a     02 67 FA 01 
10a0e     01 02 98 BA | 	byte	$57, $08, $09, $81, $97, $22, $10, $00, $02, $67, $fa, $01, $01, $02, $98, $ba
10a12     20 00 F0 00 
10a16     97 00 08 02 
10a1a     A2 FA 01 00 
10a1e     00 08 84 97 | 	byte	$20, $00, $f0, $00, $97, $00, $08, $02, $a2, $fa, $01, $00, $00, $08, $84, $97
10a22     08 22 1C 02 
10a26     97 00 06 00 
10a2a     00 09 81 97 
10a2e     22 14 0A 00 | 	byte	$08, $22, $1c, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $14, $0a, $00
10a32     81 0A 09 04 
10a36     91 09 81 97 
10a3a     22 1C 08 04 
10a3e     57 08 09 81 | 	byte	$81, $0a, $09, $04, $91, $09, $81, $97, $22, $1c, $08, $04, $57, $08, $09, $81
10a42     97 22 04 00 
10a46     02 97 00 06 
10a4a     00 00 01 81 
10a4e     97 22 14 08 | 	byte	$97, $22, $04, $00, $02, $97, $00, $06, $00, $00, $01, $81, $97, $22, $14, $08
10a52     00 81 08 01 
10a56     08 91 01 02 
10a5a     27 0B 02 02 
10a5e     98 1E 06 00 | 	byte	$00, $81, $08, $01, $08, $91, $01, $02, $27, $0b, $02, $02, $98, $1e, $06, $00
10a62     F0 02 97 00 
10a66     06 00 00 09 
10a6a     81 97 22 14 
10a6e     0A 00 81 0A | 	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $14, $0a, $00, $81, $0a
10a72     09 08 91 09 
10a76     02 81 0B 00 
10a7a     00 00 09 02 
10a7e     27 00 08 04 | 	byte	$09, $08, $91, $09, $02, $81, $0b, $00, $00, $00, $09, $02, $27, $00, $08, $04
10a82     17 08 09 02 
10a86     27 01 00 81 
10a8a     97 22 08 01 
10a8e     02 97 00 06 | 	byte	$17, $08, $09, $02, $27, $01, $00, $81, $97, $22, $08, $01, $02, $97, $00, $06
10a92     00 00 02 02 
10a96     98 29 02 00 
10a9a     F0 02 27 00 
10a9e     08 84 97 08 | 	byte	$00, $00, $02, $02, $98, $29, $02, $00, $f0, $02, $27, $00, $08, $84, $97, $08
10aa2     22 20 81 97 
10aa6     22 20 08 81 
10aaa     97 22 1C 09 
10aae     00 87 09 08 | 	byte	$22, $20, $81, $97, $22, $20, $08, $81, $97, $22, $1c, $09, $00, $87, $09, $08
10ab2     32 27 01 08 
10ab6     42 27 00 08 
10aba     02 87 00 00 
10abe     00 00 08 12 | 	byte	$32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12
10ac2     88 C4 0C 00 
10ac6     F0 81 97 22 
10aca     08 00 02 98 
10ace     86 21 00 F0 | 	byte	$88, $c4, $0c, $00, $f0, $81, $97, $22, $08, $00, $02, $98, $86, $21, $00, $f0
10ad2     00 97 00 08 
10ad6     84 97 08 22 
10ada     24 81 97 22 
10ade     24 00 02 98 | 	byte	$00, $97, $00, $08, $84, $97, $08, $22, $24, $81, $97, $22, $24, $00, $02, $98
10ae2     B9 24 00 F0 
10ae6     81 97 22 24 
10aea     00 81 97 22 
10aee     08 01 02 97 | 	byte	$b9, $24, $00, $f0, $81, $97, $22, $24, $00, $81, $97, $22, $08, $01, $02, $97
10af2     00 06 00 00 
10af6     02 02 98 01 
10afa     02 00 F0 02 
10afe     97 00 06 00 | 	byte	$00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00
10b02     00 09 02 27 
10b06     FF 08 04 17 
10b0a     08 09 02 97 
10b0e     00 06 00 00 | 	byte	$00, $09, $02, $27, $ff, $08, $04, $17, $08, $09, $02, $97, $00, $06, $00, $00
10b12     09 00 91 09 
10b16     02 27 00 08 
10b1a     04 17 08 09 
10b1e     81 97 22 20 | 	byte	$09, $00, $91, $09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $20
10b22     08 81 97 22 
10b26     1C 09 00 B1 
10b2a     09 00 87 09 
10b2e     08 22 27 01 | 	byte	$08, $81, $97, $22, $1c, $09, $00, $b1, $09, $00, $87, $09, $08, $22, $27, $01
10b32     08 12 27 00 
10b36     08 02 87 00 
10b3a     00 00 00 08 
10b3e     22 88 DE 0B | 	byte	$08, $12, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $de, $0b
10b42     00 F0 02 88 
10b46     13 0C 00 F0 
10b4a     02 97 00 06 
10b4e     00 00 09 04 | 	byte	$00, $f0, $02, $88, $13, $0c, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $04
10b52     91 09 81 97 
10b56     22 08 00 02 
10b5a     98 86 21 00 
10b5e     F0 00 97 00 | 	byte	$91, $09, $81, $97, $22, $08, $00, $02, $98, $86, $21, $00, $f0, $00, $97, $00
10b62     08 04 57 08 
10b66     09 02 97 00 
10b6a     06 00 00 09 
10b6e     08 91 09 02 | 	byte	$08, $04, $57, $08, $09, $02, $97, $00, $06, $00, $00, $09, $08, $91, $09, $02
10b72     27 00 08 04 
10b76     57 08 09 02 
10b7a     88 45 0C 00 
10b7e     F0 02 97 00 | 	byte	$27, $00, $08, $04, $57, $08, $09, $02, $88, $45, $0c, $00, $f0, $02, $97, $00
10b82     06 00 00 09 
10b86     04 91 09 02 
10b8a     27 00 08 04 
10b8e     57 08 09 02 | 	byte	$06, $00, $00, $09, $04, $91, $09, $02, $27, $00, $08, $04, $57, $08, $09, $02
10b92     97 00 06 00 
10b96     00 09 08 91 
10b9a     09 81 97 22 
10b9e     10 08 02 B5 | 	byte	$97, $00, $06, $00, $00, $09, $08, $91, $09, $81, $97, $22, $10, $08, $02, $b5
10ba2     FA 01 00 00 
10ba6     08 04 57 08 
10baa     09 02 88 45 
10bae     0C 00 F0 02 | 	byte	$fa, $01, $00, $00, $08, $04, $57, $08, $09, $02, $88, $45, $0c, $00, $f0, $02
10bb2     27 06 08 84 
10bb6     97 08 22 28 
10bba     81 97 22 28 
10bbe     08 02 87 00 | 	byte	$27, $06, $08, $84, $97, $08, $22, $28, $81, $97, $22, $28, $08, $02, $87, $00
10bc2     02 00 00 08 
10bc6     32 27 01 08 
10bca     42 27 00 08 
10bce     02 87 00 00 | 	byte	$02, $00, $00, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00
10bd2     00 00 08 12 
10bd6     88 9A 0C 00 
10bda     F0 02 97 00 
10bde     06 00 00 09 | 	byte	$00, $00, $08, $12, $88, $9a, $0c, $00, $f0, $02, $97, $00, $06, $00, $00, $09
10be2     81 97 22 28 
10be6     0A 00 81 0A 
10bea     09 02 27 00 
10bee     08 04 17 08 | 	byte	$81, $97, $22, $28, $0a, $00, $81, $0a, $09, $02, $27, $00, $08, $04, $17, $08
10bf2     09 81 97 22 
10bf6     28 08 00 91 
10bfa     08 84 97 08 
10bfe     22 28 02 88 | 	byte	$09, $81, $97, $22, $28, $08, $00, $91, $08, $84, $97, $08, $22, $28, $02, $88
10c02     4E 0C 00 F0 
10c06     81 97 22 24 
10c0a     00 81 97 22 
10c0e     08 01 02 97 | 	byte	$4e, $0c, $00, $f0, $81, $97, $22, $24, $00, $81, $97, $22, $08, $01, $02, $97
10c12     00 06 00 00 
10c16     02 02 98 29 
10c1a     02 00 F0 81 
10c1e     97 22 20 08 | 	byte	$00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $81, $97, $22, $20, $08
10c22     00 91 08 84 
10c26     97 08 22 20 
10c2a     02 88 38 0B 
10c2e     00 F0 81 97 | 	byte	$00, $91, $08, $84, $97, $08, $22, $20, $02, $88, $38, $0b, $00, $f0, $81, $97
10c32     22 04 00 81 
10c36     97 22 08 01 
10c3a     81 97 22 0C 
10c3e     02 02 98 F9 | 	byte	$22, $04, $00, $81, $97, $22, $08, $01, $81, $97, $22, $0c, $02, $02, $98, $f9
10c42     07 00 F0 00 
10c46     97 00 00 02 
10c4a     88 E3 0C 00 
10c4e     F0 08 91 20 | 	byte	$07, $00, $f0, $00, $97, $00, $00, $02, $88, $e3, $0c, $00, $f0, $08, $91, $20
10c52     00 9A 01 00 
10c56     9A 02 00 9A 
10c5a     03 02 81 18 
10c5e     00 00 00 20 | 	byte	$00, $9a, $01, $00, $9a, $02, $00, $9a, $03, $02, $81, $18, $00, $00, $00, $20
10c62     00 9A 22 00 
10c66     9A 08 00 9A 
10c6a     09 00 9A 0A 
10c6e     00 AA 00 8A | 	byte	$00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $aa, $00, $8a
10c72     02 00 8A 01 
10c76     00 8A 0A 00 
10c7a     8A 09 00 8A 
10c7e     08 00 8A 22 | 	byte	$02, $00, $8a, $01, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22
10c82     02 A1 14 00 
10c86     00 00 20 00 
10c8a     8A 00 00 97 
10c8e     20 22 08 B1 | 	byte	$02, $a1, $14, $00, $00, $00, $20, $00, $8a, $00, $00, $97, $20, $22, $08, $b1
10c92     22 02 27 01 
10c96     00 81 97 22 
10c9a     04 01 02 81 
10c9e     00 00 00 00 | 	byte	$22, $02, $27, $01, $00, $81, $97, $22, $04, $01, $02, $81, $00, $00, $00, $00
10ca2     01 01 27 01 
10ca6     01 02 97 00 
10caa     06 00 00 02 
10cae     02 98 01 02 | 	byte	$01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02
10cb2     00 F0 02 27 
10cb6     01 08 84 97 
10cba     08 22 08 81 
10cbe     97 22 08 08 | 	byte	$00, $f0, $02, $27, $01, $08, $84, $97, $08, $22, $08, $81, $97, $22, $08, $08
10cc2     02 87 20 00 
10cc6     00 00 08 32 
10cca     27 01 08 42 
10cce     27 00 08 02 | 	byte	$02, $87, $20, $00, $00, $00, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02
10cd2     87 00 00 00 
10cd6     00 08 12 88 
10cda     1A 0E 00 F0 
10cde     02 97 00 06 | 	byte	$87, $00, $00, $00, $00, $08, $12, $88, $1a, $0e, $00, $f0, $02, $97, $00, $06
10ce2     00 00 09 81 
10ce6     97 22 08 0A 
10cea     02 94 10 00 
10cee     00 00 0A 00 | 	byte	$00, $00, $09, $81, $97, $22, $08, $0a, $02, $94, $10, $00, $00, $00, $0a, $00
10cf2     81 0A 09 01 
10cf6     67 09 08 81 
10cfa     97 22 04 09 
10cfe     00 91 09 01 | 	byte	$81, $0a, $09, $01, $67, $09, $08, $81, $97, $22, $04, $09, $00, $91, $09, $01
10d02     67 09 09 00 
10d06     87 09 08 12 
10d0a     27 01 08 22 
10d0e     27 00 08 02 | 	byte	$67, $09, $09, $00, $87, $09, $08, $12, $27, $01, $08, $22, $27, $00, $08, $02
10d12     87 00 00 00 
10d16     00 08 22 88 
10d1a     B8 0D 00 F0 
10d1e     02 88 07 0E | 	byte	$87, $00, $00, $00, $00, $08, $22, $88, $b8, $0d, $00, $f0, $02, $88, $07, $0e
10d22     00 F0 02 97 
10d26     00 06 00 00 
10d2a     09 81 97 22 
10d2e     08 0A 02 94 | 	byte	$00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $08, $0a, $02, $94
10d32     10 00 00 00 
10d36     0A 00 81 0A 
10d3a     09 01 67 09 
10d3e     08 84 57 08 | 	byte	$10, $00, $00, $00, $0a, $00, $81, $0a, $09, $01, $67, $09, $08, $84, $57, $08
10d42     22 10 02 97 
10d46     00 06 00 00 
10d4a     09 81 97 22 
10d4e     08 0A 02 94 | 	byte	$22, $10, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $08, $0a, $02, $94
10d52     10 00 00 00 
10d56     0A 00 81 0A 
10d5a     09 04 91 09 
10d5e     01 67 09 08 | 	byte	$10, $00, $00, $00, $0a, $00, $81, $0a, $09, $04, $91, $09, $01, $67, $09, $08
10d62     84 57 08 22 
10d66     18 02 88 1A 
10d6a     0E 00 F0 02 
10d6e     88 07 0E 00 | 	byte	$84, $57, $08, $22, $18, $02, $88, $1a, $0e, $00, $f0, $02, $88, $07, $0e, $00
10d72     F0 81 97 22 
10d76     08 08 00 91 
10d7a     08 84 97 08 
10d7e     22 08 02 88 | 	byte	$f0, $81, $97, $22, $08, $08, $00, $91, $08, $84, $97, $08, $22, $08, $02, $88
10d82     51 0D 00 F0 
10d86     81 97 22 08 
10d8a     08 02 87 20 
10d8e     00 00 00 08 | 	byte	$51, $0d, $00, $f0, $81, $97, $22, $08, $08, $02, $87, $20, $00, $00, $00, $08
10d92     12 27 01 08 
10d96     22 27 00 08 
10d9a     02 87 00 00 
10d9e     00 00 08 22 | 	byte	$12, $27, $01, $08, $22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22
10da2     88 41 0E 00 
10da6     F0 02 88 4D 
10daa     0E 00 F0 02 
10dae     88 D3 0F 00 | 	byte	$88, $41, $0e, $00, $f0, $02, $88, $4d, $0e, $00, $f0, $02, $88, $d3, $0f, $00
10db2     F0 02 88 4D 
10db6     0E 00 F0 02 
10dba     27 00 08 84 
10dbe     97 08 22 0C | 	byte	$f0, $02, $88, $4d, $0e, $00, $f0, $02, $27, $00, $08, $84, $97, $08, $22, $0c
10dc2     81 97 22 0C 
10dc6     08 02 87 10 
10dca     00 00 00 08 
10dce     32 27 01 08 | 	byte	$81, $97, $22, $0c, $08, $02, $87, $10, $00, $00, $00, $08, $32, $27, $01, $08
10dd2     42 27 00 08 
10dd6     02 87 00 00 
10dda     00 00 08 12 
10dde     88 B2 0E 00 | 	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $b2, $0e, $00
10de2     F0 02 97 00 
10de6     06 00 00 09 
10dea     81 97 22 08 
10dee     0A 02 94 10 | 	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $08, $0a, $02, $94, $10
10df2     00 00 00 0A 
10df6     00 81 0A 09 
10dfa     81 97 22 0C 
10dfe     0A 00 81 0A | 	byte	$00, $00, $00, $0a, $00, $81, $0a, $09, $81, $97, $22, $0c, $0a, $00, $81, $0a
10e02     09 02 27 00 
10e06     08 04 17 08 
10e0a     09 81 97 22 
10e0e     0C 08 00 91 | 	byte	$09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $08, $00, $91
10e12     08 84 97 08 
10e16     22 0C 02 88 
10e1a     56 0E 00 F0 
10e1e     02 27 01 00 | 	byte	$08, $84, $97, $08, $22, $0c, $02, $88, $56, $0e, $00, $f0, $02, $27, $01, $00
10e22     81 97 22 04 
10e26     01 02 81 00 
10e2a     00 00 00 01 
10e2e     01 27 01 01 | 	byte	$81, $97, $22, $04, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01
10e32     02 97 00 06 
10e36     00 00 02 02 
10e3a     98 29 02 00 
10e3e     F0 02 27 00 | 	byte	$02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $02, $27, $00
10e42     08 84 97 08 
10e46     22 08 81 97 
10e4a     22 08 08 81 
10e4e     67 22 18 09 | 	byte	$08, $84, $97, $08, $22, $08, $81, $97, $22, $08, $08, $81, $67, $22, $18, $09
10e52     00 87 09 08 
10e56     32 27 01 08 
10e5a     42 27 00 08 
10e5e     02 87 00 00 | 	byte	$00, $87, $09, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00
10e62     00 00 08 12 
10e66     88 D3 0F 00 
10e6a     F0 81 67 22 
10e6e     10 00 81 97 | 	byte	$00, $00, $08, $12, $88, $d3, $0f, $00, $f0, $81, $67, $22, $10, $00, $81, $97
10e72     22 04 01 02 
10e76     81 00 00 00 
10e7a     00 01 01 27 
10e7e     01 01 02 97 | 	byte	$22, $04, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97
10e82     00 06 00 00 
10e86     02 02 98 01 
10e8a     02 00 F0 02 
10e8e     97 00 06 00 | 	byte	$00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00
10e92     00 09 04 91 
10e96     09 01 67 09 
10e9a     08 84 57 08 
10e9e     22 14 81 67 | 	byte	$00, $09, $04, $91, $09, $01, $67, $09, $08, $84, $57, $08, $22, $14, $81, $67
10ea2     22 10 00 02 
10ea6     98 D2 25 00 
10eaa     F0 02 27 00 
10eae     08 84 97 08 | 	byte	$22, $10, $00, $02, $98, $d2, $25, $00, $f0, $02, $27, $00, $08, $84, $97, $08
10eb2     22 0C 81 97 
10eb6     22 0C 08 02 
10eba     87 00 02 00 
10ebe     00 08 32 27 | 	byte	$22, $0c, $81, $97, $22, $0c, $08, $02, $87, $00, $02, $00, $00, $08, $32, $27
10ec2     01 08 42 27 
10ec6     00 08 02 87 
10eca     00 00 00 00 
10ece     08 12 88 94 | 	byte	$01, $08, $42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $94
10ed2     0F 00 F0 02 
10ed6     97 00 06 00 
10eda     00 09 81 97 
10ede     22 0C 0A 00 | 	byte	$0f, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $0c, $0a, $00
10ee2     81 0A 09 02 
10ee6     27 00 08 04 
10eea     17 08 09 81 
10eee     97 22 0C 08 | 	byte	$81, $0a, $09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $08
10ef2     00 91 08 84 
10ef6     97 08 22 0C 
10efa     02 88 48 0F 
10efe     00 F0 81 67 | 	byte	$00, $91, $08, $84, $97, $08, $22, $0c, $02, $88, $48, $0f, $00, $f0, $81, $67
10f02     22 10 00 81 
10f06     97 22 04 01 
10f0a     02 81 00 00 
10f0e     00 00 01 01 | 	byte	$22, $10, $00, $81, $97, $22, $04, $01, $02, $81, $00, $00, $00, $00, $01, $01
10f12     27 01 01 02 
10f16     97 00 06 00 
10f1a     00 02 02 98 
10f1e     29 02 00 F0 | 	byte	$27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0
10f22     81 67 22 14 
10f26     08 84 57 08 
10f2a     22 10 81 97 
10f2e     22 08 08 00 | 	byte	$81, $67, $22, $14, $08, $84, $57, $08, $22, $10, $81, $97, $22, $08, $08, $00
10f32     91 08 84 97 
10f36     08 22 08 02 
10f3a     88 DC 0E 00 
10f3e     F0 02 81 18 | 	byte	$91, $08, $84, $97, $08, $22, $08, $02, $88, $dc, $0e, $00, $f0, $02, $81, $18
10f42     00 00 00 20 
10f46     00 9A 22 00 
10f4a     9A 08 00 9A 
10f4e     09 00 9A 0A | 	byte	$00, $00, $00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a
10f52     00 9A 01 00 
10f56     9A 02 00 AA 
10f5a     00 8A 02 00 
10f5e     8A 0A 00 8A | 	byte	$00, $9a, $01, $00, $9a, $02, $00, $aa, $00, $8a, $02, $00, $8a, $0a, $00, $8a
10f62     09 00 8A 08 
10f66     00 8A 22 0C 
10f6a     B1 20 00 8A 
10f6e     01 00 8A 00 | 	byte	$09, $00, $8a, $08, $00, $8a, $22, $0c, $b1, $20, $00, $8a, $01, $00, $8a, $00
10f72     00 97 20 22 
10f76     08 B1 22 02 
10f7a     27 00 08 84 
10f7e     97 08 22 0C | 	byte	$00, $97, $20, $22, $08, $b1, $22, $02, $27, $00, $08, $84, $97, $08, $22, $0c
10f82     81 97 22 0C 
10f86     08 02 87 00 
10f8a     02 00 00 08 
10f8e     32 27 01 08 | 	byte	$81, $97, $22, $0c, $08, $02, $87, $00, $02, $00, $00, $08, $32, $27, $01, $08
10f92     42 27 00 08 
10f96     02 87 00 00 
10f9a     00 00 08 12 
10f9e     88 62 10 00 | 	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $62, $10, $00
10fa2     F0 02 97 00 
10fa6     06 00 00 09 
10faa     81 97 22 0C 
10fae     0A 00 81 0A | 	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $0c, $0a, $00, $81, $0a
10fb2     09 02 27 00 
10fb6     08 04 17 08 
10fba     09 81 97 22 
10fbe     0C 08 00 91 | 	byte	$09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $08, $00, $91
10fc2     08 84 97 08 
10fc6     22 0C 02 88 
10fca     16 10 00 F0 
10fce     81 97 22 08 | 	byte	$08, $84, $97, $08, $22, $0c, $02, $88, $16, $10, $00, $f0, $81, $97, $22, $08
10fd2     00 02 67 00 
10fd6     10 01 02 98 
10fda     BA 20 00 F0 
10fde     00 97 00 08 | 	byte	$00, $02, $67, $00, $10, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00, $08
10fe2     02 95 0C 08 
10fe6     84 17 08 22 
10fea     10 02 97 00 
10fee     06 00 00 09 | 	byte	$02, $95, $0c, $08, $84, $17, $08, $22, $10, $02, $97, $00, $06, $00, $00, $09
10ff2     81 27 22 10 
10ff6     08 04 17 08 
10ffa     09 02 97 00 
10ffe     06 00 00 09 | 	byte	$81, $27, $22, $10, $08, $04, $17, $08, $09, $02, $97, $00, $06, $00, $00, $09
11002     00 91 09 02 
11006     27 01 08 04 
1100a     17 08 09 02 
1100e     97 00 06 00 | 	byte	$00, $91, $09, $02, $27, $01, $08, $04, $17, $08, $09, $02, $97, $00, $06, $00
11012     00 09 04 91 
11016     09 02 27 52 
1101a     08 04 17 08 
1101e     09 02 97 00 | 	byte	$00, $09, $04, $91, $09, $02, $27, $52, $08, $04, $17, $08, $09, $02, $97, $00
11022     06 00 00 09 
11026     02 81 03 00 
1102a     00 00 09 02 
1102e     27 59 08 04 | 	byte	$06, $00, $00, $09, $02, $81, $03, $00, $00, $00, $09, $02, $27, $59, $08, $04
11032     17 08 09 02 
11036     97 00 06 00 
1103a     00 09 08 91 
1103e     09 81 97 22 | 	byte	$17, $08, $09, $02, $97, $00, $06, $00, $00, $09, $08, $91, $09, $81, $97, $22
11042     08 08 04 57 
11046     08 09 02 97 
1104a     EE 26 00 F0 
1104e     00 02 97 00 | 	byte	$08, $08, $04, $57, $08, $09, $02, $97, $ee, $26, $00, $f0, $00, $02, $97, $00
11052     06 00 00 01 
11056     02 81 06 00 
1105a     00 00 01 02 
1105e     98 2E 07 00 | 	byte	$06, $00, $00, $01, $02, $81, $06, $00, $00, $00, $01, $02, $98, $2e, $07, $00
11062     F0 02 27 01 
11066     00 81 97 22 
1106a     04 01 02 97 
1106e     00 06 00 00 | 	byte	$f0, $02, $27, $01, $00, $81, $97, $22, $04, $01, $02, $97, $00, $06, $00, $00
11072     02 02 98 29 
11076     02 00 F0 02 
1107a     27 00 08 84 
1107e     97 08 22 0C | 	byte	$02, $02, $98, $29, $02, $00, $f0, $02, $27, $00, $08, $84, $97, $08, $22, $0c
11082     81 97 22 0C 
11086     08 02 87 00 
1108a     02 00 00 08 
1108e     32 27 01 08 | 	byte	$81, $97, $22, $0c, $08, $02, $87, $00, $02, $00, $00, $08, $32, $27, $01, $08
11092     42 27 00 08 
11096     02 87 00 00 
1109a     00 00 08 12 
1109e     88 62 11 00 | 	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $62, $11, $00
110a2     F0 02 97 00 
110a6     06 00 00 09 
110aa     81 97 22 0C 
110ae     0A 00 81 0A | 	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $0c, $0a, $00, $81, $0a
110b2     09 02 27 00 
110b6     08 04 17 08 
110ba     09 81 97 22 
110be     0C 08 00 91 | 	byte	$09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $08, $00, $91
110c2     08 84 97 08 
110c6     22 0C 02 88 
110ca     16 11 00 F0 
110ce     02 27 00 08 | 	byte	$08, $84, $97, $08, $22, $0c, $02, $88, $16, $11, $00, $f0, $02, $27, $00, $08
110d2     84 97 08 22 
110d6     0C 81 97 22 
110da     0C 08 81 27 
110de     22 10 09 00 | 	byte	$84, $97, $08, $22, $0c, $81, $97, $22, $0c, $08, $81, $27, $22, $10, $09, $00
110e2     87 09 08 32 
110e6     27 01 08 42 
110ea     27 00 08 02 
110ee     87 00 00 00 | 	byte	$87, $09, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00, $00
110f2     00 08 12 88 
110f6     BB 11 00 F0 
110fa     81 97 22 0C 
110fe     00 04 91 00 | 	byte	$00, $08, $12, $88, $bb, $11, $00, $f0, $81, $97, $22, $0c, $00, $04, $91, $00
11102     81 97 22 04 
11106     01 02 97 00 
1110a     06 00 00 02 
1110e     02 98 29 02 | 	byte	$81, $97, $22, $04, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02
11112     00 F0 81 97 
11116     22 0C 08 00 
1111a     91 08 84 97 
1111e     08 22 0C 02 | 	byte	$00, $f0, $81, $97, $22, $0c, $08, $00, $91, $08, $84, $97, $08, $22, $0c, $02
11122     88 6B 11 00 
11126     F0 02 27 00 
1112a     00 81 97 22 
1112e     04 01 02 98 | 	byte	$88, $6b, $11, $00, $f0, $02, $27, $00, $00, $81, $97, $22, $04, $01, $02, $98
11132     B9 24 00 F0 
11136     02 27 01 00 
1113a     81 97 22 04 
1113e     01 02 98 B9 | 	byte	$b9, $24, $00, $f0, $02, $27, $01, $00, $81, $97, $22, $04, $01, $02, $98, $b9
11142     24 00 F0 02 
11146     27 00 08 84 
1114a     97 08 22 0C 
1114e     81 97 22 0C | 	byte	$24, $00, $f0, $02, $27, $00, $08, $84, $97, $08, $22, $0c, $81, $97, $22, $0c
11152     08 81 27 22 
11156     10 09 00 87 
1115a     09 08 32 27 
1115e     01 08 42 27 | 	byte	$08, $81, $27, $22, $10, $09, $00, $87, $09, $08, $32, $27, $01, $08, $42, $27
11162     00 08 02 87 
11166     00 00 00 00 
1116a     08 12 88 2B 
1116e     12 00 F0 81 | 	byte	$00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $2b, $12, $00, $f0, $81
11172     97 22 0C 00 
11176     04 91 00 81 
1117a     97 22 04 01 
1117e     02 98 B9 24 | 	byte	$97, $22, $0c, $00, $04, $91, $00, $81, $97, $22, $04, $01, $02, $98, $b9, $24
11182     00 F0 81 97 
11186     22 0C 08 00 
1118a     91 08 84 97 
1118e     08 22 0C 02 | 	byte	$00, $f0, $81, $97, $22, $0c, $08, $00, $91, $08, $84, $97, $08, $22, $0c, $02
11192     88 E2 11 00 
11196     F0 08 91 20 
1119a     00 9A 01 0C 
1119e     91 20 00 9A | 	byte	$88, $e2, $11, $00, $f0, $08, $91, $20, $00, $9a, $01, $0c, $91, $20, $00, $9a
111a2     22 00 9A 08 
111a6     00 9A 09 00 
111aa     9A 0A 00 9A 
111ae     02 00 AA 00 | 	byte	$22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $02, $00, $aa, $00
111b2     8A 09 00 8A 
111b6     08 00 8A 22 
111ba     00 8A 01 00 
111be     8A 00 00 97 | 	byte	$8a, $09, $00, $8a, $08, $00, $8a, $22, $00, $8a, $01, $00, $8a, $00, $00, $97
111c2     20 22 08 B1 
111c6     22 81 97 22 
111ca     04 08 81 97 
111ce     22 08 09 02 | 	byte	$20, $22, $08, $b1, $22, $81, $97, $22, $04, $08, $81, $97, $22, $08, $09, $02
111d2     81 03 00 00 
111d6     00 09 04 97 
111da     08 09 08 91 
111de     20 00 9A 01 | 	byte	$81, $03, $00, $00, $00, $09, $04, $97, $08, $09, $08, $91, $20, $00, $9a, $01
111e2     00 9A 22 00 
111e6     9A 08 00 9A 
111ea     09 00 AA 00 
111ee     8A 22 00 8A | 	byte	$00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $aa, $00, $8a, $22, $00, $8a
111f2     00 00 97 20 
111f6     22 08 B1 22 
111fa     81 97 22 04 
111fe     00 02 81 03 | 	byte	$00, $00, $97, $20, $22, $08, $b1, $22, $81, $97, $22, $04, $00, $02, $81, $03
11202     00 00 00 00 
11206     01 97 00 00 
1120a     02 88 A4 12 
1120e     00 F0 08 91 | 	byte	$00, $00, $00, $00, $01, $97, $00, $00, $02, $88, $a4, $12, $00, $f0, $08, $91
11212     20 00 9A 22 
11216     00 AA 00 8A 
1121a     09 00 8A 08 
1121e     00 8A 22 02 | 	byte	$20, $00, $9a, $22, $00, $aa, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $02
11222     A1 1C 00 00 
11226     00 20 00 8A 
1122a     02 00 8A 01 
1122e     00 8A 00 00 | 	byte	$a1, $1c, $00, $00, $00, $20, $00, $8a, $02, $00, $8a, $01, $00, $8a, $00, $00
11232     97 20 22 08 
11236     B1 22 81 97 
1123a     22 04 08 84 
1123e     97 08 22 10 | 	byte	$97, $20, $22, $08, $b1, $22, $81, $97, $22, $04, $08, $84, $97, $08, $22, $10
11242     81 97 22 08 
11246     08 02 81 03 
1124a     00 00 00 08 
1124e     01 97 08 08 | 	byte	$81, $97, $22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08, $08
11252     02 B5 FA 01 
11256     00 00 08 81 
1125a     97 22 04 09 
1125e     00 81 09 08 | 	byte	$02, $b5, $fa, $01, $00, $00, $08, $81, $97, $22, $04, $09, $00, $81, $09, $08
11262     02 81 F9 01 
11266     00 00 08 02 
1126a     A2 FA 01 00 
1126e     00 08 84 97 | 	byte	$02, $81, $f9, $01, $00, $00, $08, $02, $a2, $fa, $01, $00, $00, $08, $84, $97
11272     08 22 14 81 
11276     97 22 08 00 
1127a     02 81 03 00 
1127e     00 00 00 01 | 	byte	$08, $22, $14, $81, $97, $22, $08, $00, $02, $81, $03, $00, $00, $00, $00, $01
11282     97 00 00 02 
11286     67 FA 01 01 
1128a     02 98 BA 20 
1128e     00 F0 00 97 | 	byte	$97, $00, $00, $02, $67, $fa, $01, $01, $02, $98, $ba, $20, $00, $f0, $00, $97
11292     00 08 02 B4 
11296     FA 01 00 00 
1129a     08 84 97 08 
1129e     22 18 81 97 | 	byte	$00, $08, $02, $b4, $fa, $01, $00, $00, $08, $84, $97, $08, $22, $18, $81, $97
112a2     22 08 08 02 
112a6     81 03 00 00 
112aa     00 08 01 97 
112ae     08 08 02 87 | 	byte	$22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08, $08, $02, $87
112b2     00 00 00 00 
112b6     08 52 27 01 
112ba     08 62 27 00 
112be     08 81 97 22 | 	byte	$00, $00, $00, $00, $08, $52, $27, $01, $08, $62, $27, $00, $08, $81, $97, $22
112c2     08 09 02 81 
112c6     03 00 00 00 
112ca     09 01 97 09 
112ce     09 02 B5 FA | 	byte	$08, $09, $02, $81, $03, $00, $00, $00, $09, $01, $97, $09, $09, $02, $b5, $fa
112d2     01 00 00 09 
112d6     02 87 00 00 
112da     00 00 09 12 
112de     27 01 09 22 | 	byte	$01, $00, $00, $09, $02, $87, $00, $00, $00, $00, $09, $12, $27, $01, $09, $22
112e2     27 00 09 00 
112e6     83 09 08 02 
112ea     87 00 00 00 
112ee     00 08 22 88 | 	byte	$27, $00, $09, $00, $83, $09, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88
112f2     90 13 00 F0 
112f6     02 88 A3 13 
112fa     00 F0 81 97 
112fe     22 18 08 00 | 	byte	$90, $13, $00, $f0, $02, $88, $a3, $13, $00, $f0, $81, $97, $22, $18, $08, $00
11302     91 08 84 97 
11306     08 22 18 02 
1130a     88 A3 13 00 
1130e     F0 81 97 22 | 	byte	$91, $08, $84, $97, $08, $22, $18, $02, $88, $a3, $13, $00, $f0, $81, $97, $22
11312     08 08 00 91 
11316     08 01 67 08 
1131a     08 84 57 08 
1131e     22 20 81 97 | 	byte	$08, $08, $00, $91, $08, $01, $67, $08, $08, $84, $57, $08, $22, $20, $81, $97
11322     22 18 08 02 
11326     87 00 00 00 
1132a     00 08 12 27 
1132e     01 08 22 27 | 	byte	$22, $18, $08, $02, $87, $00, $00, $00, $00, $08, $12, $27, $01, $08, $22, $27
11332     00 08 02 87 
11336     00 00 00 00 
1133a     08 22 88 DB 
1133e     13 00 F0 02 | 	byte	$00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $db, $13, $00, $f0, $02
11342     88 EB 13 00 
11346     F0 81 67 22 
1134a     20 08 84 57 
1134e     08 22 1C 02 | 	byte	$88, $eb, $13, $00, $f0, $81, $67, $22, $20, $08, $84, $57, $08, $22, $1c, $02
11352     88 55 14 00 
11356     F0 81 97 22 
1135a     18 08 02 87 
1135e     00 00 00 00 | 	byte	$88, $55, $14, $00, $f0, $81, $97, $22, $18, $08, $02, $87, $00, $00, $00, $00
11362     08 12 88 4F 
11366     14 00 F0 81 
1136a     67 22 20 00 
1136e     81 97 22 08 | 	byte	$08, $12, $88, $4f, $14, $00, $f0, $81, $67, $22, $20, $00, $81, $97, $22, $08
11372     01 02 81 00 
11376     00 00 00 01 
1137a     01 27 01 01 
1137e     02 97 00 06 | 	byte	$01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06
11382     00 00 02 02 
11386     98 01 02 00 
1138a     F0 81 67 22 
1138e     20 08 84 57 | 	byte	$00, $00, $02, $02, $98, $01, $02, $00, $f0, $81, $67, $22, $20, $08, $84, $57
11392     08 22 1C 02 
11396     97 00 06 00 
1139a     00 09 04 91 
1139e     09 01 67 09 | 	byte	$08, $22, $1c, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $01, $67, $09
113a2     08 84 57 08 
113a6     22 20 81 97 
113aa     22 18 08 00 
113ae     B1 08 84 97 | 	byte	$08, $84, $57, $08, $22, $20, $81, $97, $22, $18, $08, $00, $b1, $08, $84, $97
113b2     08 22 18 02 
113b6     88 EB 13 00 
113ba     F0 02 88 55 
113be     14 00 F0 81 | 	byte	$08, $22, $18, $02, $88, $eb, $13, $00, $f0, $02, $88, $55, $14, $00, $f0, $81
113c2     67 22 1C 08 
113c6     84 57 08 22 
113ca     20 81 97 22 
113ce     08 08 02 81 | 	byte	$67, $22, $1c, $08, $84, $57, $08, $22, $20, $81, $97, $22, $08, $08, $02, $81
113d2     03 00 00 00 
113d6     08 01 97 08 
113da     08 02 B5 FA 
113de     01 00 00 08 | 	byte	$03, $00, $00, $00, $08, $01, $97, $08, $08, $02, $b5, $fa, $01, $00, $00, $08
113e2     84 97 08 22 
113e6     28 81 97 22 
113ea     14 08 02 87 
113ee     00 00 00 00 | 	byte	$84, $97, $08, $22, $28, $81, $97, $22, $14, $08, $02, $87, $00, $00, $00, $00
113f2     08 12 88 77 
113f6     15 00 F0 81 
113fa     67 22 20 00 
113fe     81 97 22 08 | 	byte	$08, $12, $88, $77, $15, $00, $f0, $81, $67, $22, $20, $00, $81, $97, $22, $08
11402     01 02 81 00 
11406     00 00 00 01 
1140a     01 27 01 01 
1140e     02 97 00 06 | 	byte	$01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06
11412     00 00 02 02 
11416     98 01 02 00 
1141a     F0 02 67 FA 
1141e     01 08 81 97 | 	byte	$00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $67, $fa, $01, $08, $81, $97
11422     22 28 09 00 
11426     A1 09 08 84 
1142a     97 08 22 24 
1142e     81 97 22 24 | 	byte	$22, $28, $09, $00, $a1, $09, $08, $84, $97, $08, $22, $24, $81, $97, $22, $24
11432     08 81 97 22 
11436     04 09 00 87 
1143a     09 08 42 27 
1143e     01 08 32 27 | 	byte	$08, $81, $97, $22, $04, $09, $00, $87, $09, $08, $42, $27, $01, $08, $32, $27
11442     00 08 02 87 
11446     00 00 00 00 
1144a     08 22 88 EB 
1144e     14 00 F0 02 | 	byte	$00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $eb, $14, $00, $f0, $02
11452     88 FB 14 00 
11456     F0 81 97 22 
1145a     04 08 84 97 
1145e     08 22 24 02 | 	byte	$88, $fb, $14, $00, $f0, $81, $97, $22, $04, $08, $84, $97, $08, $22, $24, $02
11462     88 FB 14 00 
11466     F0 02 97 00 
1146a     06 00 00 00 
1146e     02 81 06 00 | 	byte	$88, $fb, $14, $00, $f0, $02, $97, $00, $06, $00, $00, $00, $02, $81, $06, $00
11472     00 00 00 81 
11476     97 22 28 08 
1147a     00 81 08 00 
1147e     81 97 22 0C | 	byte	$00, $00, $00, $81, $97, $22, $28, $08, $00, $81, $08, $00, $81, $97, $22, $0c
11482     01 81 97 22 
11486     24 02 02 98 
1148a     1E 06 00 F0 
1148e     02 97 00 06 | 	byte	$01, $81, $97, $22, $24, $02, $02, $98, $1e, $06, $00, $f0, $02, $97, $00, $06
11492     00 00 09 04 
11496     91 09 01 67 
1149a     09 08 84 57 
1149e     08 22 20 81 | 	byte	$00, $00, $09, $04, $91, $09, $01, $67, $09, $08, $84, $57, $08, $22, $20, $81
114a2     97 22 0C 08 
114a6     81 97 22 24 
114aa     09 00 81 09 
114ae     08 84 97 08 | 	byte	$97, $22, $0c, $08, $81, $97, $22, $24, $09, $00, $81, $09, $08, $84, $97, $08
114b2     22 0C 81 97 
114b6     22 04 08 81 
114ba     97 22 24 09 
114be     00 A1 09 08 | 	byte	$22, $0c, $81, $97, $22, $04, $08, $81, $97, $22, $24, $09, $00, $a1, $09, $08
114c2     84 97 08 22 
114c6     04 81 97 22 
114ca     14 08 00 B1 
114ce     08 84 97 08 | 	byte	$84, $97, $08, $22, $04, $81, $97, $22, $14, $08, $00, $b1, $08, $84, $97, $08
114d2     22 14 02 27 
114d6     00 08 84 97 
114da     08 22 28 02 
114de     88 7B 14 00 | 	byte	$22, $14, $02, $27, $00, $08, $84, $97, $08, $22, $28, $02, $88, $7b, $14, $00
114e2     F0 81 97 22 
114e6     08 08 02 81 
114ea     03 00 00 00 
114ee     08 01 97 08 | 	byte	$f0, $81, $97, $22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08
114f2     08 81 97 22 
114f6     10 09 00 81 
114fa     09 08 81 97 
114fe     22 08 09 02 | 	byte	$08, $81, $97, $22, $10, $09, $00, $81, $09, $08, $81, $97, $22, $08, $09, $02
11502     81 03 00 00 
11506     00 09 04 97 
1150a     08 09 08 91 
1150e     20 00 9A 01 | 	byte	$81, $03, $00, $00, $00, $09, $04, $97, $08, $09, $08, $91, $20, $00, $9a, $01
11512     00 9A 02 02 
11516     81 1C 00 00 
1151a     00 20 00 9A 
1151e     22 00 9A 08 | 	byte	$00, $9a, $02, $02, $81, $1c, $00, $00, $00, $20, $00, $9a, $22, $00, $9a, $08
11522     00 9A 09 00 
11526     AA 00 8A 09 
1152a     00 8A 08 00 
1152e     8A 22 02 A1 | 	byte	$00, $9a, $09, $00, $aa, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $02, $a1
11532     1C 00 00 00 
11536     20 00 8A 02 
1153a     00 8A 01 00 
1153e     8A 00 00 97 | 	byte	$1c, $00, $00, $00, $20, $00, $8a, $02, $00, $8a, $01, $00, $8a, $00, $00, $97
11542     20 22 08 B1 
11546     22 81 97 22 
1154a     08 08 02 81 
1154e     03 00 00 00 | 	byte	$20, $22, $08, $b1, $22, $81, $97, $22, $08, $08, $02, $81, $03, $00, $00, $00
11552     08 01 97 08 
11556     08 02 B5 FA 
1155a     01 00 00 08 
1155e     81 97 22 04 | 	byte	$08, $01, $97, $08, $08, $02, $b5, $fa, $01, $00, $00, $08, $81, $97, $22, $04
11562     09 00 81 09 
11566     08 02 81 F9 
1156a     01 00 00 08 
1156e     02 A2 FA 01 | 	byte	$09, $00, $81, $09, $08, $02, $81, $f9, $01, $00, $00, $08, $02, $a2, $fa, $01
11572     00 00 08 84 
11576     97 08 22 10 
1157a     81 97 22 08 
1157e     00 02 81 03 | 	byte	$00, $00, $08, $84, $97, $08, $22, $10, $81, $97, $22, $08, $00, $02, $81, $03
11582     00 00 00 00 
11586     01 97 00 00 
1158a     02 67 FA 01 
1158e     01 02 98 BA | 	byte	$00, $00, $00, $00, $01, $97, $00, $00, $02, $67, $fa, $01, $01, $02, $98, $ba
11592     20 00 F0 00 
11596     97 00 08 02 
1159a     B4 FA 01 00 
1159e     00 08 84 97 | 	byte	$20, $00, $f0, $00, $97, $00, $08, $02, $b4, $fa, $01, $00, $00, $08, $84, $97
115a2     08 22 14 81 
115a6     97 22 08 08 
115aa     02 81 03 00 
115ae     00 00 08 01 | 	byte	$08, $22, $14, $81, $97, $22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01
115b2     97 08 08 02 
115b6     87 00 00 00 
115ba     00 08 52 27 
115be     01 08 62 27 | 	byte	$97, $08, $08, $02, $87, $00, $00, $00, $00, $08, $52, $27, $01, $08, $62, $27
115c2     00 08 81 97 
115c6     22 08 09 02 
115ca     81 03 00 00 
115ce     00 09 01 97 | 	byte	$00, $08, $81, $97, $22, $08, $09, $02, $81, $03, $00, $00, $00, $09, $01, $97
115d2     09 09 02 B5 
115d6     FA 01 00 00 
115da     09 02 87 00 
115de     00 00 00 09 | 	byte	$09, $09, $02, $b5, $fa, $01, $00, $00, $09, $02, $87, $00, $00, $00, $00, $09
115e2     12 27 01 09 
115e6     22 27 00 09 
115ea     00 83 09 08 
115ee     02 87 00 00 | 	byte	$12, $27, $01, $09, $22, $27, $00, $09, $00, $83, $09, $08, $02, $87, $00, $00
115f2     00 00 08 22 
115f6     88 95 16 00 
115fa     F0 02 88 A8 
115fe     16 00 F0 81 | 	byte	$00, $00, $08, $22, $88, $95, $16, $00, $f0, $02, $88, $a8, $16, $00, $f0, $81
11602     97 22 14 08 
11606     00 91 08 84 
1160a     97 08 22 14 
1160e     02 88 A8 16 | 	byte	$97, $22, $14, $08, $00, $91, $08, $84, $97, $08, $22, $14, $02, $88, $a8, $16
11612     00 F0 81 97 
11616     22 08 08 00 
1161a     91 08 01 67 
1161e     08 08 84 57 | 	byte	$00, $f0, $81, $97, $22, $08, $08, $00, $91, $08, $01, $67, $08, $08, $84, $57
11622     08 22 1C 81 
11626     97 22 14 08 
1162a     02 87 00 00 
1162e     00 00 08 12 | 	byte	$08, $22, $1c, $81, $97, $22, $14, $08, $02, $87, $00, $00, $00, $00, $08, $12
11632     27 01 08 22 
11636     27 00 08 02 
1163a     87 00 00 00 
1163e     00 08 22 88 | 	byte	$27, $01, $08, $22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88
11642     E0 16 00 F0 
11646     02 88 F0 16 
1164a     00 F0 81 67 
1164e     22 1C 08 84 | 	byte	$e0, $16, $00, $f0, $02, $88, $f0, $16, $00, $f0, $81, $67, $22, $1c, $08, $84
11652     57 08 22 18 
11656     02 88 5A 17 
1165a     00 F0 81 97 
1165e     22 14 08 02 | 	byte	$57, $08, $22, $18, $02, $88, $5a, $17, $00, $f0, $81, $97, $22, $14, $08, $02
11662     87 00 00 00 
11666     00 08 12 88 
1166a     54 17 00 F0 
1166e     81 67 22 1C | 	byte	$87, $00, $00, $00, $00, $08, $12, $88, $54, $17, $00, $f0, $81, $67, $22, $1c
11672     00 81 97 22 
11676     08 01 02 81 
1167a     00 00 00 00 
1167e     01 01 27 01 | 	byte	$00, $81, $97, $22, $08, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01
11682     01 02 97 00 
11686     06 00 00 02 
1168a     02 98 01 02 
1168e     00 F0 81 67 | 	byte	$01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $81, $67
11692     22 1C 08 84 
11696     57 08 22 18 
1169a     02 97 00 06 
1169e     00 00 09 04 | 	byte	$22, $1c, $08, $84, $57, $08, $22, $18, $02, $97, $00, $06, $00, $00, $09, $04
116a2     91 09 01 67 
116a6     09 08 84 57 
116aa     08 22 1C 81 
116ae     97 22 14 08 | 	byte	$91, $09, $01, $67, $09, $08, $84, $57, $08, $22, $1c, $81, $97, $22, $14, $08
116b2     00 B1 08 84 
116b6     97 08 22 14 
116ba     02 88 F0 16 
116be     00 F0 02 88 | 	byte	$00, $b1, $08, $84, $97, $08, $22, $14, $02, $88, $f0, $16, $00, $f0, $02, $88
116c2     5A 17 00 F0 
116c6     81 67 22 18 
116ca     08 84 57 08 
116ce     22 1C 81 97 | 	byte	$5a, $17, $00, $f0, $81, $67, $22, $18, $08, $84, $57, $08, $22, $1c, $81, $97
116d2     22 08 08 02 
116d6     81 03 00 00 
116da     00 08 01 97 
116de     08 08 02 B5 | 	byte	$22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08, $08, $02, $b5
116e2     FA 01 00 00 
116e6     08 84 97 08 
116ea     22 28 81 97 
116ee     22 10 08 02 | 	byte	$fa, $01, $00, $00, $08, $84, $97, $08, $22, $28, $81, $97, $22, $10, $08, $02
116f2     87 00 00 00 
116f6     00 08 12 88 
116fa     54 19 00 F0 
116fe     02 67 FA 01 | 	byte	$87, $00, $00, $00, $00, $08, $12, $88, $54, $19, $00, $f0, $02, $67, $fa, $01
11702     08 81 97 22 
11706     28 09 00 A1 
1170a     09 08 84 97 
1170e     08 22 20 81 | 	byte	$08, $81, $97, $22, $28, $09, $00, $a1, $09, $08, $84, $97, $08, $22, $20, $81
11712     97 22 20 08 
11716     81 97 22 04 
1171a     09 00 87 09 
1171e     08 42 27 01 | 	byte	$97, $22, $20, $08, $81, $97, $22, $04, $09, $00, $87, $09, $08, $42, $27, $01
11722     08 32 27 00 
11726     08 02 87 00 
1172a     00 00 00 08 
1172e     22 88 CE 17 | 	byte	$08, $32, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $ce, $17
11732     00 F0 02 88 
11736     DE 17 00 F0 
1173a     81 97 22 04 
1173e     08 84 97 08 | 	byte	$00, $f0, $02, $88, $de, $17, $00, $f0, $81, $97, $22, $04, $08, $84, $97, $08
11742     22 20 02 88 
11746     DE 17 00 F0 
1174a     81 97 22 08 
1174e     00 02 98 AF | 	byte	$22, $20, $02, $88, $de, $17, $00, $f0, $81, $97, $22, $08, $00, $02, $98, $af
11752     19 00 F0 00 
11756     97 00 08 84 
1175a     97 08 22 24 
1175e     81 97 22 08 | 	byte	$19, $00, $f0, $00, $97, $00, $08, $84, $97, $08, $22, $24, $81, $97, $22, $08
11762     08 02 81 03 
11766     00 00 00 08 
1176a     01 97 08 08 
1176e     81 97 22 20 | 	byte	$08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08, $08, $81, $97, $22, $20
11772     09 00 81 09 
11776     08 81 97 22 
1177a     24 09 00 87 
1177e     09 08 52 27 | 	byte	$09, $00, $81, $09, $08, $81, $97, $22, $24, $09, $00, $87, $09, $08, $52, $27
11782     01 08 62 27 
11786     00 08 02 87 
1178a     00 00 00 00 
1178e     08 22 88 2F | 	byte	$01, $08, $62, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $2f
11792     18 00 F0 02 
11796     88 6B 18 00 
1179a     F0 81 97 22 
1179e     08 00 02 81 | 	byte	$18, $00, $f0, $02, $88, $6b, $18, $00, $f0, $81, $97, $22, $08, $00, $02, $81
117a2     03 00 00 00 
117a6     00 01 97 00 
117aa     00 81 97 22 
117ae     24 09 00 A1 | 	byte	$03, $00, $00, $00, $00, $01, $97, $00, $00, $81, $97, $22, $24, $09, $00, $a1
117b2     09 00 81 97 
117b6     22 20 09 00 
117ba     81 09 00 81 
117be     97 22 08 01 | 	byte	$09, $00, $81, $97, $22, $20, $09, $00, $81, $09, $00, $81, $97, $22, $08, $01
117c2     02 98 E9 1B 
117c6     00 F0 00 97 
117ca     00 08 84 57 
117ce     08 22 1C 02 | 	byte	$02, $98, $e9, $1b, $00, $f0, $00, $97, $00, $08, $84, $57, $08, $22, $1c, $02
117d2     88 6B 18 00 
117d6     F0 81 67 22 
117da     1C 00 81 97 
117de     22 08 01 02 | 	byte	$88, $6b, $18, $00, $f0, $81, $67, $22, $1c, $00, $81, $97, $22, $08, $01, $02
117e2     81 00 00 00 
117e6     00 01 01 27 
117ea     01 01 02 97 
117ee     00 06 00 00 | 	byte	$81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00
117f2     02 02 98 01 
117f6     02 00 F0 81 
117fa     97 22 0C 00 
117fe     02 97 00 06 | 	byte	$02, $02, $98, $01, $02, $00, $f0, $81, $97, $22, $0c, $00, $02, $97, $00, $06
11802     00 00 01 02 
11806     81 06 00 00 
1180a     00 01 81 97 
1180e     22 28 08 00 | 	byte	$00, $00, $01, $02, $81, $06, $00, $00, $00, $01, $81, $97, $22, $28, $08, $00
11812     81 08 01 81 
11816     97 22 20 02 
1181a     02 98 1E 06 
1181e     00 F0 81 67 | 	byte	$81, $08, $01, $81, $97, $22, $20, $02, $02, $98, $1e, $06, $00, $f0, $81, $67
11822     22 1C 00 81 
11826     97 22 08 01 
1182a     02 81 00 00 
1182e     00 00 01 01 | 	byte	$22, $1c, $00, $81, $97, $22, $08, $01, $02, $81, $00, $00, $00, $00, $01, $01
11832     27 01 01 02 
11836     97 00 06 00 
1183a     00 02 02 98 
1183e     29 02 00 F0 | 	byte	$27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0
11842     02 97 00 06 
11846     00 00 09 04 
1184a     91 09 01 67 
1184e     09 08 84 57 | 	byte	$02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $01, $67, $09, $08, $84, $57
11852     08 22 1C 81 
11856     97 22 0C 08 
1185a     81 97 22 20 
1185e     09 00 81 09 | 	byte	$08, $22, $1c, $81, $97, $22, $0c, $08, $81, $97, $22, $20, $09, $00, $81, $09
11862     08 84 97 08 
11866     22 0C 81 97 
1186a     22 04 08 81 
1186e     97 22 20 09 | 	byte	$08, $84, $97, $08, $22, $0c, $81, $97, $22, $04, $08, $81, $97, $22, $20, $09
11872     00 A1 09 08 
11876     84 97 08 22 
1187a     04 81 97 22 
1187e     10 08 00 B1 | 	byte	$00, $a1, $09, $08, $84, $97, $08, $22, $04, $81, $97, $22, $10, $08, $00, $b1
11882     08 84 97 08 
11886     22 10 81 97 
1188a     22 08 08 02 
1188e     81 03 00 00 | 	byte	$08, $84, $97, $08, $22, $10, $81, $97, $22, $08, $08, $02, $81, $03, $00, $00
11892     00 08 01 97 
11896     08 08 81 97 
1189a     22 20 09 00 
1189e     81 09 08 81 | 	byte	$00, $08, $01, $97, $08, $08, $81, $97, $22, $20, $09, $00, $81, $09, $08, $81
118a2     97 22 08 09 
118a6     02 81 03 00 
118aa     00 00 09 04 
118ae     97 08 09 02 | 	byte	$97, $22, $08, $09, $02, $81, $03, $00, $00, $00, $09, $04, $97, $08, $09, $02
118b2     27 00 08 84 
118b6     97 08 22 28 
118ba     02 88 80 17 
118be     00 F0 08 91 | 	byte	$27, $00, $08, $84, $97, $08, $22, $28, $02, $88, $80, $17, $00, $f0, $08, $91
118c2     20 00 9A 01 
118c6     00 9A 02 02 
118ca     81 1C 00 00 
118ce     00 20 00 9A | 	byte	$20, $00, $9a, $01, $00, $9a, $02, $02, $81, $1c, $00, $00, $00, $20, $00, $9a
118d2     22 00 9A 08 
118d6     00 9A 09 00 
118da     AA 00 8A 02 
118de     00 8A 22 00 | 	byte	$22, $00, $9a, $08, $00, $9a, $09, $00, $aa, $00, $8a, $02, $00, $8a, $22, $00
118e2     8A 01 00 8A 
118e6     00 00 97 20 
118ea     22 08 B1 22 
118ee     81 97 22 04 | 	byte	$8a, $01, $00, $8a, $00, $00, $97, $20, $22, $08, $b1, $22, $81, $97, $22, $04
118f2     00 02 98 AF 
118f6     19 00 F0 00 
118fa     97 00 00 81 
118fe     97 22 04 01 | 	byte	$00, $02, $98, $af, $19, $00, $f0, $00, $97, $00, $00, $81, $97, $22, $04, $01
11902     81 97 22 08 
11906     02 02 98 AC 
1190a     12 00 F0 08 
1190e     91 20 00 9A | 	byte	$81, $97, $22, $08, $02, $02, $98, $ac, $12, $00, $f0, $08, $91, $20, $00, $9a
11912     01 00 9A 22 
11916     00 9A 02 00 
1191a     AA 00 8A 02 
1191e     00 8A 01 00 | 	byte	$01, $00, $9a, $22, $00, $9a, $02, $00, $aa, $00, $8a, $02, $00, $8a, $01, $00
11922     8A 0A 00 8A 
11926     09 00 8A 08 
1192a     00 8A 22 0C 
1192e     B1 20 00 8A | 	byte	$8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $0c, $b1, $20, $00, $8a
11932     00 00 97 20 
11936     22 08 B1 22 
1193a     02 27 00 08 
1193e     84 97 08 22 | 	byte	$00, $00, $97, $20, $22, $08, $b1, $22, $02, $27, $00, $08, $84, $97, $08, $22
11942     08 81 97 22 
11946     04 08 00 91 
1194a     08 01 67 08 
1194e     08 84 57 08 | 	byte	$08, $81, $97, $22, $04, $08, $00, $91, $08, $01, $67, $08, $08, $84, $57, $08
11952     22 0C 02 27 
11956     01 08 02 87 
1195a     00 00 00 00 
1195e     08 12 88 90 | 	byte	$22, $0c, $02, $27, $01, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $90
11962     1A 00 F0 81 
11966     67 22 0C 00 
1196a     81 97 22 04 
1196e     01 02 81 00 | 	byte	$1a, $00, $f0, $81, $67, $22, $0c, $00, $81, $97, $22, $04, $01, $02, $81, $00
11972     00 00 00 01 
11976     01 27 01 01 
1197a     02 97 00 06 
1197e     00 00 02 02 | 	byte	$00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02
11982     98 01 02 00 
11986     F0 02 97 00 
1198a     06 00 00 09 
1198e     04 91 09 01 | 	byte	$98, $01, $02, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $01
11992     67 09 08 84 
11996     57 08 22 0C 
1199a     81 67 22 0C 
1199e     08 02 87 00 | 	byte	$67, $09, $08, $84, $57, $08, $22, $0c, $81, $67, $22, $0c, $08, $02, $87, $00
119a2     00 00 00 08 
119a6     22 88 46 1A 
119aa     00 F0 02 88 
119ae     5D 1A 00 F0 | 	byte	$00, $00, $00, $08, $22, $88, $46, $1a, $00, $f0, $02, $88, $5d, $1a, $00, $f0
119b2     81 97 22 08 
119b6     08 02 81 FA 
119ba     01 00 00 08 
119be     84 97 08 22 | 	byte	$81, $97, $22, $08, $08, $02, $81, $fa, $01, $00, $00, $08, $84, $97, $08, $22
119c2     08 02 88 8A 
119c6     1A 00 F0 81 
119ca     97 22 08 08 
119ce     02 97 00 06 | 	byte	$08, $02, $88, $8a, $1a, $00, $f0, $81, $97, $22, $08, $08, $02, $97, $00, $06
119d2     00 00 0A 08 
119d6     91 0A 01 67 
119da     0A 09 00 81 
119de     09 08 84 97 | 	byte	$00, $00, $0a, $08, $91, $0a, $01, $67, $0a, $09, $00, $81, $09, $08, $84, $97
119e2     08 22 08 81 
119e6     97 22 08 00 
119ea     02 88 90 1A 
119ee     00 F0 02 88 | 	byte	$08, $22, $08, $81, $97, $22, $08, $00, $02, $88, $90, $1a, $00, $f0, $02, $88
119f2     8A 1A 00 F0 
119f6     02 88 E8 19 
119fa     00 F0 02 81 
119fe     0C 00 00 00 | 	byte	$8a, $1a, $00, $f0, $02, $88, $e8, $19, $00, $f0, $02, $81, $0c, $00, $00, $00
11a02     20 00 9A 22 
11a06     00 9A 08 00 
11a0a     9A 09 00 9A 
11a0e     0A 00 9A 01 | 	byte	$20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $01
11a12     00 9A 02 00 
11a16     AA 00 8A 02 
11a1a     00 8A 0A 00 
11a1e     8A 09 00 8A | 	byte	$00, $9a, $02, $00, $aa, $00, $8a, $02, $00, $8a, $0a, $00, $8a, $09, $00, $8a
11a22     08 00 8A 22 
11a26     02 A1 10 00 
11a2a     00 00 20 00 
11a2e     8A 01 00 8A | 	byte	$08, $00, $8a, $22, $02, $a1, $10, $00, $00, $00, $20, $00, $8a, $01, $00, $8a
11a32     00 00 97 20 
11a36     22 08 B1 22 
11a3a     02 27 01 00 
11a3e     81 97 22 08 | 	byte	$00, $00, $97, $20, $22, $08, $b1, $22, $02, $27, $01, $00, $81, $97, $22, $08
11a42     01 02 97 00 
11a46     06 00 00 02 
11a4a     02 98 01 02 
11a4e     00 F0 02 27 | 	byte	$01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $27
11a52     1F 08 84 97 
11a56     08 22 0C 02 
11a5a     27 00 08 84 
11a5e     97 08 22 10 | 	byte	$1f, $08, $84, $97, $08, $22, $0c, $02, $27, $00, $08, $84, $97, $08, $22, $10
11a62     02 27 14 08 
11a66     84 97 08 22 
11a6a     14 02 27 00 
11a6e     08 84 97 08 | 	byte	$02, $27, $14, $08, $84, $97, $08, $22, $14, $02, $27, $00, $08, $84, $97, $08
11a72     22 18 81 97 
11a76     22 0C 08 02 
11a7a     87 00 00 00 
11a7e     00 08 12 88 | 	byte	$22, $18, $81, $97, $22, $0c, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88
11a82     C0 1B 00 F0 
11a86     02 97 00 06 
11a8a     00 00 09 81 
11a8e     97 22 14 0A | 	byte	$c0, $1b, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $14, $0a
11a92     00 81 0A 09 
11a96     01 27 09 08 
11a9a     02 87 00 00 
11a9e     00 00 08 22 | 	byte	$00, $81, $0a, $09, $01, $27, $09, $08, $02, $87, $00, $00, $00, $00, $08, $22
11aa2     27 01 08 12 
11aa6     27 00 08 02 
11aaa     87 00 00 00 
11aae     00 08 22 88 | 	byte	$27, $01, $08, $12, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88
11ab2     50 1B 00 F0 
11ab6     02 88 9C 1B 
11aba     00 F0 02 97 
11abe     00 06 00 00 | 	byte	$50, $1b, $00, $f0, $02, $88, $9c, $1b, $00, $f0, $02, $97, $00, $06, $00, $00
11ac2     00 81 97 22 
11ac6     14 08 00 81 
11aca     08 00 81 97 
11ace     22 04 01 81 | 	byte	$00, $81, $97, $22, $14, $08, $00, $81, $08, $00, $81, $97, $22, $04, $01, $81
11ad2     97 22 10 08 
11ad6     00 81 08 01 
11ada     02 27 0B 02 
11ade     02 98 1E 06 | 	byte	$97, $22, $10, $08, $00, $81, $08, $01, $02, $27, $0b, $02, $02, $98, $1e, $06
11ae2     00 F0 81 97 
11ae6     22 18 08 00 
11aea     91 08 84 97 
11aee     08 22 18 81 | 	byte	$00, $f0, $81, $97, $22, $18, $08, $00, $91, $08, $84, $97, $08, $22, $18, $81
11af2     97 22 10 08 
11af6     02 81 0B 00 
11afa     00 00 08 84 
11afe     97 08 22 10 | 	byte	$97, $22, $10, $08, $02, $81, $0b, $00, $00, $00, $08, $84, $97, $08, $22, $10
11b02     02 88 9C 1B 
11b06     00 F0 81 97 
11b0a     22 14 08 02 
11b0e     81 10 00 00 | 	byte	$02, $88, $9c, $1b, $00, $f0, $81, $97, $22, $14, $08, $02, $81, $10, $00, $00
11b12     00 08 84 97 
11b16     08 22 14 81 
11b1a     97 22 0C 08 
11b1e     00 B1 08 84 | 	byte	$00, $08, $84, $97, $08, $22, $14, $81, $97, $22, $0c, $08, $00, $b1, $08, $84
11b22     97 08 22 0C 
11b26     02 88 08 1B 
11b2a     00 F0 81 97 
11b2e     22 18 00 02 | 	byte	$97, $08, $22, $0c, $02, $88, $08, $1b, $00, $f0, $81, $97, $22, $18, $00, $02
11b32     88 CB 1B 00 
11b36     F0 08 91 20 
11b3a     00 9A 01 02 
11b3e     81 10 00 00 | 	byte	$88, $cb, $1b, $00, $f0, $08, $91, $20, $00, $9a, $01, $02, $81, $10, $00, $00
11b42     00 20 00 9A 
11b46     22 00 9A 08 
11b4a     00 9A 09 00 
11b4e     9A 0A 00 9A | 	byte	$00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a
11b52     02 00 AA 00 
11b56     8A 02 00 8A 
11b5a     0A 00 8A 09 
11b5e     00 8A 08 00 | 	byte	$02, $00, $aa, $00, $8a, $02, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00
11b62     8A 22 02 A1 
11b66     24 00 00 00 
11b6a     20 00 8A 01 
11b6e     00 8A 00 00 | 	byte	$8a, $22, $02, $a1, $24, $00, $00, $00, $20, $00, $8a, $01, $00, $8a, $00, $00
11b72     97 20 22 08 
11b76     B1 22 81 97 
11b7a     22 08 00 02 
11b7e     98 AF 19 00 | 	byte	$97, $20, $22, $08, $b1, $22, $81, $97, $22, $08, $00, $02, $98, $af, $19, $00
11b82     F0 00 97 00 
11b86     08 84 97 08 
11b8a     22 14 81 97 
11b8e     22 14 08 81 | 	byte	$f0, $00, $97, $00, $08, $84, $97, $08, $22, $14, $81, $97, $22, $14, $08, $81
11b92     97 22 04 09 
11b96     00 81 09 08 
11b9a     84 97 08 22 
11b9e     18 81 97 22 | 	byte	$97, $22, $04, $09, $00, $81, $09, $08, $84, $97, $08, $22, $18, $81, $97, $22
11ba2     14 00 02 67 
11ba6     FA 01 01 02 
11baa     98 BA 20 00 
11bae     F0 00 97 00 | 	byte	$14, $00, $02, $67, $fa, $01, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00
11bb2     08 02 A2 FA 
11bb6     01 00 00 08 
11bba     84 97 08 22 
11bbe     0C 81 97 22 | 	byte	$08, $02, $a2, $fa, $01, $00, $00, $08, $84, $97, $08, $22, $0c, $81, $97, $22
11bc2     18 00 02 67 
11bc6     FA 01 01 02 
11bca     98 BA 20 00 
11bce     F0 00 97 00 | 	byte	$18, $00, $02, $67, $fa, $01, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00
11bd2     08 02 A2 FA 
11bd6     01 00 00 08 
11bda     84 97 08 22 
11bde     10 81 97 22 | 	byte	$08, $02, $a2, $fa, $01, $00, $00, $08, $84, $97, $08, $22, $10, $81, $97, $22
11be2     10 08 81 97 
11be6     22 0C 09 00 
11bea     87 09 08 22 
11bee     27 01 08 12 | 	byte	$10, $08, $81, $97, $22, $0c, $09, $00, $87, $09, $08, $22, $27, $01, $08, $12
11bf2     27 00 08 02 
11bf6     87 00 00 00 
11bfa     00 08 22 88 
11bfe     9C 1C 00 F0 | 	byte	$27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $9c, $1c, $00, $f0
11c02     02 88 B6 1D 
11c06     00 F0 02 27 
11c0a     01 00 81 97 
11c0e     22 08 01 02 | 	byte	$02, $88, $b6, $1d, $00, $f0, $02, $27, $01, $00, $81, $97, $22, $08, $01, $02
11c12     81 00 00 00 
11c16     00 01 01 27 
11c1a     01 01 02 97 
11c1e     00 06 00 00 | 	byte	$81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00
11c22     02 02 98 01 
11c26     02 00 F0 02 
11c2a     27 01 08 84 
11c2e     97 08 22 28 | 	byte	$02, $02, $98, $01, $02, $00, $f0, $02, $27, $01, $08, $84, $97, $08, $22, $28
11c32     81 97 22 28 
11c36     08 02 87 20 
11c3a     00 00 00 08 
11c3e     32 27 01 08 | 	byte	$81, $97, $22, $28, $08, $02, $87, $20, $00, $00, $00, $08, $32, $27, $01, $08
11c42     42 27 00 08 
11c46     02 87 00 00 
11c4a     00 00 08 12 
11c4e     88 8F 1D 00 | 	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $8f, $1d, $00
11c52     F0 02 97 00 
11c56     06 00 00 09 
11c5a     81 97 22 28 
11c5e     0A 02 94 10 | 	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $28, $0a, $02, $94, $10
11c62     00 00 00 0A 
11c66     00 81 0A 09 
11c6a     01 67 09 08 
11c6e     81 97 22 08 | 	byte	$00, $00, $00, $0a, $00, $81, $0a, $09, $01, $67, $09, $08, $81, $97, $22, $08
11c72     09 00 91 09 
11c76     01 67 09 09 
11c7a     00 87 09 08 
11c7e     12 27 01 08 | 	byte	$09, $00, $91, $09, $01, $67, $09, $09, $00, $87, $09, $08, $12, $27, $01, $08
11c82     22 27 00 08 
11c86     02 87 00 00 
11c8a     00 00 08 22 
11c8e     88 2D 1D 00 | 	byte	$22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $2d, $1d, $00
11c92     F0 02 88 7C 
11c96     1D 00 F0 02 
11c9a     97 00 06 00 
11c9e     00 09 81 97 | 	byte	$f0, $02, $88, $7c, $1d, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97
11ca2     22 28 0A 02 
11ca6     94 10 00 00 
11caa     00 0A 00 81 
11cae     0A 09 04 91 | 	byte	$22, $28, $0a, $02, $94, $10, $00, $00, $00, $0a, $00, $81, $0a, $09, $04, $91
11cb2     09 01 67 09 
11cb6     08 84 97 08 
11cba     22 2C 02 97 
11cbe     00 06 00 00 | 	byte	$09, $01, $67, $09, $08, $84, $97, $08, $22, $2c, $02, $97, $00, $06, $00, $00
11cc2     09 81 97 22 
11cc6     28 0A 02 94 
11cca     10 00 00 00 
11cce     0A 00 81 0A | 	byte	$09, $81, $97, $22, $28, $0a, $02, $94, $10, $00, $00, $00, $0a, $00, $81, $0a
11cd2     09 04 91 09 
11cd6     81 97 22 2C 
11cda     08 00 91 08 
11cde     04 57 08 09 | 	byte	$09, $04, $91, $09, $81, $97, $22, $2c, $08, $00, $91, $08, $04, $57, $08, $09
11ce2     02 88 7C 1D 
11ce6     00 F0 81 97 
11cea     22 28 08 00 
11cee     91 08 84 97 | 	byte	$02, $88, $7c, $1d, $00, $f0, $81, $97, $22, $28, $08, $00, $91, $08, $84, $97
11cf2     08 22 28 02 
11cf6     88 C6 1C 00 
11cfa     F0 02 27 01 
11cfe     00 81 97 22 | 	byte	$08, $22, $28, $02, $88, $c6, $1c, $00, $f0, $02, $27, $01, $00, $81, $97, $22
11d02     08 01 02 81 
11d06     00 00 00 00 
11d0a     01 01 27 01 
11d0e     01 02 97 00 | 	byte	$08, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00
11d12     06 00 00 02 
11d16     02 98 29 02 
11d1a     00 F0 02 88 
11d1e     B6 1D 00 F0 | 	byte	$06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $02, $88, $b6, $1d, $00, $f0
11d22     81 97 22 0C 
11d26     08 84 97 08 
11d2a     22 1C 81 97 
11d2e     22 08 08 02 | 	byte	$81, $97, $22, $0c, $08, $84, $97, $08, $22, $1c, $81, $97, $22, $08, $08, $02
11d32     81 03 00 00 
11d36     00 08 01 97 
11d3a     08 08 02 87 
11d3e     00 00 00 00 | 	byte	$81, $03, $00, $00, $00, $08, $01, $97, $08, $08, $02, $87, $00, $00, $00, $00
11d42     08 52 27 01 
11d46     08 62 27 00 
11d4a     08 81 97 22 
11d4e     08 09 02 81 | 	byte	$08, $52, $27, $01, $08, $62, $27, $00, $08, $81, $97, $22, $08, $09, $02, $81
11d52     03 00 00 00 
11d56     09 01 97 09 
11d5a     09 02 B5 FA 
11d5e     01 00 00 09 | 	byte	$03, $00, $00, $00, $09, $01, $97, $09, $09, $02, $b5, $fa, $01, $00, $00, $09
11d62     02 87 00 00 
11d66     00 00 09 12 
11d6a     27 01 09 22 
11d6e     27 00 09 00 | 	byte	$02, $87, $00, $00, $00, $00, $09, $12, $27, $01, $09, $22, $27, $00, $09, $00
11d72     83 09 08 02 
11d76     87 00 00 00 
11d7a     00 08 22 88 
11d7e     1C 1E 00 F0 | 	byte	$83, $09, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $1c, $1e, $00, $f0
11d82     02 88 2F 1E 
11d86     00 F0 81 97 
11d8a     22 1C 08 00 
11d8e     91 08 84 97 | 	byte	$02, $88, $2f, $1e, $00, $f0, $81, $97, $22, $1c, $08, $00, $91, $08, $84, $97
11d92     08 22 1C 02 
11d96     88 2F 1E 00 
11d9a     F0 81 97 22 
11d9e     08 08 00 91 | 	byte	$08, $22, $1c, $02, $88, $2f, $1e, $00, $f0, $81, $97, $22, $08, $08, $00, $91
11da2     08 01 67 08 
11da6     08 84 97 08 
11daa     22 20 81 97 
11dae     22 20 08 84 | 	byte	$08, $01, $67, $08, $08, $84, $97, $08, $22, $20, $81, $97, $22, $20, $08, $84
11db2     97 08 22 24 
11db6     81 97 22 1C 
11dba     08 02 87 00 
11dbe     00 00 00 08 | 	byte	$97, $08, $22, $24, $81, $97, $22, $1c, $08, $02, $87, $00, $00, $00, $00, $08
11dc2     12 88 AE 1E 
11dc6     00 F0 81 97 
11dca     22 20 00 81 
11dce     97 22 08 01 | 	byte	$12, $88, $ae, $1e, $00, $f0, $81, $97, $22, $20, $00, $81, $97, $22, $08, $01
11dd2     02 81 00 00 
11dd6     00 00 01 01 
11dda     27 01 01 02 
11dde     97 00 06 00 | 	byte	$02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00
11de2     00 02 02 98 
11de6     01 02 00 F0 
11dea     81 97 22 20 
11dee     08 84 97 08 | 	byte	$00, $02, $02, $98, $01, $02, $00, $f0, $81, $97, $22, $20, $08, $84, $97, $08
11df2     22 24 02 97 
11df6     00 06 00 00 
11dfa     09 04 91 09 
11dfe     01 67 09 08 | 	byte	$22, $24, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $01, $67, $09, $08
11e02     84 97 08 22 
11e06     20 81 97 22 
11e0a     1C 08 00 B1 
11e0e     08 84 97 08 | 	byte	$84, $97, $08, $22, $20, $81, $97, $22, $1c, $08, $00, $b1, $08, $84, $97, $08
11e12     22 1C 02 88 
11e16     4A 1E 00 F0 
11e1a     81 97 22 10 
11e1e     08 81 97 22 | 	byte	$22, $1c, $02, $88, $4a, $1e, $00, $f0, $81, $97, $22, $10, $08, $81, $97, $22
11e22     0C 09 00 87 
11e26     09 08 22 27 
11e2a     01 08 12 27 
11e2e     00 08 02 87 | 	byte	$0c, $09, $00, $87, $09, $08, $22, $27, $01, $08, $12, $27, $00, $08, $02, $87
11e32     00 00 00 00 
11e36     08 22 88 D7 
11e3a     1E 00 F0 02 
11e3e     88 4F 20 00 | 	byte	$00, $00, $00, $00, $08, $22, $88, $d7, $1e, $00, $f0, $02, $88, $4f, $20, $00
11e42     F0 81 97 22 
11e46     08 00 02 81 
11e4a     00 00 00 00 
11e4e     00 01 27 00 | 	byte	$f0, $81, $97, $22, $08, $00, $02, $81, $00, $00, $00, $00, $00, $01, $27, $00
11e52     00 02 98 86 
11e56     21 00 F0 00 
11e5a     97 00 08 84 
11e5e     97 08 22 2C | 	byte	$00, $02, $98, $86, $21, $00, $f0, $00, $97, $00, $08, $84, $97, $08, $22, $2c
11e62     81 97 22 24 
11e66     00 81 97 22 
11e6a     08 01 02 81 
11e6e     00 00 00 00 | 	byte	$81, $97, $22, $24, $00, $81, $97, $22, $08, $01, $02, $81, $00, $00, $00, $00
11e72     01 01 27 01 
11e76     01 02 97 00 
11e7a     06 00 00 02 
11e7e     02 98 01 02 | 	byte	$01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02
11e82     00 F0 02 97 
11e86     00 06 00 00 
11e8a     09 04 91 09 
11e8e     81 97 22 2C | 	byte	$00, $f0, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $81, $97, $22, $2c
11e92     08 04 57 08 
11e96     09 02 97 00 
11e9a     06 00 00 09 
11e9e     08 91 09 02 | 	byte	$08, $04, $57, $08, $09, $02, $97, $00, $06, $00, $00, $09, $08, $91, $09, $02
11ea2     27 00 08 04 
11ea6     57 08 09 81 
11eaa     97 22 24 00 
11eae     81 97 22 08 | 	byte	$27, $00, $08, $04, $57, $08, $09, $81, $97, $22, $24, $00, $81, $97, $22, $08
11eb2     01 02 81 00 
11eb6     00 00 00 01 
11eba     01 27 01 01 
11ebe     02 97 00 06 | 	byte	$01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06
11ec2     00 00 02 02 
11ec6     98 29 02 00 
11eca     F0 81 97 22 
11ece     2C 00 81 97 | 	byte	$00, $00, $02, $02, $98, $29, $02, $00, $f0, $81, $97, $22, $2c, $00, $81, $97
11ed2     22 08 01 02 
11ed6     81 00 00 00 
11eda     00 01 01 27 
11ede     01 01 02 98 | 	byte	$22, $08, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $98
11ee2     B9 24 00 F0 
11ee6     02 97 00 06 
11eea     00 00 09 02 
11eee     27 FF 08 04 | 	byte	$b9, $24, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $02, $27, $ff, $08, $04
11ef2     17 08 09 02 
11ef6     97 00 06 00 
11efa     00 09 00 91 
11efe     09 02 27 00 | 	byte	$17, $08, $09, $02, $97, $00, $06, $00, $00, $09, $00, $91, $09, $02, $27, $00
11f02     08 04 17 08 
11f06     09 02 97 00 
11f0a     06 00 00 09 
11f0e     04 91 09 02 | 	byte	$08, $04, $17, $08, $09, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $02
11f12     27 00 08 04 
11f16     57 08 09 02 
11f1a     97 00 06 00 
11f1e     00 09 08 91 | 	byte	$27, $00, $08, $04, $57, $08, $09, $02, $97, $00, $06, $00, $00, $09, $08, $91
11f22     09 81 97 22 
11f26     18 08 02 B5 
11f2a     FA 01 00 00 
11f2e     08 04 57 08 | 	byte	$09, $81, $97, $22, $18, $08, $02, $b5, $fa, $01, $00, $00, $08, $04, $57, $08
11f32     09 02 27 06 
11f36     08 84 97 08 
11f3a     22 28 81 97 
11f3e     22 28 08 02 | 	byte	$09, $02, $27, $06, $08, $84, $97, $08, $22, $28, $81, $97, $22, $28, $08, $02
11f42     87 00 02 00 
11f46     00 08 32 27 
11f4a     01 08 42 27 
11f4e     00 08 02 87 | 	byte	$87, $00, $02, $00, $00, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87
11f52     00 00 00 00 
11f56     08 12 88 1C 
11f5a     20 00 F0 02 
11f5e     97 00 06 00 | 	byte	$00, $00, $00, $00, $08, $12, $88, $1c, $20, $00, $f0, $02, $97, $00, $06, $00
11f62     00 09 81 97 
11f66     22 28 0A 00 
11f6a     81 0A 09 02 
11f6e     27 00 08 04 | 	byte	$00, $09, $81, $97, $22, $28, $0a, $00, $81, $0a, $09, $02, $27, $00, $08, $04
11f72     17 08 09 81 
11f76     97 22 28 08 
11f7a     00 91 08 84 
11f7e     97 08 22 28 | 	byte	$17, $08, $09, $81, $97, $22, $28, $08, $00, $91, $08, $84, $97, $08, $22, $28
11f82     02 88 D0 1F 
11f86     00 F0 81 97 
11f8a     22 2C 00 81 
11f8e     97 22 08 01 | 	byte	$02, $88, $d0, $1f, $00, $f0, $81, $97, $22, $2c, $00, $81, $97, $22, $08, $01
11f92     02 81 00 00 
11f96     00 00 01 01 
11f9a     27 01 01 02 
11f9e     97 00 06 00 | 	byte	$02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00
11fa2     00 02 02 98 
11fa6     29 02 00 F0 
11faa     81 97 22 2C 
11fae     00 02 88 9C | 	byte	$00, $02, $02, $98, $29, $02, $00, $f0, $81, $97, $22, $2c, $00, $02, $88, $9c
11fb2     20 00 F0 02 
11fb6     88 9C 20 00 
11fba     F0 02 97 00 
11fbe     06 00 00 09 | 	byte	$20, $00, $f0, $02, $88, $9c, $20, $00, $f0, $02, $97, $00, $06, $00, $00, $09
11fc2     08 91 09 81 
11fc6     97 22 18 08 
11fca     02 B5 FA 01 
11fce     00 00 08 04 | 	byte	$08, $91, $09, $81, $97, $22, $18, $08, $02, $b5, $fa, $01, $00, $00, $08, $04
11fd2     57 08 09 81 
11fd6     97 22 24 00 
11fda     81 97 22 08 
11fde     01 02 81 00 | 	byte	$57, $08, $09, $81, $97, $22, $24, $00, $81, $97, $22, $08, $01, $02, $81, $00
11fe2     00 00 00 01 
11fe6     01 27 01 01 
11fea     02 97 00 06 
11fee     00 00 02 02 | 	byte	$00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02
11ff2     98 29 02 00 
11ff6     F0 81 97 22 
11ffa     24 00 02 88 
11ffe     9C 20 00 F0 | 	byte	$98, $29, $02, $00, $f0, $81, $97, $22, $24, $00, $02, $88, $9c, $20, $00, $f0
12002     02 88 9C 20 
12006     00 F0 08 91 
1200a     20 00 9A 01 
1200e     02 81 24 00 | 	byte	$02, $88, $9c, $20, $00, $f0, $08, $91, $20, $00, $9a, $01, $02, $81, $24, $00
12012     00 00 20 00 
12016     9A 22 00 9A 
1201a     08 00 9A 09 
1201e     00 9A 0A 00 | 	byte	$00, $00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00
12022     9A 02 00 AA 
12026     00 8A 09 00 
1202a     8A 08 00 8A 
1202e     22 08 B1 20 | 	byte	$9a, $02, $00, $aa, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $08, $b1, $20
12032     00 8A 01 00 
12036     8A 00 00 97 
1203a     20 22 08 B1 
1203e     22 81 97 22 | 	byte	$00, $8a, $01, $00, $8a, $00, $00, $97, $20, $22, $08, $b1, $22, $81, $97, $22
12042     04 08 02 87 
12046     00 00 00 00 
1204a     08 12 27 01 
1204e     08 22 27 00 | 	byte	$04, $08, $02, $87, $00, $00, $00, $00, $08, $12, $27, $01, $08, $22, $27, $00
12052     08 02 87 00 
12056     00 00 00 08 
1205a     22 88 FA 20 
1205e     00 F0 02 88 | 	byte	$08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $fa, $20, $00, $f0, $02, $88
12062     0A 21 00 F0 
12066     02 27 00 00 
1206a     02 88 72 21 
1206e     00 F0 02 88 | 	byte	$0a, $21, $00, $f0, $02, $27, $00, $00, $02, $88, $72, $21, $00, $f0, $02, $88
12072     0A 21 00 F0 
12076     81 97 22 04 
1207a     08 81 97 22 
1207e     08 09 00 B5 | 	byte	$0a, $21, $00, $f0, $81, $97, $22, $04, $08, $81, $97, $22, $08, $09, $00, $b5
12082     09 08 84 97 
12086     08 22 0C 81 
1208a     97 22 0C 08 
1208e     02 87 00 00 | 	byte	$09, $08, $84, $97, $08, $22, $0c, $81, $97, $22, $0c, $08, $02, $87, $00, $00
12092     00 00 08 12 
12096     27 01 08 22 
1209a     27 00 08 02 
1209e     87 00 00 00 | 	byte	$00, $00, $08, $12, $27, $01, $08, $22, $27, $00, $08, $02, $87, $00, $00, $00
120a2     00 08 22 88 
120a6     44 21 00 F0 
120aa     02 88 55 21 
120ae     00 F0 81 97 | 	byte	$00, $08, $22, $88, $44, $21, $00, $f0, $02, $88, $55, $21, $00, $f0, $81, $97
120b2     22 04 00 02 
120b6     88 72 21 00 
120ba     F0 02 88 55 
120be     21 00 F0 81 | 	byte	$22, $04, $00, $02, $88, $72, $21, $00, $f0, $02, $88, $55, $21, $00, $f0, $81
120c2     97 22 04 00 
120c6     81 97 22 08 
120ca     08 00 81 08 
120ce     00 81 97 22 | 	byte	$97, $22, $04, $00, $81, $97, $22, $08, $08, $00, $81, $08, $00, $81, $97, $22
120d2     0C 08 00 A1 
120d6     08 00 02 88 
120da     72 21 00 F0 
120de     08 91 20 00 | 	byte	$0c, $08, $00, $a1, $08, $00, $02, $88, $72, $21, $00, $f0, $08, $91, $20, $00
120e2     9A 01 08 91 
120e6     20 00 9A 22 
120ea     00 9A 08 00 
120ee     9A 09 00 AA | 	byte	$9a, $01, $08, $91, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $aa
120f2     00 8A 02 00 
120f6     8A 01 00 8A 
120fa     0A 00 8A 09 
120fe     00 8A 08 00 | 	byte	$00, $8a, $02, $00, $8a, $01, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00
12102     8A 22 02 A1 
12106     14 00 00 00 
1210a     20 00 8A 00 
1210e     00 97 20 22 | 	byte	$8a, $22, $02, $a1, $14, $00, $00, $00, $20, $00, $8a, $00, $00, $97, $20, $22
12112     08 B1 22 02 
12116     27 01 00 81 
1211a     97 22 04 01 
1211e     02 97 00 06 | 	byte	$08, $b1, $22, $02, $27, $01, $00, $81, $97, $22, $04, $01, $02, $97, $00, $06
12122     00 00 02 02 
12126     98 01 02 00 
1212a     F0 02 97 00 
1212e     06 00 00 09 | 	byte	$00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00, $00, $09
12132     01 27 09 08 
12136     84 17 08 22 
1213a     10 02 27 00 
1213e     08 84 97 08 | 	byte	$01, $27, $09, $08, $84, $17, $08, $22, $10, $02, $27, $00, $08, $84, $97, $08
12142     22 08 81 97 
12146     22 08 08 81 
1214a     27 22 10 09 
1214e     00 87 09 08 | 	byte	$22, $08, $81, $97, $22, $08, $08, $81, $27, $22, $10, $09, $00, $87, $09, $08
12152     32 27 01 08 
12156     42 27 00 08 
1215a     02 87 00 00 
1215e     00 00 08 12 | 	byte	$32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12
12162     88 EA 22 00 
12166     F0 02 27 00 
1216a     08 84 97 08 
1216e     22 0C 81 97 | 	byte	$88, $ea, $22, $00, $f0, $02, $27, $00, $08, $84, $97, $08, $22, $0c, $81, $97
12172     22 08 00 04 
12176     91 00 81 97 
1217a     22 04 01 02 
1217e     97 00 06 00 | 	byte	$22, $08, $00, $04, $91, $00, $81, $97, $22, $04, $01, $02, $97, $00, $06, $00
12182     00 02 02 98 
12186     01 02 00 F0 
1218a     81 97 22 0C 
1218e     08 02 87 00 | 	byte	$00, $02, $02, $98, $01, $02, $00, $f0, $81, $97, $22, $0c, $08, $02, $87, $00
12192     02 00 00 08 
12196     32 27 01 08 
1219a     42 27 00 08 
1219e     02 87 00 00 | 	byte	$02, $00, $00, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00
121a2     00 00 08 12 
121a6     88 D7 22 00 
121aa     F0 02 97 00 
121ae     06 00 00 09 | 	byte	$00, $00, $08, $12, $88, $d7, $22, $00, $f0, $02, $97, $00, $06, $00, $00, $09
121b2     81 97 22 0C 
121b6     0A 00 81 0A 
121ba     09 01 27 09 
121be     00 02 98 07 | 	byte	$81, $97, $22, $0c, $0a, $00, $81, $0a, $09, $01, $27, $09, $00, $02, $98, $07
121c2     24 00 F0 00 
121c6     97 00 08 84 
121ca     17 08 22 14 
121ce     81 27 22 14 | 	byte	$24, $00, $f0, $00, $97, $00, $08, $84, $17, $08, $22, $14, $81, $27, $22, $14
121d2     08 02 87 FF 
121d6     00 00 00 08 
121da     22 27 01 08 
121de     12 27 00 08 | 	byte	$08, $02, $87, $ff, $00, $00, $00, $08, $22, $27, $01, $08, $12, $27, $00, $08
121e2     02 87 00 00 
121e6     00 00 08 22 
121ea     88 89 22 00 
121ee     F0 02 88 C4 | 	byte	$02, $87, $00, $00, $00, $00, $08, $22, $88, $89, $22, $00, $f0, $02, $88, $c4
121f2     22 00 F0 81 
121f6     97 22 08 08 
121fa     02 94 00 10 
121fe     00 00 08 81 | 	byte	$22, $00, $f0, $81, $97, $22, $08, $08, $02, $94, $00, $10, $00, $00, $08, $81
12202     97 22 0C 09 
12206     02 94 08 00 
1220a     00 00 09 00 
1220e     81 09 08 81 | 	byte	$97, $22, $0c, $09, $02, $94, $08, $00, $00, $00, $09, $00, $81, $09, $08, $81
12212     27 22 14 09 
12216     00 81 09 08 
1221a     84 97 08 22 
1221e     18 81 97 22 | 	byte	$27, $22, $14, $09, $00, $81, $09, $08, $84, $97, $08, $22, $18, $81, $97, $22
12222     18 00 02 88 
12226     F4 22 00 F0 
1222a     02 88 C4 22 
1222e     00 F0 81 97 | 	byte	$18, $00, $02, $88, $f4, $22, $00, $f0, $02, $88, $c4, $22, $00, $f0, $81, $97
12232     22 0C 08 00 
12236     91 08 84 97 
1223a     08 22 0C 02 
1223e     88 1E 22 00 | 	byte	$22, $0c, $08, $00, $91, $08, $84, $97, $08, $22, $0c, $02, $88, $1e, $22, $00
12242     F0 81 97 22 
12246     08 08 00 91 
1224a     08 84 97 08 
1224e     22 08 02 88 | 	byte	$f0, $81, $97, $22, $08, $08, $00, $91, $08, $84, $97, $08, $22, $08, $02, $88
12252     D8 21 00 F0 
12256     02 27 00 00 
1225a     02 88 F4 22 
1225e     00 F0 02 81 | 	byte	$d8, $21, $00, $f0, $02, $27, $00, $00, $02, $88, $f4, $22, $00, $f0, $02, $81
12262     18 00 00 00 
12266     20 00 9A 22 
1226a     00 9A 08 00 
1226e     9A 09 00 9A | 	byte	$18, $00, $00, $00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a
12272     0A 00 9A 01 
12276     00 9A 02 00 
1227a     AA 00 8A 02 
1227e     00 8A 01 00 | 	byte	$0a, $00, $9a, $01, $00, $9a, $02, $00, $aa, $00, $8a, $02, $00, $8a, $01, $00
12282     8A 0A 00 8A 
12286     09 00 8A 08 
1228a     00 8A 22 0C 
1228e     B1 20 00 8A | 	byte	$8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $0c, $b1, $20, $00, $8a
12292     00 00 97 20 
12296     22 08 B1 22 
1229a     02 27 01 00 
1229e     81 97 22 04 | 	byte	$00, $00, $97, $20, $22, $08, $b1, $22, $02, $27, $01, $00, $81, $97, $22, $04
122a2     01 02 97 00 
122a6     06 00 00 02 
122aa     02 98 01 02 
122ae     00 F0 02 27 | 	byte	$01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $27
122b2     00 08 84 97 
122b6     08 22 08 02 
122ba     27 10 08 84 
122be     97 08 22 0C | 	byte	$00, $08, $84, $97, $08, $22, $08, $02, $27, $10, $08, $84, $97, $08, $22, $0c
122c2     81 97 22 08 
122c6     08 02 87 1E 
122ca     00 00 00 08 
122ce     32 27 01 08 | 	byte	$81, $97, $22, $08, $08, $02, $87, $1e, $00, $00, $00, $08, $32, $27, $01, $08
122d2     42 27 00 08 
122d6     02 87 00 00 
122da     00 00 08 12 
122de     88 E2 23 00 | 	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $e2, $23, $00
122e2     F0 02 97 00 
122e6     06 00 00 09 
122ea     81 97 22 0C 
122ee     0A 00 81 0A | 	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $0c, $0a, $00, $81, $0a
122f2     09 01 67 09 
122f6     08 02 87 00 
122fa     00 00 00 08 
122fe     12 27 01 08 | 	byte	$09, $01, $67, $09, $08, $02, $87, $00, $00, $00, $00, $08, $12, $27, $01, $08
12302     22 27 00 08 
12306     02 87 00 00 
1230a     00 00 08 22 
1230e     88 AD 23 00 | 	byte	$22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $ad, $23, $00
12312     F0 02 88 BE 
12316     23 00 F0 81 
1231a     97 22 0C 00 
1231e     02 88 EC 23 | 	byte	$f0, $02, $88, $be, $23, $00, $f0, $81, $97, $22, $0c, $00, $02, $88, $ec, $23
12322     00 F0 02 88 
12326     BE 23 00 F0 
1232a     81 97 22 0C 
1232e     08 02 81 10 | 	byte	$00, $f0, $02, $88, $be, $23, $00, $f0, $81, $97, $22, $0c, $08, $02, $81, $10
12332     00 00 00 08 
12336     84 97 08 22 
1233a     0C 81 97 22 
1233e     08 08 00 91 | 	byte	$00, $00, $00, $08, $84, $97, $08, $22, $0c, $81, $97, $22, $08, $08, $00, $91
12342     08 84 97 08 
12346     22 08 02 88 
1234a     56 23 00 F0 
1234e     02 27 00 00 | 	byte	$08, $84, $97, $08, $22, $08, $02, $88, $56, $23, $00, $f0, $02, $27, $00, $00
12352     02 88 EC 23 
12356     00 F0 02 81 
1235a     0C 00 00 00 
1235e     20 00 9A 22 | 	byte	$02, $88, $ec, $23, $00, $f0, $02, $81, $0c, $00, $00, $00, $20, $00, $9a, $22
12362     00 9A 08 00 
12366     9A 09 00 9A 
1236a     0A 00 9A 01 
1236e     00 9A 02 00 | 	byte	$00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $01, $00, $9a, $02, $00
12372     AA 00 8A 08 
12376     00 8A 22 08 
1237a     B1 20 00 8A 
1237e     00 00 97 20 | 	byte	$aa, $00, $8a, $08, $00, $8a, $22, $08, $b1, $20, $00, $8a, $00, $00, $97, $20
12382     22 08 B1 22 
12386     81 27 22 04 
1238a     08 02 87 FF 
1238e     00 00 00 08 | 	byte	$22, $08, $b1, $22, $81, $27, $22, $04, $08, $02, $87, $ff, $00, $00, $00, $08
12392     12 27 01 08 
12396     22 27 00 08 
1239a     02 87 00 00 
1239e     00 00 08 22 | 	byte	$12, $27, $01, $08, $22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22
123a2     88 41 24 00 
123a6     F0 02 88 51 
123aa     24 00 F0 02 
123ae     27 FF 00 02 | 	byte	$88, $41, $24, $00, $f0, $02, $88, $51, $24, $00, $f0, $02, $27, $ff, $00, $02
123b2     88 AE 24 00 
123b6     F0 02 88 51 
123ba     24 00 F0 02 
123be     27 00 08 84 | 	byte	$88, $ae, $24, $00, $f0, $02, $88, $51, $24, $00, $f0, $02, $27, $00, $08, $84
123c2     17 08 22 08 
123c6     81 27 22 04 
123ca     08 02 B5 02 
123ce     00 00 00 08 | 	byte	$17, $08, $22, $08, $81, $27, $22, $04, $08, $02, $b5, $02, $00, $00, $00, $08
123d2     02 87 01 00 
123d6     00 00 08 12 
123da     27 01 08 22 
123de     27 00 08 02 | 	byte	$02, $87, $01, $00, $00, $00, $08, $12, $27, $01, $08, $22, $27, $00, $08, $02
123e2     87 00 00 00 
123e6     00 08 12 88 
123ea     A3 24 00 F0 
123ee     81 27 22 08 | 	byte	$87, $00, $00, $00, $00, $08, $12, $88, $a3, $24, $00, $f0, $81, $27, $22, $08
123f2     08 00 91 08 
123f6     84 17 08 22 
123fa     08 81 27 22 
123fe     04 08 02 95 | 	byte	$08, $00, $91, $08, $84, $17, $08, $22, $08, $81, $27, $22, $04, $08, $02, $95
12402     01 08 84 17 
12406     08 22 04 02 
1240a     88 5A 24 00 
1240e     F0 81 27 22 | 	byte	$01, $08, $84, $17, $08, $22, $04, $02, $88, $5a, $24, $00, $f0, $81, $27, $22
12412     08 00 02 88 
12416     AE 24 00 F0 
1241a     0C 91 20 00 
1241e     9A 22 00 9A | 	byte	$08, $00, $02, $88, $ae, $24, $00, $f0, $0c, $91, $20, $00, $9a, $22, $00, $9a
12422     08 00 AA 00 
12426     8A 02 00 8A 
1242a     0A 00 8A 09 
1242e     00 8A 08 00 | 	byte	$08, $00, $aa, $00, $8a, $02, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00
12432     8A 22 02 A1 
12436     10 00 00 00 
1243a     20 00 8A 01 
1243e     00 8A 00 00 | 	byte	$8a, $22, $02, $a1, $10, $00, $00, $00, $20, $00, $8a, $01, $00, $8a, $00, $00
12442     97 20 22 08 
12446     B1 22 81 97 
1244a     22 04 00 00 
1244e     91 00 02 67 | 	byte	$97, $20, $22, $08, $b1, $22, $81, $97, $22, $04, $00, $00, $91, $00, $02, $67
12452     00 10 01 02 
12456     98 BA 20 00 
1245a     F0 00 97 00 
1245e     08 02 95 0C | 	byte	$00, $10, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00, $08, $02, $95, $0c
12462     08 00 91 08 
12466     84 97 08 22 
1246a     0C 81 97 22 
1246e     04 00 00 91 | 	byte	$08, $00, $91, $08, $84, $97, $08, $22, $0c, $81, $97, $22, $04, $00, $00, $91
12472     00 02 27 08 
12476     01 02 98 BA 
1247a     20 00 F0 00 
1247e     97 00 08 02 | 	byte	$00, $02, $27, $08, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00, $08, $02
12482     95 03 08 00 
12486     B1 08 02 B5 
1248a     00 02 00 00 
1248e     08 84 97 08 | 	byte	$95, $03, $08, $00, $b1, $08, $02, $b5, $00, $02, $00, $00, $08, $84, $97, $08
12492     22 10 81 97 
12496     22 04 08 02 
1249a     B5 08 00 00 
1249e     00 08 84 17 | 	byte	$22, $10, $81, $97, $22, $04, $08, $02, $b5, $08, $00, $00, $00, $08, $84, $17
124a2     08 22 14 81 
124a6     97 22 0C 00 
124aa     81 97 22 08 
124ae     01 02 97 00 | 	byte	$08, $22, $14, $81, $97, $22, $0c, $00, $81, $97, $22, $08, $01, $02, $97, $00
124b2     06 00 00 02 
124b6     02 98 01 02 
124ba     00 F0 02 97 
124be     00 06 00 00 | 	byte	$06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00, $00
124c2     09 81 97 22 
124c6     10 0A 00 81 
124ca     0A 09 01 27 
124ce     09 08 84 17 | 	byte	$09, $81, $97, $22, $10, $0a, $00, $81, $0a, $09, $01, $27, $09, $08, $84, $17
124d2     08 22 18 81 
124d6     27 22 18 08 
124da     02 27 01 09 
124de     81 27 22 14 | 	byte	$08, $22, $18, $81, $27, $22, $18, $08, $02, $27, $01, $09, $81, $27, $22, $14
124e2     0A 00 84 0A 
124e6     09 00 93 09 
124ea     08 84 17 08 
124ee     22 18 02 97 | 	byte	$0a, $00, $84, $0a, $09, $00, $93, $09, $08, $84, $17, $08, $22, $18, $02, $97
124f2     00 06 00 00 
124f6     09 81 97 22 
124fa     10 0A 00 81 
124fe     0A 09 81 27 | 	byte	$00, $06, $00, $00, $09, $81, $97, $22, $10, $0a, $00, $81, $0a, $09, $81, $27
12502     22 18 08 04 
12506     17 08 09 81 
1250a     97 22 0C 00 
1250e     81 97 22 08 | 	byte	$22, $18, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $00, $81, $97, $22, $08
12512     01 02 97 00 
12516     06 00 00 02 
1251a     02 98 29 02 
1251e     00 F0 08 91 | 	byte	$01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $08, $91
12522     20 00 9A 01 
12526     02 81 10 00 
1252a     00 00 20 00 
1252e     9A 22 00 9A | 	byte	$20, $00, $9a, $01, $02, $81, $10, $00, $00, $00, $20, $00, $9a, $22, $00, $9a
12532     08 00 9A 09 
12536     00 9A 0A 00 
1253a     9A 02 00 AA 
1253e     00 8A 02 00 | 	byte	$08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $02, $00, $aa, $00, $8a, $02, $00
12542     8A 0A 00 8A 
12546     09 00 8A 08 
1254a     00 8A 22 02 
1254e     A1 10 00 00 | 	byte	$8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $02, $a1, $10, $00, $00
12552     00 20 00 8A 
12556     01 00 8A 00 
1255a     00 97 20 22 
1255e     08 B1 22 81 | 	byte	$00, $20, $00, $8a, $01, $00, $8a, $00, $00, $97, $20, $22, $08, $b1, $22, $81
12562     97 22 04 00 
12566     00 91 00 02 
1256a     67 00 10 01 
1256e     02 98 BA 20 | 	byte	$97, $22, $04, $00, $00, $91, $00, $02, $67, $00, $10, $01, $02, $98, $ba, $20
12572     00 F0 00 97 
12576     00 08 02 95 
1257a     0C 08 00 91 
1257e     08 84 97 08 | 	byte	$00, $f0, $00, $97, $00, $08, $02, $95, $0c, $08, $00, $91, $08, $84, $97, $08
12582     22 0C 81 97 
12586     22 04 00 00 
1258a     91 00 02 27 
1258e     08 01 02 98 | 	byte	$22, $0c, $81, $97, $22, $04, $00, $00, $91, $00, $02, $27, $08, $01, $02, $98
12592     BA 20 00 F0 
12596     00 97 00 08 
1259a     02 95 03 08 
1259e     00 B1 08 02 | 	byte	$ba, $20, $00, $f0, $00, $97, $00, $08, $02, $95, $03, $08, $00, $b1, $08, $02
125a2     B5 00 02 00 
125a6     00 08 84 97 
125aa     08 22 10 81 
125ae     97 22 04 08 | 	byte	$b5, $00, $02, $00, $00, $08, $84, $97, $08, $22, $10, $81, $97, $22, $04, $08
125b2     02 B5 08 00 
125b6     00 00 08 84 
125ba     17 08 22 14 
125be     81 97 22 0C | 	byte	$02, $b5, $08, $00, $00, $00, $08, $84, $17, $08, $22, $14, $81, $97, $22, $0c
125c2     00 81 97 22 
125c6     08 01 02 97 
125ca     00 06 00 00 
125ce     02 02 98 01 | 	byte	$00, $81, $97, $22, $08, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01
125d2     02 00 F0 02 
125d6     97 00 06 00 
125da     00 09 81 97 
125de     22 10 0A 00 | 	byte	$02, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $10, $0a, $00
125e2     81 0A 09 01 
125e6     27 09 08 84 
125ea     17 08 22 18 
125ee     81 27 22 18 | 	byte	$81, $0a, $09, $01, $27, $09, $08, $84, $17, $08, $22, $18, $81, $27, $22, $18
125f2     08 02 27 01 
125f6     09 81 27 22 
125fa     14 0A 00 84 
125fe     0A 09 00 B3 | 	byte	$08, $02, $27, $01, $09, $81, $27, $22, $14, $0a, $00, $84, $0a, $09, $00, $b3
12602     09 00 83 09 
12606     08 84 17 08 
1260a     22 18 02 97 
1260e     00 06 00 00 | 	byte	$09, $00, $83, $09, $08, $84, $17, $08, $22, $18, $02, $97, $00, $06, $00, $00
12612     09 81 97 22 
12616     10 0A 00 81 
1261a     0A 09 81 27 
1261e     22 18 08 04 | 	byte	$09, $81, $97, $22, $10, $0a, $00, $81, $0a, $09, $81, $27, $22, $18, $08, $04
12622     17 08 09 81 
12626     97 22 0C 00 
1262a     81 97 22 08 
1262e     01 02 97 00 | 	byte	$17, $08, $09, $81, $97, $22, $0c, $00, $81, $97, $22, $08, $01, $02, $97, $00
12632     06 00 00 02 
12636     02 98 29 02 
1263a     00 F0 08 91 
1263e     20 00 9A 01 | 	byte	$06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $08, $91, $20, $00, $9a, $01
12642     02 81 10 00 
12646     00 00 20 00 
1264a     9A 22 00 9A 
1264e     08 00 9A 09 | 	byte	$02, $81, $10, $00, $00, $00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09
12652     00 9A 0A 00 
12656     9A 02 00 AA 
1265a     72 61 6D 64 
1265e     69 73 6B 00 | 	byte	$00, $9a, $0a, $00, $9a, $02, $00, $aa, $72, $61, $6d, $64, $69, $73, $6b, $00
12662     00 00 00 00 
      ...             
12f66     00 00 00 00 
12f6a     00 00       | 	byte	$00[2314]
12f6c     54 00 00 F0 
12f70     00 00 00 00 
12f74     00 00 00 00 
12f78     57 02 00 F0 | 	byte	$54, $00, $00, $f0, $00, $00, $00, $00, $00, $00, $00, $00, $57, $02, $00, $f0
12f7c     51 02 00 F0 
12f80     5D 02 00 F0 
12f84     00 00 00 00 
12f88     00 00 00 00 | 	byte	$51, $02, $00, $f0, $5d, $02, $00, $f0, $00, $00, $00, $00, $00, $00, $00, $00
12f8c     00 00 00 00 
12f90     00 00 00 00 
12f94     00 00 00 00 
12f98     00 00 00 00 | 	byte	$00[16]
12f9c     74 00 00 F0 
12fa0     6B 00 00 F0 
12fa4     00 00 00 00 
12fa8     00 00 00 00 | 	byte	$74, $00, $00, $f0, $6b, $00, $00, $f0, $00, $00, $00, $00, $00, $00, $00, $00
12fac     00 00 00 00 
      ...             
13064     00 00 00 00 
13068     00 00 00 00 | 	byte	$00[192]
1306c     01 02 00 F0 
13070     29 02 00 F0 
13074     F9 07 00 F0 
13078     45 12 00 F0 | 	byte	$01, $02, $00, $f0, $29, $02, $00, $f0, $f9, $07, $00, $f0, $45, $12, $00, $f0
1307c     AC 12 00 F0 
13080     6F 19 00 F0 
13084     AF 19 00 F0 
13088     AB 1A 00 F0 | 	byte	$ac, $12, $00, $f0, $6f, $19, $00, $f0, $af, $19, $00, $f0, $ab, $1a, $00, $f0
1308c     81 12 00 F0 
13090     BB 15 00 F0 
13094     00 00 00 00 
13098     77 09 00 F0 | 	byte	$81, $12, $00, $f0, $bb, $15, $00, $f0, $00, $00, $00, $00, $77, $09, $00, $f0
1309c     04 0D 00 F0 
130a0     EE 0F 00 F0 
130a4     00 00 00 00 
130a8     00 00 00 00 | 	byte	$04, $0d, $00, $f0, $ee, $0f, $00, $f0, $00, $00, $00, $00, $00, $00, $00, $00
130ac     00 00 00 00 
      ...             
13164     00 00 00 00 
13168     00 00 00 00 | 	byte	$00[192]
1316c     1E 06 00 F0 
13170     46 06 00 F0 
13174     2E 07 00 F0 
13178     6E 06 00 F0 | 	byte	$1e, $06, $00, $f0, $46, $06, $00, $f0, $2e, $07, $00, $f0, $6e, $06, $00, $f0
1317c     A7 06 00 F0 
13180     5A 07 00 F0 
13184     9B 07 00 F0 
13188     00 00 00 00 | 	byte	$a7, $06, $00, $f0, $5a, $07, $00, $f0, $9b, $07, $00, $f0, $00, $00, $00, $00
1318c     00 00 00 00 
      ...             
13264     00 00 00 00 
13268     00 00 00 00 | 	byte	$00[224]
1326c     77 05 00 F0 | 	byte	$77, $05, $00, $f0
13270                 | 	alignl
13270                 | _p2textdrv_dat_
13270                 |         orgh
13270                 | ' a default VGA palette
13270                 | vgapalette
13270     00 00 00 00 |             long    $00_00_00_00   ' 0 = black
13274     00 AA 00 00 |             long    $00_00_AA_00   ' 1 = dark blue
13278     00 00 AA 00 |             long    $00_AA_00_00   ' 2 = dark green
1327c     00 AA AA 00 |             long    $00_AA_AA_00   ' 3 = dark cyan
13280     00 00 00 AA |             long    $AA_00_00_00   ' 4 = dark red
13284     00 AA 00 AA |             long    $AA_00_AA_00   ' 5 = dark magenta
13288     00 00 55 AA |             long    $AA_55_00_00   ' 6 = brown
1328c     00 AA AA AA |             long    $AA_AA_AA_00   ' 7 = light grey
13290     00 55 55 55 |             long    $55_55_55_00   ' 8 = dark grey
13294     00 FF 55 55 |             long    $55_55_FF_00   ' 9 = light blue
13298     00 55 FF 55 |             long    $55_FF_55_00   '10 = light green
1329c     00 FF FF 55 |             long    $55_FF_FF_00   '11 = light cyan
132a0     00 55 55 FF |             long    $FF_55_55_00   '12 = light red
132a4     00 FF 55 FF |             long    $FF_55_FF_00   '13 = light magenta
132a8     00 55 FF FF |             long    $FF_FF_55_00   '14 = yellow
132ac     00 FF FF FF |             long    $FF_FF_FF_00   '15 = white
132b0                 | 
132b0                 | ' a default 16 scan line font for the P2
132b0     00 00 00 00 
132b4     00 00 00 00 | font        file    "p2font16"
132b8     FF 00 FF 00 
132bc     00 00 00 00 
132c0     00 00 00 00 
132c4     00 00 00 00 | 	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
132c8     00 00 00 00 
132cc     00 00 00 00 
132d0     00 00 00 00 | 	byte	$00[12]
132d4     18 00 00 00 
132d8     00 00 00 00 
132dc     00 00 00 00 
132e0     00 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
132e4     00 00 00 00 
      ...             
13308     00 00 00 00 
1330c     00 00       | 	byte	$00[42]
1330e     08 00 0C 00 
13312     00 00 00 00 
13316     00 00 00 00 
1331a     00 00 00 00 | 	byte	$08, $00, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
1331e     00 00 00 00 
      ...             
1333a     00 00 00 00 
1333e     00          | 	byte	$00[33]
1333f     1C 18 00 00 
13343     00 00 00 00 
13347     00 00 00 00 
1334b     00 00 00 00 | 	byte	$1c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
1334f     00 00 00 00 
13353     00 00       | 	byte	$00[6]
13355     6E 00 00 00 
13359     00 00 00 00 
1335d     00 00 00 88 
13361     AA BB 18 18 | 	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $88, $aa, $bb, $18, $18
13365     18 6C 00 00 
13369     6C 6C 00 6C 
1336d     6C 18 00 18 
13371     18 00 18 00 | 	byte	$18, $6c, $00, $00, $6c, $6c, $00, $6c, $6c, $18, $00, $18, $18, $00, $18, $00
13375     18 18 6C 6C 
13379     00 6C 00 6C 
1337d     00 6C 18 6C 
13381     00 00 6C 18 | 	byte	$18, $18, $6c, $6c, $00, $6c, $00, $6c, $00, $6c, $18, $6c, $00, $00, $6c, $18
13385     00 00 6C 18 
13389     18 00 FF 00 
1338d     0F F0 FF 00 
13391     00 00 00 00 | 	byte	$00, $00, $6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $00, $00, $00, $00, $00
13395     00 00 00 00 
13399     00 00 00 00 
1339d     00 00 00 00 
133a1     00 00 00 00 | 	byte	$00[16]
133a5     18 00 00 00 
133a9     00 00 00 00 
133ad     00 00 00 00 
133b1     00 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
133b5     00 00 00 FF 
133b9     00 FF 00 00 
133bd     00 00 00 01 
133c1     40 00 00 00 | 	byte	$00, $00, $00, $ff, $00, $ff, $00, $00, $00, $00, $00, $01, $40, $00, $00, $00
133c5     3E 00 00 00 
133c9     00 00 00 00 
133cd     00 00 00 00 
133d1     00 66 00 18 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $00, $18
133d5     00 00 0C 00 
133d9     00 00 00 00 
133dd     00 00 00 00 
133e1     00 00 00 00 | 	byte	$00, $00, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
133e5     00 00 00 00 
      ...             
13409     00 00 00 00 
1340d     00          | 	byte	$00[41]
1340e     1C 00 0C 00 
13412     00 00 00 00 
13416     00 00 00 00 
1341a     00 00 00 00 | 	byte	$1c, $00, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
1341e     00 00 00 00 
13422     00 00 00 00 
13426     00 00 00 00 
1342a     00 00 00 00 
1342e     00 00 00 00 | 	byte	$00[20]
13432     30 08 00 06 
13436     1C 00 08 00 
1343a     06 00 18 06 
1343e     63 36 0C 00 | 	byte	$30, $08, $00, $06, $1c, $00, $08, $00, $06, $00, $18, $06, $63, $36, $0c, $00
13442     00 08 00 06 
13446     0C 06 00 63 
1344a     63 18 1C 00 
1344e     1F 70 18 30 | 	byte	$00, $08, $00, $06, $0c, $06, $00, $63, $63, $18, $1c, $00, $1f, $70, $18, $30
13452     18 18 00 3B 
13456     3C 1C 00 00 
1345a     00 03 03 00 
1345e     00 00 22 55 | 	byte	$18, $18, $00, $3b, $3c, $1c, $00, $00, $00, $03, $03, $00, $00, $00, $22, $55
13462     EE 18 18 18 
13466     6C 00 00 6C 
1346a     6C 00 6C 6C 
1346e     18 00 18 18 | 	byte	$ee, $18, $18, $18, $6c, $00, $00, $6c, $6c, $00, $6c, $6c, $18, $00, $18, $18
13472     00 18 00 18 
13476     18 6C 6C 00 
1347a     6C 00 6C 00 
1347e     6C 18 6C 00 | 	byte	$00, $18, $00, $18, $18, $6c, $6c, $00, $6c, $00, $6c, $00, $6c, $18, $6c, $00
13482     00 6C 18 00 
13486     00 6C 18 18 
1348a     00 FF 00 0F 
1348e     F0 FF 00 00 | 	byte	$00, $6c, $18, $00, $00, $6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $00, $00
13492     00 00 00 00 
13496     00 00 00 00 
1349a     00 00 00 00 
1349e     00 00 00 00 
134a2     00 00 00    | 	byte	$00[19]
134a5     18 00 00 1C 
134a9     00 00 F0 1B 
134ad     0E 00 00 00 
134b1     7E 7E 00 00 | 	byte	$18, $00, $00, $1c, $00, $00, $f0, $1b, $0e, $00, $00, $00, $7e, $7e, $00, $00
134b5     00 00 00 FF 
134b9     00 FF 78 3C 
134bd     FC FE 00 03 
134c1     60 18 66 FE | 	byte	$00, $00, $00, $ff, $00, $ff, $78, $3c, $fc, $fe, $00, $03, $60, $18, $66, $fe
134c5     63 00 18 18 
134c9     18 00 00 00 
134cd     00 00 00 00 
134d1     18 66 00 3E | 	byte	$63, $00, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $66, $00, $3e
134d5     00 1C 0C 30 
134d9     0C 00 00 00 
134dd     00 00 00 1C 
134e1     18 3E 3E 30 | 	byte	$00, $1c, $0c, $30, $0c, $00, $00, $00, $00, $00, $00, $1c, $18, $3e, $3e, $30
134e5     7F 1C 7F 3E 
134e9     3E 00 00 00 
134ed     00 00 3E 00 
134f1     08 3F 3C 1F | 	byte	$7f, $1c, $7f, $3e, $3e, $00, $00, $00, $00, $00, $3e, $00, $08, $3f, $3c, $1f
134f5     7F 7F 3C 63 
134f9     3C 78 67 0F 
134fd     63 63 3E 3F 
13501     3E 3F 3E 7E | 	byte	$7f, $7f, $3c, $63, $3c, $78, $67, $0f, $63, $63, $3e, $3f, $3e, $3f, $3e, $7e
13505     63 63 63 63 
13509     66 7F 3C 00 
1350d     3C 36 00 18 
13511     00 07 00 38 | 	byte	$63, $63, $63, $63, $66, $7f, $3c, $00, $3c, $36, $00, $18, $00, $07, $00, $38
13515     00 1C 00 07 
13519     18 60 07 1C 
1351d     00 00 00 00 
13521     00 00 00 08 | 	byte	$00, $1c, $00, $07, $18, $60, $07, $1c, $00, $00, $00, $00, $00, $00, $00, $08
13525     00 00 00 00 
13529     00 00       | 	byte	$00[6]
1352b     70 18 0E 6E 
1352f     00 3C 33 18 
13533     1C 33 0C 36 
13537     00 1C 63 0C | 	byte	$70, $18, $0e, $6e, $00, $3c, $33, $18, $1c, $33, $0c, $36, $00, $1c, $63, $0c
1353b     66 3C 0C 00 
1353f     1C 06 00 7C 
13543     1C 63 0C 1E 
13547     0C 63 00 00 | 	byte	$66, $3c, $0c, $00, $1c, $06, $00, $7c, $1c, $63, $0c, $1e, $0c, $63, $00, $00
1354b     18 36 66 33 
1354f     D8 0C 18 0C 
13553     0C 6E 00 36 
13557     36 0C 00 00 | 	byte	$18, $36, $66, $33, $d8, $0c, $18, $0c, $0c, $6e, $00, $36, $36, $0c, $00, $00
1355b     03 03 18 00 
1355f     00 88 AA BB 
13563     18 18 18 6C 
13567     00 00 6C 6C | 	byte	$03, $03, $18, $00, $00, $88, $aa, $bb, $18, $18, $18, $6c, $00, $00, $6c, $6c
1356b     00 6C 6C 18 
1356f     00 18 18 00 
13573     18 00 18 18 
13577     6C 6C 00 6C | 	byte	$00, $6c, $6c, $18, $00, $18, $18, $00, $18, $00, $18, $18, $6c, $6c, $00, $6c
1357b     00 6C 00 6C 
1357f     18 6C 00 00 
13583     6C 18 00 00 
13587     6C 18 18 00 | 	byte	$00, $6c, $00, $6c, $18, $6c, $00, $00, $6c, $18, $00, $00, $6c, $18, $18, $00
1358b     FF 00 0F F0 
1358f     FF 00 1E 7F 
13593     00 00 00 00 
13597     00 00 00 1C | 	byte	$ff, $00, $0f, $f0, $ff, $00, $1e, $7f, $00, $00, $00, $00, $00, $00, $00, $1c
1359b     78 00 00 38 
1359f     00 00 00 00 
135a3     00 70 18 00 
135a7     00 36 00 00 | 	byte	$78, $00, $00, $38, $00, $00, $00, $00, $00, $70, $18, $00, $00, $36, $00, $00
135ab     30 36 1B 00 
135af     00 00 81 FF 
135b3     00 00 18 18 
135b7     00 FF 00 FF | 	byte	$30, $36, $1b, $00, $00, $00, $81, $ff, $00, $00, $18, $18, $00, $ff, $00, $ff
135bb     70 66 CC C6 
135bf     18 07 70 3C 
135c3     66 DB 06 00 
135c7     3C 3C 18 00 | 	byte	$70, $66, $cc, $c6, $18, $07, $70, $3c, $66, $db, $06, $00, $3c, $3c, $18, $00
135cb     00 00 00 00 
135cf     00 00       | 	byte	$00[6]
135d1     3C 66 36 63 
135d5     00 36 0C 18 
135d9     18 00 00 00 
135dd     00 00 00 36 | 	byte	$3c, $66, $36, $63, $00, $36, $0c, $18, $18, $00, $00, $00, $00, $00, $00, $36
135e1     1C 63 63 38 
135e5     03 06 63 63 
135e9     63 00 00 60 
135ed     00 06 63 3E | 	byte	$1c, $63, $63, $38, $03, $06, $63, $63, $63, $00, $00, $60, $00, $06, $63, $3e
135f1     1C 66 66 36 
135f5     66 66 66 63 
135f9     18 30 66 06 
135fd     77 67 63 66 | 	byte	$1c, $66, $66, $36, $66, $66, $66, $63, $18, $30, $66, $06, $77, $67, $63, $66
13601     63 66 63 7E 
13605     63 63 63 63 
13609     66 63 0C 01 
1360d     30 63 00 00 | 	byte	$63, $66, $63, $7e, $63, $63, $63, $63, $66, $63, $0c, $01, $30, $63, $00, $00
13611     00 06 00 30 
13615     00 36 00 06 
13619     18 60 06 18 
1361d     00 00 00 00 | 	byte	$00, $06, $00, $30, $00, $36, $00, $06, $18, $60, $06, $18, $00, $00, $00, $00
13621     00 00 00 0C 
13625     00 00 00 00 
13629     00 00 18 18 
1362d     18 3B 00 66 | 	byte	$00, $00, $00, $0c, $00, $00, $00, $00, $00, $00, $18, $18, $18, $3b, $00, $66
13631     00 0C 36 00 
13635     18 1C 00 36 
13639     00 18 00 66 
1363d     18 08 00 00 | 	byte	$00, $0c, $36, $00, $18, $1c, $00, $36, $00, $18, $00, $66, $18, $08, $00, $00
13641     00 36 36 00 
13645     18 33 18 00 
13649     3E 63 3C 26 
1364d     66 33 18 06 | 	byte	$00, $36, $36, $00, $18, $33, $18, $00, $3e, $63, $3c, $26, $66, $33, $18, $06
13651     0C 06 06 3B 
13655     63 36 36 0C 
13659     00 00 43 43 
1365d     18 00 00 22 | 	byte	$0c, $06, $06, $3b, $63, $36, $36, $0c, $00, $00, $43, $43, $18, $00, $00, $22
13661     55 EE 18 18 
13665     18 6C 00 00 
13669     6C 6C 00 6C 
1366d     6C 18 00 18 | 	byte	$55, $ee, $18, $18, $18, $6c, $00, $00, $6c, $6c, $00, $6c, $6c, $18, $00, $18
13671     18 00 18 00 
13675     18 18 6C 6C 
13679     00 6C 00 6C 
1367d     00 6C 18 6C | 	byte	$18, $00, $18, $00, $18, $18, $6c, $6c, $00, $6c, $00, $6c, $00, $6c, $18, $6c
13681     00 00 6C 18 
13685     00 00 6C 18 
13689     18 00 FF 00 
1368d     0F F0 FF 00 | 	byte	$00, $00, $6c, $18, $00, $00, $6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $00
13691     33 63 00 7F 
13695     00 00 00 7E 
13699     1C 36 0C 00 
1369d     C0 0C 3E 00 | 	byte	$33, $63, $00, $7f, $00, $00, $00, $7e, $1c, $36, $0c, $00, $c0, $0c, $3e, $00
136a1     00 0C 30 D8 
136a5     18 00 00 36 
136a9     00 00 30 36 
136ad     0C 00 00 00 | 	byte	$00, $0c, $30, $d8, $18, $00, $00, $36, $00, $00, $30, $36, $0c, $00, $00, $00
136b1     A5 DB 36 08 
136b5     3C 3C 00 FF 
136b9     00 FF 58 66 
136bd     FC FE 18 0F | 	byte	$a5, $db, $36, $08, $3c, $3c, $00, $ff, $00, $ff, $58, $66, $fc, $fe, $18, $0f
136c1     78 7E 66 DB 
136c5     1C 00 7E 7E 
136c9     18 00 00 00 
136cd     00 08 7F 00 | 	byte	$78, $7e, $66, $db, $1c, $00, $7e, $7e, $18, $00, $00, $00, $00, $08, $7f, $00
136d1     3C 24 36 43 
136d5     43 36 06 0C 
136d9     30 00 00 00 
136dd     00 00 40 63 | 	byte	$3c, $24, $36, $43, $43, $36, $06, $0c, $30, $00, $00, $00, $00, $00, $40, $63
136e1     1E 60 60 3C 
136e5     03 03 60 63 
136e9     63 18 18 30 
136ed     00 0C 63 63 | 	byte	$1e, $60, $60, $3c, $03, $03, $60, $63, $63, $18, $18, $30, $00, $0c, $63, $63
136f1     36 66 43 66 
136f5     46 46 43 63 
136f9     18 30 66 06 
136fd     7F 6F 63 66 | 	byte	$36, $66, $43, $66, $46, $46, $43, $63, $18, $30, $66, $06, $7f, $6f, $63, $66
13701     63 66 63 5A 
13705     63 63 63 36 
13709     66 61 0C 03 
1370d     30 00 00 00 | 	byte	$63, $66, $63, $5a, $63, $63, $63, $36, $66, $61, $0c, $03, $30, $00, $00, $00
13711     00 06 00 30 
13715     00 26 00 06 
13719     00 00 06 18 
1371d     00 00 00 00 | 	byte	$00, $06, $00, $30, $00, $26, $00, $06, $00, $00, $06, $18, $00, $00, $00, $00
13721     00 00 00 0C 
13725     00 00 00 00 
13729     00 00 18 18 
1372d     18 00 08 43 | 	byte	$00, $00, $00, $0c, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $08, $43
13731     00 00 00 00 
13735     00 00       | 	byte	$00[6]
13737     3C 00 00 00 
1373b     00 00 00 1C 
1373f     1C 7F 00 33 
13743     00 00 00 00 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $1c, $1c, $7f, $00, $33, $00, $00, $00, $00
13747     00 00 63 63 
1374b     66 06 3C 1F 
1374f     18 00 00 00 
13753     00 00 67 7C | 	byte	$00, $00, $63, $63, $66, $06, $3c, $1f, $18, $00, $00, $00, $00, $00, $67, $7c
13757     1C 00 00 00 
1375b     63 63 00 00 
1375f     00 88 AA BB 
13763     18 18 18 6C | 	byte	$1c, $00, $00, $00, $63, $63, $00, $00, $00, $88, $aa, $bb, $18, $18, $18, $6c
13767     00 00 6C 6C 
1376b     00 6C 6C 18 
1376f     00 18 18 00 
13773     18 00 18 18 | 	byte	$00, $00, $6c, $6c, $00, $6c, $6c, $18, $00, $18, $18, $00, $18, $00, $18, $18
13777     6C 6C 00 6C 
1377b     00 6C 00 6C 
1377f     18 6C 00 00 
13783     6C 18 00 00 | 	byte	$6c, $6c, $00, $6c, $00, $6c, $00, $6c, $18, $6c, $00, $00, $6c, $18, $00, $00
13787     6C 18 18 00 
1378b     FF 00 0F F0 
1378f     FF 00 33 63 
13793     7F 63 00 66 | 	byte	$6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $00, $33, $63, $7f, $63, $00, $66
13797     6E 18 36 63 
1379b     18 00 60 06 
1379f     63 7F 18 18 
137a3     18 D8 18 18 | 	byte	$6e, $18, $36, $63, $18, $00, $60, $06, $63, $7f, $18, $18, $18, $d8, $18, $18
137a7     00 1C 00 00 
137ab     30 36 06 3E 
137af     00 00 81 FF 
137b3     7F 1C 3C 7E | 	byte	$00, $1c, $00, $00, $30, $36, $06, $3e, $00, $00, $81, $ff, $7f, $1c, $3c, $7e
137b7     00 FF 3C C3 
137bb     4C 66 0C C6 
137bf     DB 1F 7C 18 
137c3     66 DB 36 00 | 	byte	$00, $ff, $3c, $c3, $4c, $66, $0c, $c6, $db, $1f, $7c, $18, $66, $db, $36, $00
137c7     18 18 18 18 
137cb     0C 00 14 1C 
137cf     7F 00 3C 00 
137d3     7F 03 63 1C | 	byte	$18, $18, $18, $18, $0c, $00, $14, $1c, $7f, $00, $3c, $00, $7f, $03, $63, $1c
137d7     00 0C 30 66 
137db     18 00 00 00 
137df     60 63 18 30 
137e3     60 36 03 03 | 	byte	$00, $0c, $30, $66, $18, $00, $00, $00, $60, $63, $18, $30, $60, $36, $03, $03
137e7     60 63 63 18 
137eb     18 18 7E 18 
137ef     30 63 63 66 
137f3     03 66 16 16 | 	byte	$60, $63, $63, $18, $18, $18, $7e, $18, $30, $63, $63, $66, $03, $66, $16, $16
137f7     03 63 18 30 
137fb     36 06 7F 7F 
137ff     63 66 63 66 
13803     06 18 63 63 | 	byte	$03, $63, $18, $30, $36, $06, $7f, $7f, $63, $66, $63, $66, $06, $18, $63, $63
13807     63 3E 66 30 
1380b     0C 07 30 00 
1380f     00 00 1E 1E 
13813     3E 3C 3E 06 | 	byte	$63, $3e, $66, $30, $0c, $07, $30, $00, $00, $00, $1e, $1e, $3e, $3c, $3e, $06
13817     6E 36 1C 70 
1381b     66 18 37 3B 
1381f     3E 3B 6E 3B 
13823     3E 3F 33 66 | 	byte	$6e, $36, $1c, $70, $66, $18, $37, $3b, $3e, $3b, $6e, $3b, $3e, $3f, $33, $66
13827     63 63 63 7F 
1382b     18 18 18 00 
1382f     1C 03 33 3E 
13833     1E 1E 1E 1E | 	byte	$63, $63, $63, $7f, $18, $18, $18, $00, $1c, $03, $33, $3e, $1e, $1e, $1e, $1e
13837     66 3E 3E 3E 
1383b     1C 1C 1C 36 
1383f     36 66 33 33 
13843     3E 3E 3E 33 | 	byte	$66, $3e, $3e, $3e, $1c, $1c, $1c, $36, $36, $66, $33, $33, $3e, $3e, $3e, $33
13847     33 63 63 63 
1384b     06 0F 18 23 
1384f     18 1E 1C 3E 
13853     33 3B 6F 00 | 	byte	$33, $63, $63, $63, $06, $0f, $18, $23, $18, $1e, $1c, $3e, $33, $3b, $6f, $00
13857     00 0C 00 00 
1385b     33 33 18 6C 
1385f     1B 22 55 EE 
13863     18 18 1F 6C | 	byte	$00, $0c, $00, $00, $33, $33, $18, $6c, $1b, $22, $55, $ee, $18, $18, $1f, $6c
13867     00 1F 6F 6C 
1386b     7F 6F 6C 1F 
1386f     00 18 18 00 
13873     18 00 18 F8 | 	byte	$00, $1f, $6f, $6c, $7f, $6f, $6c, $1f, $00, $18, $18, $00, $18, $00, $18, $f8
13877     6C EC FC EF 
1387b     FF EC FF EF 
1387f     FF 6C FF 00 
13883     6C F8 F8 00 | 	byte	$6c, $ec, $fc, $ef, $ff, $ec, $ff, $ef, $ff, $6c, $ff, $00, $6c, $f8, $f8, $00
13887     6C FF 18 00 
1388b     FF 00 0F F0 
1388f     FF 6E 33 03 
13893     36 06 7E 66 | 	byte	$6c, $ff, $18, $00, $ff, $00, $0f, $f0, $ff, $6e, $33, $03, $36, $06, $7e, $66
13897     3B 3C 63 63 
1389b     30 7E 7E 06 
1389f     63 00 18 30 
138a3     0C 18 18 18 | 	byte	$3b, $3c, $63, $63, $30, $7e, $7e, $06, $63, $00, $18, $30, $0c, $18, $18, $18
138a7     6E 00 00 00 
138ab     30 36 13 3E 
138af     00 00 81 FF 
138b3     7F 3E E7 FF | 	byte	$6e, $00, $00, $00, $30, $36, $13, $3e, $00, $00, $81, $ff, $7f, $3e, $e7, $ff
138b7     18 E7 66 99 
138bb     1E 66 0C C6 
138bf     3C 7F 7F 18 
138c3     66 DE 63 00 | 	byte	$18, $e7, $66, $99, $1e, $66, $0c, $c6, $3c, $7f, $7f, $18, $66, $de, $63, $00
138c7     18 18 18 30 
138cb     06 03 36 1C 
138cf     3E 00 18 00 
138d3     36 3E 30 6E | 	byte	$18, $18, $18, $30, $06, $03, $36, $1c, $3e, $00, $18, $00, $36, $3e, $30, $6e
138d7     00 0C 30 3C 
138db     18 00 00 00 
138df     30 6B 18 18 
138e3     3C 33 3F 3F | 	byte	$00, $0c, $30, $3c, $18, $00, $00, $00, $30, $6b, $18, $18, $3c, $33, $3f, $3f
138e7     30 3E 7E 00 
138eb     00 0C 00 30 
138ef     18 7B 63 3E 
138f3     03 66 1E 1E | 	byte	$30, $3e, $7e, $00, $00, $0c, $00, $30, $18, $7b, $63, $3e, $03, $66, $1e, $1e
138f7     03 7F 18 30 
138fb     1E 06 6B 7B 
138ff     63 3E 63 3E 
13903     1C 18 63 63 | 	byte	$03, $7f, $18, $30, $1e, $06, $6b, $7b, $63, $3e, $63, $3e, $1c, $18, $63, $63
13907     6B 1C 3C 18 
1390b     0C 0E 30 00 
1390f     00 00 30 36 
13913     63 36 63 0F | 	byte	$6b, $1c, $3c, $18, $0c, $0e, $30, $00, $00, $00, $30, $36, $63, $36, $63, $0f
13917     33 6E 18 60 
1391b     36 18 7F 66 
1391f     63 66 33 6E 
13923     63 0C 33 66 | 	byte	$33, $6e, $18, $60, $36, $18, $7f, $66, $63, $66, $33, $6e, $63, $0c, $33, $66
13927     63 36 63 33 
1392b     0E 00 70 00 
1392f     36 03 33 63 
13933     30 30 30 30 | 	byte	$63, $36, $63, $33, $0e, $00, $70, $00, $36, $03, $33, $63, $30, $30, $30, $30
13937     06 63 63 63 
1393b     18 18 18 63 
1393f     63 06 6E 7F 
13943     63 63 63 33 | 	byte	$06, $63, $63, $63, $18, $18, $18, $63, $63, $06, $6e, $7f, $63, $63, $63, $33
13947     33 63 63 63 
1394b     06 06 7E 33 
1394f     7E 30 18 63 
13953     33 66 7F 7E | 	byte	$33, $63, $63, $63, $06, $06, $7e, $33, $7e, $30, $18, $63, $33, $66, $7f, $7e
13957     3E 0C 7F 7F 
1395b     18 18 18 36 
1395f     36 88 AA BB 
13963     18 18 18 6C | 	byte	$3e, $0c, $7f, $7f, $18, $18, $18, $36, $36, $88, $aa, $bb, $18, $18, $18, $6c
13967     00 18 60 6C 
1396b     60 60 6C 18 
1396f     00 18 18 00 
13973     18 00 18 18 | 	byte	$00, $18, $60, $6c, $60, $60, $6c, $18, $00, $18, $18, $00, $18, $00, $18, $18
13977     6C 0C 0C 00 
1397b     00 0C 00 00 
1397f     00 6C 00 00 
13983     6C 18 18 00 | 	byte	$6c, $0c, $0c, $00, $00, $0c, $00, $00, $00, $6c, $00, $00, $6c, $18, $18, $00
13987     6C 18 18 00 
1398b     FF 00 0F F0 
1398f     FF 3B 1B 03 
13993     36 0C 1B 66 | 	byte	$6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $3b, $1b, $03, $36, $0c, $1b, $66
13997     18 66 63 63 
1399b     7C DB DB 3E 
1399f     63 00 7E 60 
139a3     06 18 18 00 | 	byte	$18, $66, $63, $63, $7c, $db, $db, $3e, $63, $00, $7e, $60, $06, $18, $18, $00
139a7     3B 00 00 00 
139ab     30 36 1F 3E 
139af     00 00 BD C3 
139b3     7F 7F E7 FF | 	byte	$3b, $00, $00, $00, $30, $36, $1f, $3e, $00, $00, $bd, $c3, $7f, $7f, $e7, $ff
139b7     3C C3 42 BD 
139bb     33 3C 0C C6 
139bf     E7 1F 7C 18 
139c3     66 D8 63 00 | 	byte	$3c, $c3, $42, $bd, $33, $3c, $0c, $c6, $e7, $1f, $7c, $18, $66, $d8, $63, $00
139c7     18 18 18 7F 
139cb     7F 03 7F 3E 
139cf     3E 00 18 00 
139d3     36 60 18 3B | 	byte	$18, $18, $18, $7f, $7f, $03, $7f, $3e, $3e, $00, $18, $00, $36, $60, $18, $3b
139d7     00 0C 30 FF 
139db     7E 00 7F 00 
139df     18 6B 18 0C 
139e3     60 7F 60 63 | 	byte	$00, $0c, $30, $ff, $7e, $00, $7f, $00, $18, $6b, $18, $0c, $60, $7f, $60, $63
139e7     18 63 60 00 
139eb     00 06 00 60 
139ef     18 7B 7F 66 
139f3     03 66 16 16 | 	byte	$18, $63, $60, $00, $00, $06, $00, $60, $18, $7b, $7f, $66, $03, $66, $16, $16
139f7     7B 63 18 30 
139fb     1E 06 63 73 
139ff     63 06 63 36 
13a03     30 18 63 63 | 	byte	$7b, $63, $18, $30, $1e, $06, $63, $73, $63, $06, $63, $36, $30, $18, $63, $63
13a07     6B 1C 18 0C 
13a0b     0C 1C 30 00 
13a0f     00 00 3E 66 
13a13     03 33 7F 06 | 	byte	$6b, $1c, $18, $0c, $0c, $1c, $30, $00, $00, $00, $3e, $66, $03, $33, $7f, $06
13a17     33 66 18 60 
13a1b     1E 18 6B 66 
13a1f     63 66 33 66 
13a23     06 0C 33 66 | 	byte	$33, $66, $18, $60, $1e, $18, $6b, $66, $63, $66, $33, $66, $06, $0c, $33, $66
13a27     6B 1C 63 18 
13a2b     18 18 18 00 
13a2f     63 03 33 7F 
13a33     3E 3E 3E 3E | 	byte	$6b, $1c, $63, $18, $18, $18, $18, $00, $63, $03, $33, $7f, $3e, $3e, $3e, $3e
13a37     06 7F 7F 7F 
13a3b     18 18 18 63 
13a3f     63 3E 6C 33 
13a43     63 63 63 33 | 	byte	$06, $7f, $7f, $7f, $18, $18, $18, $63, $63, $3e, $6c, $33, $63, $63, $63, $33
13a47     33 63 63 63 
13a4b     06 06 18 7B 
13a4f     18 3E 18 63 
13a53     33 66 7B 00 | 	byte	$33, $63, $63, $63, $06, $06, $18, $7b, $18, $3e, $18, $63, $33, $66, $7b, $00
13a57     00 06 03 60 
13a5b     0C 0C 18 1B 
13a5f     6C 22 55 EE 
13a63     18 1F 1F 6F | 	byte	$00, $06, $03, $60, $0c, $0c, $18, $1b, $6c, $22, $55, $ee, $18, $1f, $1f, $6f
13a67     7F 1F 6F 6C 
13a6b     6F 7F 7F 1F 
13a6f     1F F8 FF FF 
13a73     F8 FF FF F8 | 	byte	$7f, $1f, $6f, $6c, $6f, $7f, $7f, $1f, $1f, $f8, $ff, $ff, $f8, $ff, $ff, $f8
13a77     EC FC EC FF 
13a7b     EF EC FF EF 
13a7f     FF FF FF FF 
13a83     FC F8 F8 FC | 	byte	$ec, $fc, $ec, $ff, $ef, $ec, $ff, $ef, $ff, $ff, $ff, $ff, $fc, $f8, $f8, $fc
13a87     FF FF 1F F8 
13a8b     FF FF 0F F0 
13a8f     00 1B 33 03 
13a93     36 18 1B 66 | 	byte	$ff, $ff, $1f, $f8, $ff, $ff, $0f, $f0, $00, $1b, $33, $03, $36, $18, $1b, $66
13a97     18 66 7F 36 
13a9b     66 DB DB 06 
13a9f     63 7F 18 30 
13aa3     0C 18 18 7E | 	byte	$18, $66, $7f, $36, $66, $db, $db, $06, $63, $7f, $18, $30, $0c, $18, $18, $7e
13aa7     00 00 18 00 
13aab     37 00 00 3E 
13aaf     00 00 99 E7 
13ab3     7F 3E E7 7E | 	byte	$00, $00, $18, $00, $37, $00, $00, $3e, $00, $00, $99, $e7, $7f, $3e, $e7, $7e
13ab7     3C C3 42 BD 
13abb     33 18 0C C6 
13abf     3C 0F 78 7E 
13ac3     66 D8 36 7F | 	byte	$3c, $c3, $42, $bd, $33, $18, $0c, $c6, $3c, $0f, $78, $7e, $66, $d8, $36, $7f
13ac7     7E 18 18 30 
13acb     06 03 36 3E 
13acf     1C 00 18 00 
13ad3     36 60 0C 33 | 	byte	$7e, $18, $18, $30, $06, $03, $36, $3e, $1c, $00, $18, $00, $36, $60, $0c, $33
13ad7     00 0C 30 3C 
13adb     18 00 00 00 
13adf     0C 63 18 06 
13ae3     60 30 60 63 | 	byte	$00, $0c, $30, $3c, $18, $00, $00, $00, $0c, $63, $18, $06, $60, $30, $60, $63
13ae7     0C 63 60 00 
13aeb     00 0C 7E 30 
13aef     18 7B 63 66 
13af3     03 66 06 06 | 	byte	$0c, $63, $60, $00, $00, $0c, $7e, $30, $18, $7b, $63, $66, $03, $66, $06, $06
13af7     63 63 18 33 
13afb     36 06 63 63 
13aff     63 06 63 66 
13b03     60 18 63 63 | 	byte	$63, $63, $18, $33, $36, $06, $63, $63, $63, $06, $63, $66, $60, $18, $63, $63
13b07     6B 3E 18 06 
13b0b     0C 38 30 00 
13b0f     00 00 33 66 
13b13     03 33 03 06 | 	byte	$6b, $3e, $18, $06, $0c, $38, $30, $00, $00, $00, $33, $66, $03, $33, $03, $06
13b17     33 66 18 60 
13b1b     1E 18 6B 66 
13b1f     63 66 33 06 
13b23     1C 0C 33 66 | 	byte	$33, $66, $18, $60, $1e, $18, $6b, $66, $63, $66, $33, $06, $1c, $0c, $33, $66
13b27     6B 1C 63 0C 
13b2b     18 18 18 00 
13b2f     63 43 33 03 
13b33     33 33 33 33 | 	byte	$6b, $1c, $63, $0c, $18, $18, $18, $00, $63, $43, $33, $03, $33, $33, $33, $33
13b37     66 03 03 03 
13b3b     18 18 18 7F 
13b3f     7F 06 7E 33 
13b43     63 63 63 33 | 	byte	$66, $03, $03, $03, $18, $18, $18, $7f, $7f, $06, $7e, $33, $63, $63, $63, $33
13b47     33 63 63 63 
13b4b     66 06 7E 33 
13b4f     18 33 18 63 
13b53     33 66 73 00 | 	byte	$33, $63, $63, $63, $66, $06, $7e, $33, $18, $33, $18, $63, $33, $66, $73, $00
13b57     00 03 03 60 
13b5b     06 66 3C 36 
13b5f     36 88 AA BB 
13b63     18 18 18 6C | 	byte	$00, $03, $03, $60, $06, $66, $3c, $36, $36, $88, $aa, $bb, $18, $18, $18, $6c
13b67     6C 18 6C 6C 
13b6b     6C 00 00 00 
13b6f     18 00 00 18 
13b73     18 00 18 18 | 	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
13b77     6C 00 6C 00 
13b7b     6C 6C 00 6C 
13b7f     00 00 18 6C 
13b83     00 00 18 6C | 	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
13b87     6C 18 00 18 
13b8b     FF FF 0F F0 
13b8f     00 1B 63 03 
13b93     36 0C 1B 66 | 	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $1b, $63, $03, $36, $0c, $1b, $66
13b97     18 66 63 36 
13b9b     66 DB CF 06 
13b9f     63 00 18 18 
13ba3     18 18 1B 00 | 	byte	$18, $66, $63, $36, $66, $db, $cf, $06, $63, $00, $18, $18, $18, $18, $1b, $00
13ba7     6E 00 18 18 
13bab     36 00 00 3E 
13baf     00 00 81 FF 
13bb3     3E 1C 18 18 | 	byte	$6e, $00, $18, $18, $36, $00, $00, $3e, $00, $00, $81, $ff, $3e, $1c, $18, $18
13bb7     18 E7 66 99 
13bbb     33 7E 0E E6 
13bbf     DB 07 70 3C 
13bc3     00 D8 1C 7F | 	byte	$18, $e7, $66, $99, $33, $7e, $0e, $e6, $db, $07, $70, $3c, $00, $d8, $1c, $7f
13bc7     3C 18 7E 18 
13bcb     0C 7F 14 7F 
13bcf     1C 00 00 00 
13bd3     7F 61 06 33 | 	byte	$3c, $18, $7e, $18, $0c, $7f, $14, $7f, $1c, $00, $00, $00, $7f, $61, $06, $33
13bd7     00 0C 30 66 
13bdb     18 18 00 00 
13bdf     06 63 18 03 
13be3     60 30 60 63 | 	byte	$00, $0c, $30, $66, $18, $18, $00, $00, $06, $63, $18, $03, $60, $30, $60, $63
13be7     0C 63 60 18 
13beb     18 18 00 18 
13bef     00 3B 63 66 
13bf3     43 66 46 06 | 	byte	$0c, $63, $60, $18, $18, $18, $00, $18, $00, $3b, $63, $66, $43, $66, $46, $06
13bf7     63 63 18 33 
13bfb     66 46 63 63 
13bff     63 06 6B 66 
13c03     63 18 63 36 | 	byte	$63, $63, $18, $33, $66, $46, $63, $63, $63, $06, $6b, $66, $63, $18, $63, $36
13c07     7F 36 18 43 
13c0b     0C 70 30 00 
13c0f     00 00 33 66 
13c13     03 33 03 06 | 	byte	$7f, $36, $18, $43, $0c, $70, $30, $00, $00, $00, $33, $66, $03, $33, $03, $06
13c17     33 66 18 60 
13c1b     36 18 6B 66 
13c1f     63 66 33 06 
13c23     30 0C 33 66 | 	byte	$33, $66, $18, $60, $36, $18, $6b, $66, $63, $66, $33, $06, $30, $0c, $33, $66
13c27     6B 1C 63 06 
13c2b     18 18 18 00 
13c2f     63 66 33 03 
13c33     33 33 33 33 | 	byte	$6b, $1c, $63, $06, $18, $18, $18, $00, $63, $66, $33, $03, $33, $33, $33, $33
13c37     3C 03 03 03 
13c3b     18 18 18 63 
13c3f     63 06 1B 33 
13c43     63 63 63 33 | 	byte	$3c, $03, $03, $03, $18, $18, $18, $63, $63, $06, $1b, $33, $63, $63, $63, $33
13c47     33 63 63 63 
13c4b     3C 06 18 33 
13c4f     18 33 18 63 
13c53     33 66 63 00 | 	byte	$33, $63, $63, $63, $3c, $06, $18, $33, $18, $33, $18, $63, $33, $66, $63, $00
13c57     00 63 03 60 
13c5b     3B 73 3C 6C 
13c5f     1B 22 55 EE 
13c63     18 18 18 6C | 	byte	$00, $63, $03, $60, $3b, $73, $3c, $6c, $1b, $22, $55, $ee, $18, $18, $18, $6c
13c67     6C 18 6C 6C 
13c6b     6C 00 00 00 
13c6f     18 00 00 18 
13c73     18 00 18 18 | 	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
13c77     6C 00 6C 00 
13c7b     6C 6C 00 6C 
13c7f     00 00 18 6C 
13c83     00 00 18 6C | 	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
13c87     6C 18 00 18 
13c8b     FF FF 0F F0 
13c8f     00 1B 63 03 
13c93     36 06 1B 3E | 	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $1b, $63, $03, $36, $06, $1b, $3e
13c97     18 3C 63 36 
13c9b     66 7E 7E 06 
13c9f     63 00 00 0C 
13ca3     30 18 1B 18 | 	byte	$18, $3c, $63, $36, $66, $7e, $7e, $06, $63, $00, $00, $0c, $30, $18, $1b, $18
13ca7     3B 00 00 00 
13cab     36 00 00 3E 
13caf     00 00 81 FF 
13cb3     1C 08 18 18 | 	byte	$3b, $00, $00, $00, $36, $00, $00, $3e, $00, $00, $81, $ff, $1c, $08, $18, $18
13cb7     00 FF 3C C3 
13cbb     33 18 0F E7 
13cbf     18 03 60 18 
13cc3     66 D8 30 7F | 	byte	$00, $ff, $3c, $c3, $33, $18, $0f, $e7, $18, $03, $60, $18, $66, $d8, $30, $7f
13cc7     18 18 3C 00 
13ccb     00 00 00 7F 
13ccf     08 00 18 00 
13cd3     36 63 63 33 | 	byte	$18, $18, $3c, $00, $00, $00, $00, $7f, $08, $00, $18, $00, $36, $63, $63, $33
13cd7     00 18 18 00 
13cdb     00 18 00 18 
13cdf     03 36 18 63 
13ce3     63 30 63 63 | 	byte	$00, $18, $18, $00, $00, $18, $00, $18, $03, $36, $18, $63, $63, $30, $63, $63
13ce7     0C 63 30 18 
13ceb     18 30 00 0C 
13cef     18 03 63 66 
13cf3     66 36 66 06 | 	byte	$0c, $63, $30, $18, $18, $30, $00, $0c, $18, $03, $63, $66, $66, $36, $66, $06
13cf7     66 63 18 33 
13cfb     66 66 63 63 
13cff     63 06 7B 66 
13d03     63 18 63 1C | 	byte	$66, $63, $18, $33, $66, $66, $63, $63, $63, $06, $7b, $66, $63, $18, $63, $1c
13d07     77 63 18 63 
13d0b     0C 60 30 00 
13d0f     00 00 33 66 
13d13     63 33 63 06 | 	byte	$77, $63, $18, $63, $0c, $60, $30, $00, $00, $00, $33, $66, $63, $33, $63, $06
13d17     33 66 18 60 
13d1b     66 18 6B 66 
13d1f     63 66 33 06 
13d23     63 6C 33 3C | 	byte	$33, $66, $18, $60, $66, $18, $6b, $66, $63, $66, $33, $06, $63, $6c, $33, $3c
13d27     7F 36 63 63 
13d2b     18 18 18 00 
13d2f     7F 3C 33 63 
13d33     33 33 33 33 | 	byte	$7f, $36, $63, $63, $18, $18, $18, $00, $7f, $3c, $33, $63, $33, $33, $33, $33
13d37     30 63 63 63 
13d3b     18 18 18 63 
13d3f     63 66 1B 33 
13d43     63 63 63 33 | 	byte	$30, $63, $63, $63, $18, $18, $18, $63, $63, $66, $1b, $33, $63, $63, $63, $33
13d47     33 63 63 63 
13d4b     18 67 18 33 
13d4f     18 33 18 63 
13d53     33 66 63 00 | 	byte	$33, $63, $63, $63, $18, $67, $18, $33, $18, $33, $18, $63, $33, $66, $63, $00
13d57     00 63 03 60 
13d5b     61 79 3C 00 
13d5f     00 88 AA BB 
13d63     18 18 18 6C | 	byte	$00, $63, $03, $60, $61, $79, $3c, $00, $00, $88, $aa, $bb, $18, $18, $18, $6c
13d67     6C 18 6C 6C 
13d6b     6C 00 00 00 
13d6f     18 00 00 18 
13d73     18 00 18 18 | 	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
13d77     6C 00 6C 00 
13d7b     6C 6C 00 6C 
13d7f     00 00 18 6C 
13d83     00 00 18 6C | 	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
13d87     6C 18 00 18 
13d8b     FF FF 0F F0 
13d8f     00 3B 63 03 
13d93     36 63 1B 06 | 	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $3b, $63, $03, $36, $63, $1b, $06
13d97     18 18 36 36 
13d9b     66 00 06 0C 
13d9f     63 7F 00 00 
13da3     00 18 1B 18 | 	byte	$18, $18, $36, $36, $66, $00, $06, $0c, $63, $7f, $00, $00, $00, $18, $1b, $18
13da7     00 00 00 00 
13dab     3C 00 00 3E 
13daf     00 00 7E 7E 
13db3     08 00 3C 3C | 	byte	$00, $00, $00, $00, $3c, $00, $00, $3e, $00, $00, $7e, $7e, $08, $00, $3c, $3c
13db7     00 FF 00 FF 
13dbb     1E 18 07 67 
13dbf     18 01 40 00 
13dc3     66 D8 63 7F | 	byte	$00, $ff, $00, $ff, $1e, $18, $07, $67, $18, $01, $40, $00, $66, $d8, $63, $7f
13dc7     7E 18 18 00 
13dcb     00 00 00 00 
13dcf     00 00 18 00 
13dd3     36 3E 61 6E | 	byte	$7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $00, $36, $3e, $61, $6e
13dd7     00 30 0C 00 
13ddb     00 18 00 18 
13ddf     01 1C 7E 7F 
13de3     3E 78 3E 3E | 	byte	$00, $30, $0c, $00, $00, $18, $00, $18, $01, $1c, $7e, $7f, $3e, $78, $3e, $3e
13de7     0C 3E 1E 00 
13deb     0C 60 00 06 
13def     18 3E 63 3F 
13df3     3C 1F 7F 0F | 	byte	$0c, $3e, $1e, $00, $0c, $60, $00, $06, $18, $3e, $63, $3f, $3c, $1f, $7f, $0f
13df7     5C 63 3C 1E 
13dfb     67 7F 63 63 
13dff     3E 0F 3E 67 
13e03     3E 3C 3E 08 | 	byte	$5c, $63, $3c, $1e, $67, $7f, $63, $63, $3e, $0f, $3e, $67, $3e, $3c, $3e, $08
13e07     36 63 3C 7F 
13e0b     3C 40 3C 00 
13e0f     00 00 6E 3E 
13e13     3E 6E 3E 0F | 	byte	$36, $63, $3c, $7f, $3c, $40, $3c, $00, $00, $00, $6e, $3e, $3e, $6e, $3e, $0f
13e17     3E 67 3C 60 
13e1b     67 3C 63 66 
13e1f     3E 3E 3E 0F 
13e23     3E 38 6E 18 | 	byte	$3e, $67, $3c, $60, $67, $3c, $63, $66, $3e, $3e, $3e, $0f, $3e, $38, $6e, $18
13e27     36 63 7E 7F 
13e2b     70 18 0E 00 
13e2f     00 30 6E 3E 
13e33     6E 6E 6E 6E | 	byte	$36, $63, $7e, $7f, $70, $18, $0e, $00, $00, $30, $6e, $3e, $6e, $6e, $6e, $6e
13e37     60 3E 3E 3E 
13e3b     3C 3C 3C 63 
13e3f     63 7F 76 73 
13e43     3E 3E 3E 6E | 	byte	$60, $3e, $3e, $3e, $3c, $3c, $3c, $63, $63, $7f, $76, $73, $3e, $3e, $3e, $6e
13e47     6E 7E 3E 3E 
13e4b     18 3F 18 63 
13e4f     18 6E 3C 3E 
13e53     6E 66 63 00 | 	byte	$6e, $7e, $3e, $3e, $18, $3f, $18, $63, $18, $6e, $3c, $3e, $6e, $66, $63, $00
13e57     00 3E 00 00 
13e5b     30 7C 18 00 
13e5f     00 22 55 EE 
13e63     18 18 18 6C | 	byte	$00, $3e, $00, $00, $30, $7c, $18, $00, $00, $22, $55, $ee, $18, $18, $18, $6c
13e67     6C 18 6C 6C 
13e6b     6C 00 00 00 
13e6f     18 00 00 18 
13e73     18 00 18 18 | 	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
13e77     6C 00 6C 00 
13e7b     6C 6C 00 6C 
13e7f     00 00 18 6C 
13e83     00 00 18 6C | 	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
13e87     6C 18 00 18 
13e8b     FF FF 0F F0 
13e8f     00 6E 33 03 
13e93     36 7F 0E 06 | 	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $6e, $33, $03, $36, $7f, $0e, $06
13e97     18 7E 1C 77 
13e9b     3C 00 03 38 
13e9f     63 00 FF 7E 
13ea3     7E 18 0E 00 | 	byte	$18, $7e, $1c, $77, $3c, $00, $03, $38, $63, $00, $ff, $7e, $7e, $18, $0e, $00
13ea7     00 00 00 00 
13eab     38 00 00 00 
13eaf     00 00 00 00 
13eb3     00 00 00 00 | 	byte	$00, $00, $00, $00, $38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
13eb7     00 FF 00 FF 
13ebb     00 00 00 03 
13ebf     00 00 00 00 
13ec3     00 00 3E 00 | 	byte	$00, $ff, $00, $ff, $00, $00, $00, $03, $00, $00, $00, $00, $00, $00, $3e, $00
13ec7     00 00 00 00 
13ecb     00 00 00 00 
13ecf     00 00 00 00 
13ed3     00          | 	byte	$00[13]
13ed4     18 00 00 00 
13ed8     00 00 00 00 
13edc     0C 00 00 00 
13ee0     00 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $0c, $00, $00, $00, $00, $00, $00, $00
13ee4     00 00 00 00 
      ...             
13efc     00 00 00 00 
13f00     00          | 	byte	$00[29]
13f01     30 00 00 00 
13f05     00 00 00 00 
13f09     00 00 00 00 
13f0d     00 00 00 00 | 	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
13f11     00 00 00 00 
13f15     00 00       | 	byte	$00[6]
13f17     30 00 00 66 
13f1b     00 00 00 00 
13f1f     00 06 30 00 
13f23     00 00 00 00 | 	byte	$30, $00, $00, $66, $00, $00, $00, $00, $00, $06, $30, $00, $00, $00, $00, $00
13f27     00 00 60 00 
13f2b     00 00 00 00 
13f2f     00 60 00 00 
13f33     00 00 00 00 | 	byte	$00, $00, $60, $00, $00, $00, $00, $00, $00, $60, $00, $00, $00, $00, $00, $00
13f37     3C 00 00 00 
13f3b     00 00 00 00 
13f3f     00 00 00 00 
13f43     00 00 00 00 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
13f47     00 60 00 00 
13f4b     00 00 00 00 
13f4f     1B 00 00 00 
13f53     00 00 00 00 | 	byte	$00, $60, $00, $00, $00, $00, $00, $00, $1b, $00, $00, $00, $00, $00, $00, $00
13f57     00 00 00 00 
13f5b     18 60 00 00 
13f5f     00 88 AA BB 
13f63     18 18 18 6C | 	byte	$00, $00, $00, $00, $18, $60, $00, $00, $00, $88, $aa, $bb, $18, $18, $18, $6c
13f67     6C 18 6C 6C 
13f6b     6C 00 00 00 
13f6f     18 00 00 18 
13f73     18 00 18 18 | 	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
13f77     6C 00 6C 00 
13f7b     6C 6C 00 6C 
13f7f     00 00 18 6C 
13f83     00 00 18 6C | 	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
13f87     6C 18 00 18 
13f8b     FF FF 0F F0 
13f8f     00 00 00 00 
13f93     00 00 00 03 | 	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $00, $00, $00, $00, $00, $00, $03
13f97     00 00 00 00 
13f9b     00 00 00 00 
13f9f     00 00 00 00 
13fa3     00          | 	byte	$00[13]
13fa4     18 00 00 00 
13fa8     00 00 00 00 
13fac     00 00 00 00 
13fb0     00 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
13fb4     00 00 00 00 
13fb8     FF 00 FF 00 
13fbc     00 00 00 00 
13fc0     00 00 00 00 | 	byte	$00, $00, $00, $00, $ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00
13fc4     00 00 00 00 
13fc8     00 00 00 00 
13fcc     00 00 00 00 
13fd0     00 00 00 00 | 	byte	$00[16]
13fd4     18 00 00 00 
13fd8     00 00 00 00 
13fdc     00 00 00 00 
13fe0     00 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
13fe4     00 00 00 00 
      ...             
13ffc     00 00 00 00 
14000     00          | 	byte	$00[29]
14001     70 00 00 00 
14005     00 00 00 00 
14009     00 00 00 00 
1400d     00 00 FF 00 | 	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $00
14011     00 00 00 00 
14015     00 00       | 	byte	$00[6]
14017     33 00 00 66 
1401b     00 00 00 00 
1401f     00 06 30 00 
14023     00 00 00 00 | 	byte	$33, $00, $00, $66, $00, $00, $00, $00, $00, $06, $30, $00, $00, $00, $00, $00
14027     00 00 30 00 
1402b     00 00 00 00 
1402f     00 3E 00 00 
14033     00 00 00 00 | 	byte	$00, $00, $30, $00, $00, $00, $00, $00, $00, $3e, $00, $00, $00, $00, $00, $00
14037     00 00 00 00 
1403b     00 00 00 00 
1403f     00 00 00 00 
14043     00 00 00 00 
14047     00          | 	byte	$00[17]
14048     30 00 00 00 
1404c     00 00 00 0E 
14050     00 00 00 00 
14054     00 00 00 00 | 	byte	$30, $00, $00, $00, $00, $00, $00, $0e, $00, $00, $00, $00, $00, $00, $00, $00
14058     00 00 00 7C 
1405c     60 00 00 00 
14060     22 55 EE 18 
14064     18 18 6C 6C | 	byte	$00, $00, $00, $7c, $60, $00, $00, $00, $22, $55, $ee, $18, $18, $18, $6c, $6c
14068     18 6C 6C 6C 
1406c     00 00 00 18 
14070     00 00 18 18 
14074     00 18 18 6C | 	byte	$18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18, $6c
14078     00 6C 00 6C 
1407c     6C 00 6C 00 
14080     00 18 6C 00 
14084     00 18 6C 6C | 	byte	$00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c, $6c
14088     18 00 18 FF 
1408c     FF 0F F0 00 
14090     00 00 00 00 
14094     00 00 00 00 | 	byte	$18, $00, $18, $ff, $ff, $0f, $f0, $00, $00, $00, $00, $00, $00, $00, $00, $00
14098     00 00 00 00 
1409c     00 00 00 00 
140a0     00 00 00 00 | 	byte	$00[12]
140a4     18 00 00 00 
140a8     00 00 00 00 
140ac     00 00 00 00 
140b0     00 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
140b4     00 00 00 00 
140b8     FF 00 FF 00 
140bc     00 00 00 00 
140c0     00 00 00 00 | 	byte	$00, $00, $00, $00, $ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00
140c4     00 00 00 00 
      ...             
14110     00 00 00 00 
14114     00 00 00    | 	byte	$00[83]
14117     1E 00 00 3C 
1411b     00 00 00 00 
1411f     00 0F 78 00 
14123     00 00 00 00 | 	byte	$1e, $00, $00, $3c, $00, $00, $00, $00, $00, $0f, $78, $00, $00, $00, $00, $00
14127     00 00 1F 00 
1412b     00 00 00 00 
1412f     00 00 00 00 
14133     00 00 00 00 | 	byte	$00, $00, $1f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
14137     00 00 00 00 
1413b     00 00 00 00 
1413f     00 00 00 00 
14143     00 00 00 00 
14147     00          | 	byte	$00[17]
14148     1E 00 00 00 
1414c     00 00 00 00 
14150     00 00 00 00 
14154     00 00 00 00 | 	byte	$1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
14158     00 00 00 00 
1415c     00 00 00 00 | 	byte	$00[8]
14160     88 AA BB 18 
14164     18 18 6C 6C 
14168     18 6C 6C 6C 
1416c     00 00 00 18 | 	byte	$88, $aa, $bb, $18, $18, $18, $6c, $6c, $18, $6c, $6c, $6c, $00, $00, $00, $18
14170     00 00 18 18 
14174     00 18 18 6C 
14178     00 6C 00 6C 
1417c     6C 00 6C 00 | 	byte	$00, $00, $18, $18, $00, $18, $18, $6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00
14180     00 18 6C 00 
14184     00 18 6C 6C 
14188     18 00 18 FF 
1418c     FF 0F F0 00 | 	byte	$00, $18, $6c, $00, $00, $18, $6c, $6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00
14190     00 00 00 00 
14194     00 00 00 00 
14198     00 00 00 00 
1419c     00 00 00 00 
141a0     00 00 00 00 | 	byte	$00[20]
141a4     18 00 00 00 
141a8     00 00 00 00 
141ac     00 00 00 00 
141b0     00 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
141b4     00 00 00 00 
141b8     FF 00 FF 00 
141bc     00 00 00 00 
141c0     00 00 00 00 | 	byte	$00, $00, $00, $00, $ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00
141c4     00 00 00 00 
      ...             
14258     00 00 00 00 
1425c     00 00 00 00 | 	byte	$00[156]
14260     22 55 EE 18 
14264     18 18 6C 6C 
14268     18 6C 6C 6C 
1426c     00 00 00 18 | 	byte	$22, $55, $ee, $18, $18, $18, $6c, $6c, $18, $6c, $6c, $6c, $00, $00, $00, $18
14270     00 00 18 18 
14274     00 18 18 6C 
14278     00 6C 00 6C 
1427c     6C 00 6C 00 | 	byte	$00, $00, $18, $18, $00, $18, $18, $6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00
14280     00 18 6C 00 
14284     00 18 6C 6C 
14288     18 00 18 FF 
1428c     FF 0F F0 00 | 	byte	$00, $18, $6c, $00, $00, $18, $6c, $6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00
14290     00 00 00 00 
14294     00 00 00 00 
14298     00 00 00 00 
1429c     00 00 00 00 
142a0     00 00 00 00 | 	byte	$00[20]
142a4     18 00 00 00 
142a8     00 00 00 00 
142ac     00 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
142b0                 | 	alignl
142b0                 | _p2videodrv_dat_
142b0     00 00 00 00 
      ...             
142c8     00 00 00 00 
142cc     00 00 00 00 |     context long  0[MAXCOGS] ' the printing context pointer per COG
142d0                 |             orgh
142d0                 | 
142d0                 | videodriver
142d0                 |             org 0
142d0 000             | 
142d0 000             | '--------------------------------------------------------------------------------------------------
142d0 000             | '
142d0 000             | ' Initial driver entry code, this is also reused later for variable storage
142d0 000             | '
142d0 000             | '--------------------------------------------------------------------------------------------------
142d0 000 F8 01 00 F6 | statusaddr                  mov     statusaddr, ptra        'save ptra as the status address
142d4 001 03 03 04 FB | mailbox                     rdlong  mailbox, ptra[3]        'read mailbox address information
142d8 002 04 05 04 FB | linebuf1                    rdlong  linebuf1, ptra[4]       'extract scan line buffer address
142dc 003 05 07 04 FB | linebuf2                    rdlong  linebuf2, ptra[5]       'extract scan line buffer address
142e0 004 18 F0 07 F1 | linebufsize                 add     ptra, #24               'skip past the init parameters
142e4 005 F8 0B 00 F6 | paramaddr                   mov     paramaddr, ptra         'save pointer to first region data
142e8 006 01 E8 63 FD | regn                        cogid   c                       'get our cog id
142ec 007 01 E6 FB F8 | modedata                    getbyte b, mailbox, #3          'get per COG mailbox spacing in bytes
142f0 008 F3 E5 03 F6 | screenaddr1                 mov     a, b                    'duplicate for later
142f4 009 08 E6 0F FA | screenaddr2                 mul     b, #MAXCOGS wz          'multiply by total number of COGs
142f8 00a F3 03 80 F1 | fontaddr                    sub     mailbox, b              'subtract so instances start from 1
142fc 00b F4 E5 03 FA | paletteaddr                 mul     a, c                    'compute offset for this COG ID
14300 00c 04 E4 07 F1 | cursor1                     add     a, #4                   'add offset for 2nd mailbox entry
14304 00d F2 03 00 F1 | cursor2                     add     mailbox, a              'include offset in mailbox address
14308 00e F3 53 BA F9 | mouse_xy                    sets    extm_test, b            'forces external mem off if no mbox
1430c 00f A0 F3 03 F1 | mouseptr                    add     ptrb, lutoffset         'determine hub address of LUT code
14310 010 29 FE 67 FD | wrap                        setq2   #511                    'read up to 512 instructions
14314 011 80 01 04 FB | skew                        rdlong  $000, ptrb              '...and load into LUT RAM
14318 012 B4 07 90 FD | status                      jmp     #$200                   'continue initialization in LUT RAM
1431c 013             | 
1431c 013             | '--------------------------------------------------------------------------------------------------
1431c 013             | ' Main field/frame generation loop
1431c 013             | '--------------------------------------------------------------------------------------------------
1431c 013             | 
1431c 013             | fieldloop
1431c 013 28 0E 64 FD |                             setq    #8-1                    'read 8 longs from hub
14320 014 05 48 03 FB |                             rdlong  fieldparams, paramaddr  'reload field parameters to COGRAM
14324 015 38 54 63 FD |                             setcy   cy                      'setup the colour space converter
14328 016 39 56 63 FD |                             setci   ci                      'cq is done per scan line (for PAL)
1432c 017 A8 0D 00 F6 |                             mov     regn, regionsize        'setup first region and limit
14330 018 A6 51 33 F9 |                             getword regionsize, borders, #0 'extract top border size
14334 019 10 4C 47 F0 |                             shr     borders, #16            'extract bottom border size
14338 01a A7 E5 E3 F8 |                             getbyte a, brdrcolour, #0       'extract side border size
1433c 01b F2 33 23 F9 |                             setword m_brdr, a, #0           'setup number of side border pixels
14340 01c 9D 31 23 F9 |                             setword m_rf, vis_pixels, #0    'start with default scanline width
14344 01d F2 31 83 F1 |                             sub     m_rf, a                 'adjust for left side border
14348 01e F2 31 83 F1 |                             sub     m_rf, a                 'adjust for right side border
1434c 01f 00 EA 1F F6 |                             mov     d, #0 wcz               'setup d+c,z flags for mouse+region
14350 020 F5 4F C3 F8 |                             setbyte brdrcolour, d, #0       'clear out LSB of border colour
14354 021 F0 00 B0 FD |                             call    #borderregion           'setup region defaults for border
14358 022             | 
14358 022 20 24 DC F8 | writestat1                  setbyte status, #$20, #3        'update status - doing back porch
1435c 023 36 42 4C FB | patchvbp                    callpa  #V_BP-0, #blank-0       'send vertical back porch lines
14360 024             | 
14360 024 02 F2 03 F6 |                             mov     ptrb, linebuf1          'restart line buffer
14364 025 A8 51 CB F7 |                             test    regionsize  wz          'check if a top border is present
14368 026 D8 00 B0 AD |             if_z            call    #newregion              'if not, start a new region
1436c 027 9E ED 03 F6 |                             mov     pa, vis_lines           'set number of visible lines
14370 028 2D 42 63 FD |                             call    videomode               'begin video after last border line
14374 029             | 
14374 029             | lineloop
14374 029 A0 00 B0 FD |                             call    #hsync                  'do horizontal sync
14378 02a             | 
14378 02a 29 1E 64 FD |                             setq2   #15                     'read small palettes at this time
1437c 02b 0B 00 02 FB |                             rdlong  $100, paletteaddr       'read from hub RAM
14380 02c             |             'if_c_and_z      callpb  save, #do_mouse         'c=1, render the mouse after hsync
14380 02c F1 01 78 FC |                             rdfast  #0, save                'setup the streamer read address
14384 02d 01 24 04 F1 |                             add     status, #1
14388 02e             | 
14388 02e A6 ED 0B F2 |                             cmp     pa, borders wz          'check if reached bottom border
1438c 02f 00 50 07 A6 |             if_z            mov     regionsize, #0          'if yes stop further region updates
14390 030 B4 00 B0 AD |             if_z            call    #borderregion           'and go back to border generation
14394 031 FF 32 CF F7 |                             test    m_brdr, #255 wz         'check if we have a side border
14398 032 A7 33 C3 5C |             if_nz           xcont   m_brdr, brdrcolour      'create left border pixels
1439c 033 ED 31 C3 FC |                             xcont   m_rf, palselect         'generate the visible line
143a0 034 A7 33 C3 5C |             if_nz           xcont   m_brdr, brdrcolour      'create right border pixels
143a4 035             | 
143a4 035 01 50 8F F1 |                             sub     regionsize, #1 wz       'decrement the region's size count
143a8 036 98 00 B0 AD |             if_z            call    #newregion              'when 0, reload another region
143ac 037             | 
143ac 037 2D 42 63 FD |                             call    videomode               'create the next video scan line
143b0 038 A2 25 C3 FC |                             xcont   m_bs, hsync0            'generate horizontal FP blanking
143b4 039 EF ED 6F FB |                             djnz    pa, #lineloop           'continue for all active lines
143b8 03a             | 
143b8 03a 40 24 DC F8 | writestat2                  setbyte status, #$40, #3        'update status - doing front porch
143bc 03b 1E 14 4C FB | patchvfp                    callpa  #V_FP-0, #blank         'send vertical front porch lines
143c0 03c             | 
143c0 03c 01 3E 07 F1 |                             add     fieldcount, #1          'increase the field counter
143c4 03d 0F 3E CF F7 |                             test    fieldcount, #15 wz      'check for 16 fields elapsed
143c8 03e FF E0 65 A5 | flasher     if_z            xor     flash, #$ff             'flash text ~2Hz
143cc 03f             | 
143cc 03f             | syncspace                                                   '!! These 18 instructions must be
143cc 03f             |                                                             '...maintained for patching into!
143cc 03f 9B 2F 83 F1 |                             sub     m_vi, m_slim            'reduces blank line width
143d0 040 9B 27 03 F1 | proghd0                     add     m_sn, m_slim            'widens sync (SD)
143d4 041 0F AE 3C F8 | proghd1                     setnib  flipref, #%1111, #7     '...changes back porch (HD)
143d8 042 5F 00 64 FD | vsyncon                     drvnot  #0-0                    '(patched) vsync pin on
143dc 043 3C 40 63 FD |                             setcmod cmodval
143e0 044 8F 45 03 F6 |                             mov     hsync0, sync_001        'vsync on, hsync off
143e4 045 1F 24 C4 F9 |                             decod   status, #31             'update status - in vertical sync
143e8 046 9F 25 D0 F8 |                             setbyte status, fieldcount, #2
143ec 047 8E 47 03 F6 |                             mov     hsync1, sync_000        'vsync on, hsync on
143f0 048             | 
143f0 048 11 04 4C FB | patchvsync                  callpa  #V_SYNC-0, #blank       'send vertical sync blanks
143f4 049 01 40 67 F5 | vsyncoff                    xor     cmodval, #1             'vsync pin off
143f8 04a 3C 40 63 FD |                             setcmod cmodval
143fc 04b 91 45 03 F6 |                             mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
14400 04c 90 47 03 F6 |                             mov     hsync1, sync_002        'vsync off, hsync on
14404 04d 9B 2F 03 F1 |                             add     m_vi, m_slim            'restores blank line width
14408 04e 9B 27 83 F1 | proghd2                     sub     m_sn, m_slim            'restores sync width (SD)
1440c 04f 00 AE 3C F8 | proghd3                     setnib  flipref, #0, #7         '...or restores back porch (HD)
14410 050 00 00 00 00 |                             nop                             'must keep room for 18 instructions!
14414 051             | 
14414 051 04 FF 9F FD |                             jmp     #fieldloop              'continue on to a new field/frame
14418 052             | 
14418 052             | '--------------------------------------------------------------------------------------------------
14418 052             | ' Subroutines
14418 052             | '--------------------------------------------------------------------------------------------------
14418 052             | 
14418 052 A3 27 B3 FC | hsync                       xzero   m_sn, hsync1            'generate the sync pulse
1441c 053 00 24 60 FC |                             wrlong  status, statusaddr      'update the sync status per line
14420 054 A2 29 C3 FC | dobreeze                    xcont   m_br, hsync0            'do breezeway before colour burst
14424 055 3A 52 63 FD |                             setcq   cq                      'reapply CQ for PAL colour changes
14428 056 9C 2B C3 FC | doburst                     xcont   m_cb, colourburst       'do the PAL/NTSC colour burst
1442c 057 A4 53 63 F5 | flipref                     xor     cq, palflipcq           'toggle PAL colour output per scanline
14430 058 A2 2D C3 0C | bp          _ret_           xcont   m_bv, hsync0            'generate the back porch
14434 059             | 
14434 059             | '..................................................................................................
14434 059 A4 53 63 F5 | blank_pal                   xor     cq, palflipcq           'NEEDS TO BE EVEN DIST. FROM patchvbp!
14438 05a DC FF BF FD | blank                       call    #hsync                  'do hsync at the start of the line
1443c 05b A2 2F C3 FC |                             xcont   m_vi, hsync0            'generate blank line pixels
14440 05c FD ED 6F 0B |             _ret_           djnz    pa, #blank              'repeat to generate multiple lines
14444 05d             | 
14444 05d             | '..................................................................................................
14444 05d             | ' Code to reload and setup all configurable parameters per display region
14444 05d             | 
14444 05d 13 0C 4C F7 | newregion                   zerox   regn, #19 wz            'check for any more regions?
14448 05e             | borderregion
14448 05e 01 30 27 A8 |             if_z            setnib  m_rf, #1, #4            'setup streamer for immediate data
1444c 05f 07 30 3F A8 |             if_z            setnib  m_rf, #7, #7            'setup streamer for immediate data
14450 060 59 43 07 A6 |             if_z            mov     videomode, #nullmode
14454 061 A7 DB 03 F6 |                             mov     palselect, brdrcolour   'set default border colour
14458 062 2D 00 7C AD |             if_z            ret     wcz                     'and exit if no more regions
1445c 063             | 
1445c 063 28 16 64 FD |                             setq    #12-1                   'read region parameters from hub
14460 064 06 0C 00 FB |                             rdlong  regn, regn              'update region data
14464 065 07 50 3B F9 |                             getword regionsize, modedata, #1 'extract region size
14468 066             | 
14468 066 09 0E 14 F4 |                             testb   modedata, #9 wc         'determine mode type 1=gfx, 0=text
1446c 067 0C 0E 0C F4 |                             testb   modedata, #12 wz        'check if interlaced source
14470 068 00 3E 4F F4 |                             testb   fieldcount, #0 andz     'and with LSB to get field
14474 069 0C 10 00 86 |             if_z_and_c      mov     screenaddr1, cursor1    'select source for interlaced gfx
14478 06a 0D 12 00 86 |             if_z_and_c      mov     screenaddr2, cursor2    '...same for wrapped portion
1447c 06b 00 9E 86 F4 |                             bitz    setrowscan, #0          'clear text row scan index
14480 06c 08 DA 07 F6 |                             mov     palselect, #8           'clear default
14484 06d 0A D6 FB F8 |                             getbyte rowheight, fontaddr, #3 'extract font height
14488 06e 10 DE 3B F9 |                             getword rowscan, wrap, #1       'get initial font scanline
1448c 06f             | 
1448c 06f EB DF 0B 27 |             if_z_and_nc     incmod  rowscan, rowheight wz   'wrap rowscan at row height
14490 070 6E D8 63 FD |                             wrz     row                     '..and increase row if required
14494 071             | 
14494 071 10 20 30 F9 |                             getword wrap, wrap, #0          'clear unwanted top 16 bits now
14498 072 01 DC 67 F6 |                             neg     scanline, #1
1449c 073 26 43 07 C6 |             if_c            mov     videomode, #gen_gfx     'setup function pointers
144a0 074 D2 42 07 36 |             if_nc           mov     videomode, #gen_text    '..for the appropriate mode
144a4 075 03 0E 0C F4 |                             testb   modedata, #3 wz         'if gfx, 1=LUMA8, 0=non LUMA8
144a8 076 07 DA 03 88 |             if_c_and_z      setnib  palselect, modedata, #0
144ac 077 07 E4 43 F8 |                             getnib  a, modedata, #0         'colour mode 0 is special below
144b0 078 03 E4 0F F2 |                             cmp     a, #3 wz                'check for the 8 bit LUTRAM mode
144b4 079 00 DA 07 86 |             if_c_and_z      mov     palselect, #0           'use low LUTRAM for 8 bit palettes
144b8 07a 29 FE 65 8D |             if_c_and_z      setq2   #255                    'read in a 256 colour palette from
144bc 07b 0B 00 00 8B |             if_c_and_z      rdlong  0, paletteaddr          '...HUB to LUT RAM
144c0 07c 08 E4 2F F3 |                             fle     a, #8 wz                'collapse LUMA8 modes, test for 0
144c4 07d             | 
144c4 07d             | 
144c4 07d 02 E4 07 36 | p7          if_nc           mov     a, #2                   'override index if text mode
144c8 07e 85 E5 97 F9 |                             alts    a, #modetable           'setup mode table indexing
144cc 07f 00 E4 03 F6 |                             mov     a, 0-0                  'get mode information
144d0 080 F2 D9 EB C8 |             if_c            getbyte transfers, a, #1        'setup transfer count in gfx modes
144d4 081 F2 E7 F3 F8 |                             getbyte b, a, #2                'get burst size
144d8 082 F2 D5 73 F8 |                             getnib  bppidx, a, #6           'get bit depth in bpp
144dc 083 F2 31 23 F8 |                             setnib  m_rf, a, #4             'set streamer nibble 4
144e0 084 04 E4 47 F0 |                             shr     a, #4                   'prepare next nibble
144e4 085 F2 31 3B F8 |                             setnib  m_rf, a, #7             'set streamer nibble 7
144e8 086             | 
144e8 086 50 08 04 F6 | p0                          mov     linebufsize, #COLS      'compute scan line size in bytes
144ec 087 EA 09 60 F0 |                             shl     linebufsize, bppidx     '...for the bit depth
144f0 088             | 
144f0 088 F3 81 B2 F9 |                             setd    burst, b
144f4 089 0A 0E 0C F4 |                             testb   modedata, #10 wz        'test for pixel doubling
144f8 08a 01 E6 47 A0 |             if_z            shr     b, #1                   'halve the transfer size if doubled
144fc 08b F3 7B B2 F9 |                             setd    transferloop, b         'value patched is actually size-1
14500 08c 01 E6 07 F1 |                             add     b, #1                   '...so increment to get real size
14504 08d F3 7F B2 F9 |                             setd    double, b
14508 08e 78 D5 97 F9 |                             alts    bppidx, #doublebits
1450c 08f 00 D6 03 C6 |             if_c            mov     pattern, 0-0
14510 090 EB BD B2 F9 |                             setd    doubleloop, pattern
14514 091 09 D6 47 C0 |             if_c            shr     pattern, #9
14518 092 08 F0 03 06 |             _ret_           mov     ptra, screenaddr1       'restart screen buffer at start
1451c 093             | 
1451c 093             | '..................................................................................................
1451c 093             | ' Code to generate a mouse sprite in all the different colour depths
1451c 093             | 
1451c 093             | do_mouse
1451c 093 2A F0 63 FD |                             push    ptra
14520 094 2A F2 63 FD |                             push    ptrb
14524 095             | 
14524 095 0E 0E 0C F4 |                             testb   modedata, #14 wz
14528 096 A5 1D 00 56 |             if_nz           mov     mouse_xy, globalmouse   'use global screen co-ordinates
1452c 097 EE EB 03 A6 |             if_z            mov     d, scanline             'use local region co-ordinates
14530 098             | 
14530 098 0E E4 3B F9 |                             getword a, mouse_xy, #1         'get mouse y screen co-ordinate
14534 099 0F E6 7B F8 |                             getnib  b, mouseptr, #7         'get y hotspot of mouse image
14538 09a F3 E5 83 F1 |                             sub     a, b                    'compensate for the y hotspot
1453c 09b F5 E5 C3 F2 |                             subr    a, d                    'compute sprite row offset
14540 09c 0F E4 97 F2 |                             cmpr    a, #15 wc               'check if sprite covers scanline
14544 09d             | 
14544 09d 7F D5 97 F9 |                             alts    bppidx, #bpptable       'bppidx is an index from 0-5
14548 09e 00 5A 03 F6 |                             mov     bitmask, 0-0            'get table entry using bpp index
1454c 09f AD E5 03 FA |                             mul     a, bitmask              'multiply mouse row by its length
14550 0a0 10 5A 4F F0 |                             shr     bitmask, #16 wz         'extract mask portion
14554 0a1 AD 5B 23 A6 |             if_z            not     bitmask                 'fix up the 32 bpp case
14558 0a2 AD 63 03 F6 |                             mov     bpp, bitmask
1455c 0a3 B1 63 A3 F7 |                             ones    bpp                     'convert into real bpp
14560 0a4             | 
14560 0a4 0F E4 03 F1 |                             add     a, mouseptr             'add offset to base mouse address
14564 0a5 29 20 64 FD |                             setq2   #17-1                   'get 17 longs max, mouse mask+image
14568 0a6 F2 41 02 FB |                             rdlong  $120, a                 'read mouse data and store in LUT
1456c 0a7             | 
1456c 0a7 0E 5E 33 F9 |                             getword offset, mouse_xy, #0    'get mouse x screen co-ordinate
14570 0a8 0F E6 73 F8 |                             getnib  b, mouseptr, #6         'get x hotspot of mouse image
14574 0a9             | 
14574 0a9 AF E1 03 F6 |                             mov     pixels, offset
14578 0aa F3 5F 83 F1 |                             sub     offset, b               'compensate for the x hotspot
1457c 0ab 9D E1 DB 32 |             if_nc           subr    pixels, vis_pixels wcz  'compute pixels until end of line
14580 0ac F3 E1 03 F1 |                             add     pixels, b               'increase by the x hotspot amount
14584 0ad 10 E0 27 F3 |                             fle     pixels, #16             'limit drawn pixels to 16
14588 0ae             | 
14588 0ae 80 00 90 ED |             if_c_or_z       jmp     #exitmouse              'exit if sprite is out of x/y range
1458c 0af             | 
1458c 0af 20 F3 07 F6 |                             mov     ptrb, #$120             'ptrb is used for mouse image data
14590 0b0 E1 E9 A7 FA |                             rdlut   c, ptrb++               'read in the mouse mask first
14594 0b1             | 
14594 0b1 AF E5 43 F6 |                             abs     a, offset               'retain offset (and make positive)
14598 0b2 B1 5F 13 FA |                             muls    offset, bpp             'convert number of pixels into bits
1459c 0b3 AF E7 53 F6 |                             abs     b, offset wc            'test for negative value (clipped)
145a0 0b4 AD 5D 03 F6 |                             mov     muxmask, bitmask        'setup mask for pixel's data size
145a4 0b5 F3 5D 23 30 |             if_nc           rol     muxmask, b              'align mask for first data pixel
145a8 0b6 F3 5B 23 C0 |             if_c            rol     bitmask, b              'align mask for first mouse pixel
145ac 0b7 F2 E9 43 C0 |             if_c            shr     c, a                    'eliminate mouse pixels if clipped
145b0 0b8 05 E6 47 F0 |                             shr     b, #5                   'convert bits to longs
145b4 0b9 F3 F3 03 C1 |             if_c            add     ptrb, b                 'advance mouse data to skip pixels
145b8 0ba             | 
145b8 0ba 02 E6 67 F0 |                             shl     b, #2                   'convert longs to bytes
145bc 0bb F3 EF 03 31 |             if_nc           add     pb, b                   'adjust scanline buffer position
145c0 0bc 29 1E 64 FD |                             setq2   #16-1                   'read 16 scanline longs into LUT
145c4 0bd F7 21 02 FB |                             rdlong  $110, pb                'using adjusted hub read position
145c8 0be             | 
145c8 0be 10 F1 07 F6 |                             mov     ptra, #$110             'ptra used for source image data
145cc 0bf 00 E5 A7 FA |                             rdlut   a, ptra                 'get original scanline pixel data
145d0 0c0 01 80 D5 F7 |                             test    $, #1 wc                'c=1 will trigger initial read
145d4 0c1             | 
145d4 0c1 F0 13 D8 FC |                             rep     @endmouse, pixels       'repeat loop for up to 16 pixels
145d8 0c2 E1 E7 A7 CA |             if_c            rdlut   b, ptrb++               'get next mouse sprite pixel(s)
145dc 0c3 AF E7 23 C0 |             if_c            rol     b, offset               'align with the source input data
145e0 0c4 01 E8 57 F0 |                             shr     c, #1 wc                'get mask bit 1=set, 0=transparent
145e4 0c5 28 5C 63 CD |             if_c            setq    muxmask                 'configure the muxq mask
145e8 0c6 F3 E5 F3 C9 |             if_c            muxq    a, b                    'select original or mouse pixel
145ec 0c7 00 E5 37 CC |             if_c            wrlut   a, ptra                 'write back updated data if altered
145f0 0c8 B1 5D 33 F0 |                             rol     muxmask, bpp wc         'advance mask by 1,2,4,8,16,32 bits
145f4 0c9 41 E5 A7 CA |             if_c            rdlut   a, ++ptra               '...and read next source pixel(s)
145f8 0ca B1 5B 33 F0 |                             rol     bitmask, bpp wc         'rotate mask for mouse data reload
145fc 0cb             | endmouse
145fc 0cb 1F F1 27 F3 |                             fle     ptra, #$11f             'any way to eliminate this instrn?
14600 0cc 10 F1 87 F1 |                             sub     ptra, #$110
14604 0cd 29 F0 63 FD |                             setq2   ptra
14608 0ce F7 21 62 FC |                             wrlong  $110, pb                'write LUT image data back to hub
1460c 0cf 2B F2 63 FD | exitmouse                   pop     ptrb
14610 0d0 2B F0 63 FD |                             pop     ptra
14614 0d1 2D 00 7C FD |                             ret     wcz
14618 0d2             | 
14618 0d2             | '..................................................................................................
14618 0d2             | ' Code to generate the next text scan line and cursor(s)
14618 0d2             | 
14618 0d2             | gen_text
14618 0d2 EF E7 03 F6 |                             mov     b, rowscan              'build font table base address
1461c 0d3 08 E6 67 F0 |                             shl     b, #8                   'for this font and row's scanline
14620 0d4 0A E6 03 F1 |                             add     b, fontaddr
14624 0d5 28 7E 64 FD |                             setq    #64-1                   '64 longs holds 256 bytes of font
14628 0d6 F3 55 03 FB |                             rdlong  font, b                 'read in font data for scanline
1462c 0d7             | 
1462c 0d7 08 0E 0C F4 |                             testb   modedata, #8 wz         'flashing / full colour background?
14630 0d8 83 DE AD A9 | p12         if_z            setr    testflash, #$83         'use text flashing code test
14634 0d9 EA DE AD 59 | p13         if_nz           setr    testflash, #$EA         'change into helpful zerox c,#15 wc
14638 0da             | 
14638 0da 0A 0E 0C F4 |                             testb   modedata, #10 wz        'pixel double test
1463c 0db 29 4E 64 FD | readrow                     setq2   #COLS/2-1               'read maximum of 120 longs from HUB
14640 0dc 00 21 06 FB |                             rdlong  $110, ptra              'to get next 240 chars with colours
14644 0dd 37 EF 07 F6 | p9                          mov     pb, #$10f+COLS/2        'setup LUT read pointer at end
14648 0de 14 EE 87 A1 | p10         if_z            sub     pb, #COLS/4             '...of where character data is
1464c 0df             | 
1464c 0df F9 E3 03 F6 |                             mov     save, ptrb              'save pointer register
14650 0e0 FF F3 07 F6 |                             mov     ptrb, #$1ff             'setup write location in LUT RAM
14654 0e1             | 
14654 0e1 50 46 BE A9 | p1          if_z            sets    adv, #COLS              'increase by half normal columns
14658 0e2 A0 46 BE 59 | p2          if_nz           sets    adv, #COLS*2            'increase by normal columns
1465c 0e3             | 
1465c 0e3             | patchtext
1465c 0e3 18 E4 17 F6 |                             mov     a, #%11000 wc           'reset starting lookup index
14660 0e4 28 36 DC AC | p3          if_z            rep     @endwide, #COLS/2       '2100 clocks for 40 double wide
14664 0e5 50 24 DC 5C | p4          if_nz           rep     @endnormal, #COLS       '2760 clocks for 80 normal wide
14668 0e6 32 E4 63 FD |                             skipf   a                       'skip 2 of the next 5 instructions
1466c 0e7 1E E4 67 F5 |                             xor     a, #%11110              'flip skip sequence for next time
14670 0e8 F7 EB A3 FA |                             rdlut   d, pb                   'read pair of characters/colours
14674 0e9 F5 E9 3B F9 |                             getword c, d, #1                'select first word in long (skipf)
14678 0ea F5 E9 33 F9 |                             getword c, d, #0                'select second word in long (skipf)
1467c 0eb 01 EE 87 F1 |                             sub     pb, #1                  'decrement LUT read index (skipf)
14680 0ec F4 E7 E3 F8 |                             getbyte b, c, #0                'extract font offset for char
14684 0ed AA E7 6F F9 |                             altgb   b, #font                'determine font lookup address
14688 0ee 00 E0 E3 F8 |                             getbyte pixels, 0-0, #0         'get font for character's scanline
1468c 0ef 0F E8 1F F4 | testflash                   bitl    c, #15 wcz              'test (and clear) flashing bit
14690 0f0 FF E0 07 C5 | flash       if_c            and     pixels, #$ff            'make it all background if flashing
14694 0f1 55 E8 FF F9 |                             movbyts c, #%01010101           'colours becomes BF_BF_BF_BF
14698 0f2 F4 E7 03 F6 |                             mov     b, c                    'grab a copy for muxing step next
1469c 0f3 04 E6 27 F0 |                             rol     b, #4                   'b becomes FB_FB_FB_FB
146a0 0f4 80 7F F8 FF 
146a4 0f5 28 1E 64 FD |                             setq    ##$F0FF000F             'mux mask adjusts fg and bg colours
146a8 0f6 F3 E9 F3 F9 |                             muxq    c, b                    'c becomes FF_FB_BF_BB
146ac 0f7 0A 0E 0C F4 |                             testb   modedata, #10 wz        'repeat columns test, z was trashed
146b0 0f8             | endnormal                                                   'end rep 2 instructions early (skipf)
146b0 0f8 F0 E9 FB 59 |             if_nz           movbyts c, pixels               'select pixel colours for char
146b4 0f9 FF E9 37 5C |             if_nz           wrlut   c, ptrb--               'write coloured pixel data into LUT
146b8 0fa             | 
146b8 0fa F0 E1 2B F9 |                             setword pixels, pixels, #1      'replicate low words in long
146bc 0fb 63 E0 63 FD |                             mergew  pixels                  '...to then double pixels
146c0 0fc F4 E7 03 F6 |                             mov     b, c                    'save a copy before we lose colours
146c4 0fd F0 E9 FB F9 |                             movbyts c, pixels               'compute 4 lower colours of char
146c8 0fe 08 E0 07 F0 |                             ror     pixels, #8              'get upper 8 pixels
146cc 0ff F0 E7 FB F9 |                             movbyts b, pixels               'compute 4 higher colours of char
146d0 100             | endwide                                                     'end rep 2 instructions early (skipf)
146d0 100 FF E7 37 AC |             if_z            wrlut   b, ptrb--               'save it to LUT RAM
146d4 101 FF E9 37 AC |             if_z            wrlut   c, ptrb--               'save it to LUT RAM
146d8 102             | endpatchtext
146d8 102 F1 F3 03 F6 |                             mov     ptrb, save              'restore ptrb
146dc 103 29 9E 64 FD | p5                          setq2   #COLS-1                 'write all column pixels to HUB RAM
146e0 104 80 61 67 FC | p11                         wrlong  $200-COLS, ptrb         'from LUT storage
146e4 105             | 
146e4 105             |                             'do both cursors here
146e4 105 02 34 86 F4 | p8                          bitz    increment, #2           'setup whether cursor is doubled
146e8 106 00 16 86 F4 |                             bitz    scaling, #0               'and multiply offset accordingly
146ec 107             | 
146ec 107 02 28 DC FC |                             rep     @endcursor, #2          'repeat twice for two cursors
146f0 108 0C E8 03 F6 |                             mov     c, cursor1+0            'get cursor data
146f4 109 01 10 66 F5 |                             xor     $-1, #1                 'alternate cursors
146f8 10a F4 E5 F3 F8 |                             getbyte a, c, #2                'get cursor's x position (col)
146fc 10b 02 E4 67 F0 | scaling                     shl     a, #2+0                 'transform x to long address offset
14700 10c F9 E5 03 F1 |                             add     a, ptrb                 'add offset to start of line buffer
14704 10d F4 E7 53 F8 |                             getnib  b, c, #2
14708 10e 01 E6 97 F1 |                             sub     b, #1 wc
1470c 10f EB E7 C3 F2 |                             subr    b, rowheight
14710 110 EF E7 1B 32 |             if_nc           cmp     b, rowscan wcz          'compare this scanline count
14714 111 0D E8 D7 F4 |                             testb   c, #13 xorc
14718 112 F4 E7 FB F8 |                             getbyte b, c, #3                'get cursor's y position (row)
1471c 113 EC E7 0B E2 |             if_z_or_c       cmp     b, row wz               'check if cursor is on this row
14720 114 0F E8 4F F4 |                             testb   c, #15 andz             'check if cursor is enabled
14724 115             | 
14724 115 0C E8 17 F4 |                             testb   c, #12 wc               'select the blink phase to apply
14728 116 04 3E D7 F4 | cursflash                   testb   fieldcount, #4-0 xorc   'get flashing bit from field count
1472c 117 0E E8 4F C4 |             if_c            testb   c, #14 andz             'if blink, apply blink to z
14730 118             | 
14730 118             |                          '  setnib  c, c, #1                'replicate colour nibble in byte 0
14730 118 00 E8 FF F9 |                             movbyts c, #0                   'replicate colour over all 8 pixels
14734 119 F2 E9 63 AC | wr1         if_z            wrlong  c, a                    'write cursor color to line buffer
14738 11a 00 E4 17 F1 | increment                   add     a, #0-0 wc              'advance to next long if wide text
1473c 11b F2 E9 63 AC | wr2         if_z            wrlong  c, a                    'repeat to get double wide cursor
14740 11c             | endcursor
14740 11c 0B 0E 2C F4 |                             testbn  modedata, #11 wz        'z=1 if line doubling off
14744 11d 00 DC AF F4 |                             testbn  scanline, #0 orz        'z=1 if second line
14748 11e EB DF 13 A7 |             if_z            incmod  rowscan, rowheight wc   'z=1 & c=1 if wrapped
1474c 11f             | 
1474c 11f 0C 0E 4C F4 |                             testb   modedata, #12 andz
14750 120 01 DE 07 81 |             if_z_and_c      add     rowscan, #1
14754 121 EB DF 13 27 |             if_z_and_nc     incmod  rowscan, rowheight wc
14758 122             | 
14758 122 6C EA 63 FD |                             wrc     d
1475c 123 00 F0 07 C1 | adv         if_c            add     ptra, #0-0              'advance by half or full columns
14760 124 11 F0 03 C1 |             if_c            add     ptra, skew              'allows windowing into wider screen
14764 125 84 00 90 FD |                             jmp     #selectbuf              'select next buffer to write to
14768 126             | 
14768 126             | '..................................................................................................
14768 126             | ' Code to generate next graphics scan line and handle external memory access
14768 126             | 
14768 126             | gen_gfx
14768 126 F9 E3 03 F6 |                             mov     save, ptrb              'preserve for fifo use later
1476c 127 F8 EB 03 F6 |                             mov     d, ptra                 'preserve initial source pointer
14770 128 08 E6 7B F8 |                             getnib  b, screenaddr1, #7
14774 129 60 E6 0F FA | extm_test                   mul     b, #96 wz               'check for external memory usage
14778 12a 01 E6 03 F1 |                             add     b, mailbox
1477c 12b 0D 0E 14 F4 |                             testb   modedata, #13 wc        'check transparent/sprite mode and
14780 12c F8 E3 03 86 |             if_c_and_z      mov     save, ptra              '...display from ptra if no ext mem
14784 12d 08 E4 73 58 |             if_nz           getnib  a, screenaddr1, #6      'extract bank address
14788 12e F2 F1 33 58 |             if_nz           setnib  ptra, a, #6             'copy into external request
1478c 12f 0B F0 3F 58 |             if_nz           setnib  ptra, #EXTMEMREQ, #7    'add memory read request to address
14790 130 50 E4 07 56 | p6          if_nz           mov     a, #COLS                'transfer column "units" of memory data
14794 131 EA E5 63 50 |             if_nz           shl     a, bppidx               '...multiplied by bpp into HUB RAM
14798 132 28 02 64 5D |             if_nz           setq    #2-1                    'write 2 values
1479c 133 F3 E3 63 5C |             if_nz           wrlong  save, b                 'setup memory request information
147a0 134 04 E6 87 F1 |                             sub     b, #4
147a4 135 F3 F1 63 5C |             if_nz           wrlong  ptra, b                 'initiate memory read request
147a8 136 04 F0 03 51 |             if_nz           add     ptra, linebufsize       'increase ptra by this amount
147ac 137 14 00 A4 F4 |                             bitnz   statusaddr, #20         'remember for late mouse render
147b0 138 28 00 90 DD |             if_c_or_nz      jmp     #copy_done              'no need to do any copy this time
147b4 139             | 
147b4 139 0A 0E 14 F4 |                             testb   modedata, #10 wc        'check for pixel width doubling
147b8 13a 88 83 B6 39 |             if_nc           setd    writeback, #$188        'no doubling, copied from same addr
147bc 13b 10 83 B6 C9 |             if_c            setd    writeback, #$110        'data copied from different place
147c0 13c EC E9 03 F6 |                             mov     c, transfers            'setup number of read burst loops
147c4 13d 29 00 64 FD | transferloop                setq2   #0-0                    'block copy from HUB source to LUT
147c8 13e 61 11 07 FB |                             rdlong  $188, ptra++
147cc 13f 1A 00 5C CB | double      if_c            callpb  #0-0, #doublepixels     'double pixels when enabled
147d0 140 29 00 64 FD | burst                       setq2   #0-0                    'setup output burst for hub writes
147d4 141 E1 01 64 FC | writeback                   wrlong  $0-0, ptrb++            '...and write back to line buffer
147d8 142 FA E9 6F FB |                             djnz    c, #transferloop        'repeat
147dc 143             | copy_done
147dc 143 11 F0 03 F1 |                             add     ptra, skew              'allow for some horizontal panning
147e0 144 00 DC 2F F4 |                             testbn  scanline, #0 wz         'check odd/even line state
147e4 145 0B 0E 14 F4 |                             testb   modedata, #11 wc        'check for line doubled mode
147e8 146 F5 F1 03 46 |             if_c_and_nz     mov     ptra, d                 'rewind source ptr to repeat line
147ec 147             | 
147ec 147 1F F2 0F F4 | selectbuf                   testb   ptrb, #31 wz
147f0 148 02 F2 03 56 |             if_nz           mov     ptrb, linebuf1
147f4 149 03 F2 03 A6 |             if_z            mov     ptrb, linebuf2
147f8 14a             | 
147f8 14a 01 20 8C F1 |                             sub     wrap, #1 wz             'check for wrap around to 2nd buf
147fc 14b 09 F0 03 A6 |             if_z            mov     ptra, screenaddr2       'handle it
14800 14c 09 10 00 A6 |             if_z            mov     screenaddr1,screenaddr2 'copy into screenaddr1 for later
14804 14d 09 0E 14 F4 |                             testb   modedata, #9 wc
14808 14e EF 21 00 86 |             if_c_and_z      mov     wrap, rowscan
1480c 14f 00 DE 07 26 | setrowscan  if_z_and_nc     mov     rowscan, #0
14810 150 01 EA 07 26 |             if_z_and_nc     mov     d, #1
14814 151 F5 D9 03 31 |             if_nc           add     row, d
14818 152             | 
14818 152 01 DC 07 F1 |                             add     scanline, #1
1481c 153 14 00 1C F4 |                             bitl    statusaddr, #20 wcz     'test&clear when mouse is rendered
14820 154 0F 0E 0C F4 |                             testb   modedata, #15 wz        'test if mouse shown in this region
14824 155 12 EA 33 F9 |                             getword d, status, #0           'get current scanline from top in d
14828 156 F3 E5 03 8B |              if_z_and_c     rdlong  a, b                    'check the ext memory request status
1482c 157 FE E5 B7 8B |              if_z_and_c     tjs     a, #$-1                 'wait until complete line is read
14830 158             | 
14830 158 3A E3 57 AB |              if_z           callpb  save, #do_mouse
14834 159             | '            if_z_and_nc     callpb  save, #do_mouse         'c=0, render the mouse before hsync
14834 159             | nullmode                                                    'c=1 is returned for a late mouse
14834 159 00 24 DC 08 |             _ret_           setbyte status, #0, #3          'update status - doing active lines
14838 15a             | 
14838 15a             | '..................................................................................................
14838 15a             | ' Code to double pixels in all the different colour depths
14838 15a             | 
14838 15a             | doublepixels
14838 15a 2A F0 63 FD |                             push    ptra                    'preserve current pointers
1483c 15b 2A F2 63 FD |                             push    ptrb
14840 15c 88 F1 07 F6 |                             mov     ptra, #$188             'setup pointers for LUT accesses
14844 15d 10 F3 07 F6 |                             mov     ptrb, #$110
14848 15e F7 01 D8 FC | doubleloop                  rep     #0-0, pb                'patched pixel doubling loop count
1484c 15f 32 D6 63 FD |                             skipf   pattern                 '1  2  4  8 16 32
14850 160 61 E5 A7 FA |                             rdlut   a, ptra++               '*  *  *  *  *  *
14854 161 28 FC 62 FD |                             setq    nibblemask              '      *
14858 162 62 E4 63 FD |                             splitw  a                       '   *
1485c 163 F2 E7 03 F6 |                             mov     b, a                    '*  *  *  *  *
14860 164 88 E4 FF F9 |                             movbyts a, #%%2020              '   *
14864 165 50 E4 FF F9 |                             movbyts a, #%%1100              '      *  *
14868 166 44 E4 FF F9 |                             movbyts a, #%%1010              '*           *
1486c 167 E1 E5 37 FC |                             wrlut   a, ptrb++               '               *
14870 168 61 E4 63 FD |                             mergeb  a                       '   *
14874 169 63 E4 63 FD |                             mergew  a                       '*
14878 16a F2 EF 03 F6 |                             mov     pb, a                   '      *
1487c 16b 04 EE 67 F0 |                             shl     pb, #4                  '      *
14880 16c F7 E5 F3 F9 |                             muxq    a, pb                   '      *
14884 16d E1 E5 37 FC |                             wrlut   a, ptrb++               '*  *  *  *  *  *Short 32bpp loop
14888 16e DD E6 FF F9 |                             movbyts b, #%%3131              '   *           |returns here but
1488c 16f FA E6 FF F9 |                             movbyts b, #%%3322              '      *  *     |falls through at
14890 170 EE E6 FF F9 |                             movbyts b, #%%3232              '*           *  |end after its REP
14894 171 63 E6 63 FD |                             mergew  b                       '*              |block completes.
14898 172 61 E6 63 FD |                             mergeb  b                       '   *           |
1489c 173 F3 EF 03 F6 |                             mov     pb, b                   '      *        |
148a0 174 04 EE 67 F0 |                             shl     pb, #4                  '      *        |
148a4 175 F7 E7 F3 F9 |                             muxq    b, pb                   '      *        |
148a8 176 E1 E7 37 FC |                             wrlut   b, ptrb++               '*  *  *  *  *  |<skipped for 32bpp
148ac 177 5C FD 9F FD |                             jmp     #exitmouse              'share common code to restore ptrs
148b0 178             | 
148b0 178             | '--------------------------------------------------------------------------------------------------
148b0 178             | ' Initialized data
148b0 178             | '--------------------------------------------------------------------------------------------------
148b0 178             | '                   __instr_skip_patterns____instcount
148b0 178 09 6C BB 79 | doublebits  long    %01111001101110110110110_000001001
148b4 179 0A C4 3D 77 | doublenits  long    %01110111001111011100010_000001010
148b8 17a 0E A8 87 0E | doublenibs  long    %00001110100001111010100_000001110
148bc 17b 07 AC BF 7E | doublebytes long    %01111110101111111010110_000000111
148c0 17c 07 6C BF 7D | doublewords long    %01111101101111110110110_000000111
148c4 17d 04 FC 3E 80 | doublelongs long    %10000000001111101111110_000000100
148c8 17e             | 
148c8 17e F0 0F F0 0F | nibblemask  long    $0ff00ff0
148cc 17f             | 
148cc 17f             | bpptable
148cc 17f 08 00 01 00 |             long    $0001_00_08                             '1bpp
148d0 180 08 00 03 00 |             long    $0003_00_08                             '2bpp
148d4 181 0C 00 0F 00 |             long    $000F_00_0C                             '4bpp
148d8 182 14 00 FF 00 |             long    $00FF_00_14                             '8bpp
148dc 183 24 00 FF FF |             long    $FFFF_00_24                             '16bpp
148e0 184 44 00 00 00 |             long    $0000_00_44                             '32bpp
148e4 185             | 
148e4 185             | modetable             'bppidx_gfxburst_transfer_nib7_nib4
148e4 185 72 01 13 00 |             long    %00000000_00000000_00000001_0111_0010 + ((COLS/2)-1-(COLS/4)) << 16
148e8 186 74 01 27 01 |             long    %00000001_00000000_00000001_0111_0100 + ((COLS/2)-1) << 16
148ec 187 76 02 27 02 |             long    %00000010_00000000_00000010_0111_0110 + ((COLS/2)-1) << 16
148f0 188 78 04 27 03 |             long    %00000011_00000000_00000100_0111_1000 + ((COLS/2)-1) << 16
148f4 189 B3 04 27 03 |             long    %00000011_00000000_00000100_1011_0011 + ((COLS/2)-1) << 16
148f8 18a B4 04 27 03 |             long    %00000011_00000000_00000100_1011_0100 + ((COLS/2)-1) << 16
148fc 18b B5 08 27 04 |             long    %00000100_00000000_00001000_1011_0101 + ((COLS/2)-1) << 16
14900 18c B6 10 27 05 |             long    %00000101_00000000_00010000_1011_0110 + ((COLS/2)-1) << 16
14904 18d B2 04 27 03 |             long    %00000011_00000000_00000100_1011_0010 + ((COLS/2)-1) << 16
14908 18e             | 
14908 18e             | 
14908 18e             |                     '_CHNL0_(R)__CHNL1_(G)__CHNL0_(B)_
14908 18e 53 4D 35 D5 | sync_000    long    %1101010100_1101010100_1101010100_11    '-vsync -hsync
1490c 18f AE 42 35 D5 | sync_001    long    %1101010100_1101010100_0010101011_10    '-vsync +hsync
14910 190 53 45 35 D5 | sync_002    long    %1101010100_1101010100_0101010100_11    '+vsync -hsync
14914 191 AE 4A 35 D5 | sync_003    long    %1101010100_1101010100_1010101011_10    '+vsync +hsync
14918 192             | 
14918 192 10 00 E1 7F | m_bs        long    $7fe10000 + H_FP                        'front porch before sync
1491c 193 60 00 E1 7F | m_sn        long    $7fe10000 + H_SYNC                      'sync
14920 194 00 00 E1 7F | m_br        long    $7fe10000                               'breezeway
14924 195 00 00 E1 7F | m_cb        long    $7fe10000                               'colour burst
14928 196 30 00 E1 7F | m_bv        long    $7fe10000 + H_BP                        'back porch before visible
1492c 197             | 
1492c 197 90 02 E1 7F | m_vi        long    $7fe10000 + H_VISIBLE + H_FP            'visible
14930 198 80 02 E6 7F | m_rf        long    $7fe60000 + H_VISIBLE                   'visible 8x4b for LUT lookup
14934 199             | 
14934 199 00 00 E1 7F | m_brdr      long    $7fe10000
14938 19a B0 01 E1 7F | m_half      long    $7fe10000 + 864/2
1493c 19b 2C 01 E1 7F | m_slim      long    $7fe10000 + 432 - 64 - 68
14940 19c             | 
14940 19c             | 
14940 19c             | 
14940 19c 01 51 A3 D8 | colourburst long    COLOUR_BURST_PAL                        'colour burst colour (patched)
14944 19d 80 02 00 00 | vis_pixels  long    H_VISIBLE
14948 19e E0 01 00 00 | vis_lines   long    V_VISIBLE
1494c 19f 00 00 00 00 | fieldcount  long    0
14950 1a0             | 
14950 1a0             | cmodval
14950 1a0 38 07 00 00 | lutoffset   long    setupcode - videodriver                 'offset of LUT init code in HUB
14954 1a1             | videomode
14954 1a1 FC 0F 00 00 | vsyncpin    long    %1111111111_00                          'used to flip hsync
14958 1a2             | dacmode_s                                                   'hsync 123-ohm 3.3V value below
14958 1a2 40 00 16 00 | hsync0      long    %0000_0000_000_1011000000000_01_00000_0
1495c 1a3             | dacmode_c                                                   'R/G/B 75-ohm 2.0V value below
1495c 1a3 40 00 17 00 | hsync1      long    %0000_0000_000_1011100000000_01_00000_0
14960 1a4             | 
14960 1a4             | fieldparams
14960 1a4 00 00 00 00 | palflipcq   long    0
14964 1a5 00 00 00 00 | globalmouse long    0
14968 1a6 00 00 00 00 | borders     long    0
1496c 1a7 00 00 00 00 | brdrcolour  long    0
14970 1a8 00 00 00 00 | regionsize  long    0
14974 1a9 80 09 30 C6 | cq          long    CV_PAL_EVEN
14978 1aa             | font                                                        '64 entry font table stored here
14978 1aa             |                                                             '...as well as scratch/sync code
14978 1aa             | 
14978 1aa             |             ' SDTV interlaced sync code (larger PAL variant is coded, NTSC is patched over this)
14978 1aa             | 
14978 1aa             | interlacedsd                                                'some different sync code patches
14978 1aa 00 3E 17 F4 | cy                          testb   fieldcount, #0 wc       'field interlace state
1497c 1ab 52 00 A0 CD | ci          if_c            call    #\hsync                 'deal with interlaced field lines
14980 1ac A2 37 C3 CC |             if_c            xcont   m_slim, hsync0          'send a slim half line
14984 1ad             | bitmask
14984 1ad 05 04 DC FC | ntsc1                       rep #2, #5-0                    'defaults to PAL
14988 1ae A3 1D C3 FC | muxmask                     xcont   sync_000, hsync1        'generate horizontal blanking/sync
1498c 1af A2 1F C3 FC | offset                      xcont   sync_001, hsync0
14990 1b0             | 
14990 1b0 1F 24 C4 F9 |                             decod   status, #31             'update status - in vertical sync
14994 1b1 9F 25 D0 F8 | bpp                         setbyte status, fieldcount, #2  'update field counter in status
14998 1b2 00 24 60 FC | writestat                   wrlong  status, statusaddr
1499c 1b3             | 
1499c 1b3 05 04 DC FC | ntsc2                       rep #2, #5-0                    'defaults to PAL
149a0 1b4 A3 21 C3 FC |                             xcont   sync_002, hsync1        'generate horizontal blanking/sync
149a4 1b5 A2 23 C3 FC |                             xcont   sync_003, hsync0
149a8 1b6             | 
149a8 1b6 05 04 DC FC | ntsc3                       rep #2, #5-0                    'defaults to PAL
149ac 1b7 A3 1D C3 FC |                             xcont   sync_000, hsync1        'generate horizontal blanking/sync
149b0 1b8 A2 1F C3 FC |                             xcont   sync_001, hsync0
149b4 1b9             |                                                             'PAL variant below is the default
149b4 1b9             |                                                             'while NTSC gets patched
149b4 1b9 01 46 64 C5 | ntsc4       if_c            xor     patchvbp, #1            'generate CQ XOR flip on fields 2,3
149b8 1ba 09 02 4C CB | ntsc5       if_c            callpa  #1, #$+(blank_pal-syncspace-ntsc5+interlacedsd)  'relocated call
149bc 1bb A2 35 C3 3C | ntsc6       if_nc           xcont   m_half, hsync0          'remainder after half line (PAL)
149c0 1bc             | 
149c0 1bc             | 
149c0 1bc             |                 ' HDTV interlaced sync code
149c0 1bc             | 
149c0 1bc             | interlacedhd
149c0 1bc 00 3E 17 F4 |                             testb   fieldcount, #0 wc       'get field interlace state
149c4 1bd 52 00 A0 CD |             if_c            call    #\hsync                 'deal with interlaced field lines
149c8 1be A2 35 C3 CC |             if_c            xcont   m_half, hsync0          'send a half line with sync high
149cc 1bf             | 
149cc 1bf 97 E5 03 C6 |             if_c            mov     a, m_vi
149d0 1c0 9A E5 03 36 |             if_nc           mov     a, m_half
149d4 1c1             | 
149d4 1c1 1F 24 C4 F9 |                             decod   status, #31             'update status - in vertical sync
149d8 1c2 9F 25 D0 F8 |                             setbyte status, fieldcount, #2  'update field counter in status
149dc 1c3             | 
149dc 1c3 0A E6 07 F6 | hdloopstart                 mov     b, #10-0
149e0 1c4 52 00 A0 FD | hdloop                      call    #\hsync
149e4 1c5 A3 35 C3 FC |                             xcont   m_half, hsync1
149e8 1c6 A2 25 C3 FC |                             xcont   m_bs, hsync0
149ec 1c7 FC E7 6F FB |                             djnz    b, #hdloop
149f0 1c8             | 
149f0 1c8 52 00 A0 FD |                             call    #\hsync
149f4 1c9 A2 35 C3 FC |                             xcont   m_half, hsync0          'generate horizontal blanking/sync
149f8 1ca A2 25 C3 FC |                             xcont   m_bs, hsync0
149fc 1cb 52 00 A0 FD |                             call    #\hsync
14a00 1cc A2 E5 C3 FC |                             xcont   a, hsync0
14a04 1cd A2 25 C3 3C |             if_nc           xcont   m_bs, hsync0
14a08 1ce             | 
14a08 1ce             |             org     font+64                                 'pad out remainder of font/scratch area
14a08 000             | '--------------------------------------------------------------------------------------------------
14a08 000             | ' Uninitialized data
14a08 000             | '--------------------------------------------------------------------------------------------------
14a08 000             | 
14a08 000             | bppidx      res     1
14a08 000             | bppidx      res     1
14a08 000             | rowheight                                   'name used in text mode only
14a08 000             | pattern     res     1                       'name used in gfx mode only
14a08 000             | pattern     res     1                       'name used in gfx mode only
14a08 000             | row                                         'name used in text mode only
14a08 000             | transfers   res     1                       'name used in gfx mode only
14a08 000             | transfers   res     1                       'name used in gfx mode only
14a08 000             | palselect   res     1
14a08 000             | palselect   res     1
14a08 000             | scanline    res     1
14a08 000             | scanline    res     1
14a08 000             | rowscan     res     1
14a08 000             | rowscan     res     1
14a08 000             | pixels      res     1
14a08 000             | pixels      res     1
14a08 000             | 
14a08 000             | save        res     1
14a08 000             | save        res     1
14a08 000             | a           res     1
14a08 000             | a           res     1
14a08 000             | b           res     1
14a08 000             | b           res     1
14a08 000             | c           res     1
14a08 000             | c           res     1
14a08 000             | d           res     1
14a08 000             | d           res     1
14a08 000             | 
14a08 000             |             fit     $1f6                    'ensure we fit in the COG
14a08 000             |             fit     $1f6                    'ensure we fit in the COG
14a08 000             | '--------------------------------------------------------------------------------------------------
14a08 000             | ' LUT RAM code (startup configuration only)
14a08 000             | '--------------------------------------------------------------------------------------------------
14a08 000             |             orgh
14a08                 | setupcode
14a08                 |             org     $200
14a08 200             | 
14a08 200             | ' temporary configuration code loaded to LUT and executed during driver startup
14a08 200 3B F3 07 FB |                             rdlong  ptrb, ptra[-5]          'read pin & custom timing info
14a0c 201             |  '                           wrlong  c, ptra[-5]             'write our our COG ID
14a0c 201 F9 EF 03 F6 |                             mov     pb, ptrb                'make a copy to preserve things
14a10 202 1F 04 24 F4 |                             bith    linebuf1, #31           'setup buffer toggle bit states
14a14 203 1F 06 04 F4 |                             bitl    linebuf2, #31           '..in both line buffer addresses
14a18 204 02 E2 03 F6 |                             mov     save, linebuf1          'initialize for the first time
14a1c 205 1F F2 17 F4 |                             testb   ptrb, #31 wc            'test for analog (0) or digital (1)
14a20 206 9C 02 90 CD |             if_c            jmp     #setupdvi               'if digital, do DVI setup
14a24 207 1E F2 17 F4 |                             testb   ptrb, #30 wc            'test for TV mode (1) or RGB (0)
14a28 208 08 E8 67 F0 |                             shl     c, #8                   'move cog ID into place for OR
14a2c 209 F4 45 43 F5 |                             or      dacmode_s, c            'install cog ID into sync DAC
14a30 20a F4 47 43 F5 |                             or      dacmode_c, c            'install cog ID into colour DACs
14a34 20b 30 03 90 3D |             if_nc           jmp     #setupvga               'if not TV mode, do VGA setup
14a38 20c             | 
14a38 20c             | setuptv
14a38 20c 1F 03 A0 FD |                             call    #\setuptiming
14a3c 20d F7 E5 6B F8 |                             getnib  a, pb, #5               'extract pin group
14a40 20e 04 E4 07 FA |                             mul     a, #4                   'convert pin group to pin base
14a44 20f F7 E7 FB F8 |                             getbyte b, pb, #3               'get syncoptions field
14a48 210 05 E6 17 F4 |                             testb   b, #5 wc                'test for HD sync (1), SD sync (0)
14a4c 211 7C 01 90 CD |             if_c            jmp     #hdtvsync
14a50 212 02 E6 17 F4 |                             testb   b, #2 wc                'test for composite (0), other (1)
14a54 213 18 00 90 3D |             if_nc           jmp     #compositevideo
14a58 214 6A E6 7B FD |                             rczr    b wcz                   'convert two lsb's into flags
14a5c 215 10 01 90 CD |             if_c            jmp     #componentvideo
14a60 216             | 
14a60 216             | s_video
14a60 216 50 40 07 F6 |                             mov     cmodval, #%00_10_1000_0 'enable Y/C video generation
14a64 217 40 E4 07 F1 |                             add     a, #(1<<6)              'setup two pins (Y+C)
14a68 218 40 E4 07 A1 |             if_z            add     a, #(1<<6)              'setup three pins (Y+C+Composite)
14a6c 219 0C 00 90 FD |                             jmp     #sdtvcommon
14a70 21a             | 
14a70 21a             | compositevideo
14a70 21a 70 40 07 F6 |                             mov     cmodval, #%00_11_1000_0 'enable composite video generation
14a74 21b 03 E6 07 F5 |                             and     b, #3                   'get selected output DAC ID
14a78 21c F3 E5 03 F1 |                             add     a, b                    'add to DAC ID offset
14a7c 21d             | sdtvcommon
14a7c 21d F2 47 03 FC |                             wrpin   dacmode_c, a            'enable DAC mode on DAC pin(s)
14a80 21e 41 E4 63 FD |                             dirh    a                       'enable pin output
14a84 21f 01 44 07 F6 |                             mov     hsync0, #1              'idle hsync
14a88 220 02 46 0F F6 |                             mov     hsync1, #2 wz           'active hsync, clear z
14a8c 221             | 
14a8c 221             |                             'sync_000 holds sync/2
14a8c 221             |                             'sync_001 holds line/2 - sync/2
14a8c 221             |                             'sync_002 holds line/2 - sync
14a8c 221             |                             'sync_003 holds sync
14a8c 221             | interlacedcommon
14a8c 221 98 A5 AC 59 |             if_nz           setr    hsync, #$198            'remove xzero if CVBS or S-Video
14a90 222 97 E5 33 F9 |                             getword a, m_vi, #0             'get visible + front porch pixels
14a94 223 96 E7 33 F9 |                             getword b, m_bv, #0             'get back porch pixels
14a98 224 F3 E5 03 F1 |                             add     a, b                    'sum them together
14a9c 225 93 E7 33 F9 |                             getword b, m_sn, #0             'get sync width to be added
14aa0 226 F3 E5 03 F1 |                             add     a, b                    'a contains total pixels/line (H)
14aa4 227 F3 23 03 F6 |                             mov     sync_003, b             'store the sync width
14aa8 228 01 E6 47 F0 |                             shr     b, #1                   'b now contains half sync width
14aac 229 F3 1D 03 F6 |                             mov     sync_000, b             'store the half sync width
14ab0 22a             | 
14ab0 22a 01 E4 57 F0 |                             shr     a, #1 wc                'a = H/2
14ab4 22b F2 35 23 F9 |                             setword m_half, a, #0           'setup m_half for half a scan line
14ab8 22c F2 E7 03 F6 |                             mov     b, a                    'preserve H/2
14abc 22d 8E E5 83 F1 |                             sub     a, sync_000             'a = H/2 - sync/2
14ac0 22e 01 E4 07 C1 |              if_c           add     a, #1
14ac4 22f F2 1F 03 F6 |                             mov     sync_001, a             'save this value
14ac8 230 91 E7 83 F1 |                             sub     b, sync_003             'b = H/2 - sync
14acc 231 01 E6 07 C1 |              if_c           add     b, #1
14ad0 232 F3 21 03 F6 |                             mov     sync_002, b             'save this value
14ad4 233 9A 37 03 F6 |                             mov     m_slim, m_half          'compute m_slim next
14ad8 234 91 37 83 F1 |                             sub     m_slim, sync_003        'm_slim is half line - sync width
14adc 235 96 E7 33 F9 |                             getword b, m_bv, #0             'get back porch pixels
14ae0 236 F3 37 83 F1 |                             sub     m_slim, b               'subtract them from m_slim
14ae4 237 01 36 07 C1 |              if_c           add     m_slim, #1
14ae8 238             | 
14ae8 238 F4 E5 E3 F8 |                             getbyte a, c, #0                'get colour burst pixels
14aec 239 F2 2B 23 F9 |                             setword m_cb, a, #0             'store it in m_cb streamer mode
14af0 23a F2 E7 83 F1 |                             sub     b, a                    'subtract burst from back porch
14af4 23b F4 E5 EB F8 |                             getbyte a, c, #1                'get breezeway pixels
14af8 23c F2 29 23 F9 |                             setword m_br, a, #0             'store it in m_br streamer mode
14afc 23d F2 E7 83 F1 |                             sub     b, a                    'compensate for breezeway size
14b00 23e F3 2D 23 59 |             if_nz           setword m_bv, b, #0             'write updated value to back porch
14b04 23f             |                                                             '..but not for interlaced component
14b04 23f             | 
14b04 23f 3B E4 03 F6 |                             mov     a, patchvfp
14b08 240 09 E4 47 F0 |                             shr     a, #9
14b0c 241 FF E5 CF F7 |                             test    a, #$1ff wz
14b10 242 B2 77 00 A6 |             if_z            mov     patchvfp, writestat     'no front porch (just equalization)
14b14 243             | 
14b14 243 1B EE 0F F4 |                             testb   pb, #27 wz              'test for NTSC/PAL (patch for NTSC)
14b18 244 06 5A BF 59 |             if_nz           sets    ntsc1, #6               'NTSC uses 6 equalizing pulses
14b1c 245 06 66 BF 59 |             if_nz           sets    ntsc2, #6               'NTSC uses 6 serrated vsync pulses
14b20 246 06 6C BF 59 |             if_nz           sets    ntsc3, #6               'NTSC uses 6 equalizing pulses
14b24 247 00 72 07 56 |             if_nz           mov     ntsc4, #0               'not used for NTSC case
14b28 248 00 74 07 56 |             if_nz           mov     ntsc5, #0               'not used for NTSC case
14b2c 249 0C 76 3F 58 |             if_nz           setnib  ntsc6, #%1100, #7       'turn on if_c condition for NTSC
14b30 24a 80 4C 3E 5F 
14b34 24b 01 38 07 56 |             if_nz           mov     colourburst, ##COLOUR_BURST_NTSC
14b38 24c             | 
14b38 24c 1C EE 17 F4 |                             testb   pb, #28 wc              'test for interlaced/progressive
14b3c 24d 04 5A BF 29 |             if_z_and_nc     sets    ntsc1, #4               'prog PAL uses 4 equalizing pulses
14b40 24e 00 54 07 36 |             if_nc           mov     cy, #0
14b44 24f 00 56 07 36 |             if_nc           mov     ci, #0
14b48 250 00 72 07 36 |             if_nc           mov     ntsc4, #0
14b4c 251 00 74 07 36 |             if_nc           mov     ntsc5, #0
14b50 252 00 76 07 36 |             if_nc           mov     ntsc6, #0
14b54 253             | 
14b54 253 93 E5 3B F9 |                             getword a, m_sn, #1             'get sync streamer mode top word
14b58 254 F2 1D 2B F9 |                             setword sync_000, a, #1         'and use to build streamer modes
14b5c 255 F2 1F 2B F9 |                             setword sync_001, a, #1
14b60 256 F2 21 2B F9 |                             setword sync_002, a, #1
14b64 257 F2 23 2B F9 |                             setword sync_003, a, #1
14b68 258             | 
14b68 258 50 54 4F FB |                             callpa  #interlacedsd, #copysync
14b6c 259 BC 02 90 FD |                             jmp     #setupclk               'now setup the clock
14b70 25a             | 
14b70 25a             | componentvideo
14b70 25a 34 40 07 F6 |                             mov     cmodval, #%00_01_1_0100 'enable component video generation
14b74 25b 0C 40 67 55 |             if_nz           xor     cmodval, #%1100         'flip Y/Pr sync outputs if chosen
14b78 25c 81 E4 07 F1 |                             add     a, #(2<<6)+1            'skip DAC0 and setup pins (Y+Pr+Pb)
14b7c 25d F2 47 03 FC |                             wrpin   dacmode_c, a            'enable DACs in pin group
14b80 25e 41 E4 63 FD |                             dirh    a                       'enable pin group output
14b84 25f 1C EE 0F F4 |                             testb   pb, #28 wz              'test for interlaced/progressive
14b88 260             | 
14b88 260 00 A8 04 F6 |                             mov     dobreeze, #0            'kill unwanted instructions
14b8c 261 00 AC 04 F6 |                             mov     doburst, #0
14b90 262 00 22 07 F6 |                             mov     sync_003, #0            'idle hsync, idle vsync
14b94 263 C7 20 07 F6 |                             mov     sync_002, #(-BLANK_LEVEL & $ff)  'active hsync, idle vsync
14b98 264 00 1E 07 F6 |                             mov     sync_001, #0            'idle hsync, active vsync
14b9c 265 C7 1C 07 F6 |                             mov     sync_000, #(-BLANK_LEVEL & $ff)  'active hsync, active vsync
14ba0 266 91 45 03 F6 |                             mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
14ba4 267 90 47 03 F6 |                             mov     hsync1, sync_002        'vsync off, hsync on
14ba8 268 E0 FE 9F AD |             if_z            jmp     #interlacedcommon       'interlaced sync version
14bac 269             | 
14bac 269 00 82 04 F6 |                             mov     proghd1, #0             'progressive sync version
14bb0 26a 00 9E 04 F6 |                             mov     proghd3, #0
14bb4 26b 00 84 04 F6 |                             mov     vsyncon, #0
14bb8 26c 00 92 04 F6 |                             mov     vsyncoff, #0
14bbc 26d             | 
14bbc 26d 97 37 33 F9 |                             getword m_slim, m_vi, #0        'get normal visible + fp width
14bc0 26e 93 E5 33 F9 |                             getword a, m_sn, #0             'get normal sync width
14bc4 26f F2 37 83 F1 |                             sub     m_slim, a               'save the delta for vsync interval
14bc8 270 60 02 90 FD |                             jmp     #setupclk
14bcc 271             | 
14bcc 271             | hdtvsync
14bcc 271 30 40 07 F6 |                             mov     cmodval, #%00_01_1000_0 'enable component video generation
14bd0 272 01 E4 07 F1 |                             add     a, #1                   'skip base DAC0
14bd4 273 80 E4 07 F1 |                             add     a, #(2<<6)              'setup three pins (Y+Pr+Pb)
14bd8 274 F2 47 03 FC |                             wrpin   dacmode_c, a            'enable DACs on these 3 pins
14bdc 275 41 E4 63 FD |                             dirh    a                       'enable pin output
14be0 276 04 E6 0F F4 |                             testb   b, #4 wz                'check for interlaced/progressive
14be4 277 07 E6 07 F5 |                             and     b, #7                   'use 3 lsb's as sync outputs
14be8 278 01 E6 67 F0 |                             shl     b, #1
14bec 279 F3 41 43 F5 |                             or      cmodval, b
14bf0 27a 93 E5 33 F9 |                             getword a, m_sn, #0             'get the sync width in pixels
14bf4 27b 01 E4 57 F0 |                             shr     a, #1 wc                'split it into two halves
14bf8 27c F2 27 23 F9 |                             setword m_sn, a, #0             'use first half for low sync
14bfc 27d 93 2B 03 F6 |                             mov     m_cb, m_sn              'use second half for high sync
14c00 27e 01 2A 07 C1 |             if_c            add     m_cb, #1                'compensate for any odd pixels
14c04 27f 31 38 07 F6 |                             mov     colourburst, #((+105*60/128)&$ff)
14c08 280 CF 46 07 F6 |                             mov     hsync1, #((-105*60/128)&$ff)
14c0c 281 00 44 07 F6 |                             mov     hsync0, #0
14c10 282 48 00 90 AD |             if_z            jmp     #hdtvinterlaced         'do interlaced version
14c14 283             | 
14c14 283             | hdtvprogressive
14c14 283 00 80 04 F6 |                             mov     proghd0, #0             'kill unwanted instructions
14c18 284 00 9C 04 F6 |                             mov     proghd2, #0
14c1c 285 00 84 04 F6 |                             mov     vsyncon, #0
14c20 286 00 92 04 F6 |                             mov     vsyncoff, #0
14c24 287 54 AE 00 F6 |                             mov     flipref, dobreeze       'rearrange streamer instructions
14c28 288 00 A8 04 F6 |                             mov     dobreeze, #0            'nop away old instruction
14c2c 289 00 AE 3C F8 |                             setnib  flipref, #0, #7         'return early during normal lines
14c30 28a A3 B1 BC F9 |                             sets    bp, #hsync1             'use negative sync "colour"
14c34 28b 96 29 03 F6 |                             mov     m_br, m_bv              'use breezeway to do back porch
14c38 28c 96 E5 33 F9 |                             getword a, m_bv, #0             'get back porch width
14c3c 28d 97 37 33 F9 |                             getword m_slim, m_vi, #0        'get normal visible + fp width
14c40 28e F2 37 83 F1 |                             sub     m_slim, a               'save the delta for vsync interval
14c44 28f 9B 2D 23 F9 |                             setword m_bv, m_slim, #0        'and keep it in m_bv during vsync
14c48 290             | 
14c48 290 A2 23 03 F6 |                             mov     sync_003, hsync0        'idle hsync, idle vsync
14c4c 291 A3 21 03 F6 |                             mov     sync_002, hsync1        'active hsync, idle vsync
14c50 292 A2 1F 03 F6 |                             mov     sync_001, hsync0        'idle hsync, active vsync
14c54 293 A3 1D 03 F6 |                             mov     sync_000, hsync1        'active hsync, active vsync
14c58 294 D0 01 90 FD |                             jmp     #setupclk
14c5c 295             | 
14c5c 295             | hdtvinterlaced
14c5c 295 48 E4 03 F6 |                             mov     a, patchvsync           'get vertical sync line count
14c60 296 09 E4 47 F0 |                             shr     a, #9                   '...stored in the d-field
14c64 297 01 E4 67 F0 |                             shl     a, #1                   'double it (they are half lines)
14c68 298 F2 87 BB F9 |                             sets    hdloopstart, a          'patch into hd code before copy
14c6c 299 0F 78 4F FB |                             callpa  #interlacedhd, #copysync
14c70 29a             | 
14c70 29a 97 E5 33 F9 |                             getword a, m_vi, #0             'get visible + front porch pixels
14c74 29b 96 E7 33 F9 |                             getword b, m_bv, #0             'get back porch pixels
14c78 29c F3 E5 03 F1 |                             add     a, b                    'sum them together
14c7c 29d 93 E7 33 F9 |                             getword b, m_sn, #0             'get sync width to be added
14c80 29e F3 E5 03 F1 |                             add     a, b                    'a contains total pixels/line (H)
14c84 29f 01 E4 47 F0 |                             shr     a, #1                   'a is half line size
14c88 2a0 97 35 03 F6 |                             mov     m_half, m_vi
14c8c 2a1 F2 35 83 F1 |                             sub     m_half, a
14c90 2a2 92 E5 33 F9 |                             getword a, m_bs, #0
14c94 2a3 F2 35 83 F1 |                             sub     m_half, a
14c98 2a4 01 00 00 FF 
14c9c 2a5 00 46 84 F1 |                             sub     patchvbp, ##$200        'one line gets used by vsync code
14ca0 2a6             | 
14ca0 2a6 00 A8 04 F6 |                             mov     dobreeze, #0            'nop away old instruction
14ca4 2a7 00 AE 04 F6 |                             mov     flipref, #0
14ca8 2a8 80 01 90 FD |                             jmp     #setupclk
14cac 2a9             | 
14cac 2a9 3F EC B7 F9 | copysync                    setd    pa, #syncspace          'copy code into space for sync
14cb0 2aa 12 04 DC FC |                             rep     #2, #18                 'repeat 2 instructions 18 times
14cb4 2ab 3F EC A7 F9 |                             alti    pa, #%111_111           'auto increment
14cb8 2ac 00 00 00 F6 |                             mov     0-0, 0-0                'copy longs
14cbc 2ad 2D 00 64 FD |                             ret
14cc0 2ae             | 
14cc0 2ae             | setupdvi                                                    'code configures for DVI
14cc0 2ae 00 A8 04 F6 |                             mov     dobreeze, #0
14cc4 2af 00 AC 04 F6 |                             mov     doburst, #0
14cc8 2b0 00 36 07 F6 |                             mov     m_slim, #0
14ccc 2b1 00 82 04 F6 |                             mov     proghd1, #0
14cd0 2b2 00 9E 04 F6 |                             mov     proghd3, #0
14cd4 2b3 1F 03 A0 FD |                             call    #\setuptiming           'check for any timing override
14cd8 2b4             | 
14cd8 2b4 A1 1D 63 A5 |             if_z            xor     sync_000, vsyncpin      'setup hsync polarity
14cdc 2b5 A1 1F 63 A5 |             if_z            xor     sync_001, vsyncpin      'flip if +hsync
14ce0 2b6 A1 21 63 A5 |             if_z            xor     sync_002, vsyncpin      'hsync is otherwise negative
14ce4 2b7 A1 23 63 A5 |             if_z            xor     sync_003, vsyncpin      'vsync_pin data holds flip mask
14ce8 2b8             | 
14ce8 2b8 0B 1C E7 C4 |             if_c            bitnot  sync_000, #11           'setup vsync polarity
14cec 2b9 0B 1E E7 C4 |             if_c            bitnot  sync_001, #11           'flipping bit 11 makes +vsync
14cf0 2ba 0B 20 E7 C4 |             if_c            bitnot  sync_002, #11           'vsync is otherwise negative
14cf4 2bb 0B 22 E7 C4 |             if_c            bitnot  sync_003, #11           'by default
14cf8 2bc             | 
14cf8 2bc 00 92 04 F6 |                             mov     vsyncoff, #0            'disable sync output instructions
14cfc 2bd 00 84 04 F6 |                             mov     vsyncon, #0
14d00 2be             | 
14d00 2be 00 41 07 F6 |                             mov     cmodval, #%10_00_0000_0 'enable DVI in CMOD
14d04 2bf F7 E5 6B F8 |                             getnib  a, pb, #5               'extract pin group
14d08 2c0 03 E4 1F F4 |                             bitl    a, #3 wcz               'test forward/backward DVI order
14d0c 2c1 07 40 47 F4 |                             bitc    cmodval, #7             'setup in CMOD
14d10 2c2 04 E4 67 F0 |                             shl     a, #4
14d14 2c3 32 00 66 FD |                             skipf   #%100000000
14d18 2c4 81 E4 47 F5 |                             or      a, #$81
14d1c 2c5 F2 25 D3 F8 | setupstreamer               setbyte m_bs, a, #2
14d20 2c6 F2 27 D3 F8 |                             setbyte m_sn, a, #2
14d24 2c7 F2 2D D3 F8 |                             setbyte m_bv, a, #2
14d28 2c8 F2 2F D3 F8 |                             setbyte m_vi, a, #2
14d2c 2c9 F2 33 D3 F8 |                             setbyte m_brdr, a, #2
14d30 2ca 05 E4 07 F1 |                             add     a, #5
14d34 2cb F2 31 D3 F8 |                             setbyte m_rf, a, #2
14d38 2cc 2D 00 64 FD |                             ret
14d3c 2cd 86 E4 87 F1 |                             sub     a, #$86
14d40 2ce 01 E4 47 F0 |                             shr     a, #1
14d44 2cf C0 E5 47 F5 |                             or      a, #7<<6
14d48 2d0             | 
14d48 2d0 7B 0B 80 FF 
14d4c 2d1 F2 01 0B FC |                             wrpin   ##%10110_1111_0111_10_00000_0, a  '123 ohm BITDAC for pins
14d50 2d2             | 
14d50 2d2 58 E4 63 FD |                             drvl    a                       'enable DVI output pins in group
14d54 2d3 91 45 03 F6 |                             mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
14d58 2d4 90 47 03 F6 |                             mov     hsync1, sync_002        'vsync off, hsync on
14d5c 2d5 66 66 06 FF 
14d60 2d6 CD E4 07 F6 |                             mov     a, ##$0CCCCCCC+1        'always set frequency to 1/10 clk
14d64 2d7 F4 00 90 FD |                             jmp     #applyclks
14d68 2d8             | 
14d68 2d8             | setupvga                                                    'code configures for analog/VGA
14d68 2d8 00 A8 04 F6 |                             mov     dobreeze, #0
14d6c 2d9 00 AC 04 F6 |                             mov     doburst, #0
14d70 2da 00 36 07 F6 |                             mov     m_slim, #0
14d74 2db 00 82 04 F6 |                             mov     proghd1, #0
14d78 2dc 00 9E 04 F6 |                             mov     proghd3, #0
14d7c 2dd 20 40 07 F6 |                             mov     cmodval, #%00_01_0000_0
14d80 2de 1F 03 A0 FD |                             call    #\setuptiming           'check for any timing override
14d84 2df             | 
14d84 2df 00 40 A7 F4 |                             bitnz   cmodval, #0             'set hsync polarity default
14d88 2e0 F7 43 FB F8 |                             getbyte vsyncpin, pb, #3        'get the vsync pin
14d8c 2e1             | 
14d8c 2e1 A1 E7 03 F6 |                             mov     b, vsyncpin             'get the sync/options field
14d90 2e2 3C E6 07 F5 |                             and     b, #%111100             'get base pin of vsync
14d94 2e3             | 
14d94 2e3 F7 E5 F3 F8 |                             getbyte a, pb, #2               'extract analog 4-pin group
14d98 2e4             | 
14d98 2e4 01 E4 47 F0 |                             shr     a, #1
14d9c 2e5 70 E4 07 F5 |                             and     a, #$70
14da0 2e6 01 E4 47 F5 |                             or      a, #$01
14da4 2e7 C5 02 A0 FD |                             call    #\setupstreamer
14da8 2e8             | 
14da8 2e8 F7 E5 6B F8 |                             getnib  a, pb, #5               'extract analog 4-pin group
14dac 2e9 04 E4 07 FA |                             mul     a, #4                   'convert to real pin base number
14db0 2ea             | 
14db0 2ea 00 22 07 F6 |                             mov     sync_003, #0            'idle hsync, idle vsync
14db4 2eb 01 20 07 F6 |                             mov     sync_002, #1            'active hsync, idle vsync
14db8 2ec 00 1E 07 F6 |                             mov     sync_001, #0            'idle hsync, active vsync
14dbc 2ed 01 1C 07 F6 |                             mov     sync_000, #1            'active hsync, active vsync
14dc0 2ee             | 
14dc0 2ee F3 E5 0B F2 |                             cmp     a, b wz                 'check if pin group matches
14dc4 2ef             | 
14dc4 2ef             |                             ' 5pin VGA: RGBHV
14dc4 2ef 5B 42 63 5D |             if_nz           drvnc   vsyncpin                'start with inactive vsync
14dc8 2f0 A1 85 B0 F9 |                             setd    vsyncon, vsyncpin
14dcc 2f1 42 92 00 56 |             if_nz           mov     vsyncoff, vsyncon       'use correct method for vsync
14dd0 2f2 3C 00 90 5D |             if_nz           jmp     #setup_4pins            'done 5 pin VGA, go setup pins
14dd4 2f3 03 42 CF F7 |                             test    vsyncpin, #3 wz         'test 2 lsbs of vsync, 4 cases
14dd8 2f4             |                                                             '00: RGBS 1Vp-p sync into 75ohms
14dd8 2f4             |                                                             '01: RGB/YPrPb with sync on DAC1
14dd8 2f4             |                                                             '10: RGB/YPrPb with sync on DAC2
14dd8 2f4             |                                                             '11: RGB/YPrPb with sync on DAC3
14dd8 2f4             | 
14dd8 2f4             |                             ' 4pin VGA: RGBS (VGA with Composite Sync)
14dd8 2f4 A3 45 03 A6 |             if_z            mov     dacmode_s, dacmode_c    'drive 75 ohm sync input, not ttl
14ddc 2f5 49 84 00 A6 |             if_z            mov     vsyncon, vsyncoff       'use correct method for vsync
14de0 2f6 2C 00 90 AD |             if_z            jmp     #setup_4pins
14de4 2f7             |                             ' 3pin VGA: RGB/component cases: eg. SyncOnGreen or YPrPb
14de4 2f7 00 92 BC F9 |                             sets    vsyncoff, #0
14de8 2f8 49 84 00 F6 |                             mov     vsyncon, vsyncoff
14dec 2f9 00 1C 07 F6 |                             mov     sync_000, #0
14df0 2fa C7 1E 07 F6 |                             mov     sync_001, #(256-BLANK_LEVEL)
14df4 2fb C7 20 07 F6 |                             mov     sync_002, #(256-BLANK_LEVEL)
14df8 2fc 00 22 07 F6 |                             mov     sync_003, #0
14dfc 2fd 01 E6 07 F6 |                             mov     b, #1
14e00 2fe 03 42 07 F5 |                             and     vsyncpin, #3
14e04 2ff A1 E7 63 F0 |                             shl     b, vsyncpin
14e08 300 F3 41 43 F5 |                             or      cmodval, b
14e0c 301 08 00 90 FD |                             jmp     #setup_3pins
14e10 302             | setup_4pins
14e10 302 F2 45 03 FC |                             wrpin   dacmode_s, a            'setup sync mode on DAC0 in group
14e14 303 41 E4 63 FD |                             dirh    a                       'enable the sync pin
14e18 304             | setup_3pins
14e18 304 81 E4 07 F1 |                             add     a, #1 + (2<<6)          'setup next pin group
14e1c 305 F2 47 03 FC |                             wrpin   dacmode_c, a            'setup colour mode on DACs1-3
14e20 306 41 E4 63 FD |                             dirh    a                       'enable this pin group
14e24 307 91 45 03 F6 |                             mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
14e28 308 90 47 03 F6 |                             mov     hsync1, sync_002        'vsync off, hsync on
14e2c 309             | 
14e2c 309             | setupclk
14e2c 309 84 E5 07 FB |                             rdlong  a, ptrb[4]              'get xfrq value or divider
14e30 30a F2 E7 3B F9 |                             getword b, a, #1                'extract upper long
14e34 30b F3 E7 CB F7 |                             test    b wz                    'check if xrfq value or divider
14e38 30c 20 00 90 5D |             if_nz           jmp     #applyclks              'for dividers, upper long is 0
14e3c 30d F2 E9 33 F9 |                             getword c, a, #0                'get fractional pixel clock ratio
14e40 30e F4 E9 CB F7 |                             test    c wz                    'check for divide by zero case
14e44 30f             | 
14e44 30f 05 00 00 AF 
14e48 310 00 E8 07 A6 |             if_z            mov     c, ##2560               '..if so, assume divider is 10.000
14e4c 311 F4 01 29 FD |                             qfrac   #$80, c                 'divide $80_0000_0000 by ratio
14e50 312 18 E4 63 FD |                             getqx   a                       'get quotient
14e54 313 19 E6 6B FD |                             getqy   b wz                    'get remainder and test for 0
14e58 314 01 E4 07 51 |             if_nz           add     a,  #1                  'round up if a fractional result
14e5c 315             | applyclks
14e5c 315 38 01 B0 FD |                             call    #copymono1              'determine type of text mode possible
14e60 316 86 E7 07 FB |                             rdlong  b, ptrb[6]              'read CFRQ parameter
14e64 317 15 00 0C F4 |                             testb   statusaddr, #21 wz      'check if we want a delayed start
14e68 318 24 3C 60 AD |             if_z            waitatn                         '...if so, wait for ATN
14e6c 319 01 E8 63 FD |                             cogid   c
14e70 31a F4 45 00 F8 |                             setnib  writestat1, c, #0
14e74 31b 3C 40 63 FD |                             setcmod cmodval                 'setup using cmod register
14e78 31c 3B E6 63 FD |                             setcfrq b                       'set the colour modulator rate
14e7c 31d 1D E4 63 FD |                             setxfrq a                       'set the streamer rate
14e80 31e D0 F3 9F FD |                             jmp     #fieldloop              'begin outputting video frames
14e84 31f             | 
14e84 31f             | setuptiming
14e84 31f 13 F2 47 F7 |                             zerox   ptrb, #19               'check if we have custom timing
14e88 320 03 F2 9F FB |                             tjnz    ptrb, #customtiming     'skip if we do
14e8c 321 00 E4 07 F6 |                             mov     a, #H_SYNC_POLARITY     'setup some default polarities
14e90 322 01 E4 8F F1 |                             sub     a, #1 wz                'z=1 if positive hsync desired
14e94 323 00 E4 B7 07 |             _ret_           ones    a, #V_SYNC_POLARITY wc  'c=1 if positive vsync desired
14e98 324             |                             'read in custom timing block and patch all COG code accordingly
14e98 324             | customtiming
14e98 324 82 E5 07 FB |                             rdlong  a, ptrb[2]              'read custom horizontal timing
14e9c 325 F2 E7 E3 F8 |                             getbyte b, a, #0                'get columns
14ea0 326 F0 E6 67 F3 |                             fles    b, #240                 'set maximum of 1920 pixels
14ea4 327 F3 3B 03 F6 |                             mov     vis_pixels, b           'save as visible columns
14ea8 328 08 3A 07 FA |                             mul     vis_pixels, #8          'convert to pixels
14eac 329 F3 C3 B9 F9 |                             sets    p1, b                   'patch columns into code
14eb0 32a F3 CB B9 F9 |                             sets    p4, b
14eb4 32b F3 61 BA F9 |                             sets    p6, b
14eb8 32c F3 0D B9 F9 |                             sets    p0, b
14ebc 32d F3 E9 03 F6 |                             mov     c, b
14ec0 32e 01 E6 67 F0 |                             shl     b, #1                   'compute columns*2
14ec4 32f F3 C5 B9 F9 |                             sets    p2, b                   'patch columns*2 into code
14ec8 330 02 E6 47 F0 |                             shr     b, #2                   'compute columns/2
14ecc 331 F3 C9 B9 F9 |                             sets    p3, b                   'patch columns/2 into code
14ed0 332 F3 BB B9 F9 |                             sets    p9, b
14ed4 333 01 BA 85 F1 |                             sub     p9, #1
14ed8 334 DD B6 B1 F9 |                             setd    readrow, p9             'patch columns/2 - 1 into code
14edc 335 10 BB 05 F1 |                             add     p9, #$110
14ee0 336 01 EA 07 F6 |                             mov     d, #1
14ee4 337 F3 EB C3 F2 |                             subr    d, b
14ee8 338 86 D9 B7 F9 |                             setd    row, #modetable+1
14eec 339 08 04 DC FC |                             rep     #2, #8
14ef0 33a 38 D8 A7 F9 |                             alti    row, #%111_000
14ef4 33b F5 01 D0 F8 | settable                    setbyte 0-0, d, #2
14ef8 33c 01 E6 47 F0 |                             shr     b, #1                   'compute columns/4
14efc 33d F3 EB 83 F1 |                             sub     d, b
14f00 33e F5 0B D3 F8 |                             setbyte modetable, d, #2
14f04 33f F3 BD B9 F9 |                             sets    p10, b
14f08 340 01 E8 87 F1 |                             sub     c, #1                   'compute columns -1
14f0c 341 F4 07 B2 F9 |                             setd    p5, c                   'patch columns - 1 into code
14f10 342 FF E9 C7 F2 |                             subr    c, #$1ff
14f14 343 F4 09 B2 F9 |                             setd    p11, c
14f18 344 9D 2F 23 F9 |                             setword m_vi, vis_pixels, #0    'setup streamer blank line
14f1c 345 9D 31 23 F9 |                             setword m_rf, vis_pixels, #0    'setup streamer visible line
14f20 346 8A E9 E7 FA |                             rdword  c, ptrb[10]             'read extended sync timing
14f24 347 F4 E7 43 F8 |                             getnib  b, c, #0                'get bits 8-11 of back porch
14f28 348 F2 E7 0B F9 |                             rolbyte b, a, #1                'get back porch pixels bits 7-0
14f2c 349 F3 2D 23 F9 |                             setword m_bv, b, #0             'setup H_BP
14f30 34a F4 E7 4B F8 |                             getnib  b, c, #1                'get bits 8-11 of horizontal sync
14f34 34b F2 E7 13 F9 |                             rolbyte b, a, #2                'get horizontal sync pixels bits 7-0
14f38 34c F3 27 23 F9 |                             setword m_sn, b, #0             'setup H_SYNC
14f3c 34d 1F E4 1F F4 |                             bitl    a, #31 wcz              'get hsync polarity into Z flag
14f40 34e F2 E7 FB F8 |                             getbyte b, a, #3                'get front porch pixels bit6-0
14f44 34f 01 E8 47 F0 |                             shr     c, #1                   'realign extended front porch
14f48 350 7F E8 27 F5 |                             andn    c, #$7f                 'mask 7 LSBs of unwanted data
14f4c 351 F4 E7 43 F5 |                             or      b, c                    'include extended front porch bits
14f50 352 F3 25 23 F9 |                             setword m_bs, b, #0             'setup H_FP
14f54 353 F3 2F 03 F1 |                             add     m_vi, b                 'include front porch in blank line
14f58 354 83 E5 07 FB |                             rdlong  a, ptrb[3]              'read custom vertical timing
14f5c 355 1F E4 17 F4 |                             testb   a, #31 wc               'get vsync polarity into C flag
14f60 356 03 00 00 FF 
14f64 357 FF 3D 07 F6 |                             mov     vis_lines, ##$7FF       'setup 11 bit mask
14f68 358 F2 3D 03 F5 |                             and     vis_lines, a            'extract 11 LSb's
14f6c 359 0B E4 47 F0 |                             shr     a, #11
14f70 35a F2 47 B0 F9 |                             setd    patchvbp, a             'setup V_BP
14f74 35b 09 E4 47 F0 |                             shr     a, #9
14f78 35c 07 E6 07 F6 |                             mov     b, #7                   '3 bit mask
14f7c 35d F2 E7 03 F5 |                             and     b, a                    'extract 3 LSB's
14f80 35e F3 91 B0 F9 |                             setd    patchvsync, b           'setup V_SYNC
14f84 35f 03 E4 47 F0 |                             shr     a, #3
14f88 360 08 E4 E7 C4 |             if_c            bitnot  a, #8                   'clear this bit for next setd
14f8c 361 F2 77 B0 F9 |                             setd    patchvfp, a             'setup V_FP
14f90 362 8B E9 E7 FA |                             rdword  c, ptrb[11]             'read colour burst params
14f94 363 2D 00 64 FD |                             ret                             'returned flags contain polarities!
14f98 364             | 
14f98 364             | copymono1
14f98 364 14 00 34 F4 |                             testbn   statusaddr, #20 wc     'check if mono text is not forced
14f9c 365 14 00 04 F4 |                             bitl     statusaddr, #20        'also clear this flag for later use
14fa0 366 CC CC 0C CF 
14fa4 367 9B E5 17 C2 |             if_c            cmp      a, ##$1999999B wc      'then check if at least 5x p2:pixel clock ratio
14fa8 368 2D 00 64 CD |             if_c            ret                             'if so, return to stick with colour text
14fac 369 00 16 BE F9 |                             sets     scaling, #0            'otherwise we can only do mono text
14fb0 36a 00 0A BE F9 |                             sets     p8, #0
14fb4 36b 88 33 AE F9 |                             setr     wr1, #$188             'patch opcode to wrbyte
14fb8 36c 88 37 AE F9 |                             setr     wr2, #$188             'patch opcode to wrbyte
14fbc 36d 55 55 15 FF 
14fc0 36e AC E4 17 F2 |                             cmp      a, ##$2AAAAAAC wc      'check if at least 3x p2:pixel clock ratio
14fc4 36f 14 01 90 CD |             if_c            jmp      #copymono2             'if so, we can support text attributes
14fc8 370 01 74 04 F8 |                             setnib   writestat2, #1, #0     'mono without attributes
14fcc 371 99 F1 07 F6 |                             mov      ptra, #p4a-$200
14fd0 372 00 EB A7 FA |                             rdlut    d, ptra
14fd4 373 DE E8 03 F6 |                             mov      c, p10                 'extract COLS/4
14fd8 374 F4 EB BB F9 |                             sets     d, c                   'patch and writeback to LUT
14fdc 375 7F EB 37 FC |                             wrlut    d, ptra--
14fe0 376 F4 E7 03 F6 |                             mov      b, c
14fe4 377 FF E9 07 F5 |                             and      c, #$1ff
14fe8 378 01 E8 47 F0 |                             shr      c, #1                  'compute COLS/8
14fec 379 00 EB A7 FA |                             rdlut    d, ptra
14ff0 37a F4 EB BB F9 |                             sets     d, c                   'patch and writeback to LUT
14ff4 37b 00 EB 37 FC |                             wrlut    d, ptra
14ff8 37c 01 E6 87 F1 |                             sub      b, #1
14ffc 37d F3 07 B2 F9 |                             setd     p5, b
15000 37e FF E7 C7 F2 |                             subr     b, #$1ff
15004 37f F3 09 B2 F9 |                             setd     p11, b
15008 380 00 7C 04 F6 |                             mov      flasher, #0            'disable flashing
1500c 381 00 B0 05 F6 |                             mov      p12, #0
15010 382 00 B2 05 F6 |                             mov      p13, #0
15014 383 00 FA BC F9 |                             sets     p7, #0
15018 384 00 00 20 FF 
1501c 385 02 E4 17 F2 |                             cmp      a, ##$4000_0002 wc     'check if at least 2x pixel clock ratio
15020 386 24 00 90 CD |             if_c            jmp      #nodisablemono         '...if so, skip disabling mono text
15024 387 DE E8 03 F6 |                             mov      c, p10                 'get COLS/4
15028 388 F4 EB BB F9 |                             sets     d, c                   'patch instruction
1502c 389 0F EA 3F F8 |                             setnib   d, #$f, #7             'remove conditional execution
15030 38a 01 EA B7 F9 |                             setd     d, #1                  'rep loop is now one instruction
15034 38b 00 EB 37 FC |                             wrlut    d, ptra                'write back to LUT
15038 38c 3E EB A7 FA |                             rdlut    d, ptra[-2]            'read two new instructions to copy
1503c 38d 01 EB 37 FC |                             wrlut    d, ptra[1]             'and patch LUT
15040 38e 3F EB A7 FA |                             rdlut    d, ptra[-1]            'this text mode will only show the background
15044 38f 02 EB 37 FC |                             wrlut    d, ptra[2]             'colour with no actual text
15048 390             | nodisablemono
15048 390 E3 E8 B7 F9 |                             setd     c, #patchtext
1504c 391 98 F1 07 F6 |                             mov      ptra, #startmono1-$200
15050 392 1B 04 DC FC |                             rep      #2, #(endmono1-startmono1)
15054 393 38 E8 A7 F9 |                             alti     c, #%111_000
15058 394 61 01 A4 FA |                             rdlut    0-0, ptra++
1505c 395 2D 00 64 FD |                             ret
15060 396             | 
15060 396             | 
15060 396             | ' this mono text mode code only support text without attributes
15060 396 FF 01 3C FC |                             wrlut   #0, ptrb--              'these instructions disable
15064 397 02 01 80 FD |                             jmp     #\endpatchtext          'mono text mode if required
15068 398             | startmono1
15068 398 0A 32 DC AC | p3a         if_z            rep     @endwide2, #COLS/8      'double wide mode
1506c 399 14 24 DC 5C | p4a         if_nz           rep     @endnormal2, #COLS/4    'single wide mode
15070 39a             | 
15070 39a F7 EB A3 FA |                             rdlut   d, pb                   'read 2 characters
15074 39b 01 EE 87 F1 |                             sub     pb, #1                  'decrement LUT lookup pos
15078 39c             | 
15078 39c F5 E7 F3 F8 |                             getbyte b, d, #2                'get MS char
1507c 39d AA E7 6F F9 |                             altgb   b, #font                'lookup font
15080 39e 00 E8 03 F9 |                             rolbyte c, 0-0, #0              'get pixels
15084 39f             | 
15084 39f F5 E7 E3 F8 |                             getbyte b, d, #0                'get LS char
15088 3a0 AA E7 6F F9 |                             altgb   b, #font                'lookup font
1508c 3a1 00 E8 03 F9 |                             rolbyte c, 0-0, #0              'get pixels
15090 3a2             | 
15090 3a2 F4 E5 03 A6 |             if_z            mov     a, c                    'preserve for double wide
15094 3a3 F7 EB A3 FA |                             rdlut   d, pb                   'read next 2 chars
15098 3a4 01 EE 87 F1 |                             sub     pb, #1                  'decrement LUT lookup pos
1509c 3a5             | 
1509c 3a5 F5 E7 F3 F8 |                             getbyte b, d, #2                'get MS char
150a0 3a6 AA E7 6F F9 |                             altgb   b, #font                'lookup font
150a4 3a7 00 E8 03 F9 |                             rolbyte c, 0-0, #0              'get pixels
150a8 3a8             | 
150a8 3a8 F5 E7 E3 F8 |                             getbyte b, d, #0                'get LS char
150ac 3a9 AA E7 6F F9 |                             altgb   b, #font                'lookup font
150b0 3aa 00 E8 03 F9 |                             rolbyte c, 0-0, #0              'get pixels
150b4 3ab             | 
150b4 3ab FF E9 37 5C |             if_nz           wrlut   c, ptrb--               'store normal wide pixels
150b8 3ac F4 E9 2B F9 | endnormal2                  setword c, c, #1                'setup MSW
150bc 3ad F2 E5 2B F9 |                             setword a, a, #1                'setup MSW
150c0 3ae 63 E4 63 FD |                             mergew  a                       'double pixels in wide mode
150c4 3af 63 E8 63 FD |                             mergew  c                       'double pixels in wide mode
150c8 3b0 FF E5 37 AC |             if_z            wrlut   a, ptrb--               'store double wide pixels
150cc 3b1 FF E9 37 AC |             if_z            wrlut   c, ptrb--               'store double wide pixels
150d0 3b2             | endwide2
150d0 3b2 02 01 80 FD |                             jmp     #\endpatchtext
150d4 3b3             | endmono1
150d4 3b3             | 
150d4 3b3 00 E4 07 F6 | mono2flash                  mov      a, #0
150d8 3b4 FF E4 07 A6 |             if_z            mov      a, #$ff
150dc 3b5             | 
150dc 3b5             | copymono2
150dc 3b5 02 74 04 F8 |                             setnib   writestat2, #2, #0     'mono with attributes
150e0 3b6 CE F1 07 F6 |                             mov      ptra, #p4b-$200
150e4 3b7 00 EB A7 FA |                             rdlut    d, ptra
150e8 3b8 E4 EA BB F9 |                             sets     d, p3                  'patch COLS/2 and writeback to LUT
150ec 3b9 7F EB 37 FC |                             wrlut    d, ptra--
150f0 3ba 00 EB A7 FA |                             rdlut    d, ptra
150f4 3bb DE EA BB F9 |                             sets     d, p10                 'patch COLS/4 and writeback to LUT
150f8 3bc 00 EB 37 FC |                             wrlut    d, ptra
150fc 3bd DE E6 03 F6 |                             mov      b, p10                 'extract COLS/4
15100 3be 01 E6 87 F1 |                             sub      b, #1                  'compute COLS/4 - 1
15104 3bf F3 07 B2 F9 |                             setd     p5, b
15108 3c0 FF E7 C7 F2 |                             subr     b, #$1ff
1510c 3c1 F3 09 B2 F9 |                             setd     p11, b
15110 3c2             | 
15110 3c2 D9 7C B4 F9 |                             setd     flasher, #p13          'patch flashing register
15114 3c3 00 FA BC F9 |                             sets     p7, #0
15118 3c4 B3 F1 07 F6 |                             mov      ptra, #(mono2flash-$200)
1511c 3c5 61 B1 A5 FA |                             rdlut    p12, ptra++
15120 3c6 61 B3 A5 FA |                             rdlut    p13, ptra++
15124 3c7             | 
15124 3c7 E3 E8 B7 F9 |                             setd     c, #patchtext
15128 3c8 CD F1 07 F6 |                             mov      ptra, #startmono2-$200
1512c 3c9 17 04 DC FC |                             rep      #2, #(endmono2-startmono2)
15130 3ca 38 E8 A7 F9 |                             alti     c, #%111_000
15134 3cb 61 01 A4 FA |                             rdlut    0-0, ptra++
15138 3cc 2D 00 64 FD |                             ret
1513c 3cd             | 
1513c 3cd             | 
1513c 3cd             | ' this mono text mode code supports inverse and flashing attributes
1513c 3cd             | startmono2
1513c 3cd 14 2A DC AC | p3b         if_z            rep     @endwide3, #COLS/4      'double wide mode
15140 3ce 28 22 DC 5C | p4b         if_nz           rep     @endnormal3, #COLS/2    'single wide mode
15144 3cf             | 
15144 3cf F7 EB B3 FA |                             rdlut   d, pb wc                'read 2 characters, get top attr
15148 3d0 01 EE 87 F1 |                             sub     pb, #1                  'advance source
1514c 3d1             | 
1514c 3d1 F5 E7 F3 F8 |                             getbyte b, d, #2                'get MS char
15150 3d2 AA E7 6F F9 |                             altgb   b, #font                'lookup font
15154 3d3 00 E8 03 F9 |                             rolbyte c, 0-0, #0              'get pixels
15158 3d4 F2 E9 23 C5 |             if_c            andn    c, a                    'if flashing set to background (0)
1515c 3d5 1C EA 17 F4 |                             testb   d, #28 wc               'test for inverse attribute
15160 3d6 FF E8 67 C5 |             if_c            xor     c, #$ff                 '...and apply it
15164 3d7             | 
15164 3d7 F5 E7 E3 F8 |                             getbyte b, d, #0                'get LS char
15168 3d8 AA E7 6F F9 |                             altgb   b, #font                'lookup font
1516c 3d9 00 E8 03 F9 |                             rolbyte c, 0-0, #0              'get pixels
15170 3da 0F EA 17 F4 |                             testb   d, #15 wc               'test flashing attribute
15174 3db F2 E9 23 C5 |             if_c            andn    c, a                    'if flashing set to background (0)
15178 3dc 0C EA 17 F4 |                             testb   d, #12 wc               'test for inverse attribute
1517c 3dd FF E8 67 C5 |             if_c            xor     c, #$ff                 '...and apply it
15180 3de             | 
15180 3de 00 EE 17 F4 |                             testb   pb, #0 wc
15184 3df FF E9 37 4C |             if_nz_and_c     wrlut   c, ptrb--               'store normal wide pixels every second iteration
15188 3e0             | 
15188 3e0 F4 E9 2B F9 | endnormal3                  setword c, c, #1                'setup MSW
1518c 3e1 63 E8 63 FD |                             mergew  c                       'double pixels in wide mode
15190 3e2 FF E9 37 AC |             if_z            wrlut   c, ptrb--               'store double wide pixels
15194 3e3             | endwide3
15194 3e3 02 01 80 FD |                             jmp     #\endpatchtext
15198 3e4             | endmono2
15198 3e4             | 
15198 3e4             |             fit $400
15198 3e4             |             fit $400
15198 3e4             | 
15198 3e4             | '--------------------------------------------------------------------------------------------------
15198 3e4             |             orgh
15198                 | 
15198                 | 
15198                 | 
15198                 | '  f_xfr        = f_pixel / f_clock * float($7FFF_FFFF)
15198                 | '  f_csc        = f_color / f_clock * float($7FFF_FFFF) * 2.0
15198                 | {
15198                 | }
15198                 | 
15198                 | prog240_timing     '720x240p timing @ 60Hz with 13.5MHz pixel clock
15198     FB 1A 10 01 |             long   CLK108MHz
1519c     00 F3 6F 06 |             long   108000000
151a0                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
151a0                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
151a0     5A 3A 40 10 |             long   (SYNC_NEG<<31) | ( 16<<24) | ( 64<<16) | ( 58<<8 ) | (720/8)
151a4                 |             'long  (SYNC_NEG<<31) | ( 56<<24) | ( 64<<16) | ( 98<<8 ) | (640/8)
151a4                 | 
151a4                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
151a4                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
151a4     F0 68 00 00 |             long   (SYNC_NEG<<31) | ( 0<<23) | (  0<<20) | ( 13<<11) | 240
151a8     00 08 00 00 |             long   8<<8
151ac     00 00 24 08 |             long   (8<<24) + (36<<16)
151b0                 |             'long    round(3579545.0 / 108000000.0 * float($7FFFFFFF) * 2.0)
151b0     F5 1E 7C 08 |             long   284704235/2 'reserved for CFRQ parameter
151b4                 | 
151b4                 | {
151b4                 | }
151b4                 | 
151b4                 | prog288_timing     '720x288p timing @ 50Hz with 13.5MHz pixel clock
151b4     FB 1A 10 01 |             long   CLK108MHz
151b8     00 F3 6F 06 |             long   108000000
151bc                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
151bc                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
151bc     5A 44 40 0C |             long   (SYNC_NEG<<31) | ( 12<<24) | ( 64<<16) | ( 68<<8 ) | (720/8)
151c0                 |             'long   (SYNC_NEG<<31) | ( 52<<24) | ( 64<<16) | (108<<8 ) | (640/8)
151c0                 | 
151c0                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
151c0                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
151c0     20 89 50 00 |             long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 17<<11) | 288
151c4     00 08 00 00 |             long   8<<8
151c8     00 00 1E 10 |             long   (16<<24) + (30<<16)
151cc     B3 62 82 0A |             long   352634214/2' reserved for CFRQ parameter
151d0                 | 
151d0                 | int480_timing      '720x480i timing @ 60Hz with 14.31818MHz pixel clock
151d0                 | 
151d0     0B 7D 28 01 |         long CLK114_5MHz
151d4     2E D3 D3 06 |         long 114545454
151d8                 |                     '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
151d8                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
151d8     5A 60 44 1A |             long   (SYNC_NEG<<31) | ( 26<<24) | ( 68<<16) | ( 96<<8 ) | (720/8)
151dc                 | 
151dc                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
151dc                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
151dc     F0 68 50 00 |             long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 13<<11) | 240
151e0     00 00 00 10 |             long 1<<28
151e4     00 00 24 10 |             long   (16<<24) + (36<<16)
151e8     00 00 00 08 |         long 1<<27
151ec                 | 
151ec                 | {
151ec                 | }
151ec                 | int576_timing
151ec     FB E2 7C 01 |             long   CLK141_875MHz
151f0     38 D7 74 08 |             long   141875000
151f4                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
151f4                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
151f4     5A 5A 42 20 |             long   (SYNC_NEG<<31) | ( 32<<24) | ( 66<<16) | ( 90<<8 ) | (720/8)
151f8                 |             'long   (SYNC_NEG<<31) | ( 52<<24) | ( 64<<16) | (108<<8 ) | (640/8)
151f8                 | 
151f8                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
151f8                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
151f8     1F 89 50 00 |             long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 17<<11) | 287
151fc     00 0A 00 00 |             long   10<<8
15200     00 00 20 0D |             long   (13<<24) + (32<<16)
15204     00 00 00 08 |             long   134217728
15208                 | 
15208                 | {
15208                 | }
15208                 | 
15208                 | prog480_timing     '720x480p timing @ 60Hz with 27MHz pixel clock
15208     FB 1A 0C 01 |             long   CLK135MHz
1520c     C0 EF 0B 08 |             long   135000000
15210                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
15210                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
15210     5A 4A 30 10 |             long   (SYNC_NEG<<31) | ( 16<<24) | ( 48<<16) | ( 74<<8 ) | (720/8)
15214                 |             'long   (SYNC_NEG<<31) | ( 16<<24) | ( 64<<16) | ( 58<<8 ) | (720/8)
15214                 | 
15214                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
15214                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
15214     E0 01 E1 03 |             long   (SYNC_NEG<<31) | ( 7<<23) | (  6<<20) | ( 32<<11) | 480
15218     00 05 00 00 |             long   5<<8
1521c     00 00 24 08 |             long   (8<<24) + (36<<16)
15220     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
15224                 | 
15224                 | prog576_timing     '720x576p timing @ 50Hz with 27MHz pixel clock
15224     FB 1A 0C 01 |             long   CLK135MHz
15228     C0 EF 0B 08 |             long   135000000
1522c                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
1522c                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
1522c     5A 54 30 0C |             long   (SYNC_NEG<<31) | ( 12<<24) | ( 48<<16) | ( 84<<8 ) | (720/8)
15230                 | 
15230                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
15230                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
15230     40 3A D1 02 |             long   (SYNC_NEG<<31) | ( 5<<23) | (  5<<20) | ( 39<<11) | 576
15234     00 05 00 00 |             long   5<<8
15238     00 00 1E 08 |             long   (8<<24) + (30<<16)
1523c     B3 62 82 0A |             long   176317107   ' reserved for CFRQ parameter
15240                 | 
15240                 | vga_timing         'VGA resolution 640x480 60Hz with 25.2MHz pixel clock
15240                 |             'long   CLK252MHz
15240                 |             'long   252000000
15240     00 00 00 00 |             long 0
15244     00 37 05 0F |             long 252000000
15248                 | 
15248                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
15248                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
15248     50 30 60 10 |             long   (SYNC_NEG<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)
1524c                 | 
1524c                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
1524c                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
1524c     E0 09 21 05 |             long   (SYNC_NEG<<31) | ( 10<<23) | (  2<<20) | ( 33<<11) | 480
15250     00 0A 00 00 |             long   10 << 8 ' $0ccccccc+1
15254     00 00 00 00 |             long   0
15258     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
1525c                 | 
1525c                 | dvi_timing         'VGA resolution 640x480 60Hz with 25.2MHz pixel clock
1525c     FB 3E 10 01 |             long   CLK252MHz
15260     00 37 05 0F |             long   252000000
15264                 | 
15264                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
15264                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
15264     50 30 60 10 |             long   (SYNC_NEG<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)
15268                 | 
15268                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
15268                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
15268     E0 09 21 05 |             long   (SYNC_NEG<<31) | ( 10<<23) | (  2<<20) | ( 33<<11) | 480
1526c     00 0A 00 00 |             long   10 << 8
15270     00 00 00 00 |             long   0
15274     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
15278                 | 
15278                 | vga400_timing      'VGA resolution 640x400 70Hz with 25.2MHz pixel clock
15278     FB 3E 10 01 |             long   CLK252MHz
1527c     00 37 05 0F |             long   252000000
15280                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
15280                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
15280     50 30 60 10 |             long   (SYNC_NEG<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)
15284                 | 
15284                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
15284                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
15284     90 19 21 86 |             long   (SYNC_POS<<31) | ( 12<<23) | (  2<<20) | ( 35<<11) | 400
15288     00 0A 00 00 |             long   10 << 8
1528c     00 00 00 00 |             long   0
15290     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
15294                 | 
15294                 | wvga_dvi_timing   ' reduced blanking for 800x480 60Hz LCD at 27MHz pixel clk YMMV
15294     FB 86 24 01 |             long   CLK270MHz
15298     80 DF 17 10 |             long   270000000
1529c                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
1529c                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
1529c     64 32 10 90 |             long   (SYNC_POS<<31) | ( 16<<24) | ( 16<<16) | ( 50<<8 ) | (800/8)
152a0                 | 
152a0                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
152a0                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
152a0     E0 A1 B0 83 |             long   (SYNC_POS<<31) | (  7<<23) | (  3<<20) | ( 20<<11) | 480
152a4     00 0A 00 00 |             long    10 << 8
152a8     00 00 00 00 |             long    0
152ac     00 00 00 00 |             long    0   ' reserved for CFRQ parameter
152b0                 | 
152b0                 | ega_timing         'EGA resolution 640x350 70Hz with 25.2MHz pixel clock
152b0     FB 3E 10 01 |             long   CLK252MHz
152b4     00 37 05 0F |             long   252000000
152b8                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
152b8                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
152b8     50 30 60 90 |             long   (SYNC_POS<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)
152bc                 | 
152bc                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
152bc                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
152bc     5E E1 A1 12 |             long   (SYNC_NEG<<31) | ( 37<<23) | (  2<<20) | ( 60<<11) | 350
152c0     00 0A 00 00 |             long   10 << 8
152c4     00 00 00 00 |             long   0
152c8     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
152cc                 | 
152cc                 | svga_timing   ' SVGA resolution 800x600 60Hz with 40MHz pixel clock
152cc     FB 3B 10 01 |             long   CLK240MHz
152d0     00 1C 4E 0E |             long   240_000000
152d4                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
152d4                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
152d4     64 58 80 A8 |             long   (SYNC_POS<<31) | ( 40<<24) | (128<<16) | ( 88<<8 ) | (800/8)
152d8                 | 
152d8                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
152d8                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
152d8     58 BA C0 80 |             long   (SYNC_POS<<31) | (  1<<23) | (  4<<20) | ( 23<<11) | 600
152dc     00 06 00 00 |             long    6 << 8
152e0     00 00 00 00 |             long    0
152e4     00 00 00 00 |             long    0   ' reserved for CFRQ parameter
152e8                 | 
152e8                 | svga_dvi_timing   ' massively reduced blanking for 800x600 50Hz at 25.2MHz clk YMMV
152e8     FB 3E 10 01 |             long   CLK252MHz
152ec     00 37 05 0F |             long   252000000
152f0                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
152f0                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
152f0     64 08 08 88 |             long   (SYNC_POS<<31) | (  8<<24) | (  8<<16) | (  8<<8 ) | (800/8)
152f4                 | 
152f4                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
152f4                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
152f4     58 5A 20 81 |             long   (SYNC_POS<<31) | (  2<<23) | (  2<<20) | ( 11<<11) | 600
152f8     00 0A 00 00 |             long    10 << 8
152fc     00 00 00 00 |             long    0
15300     00 00 00 00 |             long    0   ' reserved for CFRQ parameter
15304                 | 
15304                 | xga_timing ' 1024x768@60Hz at 65*5 MHz YMMV
15304     FB 40 0C 01 |             long   CLK325MHz
15308     40 1B 5F 13 |             long   325000000
1530c                 |        '    long   CLK200MHz
1530c                 |        '    long   200000000
1530c                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
1530c                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
1530c     80 A0 88 18 |             long   (SYNC_NEG<<31) | ( 24<<24) | (136<<16) | (160<<8 ) |(1024/8)
15310                 | 
15310                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
15310                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
15310     00 EB E0 01 |             long   (SYNC_NEG<<31) | (  3<<23) | (  6<<20) | (29<<11) | 768
15314     00 05 00 00 |             long    5 << 8
15318     00 00 00 00 |             long    0
1531c     00 00 00 00 |             long    0   ' reserved for CFRQ parameter
15320                 | 
15320                 | {sxga_timing ' 1280x1024@60Hz at 108*2 MHz YMMV  (216MHz)
15320                 | }
15320                 | 
15320                 | sxga_timing ' 1280x1024@60Hz at 108*3 MHz YMMV  (324MHz)
15320     00 00 00 00 |             long   0
15324     00 D9 4F 13 |             long   324000000
15328                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
15328                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
15328     A0 F8 70 B0 |             long   (SYNC_POS<<31) | ( 48<<24) | (112<<16) | (248<<8 ) |(1280/8)
1532c                 | 
1532c                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
1532c                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
1532c     00 34 B1 00 |             long   (SYNC_NEG<<31) | (  1<<23) | (  3<<20) | ( 38<<11) | 1024
15330     00 03 00 00 |             long   3 << 8
15334     00 00 00 00 |             long   0
15338     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
1533c                 | 
1533c                 | uxga_timing ' 1600x1200@60Hz at 162*2 MHz
1533c     FB 40 0C 01 |             long   CLK325MHz
15340     00 D9 4F 13 |             long   324000000
15344                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
15344                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
15344     C8 30 C0 C0 |             long   (SYNC_POS<<31) | (64<<24) | (192<<16) | (48<<8 ) |(1600/8)
15348                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
15348                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
15348                 | 
15348     B0 74 B1 80 |             long   (SYNC_POS<<31) | (  1<<23) | (  3<<20) | ( 46<<11) | 1200
1534c     00 02 00 00 |             long   2 << 8
15350                 |                    '_Breezeway__C-Burst__FrontPorchHi__SyncWidthHi__BackPorchHi
15350                 |                    '  8 bits     8 bits     8 bits        4 bits        4 bits
15350     01 00 00 00 |             long   (1 << 0)  ' Back porch MSBs
15354     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
15358                 | 
15358                 | 
15358                 | wuxga_timing ' experimental 1920x1200@60Hz for Dell 2405FPW at 77*4 MHz YMMV
15358     FB 4C 10 01 |             long   CLK308MHz
1535c     00 B5 5B 12 |             long   308000000
15360                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
15360                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
15360     F0 80 10 90 |             long   (SYNC_POS<<31) | ( 16<<24) | ( 16<<16) | (128<<8 ) |(1920/8)
15364                 | 
15364                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
15364                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
15364     B0 BC 30 04 |             long   (SYNC_NEG<<31) | (  8<<23) | (  3<<20) | ( 23<<11) | 1200
15368     00 02 00 00 |             long   2<<8
1536c     00 00 00 00 |             long   0
15370     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
15374                 | 
15374                 | hd60_timing
15374                 |             'long   CLK350MHz
15374                 |             'long   350000000
15374     FB 28 4D 01 |             long   CLK297MHz
15378     40 DC B3 11 |             long   297000000
1537c                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
1537c                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
1537c     A0 DC 50 46 |             long   (SYNC_NEG<<31) | ( 70<<24) | ( 80<<16) | (220<<8 ) |(1280/8)
15380                 | 
15380                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
15380                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
15380     D0 A2 D0 02 |             long   (SYNC_NEG<<31) | (  5<<23) | (  5<<20) | ( 20<<11) | 720
15384     00 04 00 00 |             long   4<<8
15388     00 00 00 00 |             long   0
1538c     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
15390                 | 
15390                 | hd50_timing
15390     FB 28 4D 01 |             long   CLK297MHz
15394     40 DC B3 11 |             long   297000000
15398                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
15398                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
15398     A0 DC 50 10 |             long   (SYNC_NEG<<31) | ( 16<<24) | ( 80<<16) | (220<<8 ) |(1280/8)
1539c                 | 
1539c                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
1539c                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
1539c     D0 A2 D0 02 |             long   (SYNC_NEG<<31) | (  5<<23) | (  5<<20) | ( 20<<11) | 720
153a0     00 04 00 00 |             long   4<<8
153a4                 |                    '_Breezeway__C-Burst__FrontPorchHi__SyncWidthHi__BackPorchHi
153a4                 |                    '  8 bits     8 bits     8 bits        4 bits        4 bits
153a4     00 03 00 00 |              long   (3 << 8)                         'extended front porch
153a8     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
153ac                 | 
153ac                 | fullhd_timing
153ac     FB 28 4D 01 |             long   CLK297MHz
153b0     40 DC B3 11 |             long   297000000
153b4                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
153b4                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
153b4     F0 94 2C D8 |             long   (SYNC_POS<<31) | ( 88<<24) | ( 44<<16) | (148 <<8 ) |(1920/8)
153b8                 | 
153b8                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
153b8                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
153b8     38 24 51 82 |             long   (SYNC_POS<<31) | (  4<<23) | (  5<<20) | ( 36<<11) | 1080
153bc     00 02 00 00 |             long   2<<8
153c0     00 00 00 00 |             long   0
153c4     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
153c8                 | 
153c8                 | fullhd50_timing
153c8     FB 28 4D 01 |             long   CLK297MHz
153cc     40 DC B3 11 |             long   297000000
153d0                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
153d0                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
153d0     F0 94 2C 90 |             long   (SYNC_POS<<31) | ( 16<<24) | ( 44<<16) | (148 <<8 ) |(1920/8)
153d4                 |            ' long   (SYNC_POS<<31) | (  0<<24) | ( 44<<16) | (252 <<8 ) |(1920/8)
153d4                 | 
153d4                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
153d4                 |                    '     8 bit         8 bits      3 bits      9 bits   11 bits
153d4     38 24 51 82 |             long   (SYNC_POS<<31) | (  4<<23) | (  5<<20) | ( 36<<11) | 1080
153d8     00 02 00 00 |             long   2<<8
153dc                 |                    '_Breezeway__C-Burst__FrontPorchHi__SyncWidthHi__BackPorchHi
153dc                 |                    '  8 bits     8 bits     8 bits        4 bits        4 bits
153dc     00 04 00 00 |             long   (4<<8) ' 528 ' 424 '528
153e0     00 00 00 00 |             long   0   ' reserved for CFRQ parameter
153e4                 | 
153e4                 | hdint_timing
153e4     FB 45 0C 01 |             long   CLK350MHz
153e8     80 93 DC 14 |             long   350000000
153ec                 |                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
153ec                 |                    '     1 bit         7 bits      8 bits      8 bits    8 bits
153ec     F0 94 58 AC |             long   (SYNC_POS<<31) | ( 44<<24) | ( 88<<16) | (148<<8 ) |(1920/8)
153f0                 | 
153f0                 |                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
153f0                 |                    '     1 bit         8 bits      3 bits      9 bits   11 bits
153f0     1C 7A 50 81 |             long   (SYNC_POS<<31) | (  2<<23) | (  5<<20) | ( 15<<11) | 540
153f4     00 05 00 00 |             long   5<<8
153f8     00 00 00 00 |             long   0
153fc     00 00 00 00 
15400     30 00 00 00 
15404     31 00 00 00 
15408     32 00 00 00 |             long   0
1540c     33 00 00 00 
15410     34 00 00 00 
15414     35 00 00 00 
15418     36 00 00 00 | 	byte	$33, $00, $00, $00, $34, $00, $00, $00, $35, $00, $00, $00, $36, $00, $00, $00
1541c     37 00 00 00 
15420     38 00 00 00 
15424     39 00 00 00 
15428     41 00 00 00 | 	byte	$37, $00, $00, $00, $38, $00, $00, $00, $39, $00, $00, $00, $41, $00, $00, $00
1542c     42 00 00 00 
15430     43 00 00 00 
15434     44 00 00 00 
15438     45 00 00 00 | 	byte	$42, $00, $00, $00, $43, $00, $00, $00, $44, $00, $00, $00, $45, $00, $00, $00
1543c     46 00 00 00 | 	byte	$46, $00, $00, $00
15440                 | 	alignl
15440                 | _usbnew_0016_dat_
15440                 |                 org     $000
15440 000             | 
15440 000             | usb_host_start
15440 000 F9 8F 02 F6 |                 mov     hcog_base_addr, ptrb
15444 001             | 
15444 001 03 00 00 FF 
15448 002 A0 70 07 F6 |                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
1544c 003 02 70 47 F0 |                 shr     htmp, #2                        ' so byte->long for the lut cell count
15450 004 BC 04 A0 FE |                 loc     pb, #@hlut_start - @usb_host_start
15454 005 47 EF 03 F1 |                 add     pb, hcog_base_addr
15458 006 29 70 63 FD |                 setq2   htmp
1545c 007 F7 01 00 FB |                 rdlong  0, pb                           ' Do the hub->lut copy
15460 008             | 
15460 008 60 0B A0 FE |                 loc     pb, #@usb_host_init - @usb_host_start
15464 009 47 EF 03 F1 |                 add     pb, hcog_base_addr
15468 00a 2C EE 63 FD |                 jmp     pb                              ' Initialize host and enter main processing loop
1546c 00b             | 
1546c 00b             | '------------------------------------------------------------------------------
1546c 00b             | ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
1546c 00b             | ' special because the receiving function must not respond with either STALL or
1546c 00b             | ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
1546c 00b             | ' non-control endpoint receives a SETUP token, or the function receives a
1546c 00b             | ' corrupt packet, it must ignore the transaction
1546c 00b             | '------------------------------------------------------------------------------
1546c 00b             | ' On entry:
1546c 00b             | '   PTRA - start address of the SETUP data struct.
1546c 00b             | ' On exit:
1546c 00b             | '   retval - PID_ACK on success, otherwise error code.
1546c 00b             | '------------------------------------------------------------------------------
1546c 00b             | txn_setup
1546c 00b 2D BC C6 F8 |                 setbyte ep_addr_pid, #PID_SETUP, #0
15470 00c 08 B0 06 F6 |                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
15474 00d 03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
15478 00e 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
1547c 00f F8 ED 03 F6 |                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
15480 010             | .setup
15480 010 24 01 B0 FD |                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
15484 011 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15488 012 2D 00 64 AD |         if_z    ret
1548c 013 7C 0B B0 FD |                 call    #retry_wait
15490 014 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
15494 015 2D 00 64 AD |         if_z    ret
15498 016 F6 F1 03 F6 |                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
1549c 017 E0 FF 9F FD |                 jmp     #.setup
154a0 018             | 
154a0 018             | '------------------------------------------------------------------------------
154a0 018             | ' IN/INTERRUPT transaction.
154a0 018             | ' Possible function response: STALL or NAK handshake, or DATAx packet.
154a0 018             | '------------------------------------------------------------------------------
154a0 018             | ' On entry:
154a0 018             | '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
154a0 018             | '     CRC(b19..23).
154a0 018             | ' On exit:
154a0 018             | '------------------------------------------------------------------------------
154a0 018             | txn_in
154a0 018 90 03 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
154a4 019 69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
154a8 01a BC 00 B0 FD |                 call    #utx_token                      ' Put IN request on the bus
154ac 01b             | 
154ac 01b             |                 ' Fall through to urx_packet
154ac 01b             | 
154ac 01b             | '------------------------------------------------------------------------------
154ac 01b             | ' Wait for a packet from a device/function. As host, the only two packet types
154ac 01b             | ' received are handshakes and IN DATAx.
154ac 01b             | '------------------------------------------------------------------------------
154ac 01b             | ' On entry:
154ac 01b             | ' On exit:
154ac 01b             | '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
154ac 01b             | '     returned.
154ac 01b             | '------------------------------------------------------------------------------
154ac 01b             | urx_packet
154ac 01b 23 A7 82 FA |                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
154b0 01c 04 A6 16 F4 |                 testb   urx, #SOPB              wc
154b4 01d F4 FF 9F CD |         if_c    jmp     #urx_packet
154b8 01e 1A 92 63 FD |                 getct   hct2
154bc 01f 4E 93 6B FA |                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
154c0 020 05 96 06 F4 |                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
154c4 021 00 A8 06 F6 |                 mov     newb_flg, #0                    ' Initialize for multi-byte read
154c8 022             | .wait_sop
154c8 022 23 A7 8A FA |                 rdpin   urx, dm
154cc 023 04 A6 16 F4 |                 testb   urx, #SOPB              wc
154d0 024 08 00 90 CD |         if_c    jmp     #.get_pid
154d4 025 FC 25 CC FB |                 jnct2   #.wait_sop
154d8 026 05 BE 06 06 |         _ret_   mov     retval, #ERR_TAT
154dc 027             | .get_pid
154dc 027 28 02 B0 FD |                 call    #urx_next
154e0 028 06 A6 16 F4 |                 testb   urx, #BUS_ERRB          wc
154e4 029 04 00 90 3D |         if_nc   jmp     #.chk_pid
154e8 02a 02 BE 06 06 |         _ret_   mov     retval, #ERR_URX
154ec 02b             | .chk_pid
154ec 02b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
154f0 02c 5A BE 0E 52 |         if_nz   cmp     retval, #PID_NAK        wz
154f4 02d 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz
154f8 02e 38 00 90 AD |         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
154fc 02f 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
15500 030 C3 BE 0E F2 |                 cmp     retval, #PID_DATA0      wz
15504 031 28 01 90 2D |    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
15508 032 10 00 90 8D |    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
1550c 033 4B BE 0E F2 |                 cmp     retval, #PID_DATA1      wz
15510 034 1C 01 90 8D |    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
15514 035 04 00 90 2D |    if_z_and_nc  jmp     #.ack_resend
15518 036 04 BE 06 06 |         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
1551c 037             | .ack_resend
1551c 037 23 A7 82 FA |                 rqpin   urx, dm
15520 038 05 A6 16 F4 |                 testb   urx, #EOPB              wc
15524 039 F4 FF 9F 3D |         if_nc   jmp     #.ack_resend
15528 03a D2 BE 06 F6 |                 mov     retval, #PID_ACK
1552c 03b 98 01 B0 FD |                 call    #utx_handshake                  ' Send handshake PID and return to caller
15530 03c 09 BE 06 06 |         _ret_   mov     retval, #ERR_DATAX_SYNC
15534 03d             | .chk_eop
15534 03d 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
15538 03e 1C 00 90 3D |         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
1553c 03f C8 01 B0 FD |                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
15540 040 05 96 16 F4 |                 testb   hstatus, #EOPB          wc
15544 041 10 00 90 CD |         if_c    jmp     #.idle                          ' Low-speed EOP seen
15548 042 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
1554c 043 04 BE 06 36 |         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
15550 044 02 BE 06 A6 |         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
15554 045 2D 00 64 FD |                 ret
15558 046             | .idle
15558 046 23 A7 82 FA |                 rqpin   urx, dm
1555c 047 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
15560 048 F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
15564 049 2D 00 64 FD |                 ret
15568 04a             | 
15568 04a             | '------------------------------------------------------------------------------
15568 04a             | ' Send a token packet with CRC5 checksum of address and endpoint. It is the
15568 04a             | ' responsibility of the caller to append the appropriate inter-packet delay,
15568 04a             | ' if one is required.
15568 04a             | '------------------------------------------------------------------------------
15568 04a             | ' On entry:
15568 04a             | '   ep_addr_pid - packed with the PID, address and endpoint.
15568 04a             | ' On exit:
15568 04a             | '------------------------------------------------------------------------------
15568 04a             | utx_token
15568 04a 23 A7 82 FA |                 rqpin   urx, dm
1556c 04b 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
15570 04c F4 FF 9F 3D |         if_nc   jmp     #utx_token
15574 04d 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
15578 04e 04 0D B0 CD |         if_c    call    #utx_pre
1557c 04f 80 A4 06 F6 |                 mov     utx, #OUT_SOP
15580 050 70 01 B0 FD |                 call    #utx_byte                       ' Send sync byte
15584 051 5E 71 03 F6 |                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
15588 052 03 B8 06 F6 |                 mov     pkt_cnt, #3
1558c 053             | .next_byte
1558c 053 B8 A5 E2 F8 |                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
15590 054 08 70 47 F0 |                 shr     htmp, #8                        ' Shift to next byte to send
15594 055             | .wait
15594 055 40 48 72 FD |                 testp   dp                      wc
15598 056 F8 FF 9F 3D |         if_nc   jmp     #.wait
1559c 057 24 03 08 FC |                 akpin   dp
155a0 058 23 A5 22 FC |                 wypin   utx, dm
155a4 059 F9 B9 6E 0B |         _ret_   djnz    pkt_cnt, #.next_byte
155a8 05a             | 
155a8 05a             | '------------------------------------------------------------------------------
155a8 05a             | ' SETUP/OUT/INTERRUPT transaction.
155a8 05a             | ' Possible function response in order of precedence: STALL, ACK, NAK.
155a8 05a             | '------------------------------------------------------------------------------
155a8 05a             | ' On entry:
155a8 05a             | '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
155a8 05a             | '     CRC(b19..23).
155a8 05a             | '   PTRA - start address of the data buff/struct that has the bytes to send.
155a8 05a             | '   pkt_data - count of DATAx payload bytes to send.
155a8 05a             | ' On exit:
155a8 05a             | '------------------------------------------------------------------------------
155a8 05a             | txn_out
155a8 05a 88 02 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
155ac 05b B8 FF BF FD |                 call    #utx_token                      ' Put SETUP/OUT token on the bus
155b0 05c 00 00 C0 FF 
155b4 05d F8 01 78 FC |                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
155b8 05e 58 B9 02 F6 |                 mov     pkt_cnt, pkt_data
155bc 05f             | 
155bc 05f             |                 ' Fall through to utx_data
155bc 05f             | 
155bc 05f             | '------------------------------------------------------------------------------
155bc 05f             | ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
155bc 05f             | ' calculated while the data byte is being shifted out. Since data stage
155bc 05f             | ' success/fail is not determined until the status stage of the transaction,
155bc 05f             | ' this routine is only concerned about the current DATAx packet.
155bc 05f             | '------------------------------------------------------------------------------
155bc 05f             | ' On entry:
155bc 05f             | '   PTRA - hub start address of the data to read.
155bc 05f             | '   pkt_cnt - data payload size.
155bc 05f             | ' On exit:
155bc 05f             | '------------------------------------------------------------------------------
155bc 05f             | utx_data
155bc 05f 23 A7 82 FA |                 rqpin   urx, dm
155c0 060 04 A6 16 F4 |                 testb   urx, #SOPB              wc
155c4 061 F4 FF 9F CD |         if_c    jmp     #utx_data
155c8 062 4D 99 02 F6 |                 mov     hctwait, ip_delay
155cc 063 2C 0A B0 FD |                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
155d0 064 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
155d4 065 A8 0C B0 CD |         if_c    call    #utx_pre
155d8 066 80 A4 06 F6 |                 mov     utx, #OUT_SOP
155dc 067 14 01 B0 FD |                 call    #utx_byte                       ' Send sync
155e0 068 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
155e4 069 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
155e8 06a C3 A4 06 36 |         if_nc   mov     utx, #PID_DATA0
155ec 06b 4B A4 06 C6 |         if_c    mov     utx, #PID_DATA1
155f0 06c 00 01 B0 FD |                 call    #utx_byte                       ' No CRC calc done on PID
155f4 06d 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
155f8 06e 1C 00 90 AD |         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
155fc 06f             | .read_byte
155fc 06f 10 A4 62 FD |                 rfbyte  utx                             ' Fetch data byte
15600 070 F0 00 B0 FD |                 call    #utx_byte
15604 071 69 A4 62 FD |                 rev     utx                             ' Calculate CRC while the data is shifting out
15608 072 28 A4 62 FD |                 setq    utx                             ' SETQ left-justifies the reflected data byte
1560c 073 20 BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
15610 074 20 BB DA F9 |                 crcnib  crc, usb16_poly_r
15614 075 F9 B9 6E FB |                 djnz    pkt_cnt, #.read_byte
15618 076             | .send_crc
15618 076 E0 BB E6 F4 |                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
1561c 077 5D A5 E2 F8 |                 getbyte utx, crc, #0
15620 078 D0 00 B0 FD |                 call    #utx_byte
15624 079 5D A5 EA F8 |                 getbyte utx, crc, #1
15628 07a C8 00 B0 FD |                 call    #utx_byte                       ' Last CRC byte out
1562c 07b 7C FE 9F FD |                 jmp     #urx_packet                     ' Handle function response/error and back to caller
15630 07c             | 
15630 07c             | '------------------------------------------------------------------------------
15630 07c             | ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
15630 07c             | ' payload bytes are received. The routine reads bytes until EOP is detected and
15630 07c             | ' expects that the packet includes at least the CRC word.
15630 07c             | '
15630 07c             | ' In control transfers, it's possible to recieve fewer data bytes than what
15630 07c             | ' was requested, which makes it difficult to determine where the data stops
15630 07c             | ' and the CRC word begins. So the CRC calculation is done on every byte of the
15630 07c             | ' packet, including the CRC word. The CRC value should then be equal to the
15630 07c             | ' USB-16 expected residual value of 0xB001.
15630 07c             | '
15630 07c             | ' The routine writes the IN packet data to a static max_packet_size buffer
15630 07c             | ' so the caller can verify IN success before writing the data to its final
15630 07c             | ' destination.
15630 07c             | '------------------------------------------------------------------------------
15630 07c             | ' On entry:
15630 07c             | '   pkt_data - max byte count expected to be in the packet.
15630 07c             | '   newb_flg - signals new byte ready when toggled.
15630 07c             | ' On exit:
15630 07c             | '   pkt_cnt - actual number of bytes read.
15630 07c             | '------------------------------------------------------------------------------
15630 07c             | urx_data
15630 07c F7 75 03 F6 |                 mov     htmp2, pb
15634 07d 29 EF 03 F6 |                 mov     pb, urx_buff_p
15638 07e 00 00 C0 FF 
1563c 07f F7 01 88 FC |                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
15640 080 BA EF 03 F6 |                 mov     pb, htmp2
15644 081 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
15648 082 00 B8 06 F6 |                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
1564c 083 58 83 03 F6 |                 mov     pkt_tmp, pkt_data
15650 084 02 82 07 F1 |                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
15654 085             | .wait_byte
15654 085             | ' In-line rx for max speed
15654 085 23 A7 82 FA |                 rqpin   urx, dm
15658 086 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
1565c 087 53 A5 02 F5 |                 and     utx, urx
15660 088 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
15664 089 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
15668 08a 0C 00 90 5D |         if_nz   jmp     #.get_byte                      ' New byte!
1566c 08b 05 A6 16 F4 |                 testb   urx, #EOPB              wc
15670 08c 38 00 90 CD |         if_c    jmp     #.chk_crc                       ' At end-of-packet
15674 08d DC FF 9F FD |                 jmp     #.wait_byte
15678 08e             | .get_byte
15678 08e 53 BF EA F8 |                 getbyte retval, urx, #1                 ' New byte from smart pins
1567c 08f 15 BE 62 FD |                 wfbyte  retval                          ' Add it to the data buffer
15680 090 69 BE 62 FD |                 rev     retval                          ' Calculate CRC while next byte is shifting in
15684 091 28 BE 62 FD |                 setq    retval                          ' SETQ left-justifies the reflected data byte
15688 092 20 BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
1568c 093 20 BB DA F9 |                 crcnib  crc, usb16_poly_r
15690 094             | .end_crc
15690 094 01 B8 06 F1 |                 add     pkt_cnt, #1
15694 095 C1 B9 1A F2 |                 cmp     pkt_cnt, pkt_tmp        wcz
15698 096 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
1569c 097 2D 00 64 1D |         if_a    ret
156a0 098             | ' For full-speed at 80MHz, the time it takes to do the final byte write and
156a0 098             | ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
156a0 098             | ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
156a0 098             | ' to miss it, so cheat a bit and look for SOP clear here.
156a0 098 23 A7 82 FA |                 rqpin   urx, dm
156a4 099 05 A6 16 F4 |                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
156a8 09a A8 FF 9F 3D |         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
156ac 09b             | ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
156ac 09b             | .chk_crc
156ac 09b 02 B8 86 F1 |                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
156b0 09c 58 00 00 FF 
156b4 09d 01 BA 6E F5 |                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
156b8 09e F0 FD 9F 5D |         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
156bc 09f D2 BE 06 F6 |                 mov     retval, #PID_ACK
156c0 0a0 4D 99 02 F6 |                 mov     hctwait, ip_delay
156c4 0a1 34 09 B0 FD |                 call    #poll_waitx
156c8 0a2             | 
156c8 0a2             |                 ' Fall through to utx_handshake
156c8 0a2             | 
156c8 0a2             | '------------------------------------------------------------------------------
156c8 0a2             | ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
156c8 0a2             | ' the appropriate IP delay has been inserted.
156c8 0a2             | '------------------------------------------------------------------------------
156c8 0a2             | ' On entry:
156c8 0a2             | '   retval - handshake PID to send.
156c8 0a2             | ' On exit:
156c8 0a2             | '   retval unchanged.
156c8 0a2             | '------------------------------------------------------------------------------
156c8 0a2             | utx_handshake
156c8 0a2 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
156cc 0a3 B0 0B B0 CD |         if_c    call    #utx_pre
156d0 0a4 80 A4 06 F6 |                 mov     utx, #OUT_SOP
156d4 0a5 1C 00 B0 FD |                 call    #utx_byte                       ' Send sync
156d8 0a6 5F A5 02 F6 |                 mov     utx, retval
156dc 0a7 14 00 B0 FD |                 call    #utx_byte                       ' Send handshake PID
156e0 0a8             | .idle
156e0 0a8 23 A7 82 FA |                 rqpin   urx, dm
156e4 0a9 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
156e8 0aa F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
156ec 0ab 4E 99 02 F6 |                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
156f0 0ac 08 09 90 FD |                 jmp     #poll_waitx
156f4 0ad             | 
156f4 0ad             | '------------------------------------------------------------------------------
156f4 0ad             | ' Wait for the USB tx buffer to empty and feed it a new byte.
156f4 0ad             | '------------------------------------------------------------------------------
156f4 0ad             | ' On entry:
156f4 0ad             | '   utx - byte to transmit.
156f4 0ad             | ' On exit:
156f4 0ad             | '------------------------------------------------------------------------------
156f4 0ad             | utx_byte
156f4 0ad 40 48 72 FD |                 testp   dp                      wc
156f8 0ae F8 FF 9F 3D |         if_nc   jmp     #utx_byte
156fc 0af 24 03 08 FC |                 akpin   dp
15700 0b0 1F 94 62 FD |                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
15704 0b1 23 A5 22 0C |         _ret_   wypin   utx, dm
15708 0b2             | 
15708 0b2             | '------------------------------------------------------------------------------
15708 0b2             | ' Fetch the next data byte of a packet. Always check receiver status for EOP.
15708 0b2             | '------------------------------------------------------------------------------
15708 0b2             | ' On entry:
15708 0b2             | ' On exit:
15708 0b2             | '   retval - the byte read.
15708 0b2             | '   urx - the receiver status. The caller must check the hstatus reg EOP flag
15708 0b2             | '     on return. If EOP is set, the byte in reg retval remains as the last byte
15708 0b2             | '     received.
15708 0b2             | '------------------------------------------------------------------------------
15708 0b2             | urx_next
15708 0b2 23 A7 8A FA |                 rdpin   urx, dm
1570c 0b3 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
15710 0b4 53 A5 02 F5 |                 and     utx, urx
15714 0b5 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
15718 0b6 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
1571c 0b7 53 BF EA 58 |         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
15720 0b8 2D 00 64 5D |         if_nz   ret                                     ' New byte is priority, so return now
15724 0b9 04 A6 16 F4 |                 testb   urx, #SOPB              wc
15728 0ba 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
1572c 0bb D8 FF 9F 4D |    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
15730 0bc 05 96 26 34 |         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
15734 0bd 2D 00 64 FD |                 ret
15738 0be             | 
15738 0be             | '------------------------------------------------------------------------------
15738 0be             | ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
15738 0be             | ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
15738 0be             | ' length, and the PID is not included in the CRC calculation:
15738 0be             | '  CRC5  FRAME_NUMBER SOF (full-speed)
15738 0be             | '  CRC5  ENDP ADDRESS PID
15738 0be             | ' %00000_1111_1111111_xxxxxxxx
15738 0be             | '------------------------------------------------------------------------------
15738 0be             | ' On entry:
15738 0be             | '   ep_addr_pid - stuffed with the function endpoint, address and
15738 0be             | '     SETUP/IN/OUT/SOF PID according to the USB standard.
15738 0be             | ' On exit:
15738 0be             | '   ep_addr_pid - CRC value appended to the packet.
15738 0be             | '------------------------------------------------------------------------------
15738 0be             | calc_crc5
15738 0be FF 03 00 FF 
1573c 0bf FF BD 06 F5 |                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
15740 0c0 5E 71 03 F6 |                 mov     htmp, ep_addr_pid
15744 0c1 08 70 47 F0 |                 shr     htmp, #8                        ' PID not included in CRC calc
15748 0c2 1F BA 06 F6 |                 mov     crc, #$1f                       ' Initial CRC5 value
1574c 0c3 69 70 63 FD |                 rev     htmp                            ' Input data reflected
15750 0c4 28 70 63 FD |                 setq    htmp                            ' CRCNIB setup for data bits 0..7
15754 0c5 14 BA DE F9 |                 crcnib  crc, #USB5_POLY
15758 0c6 14 BA DE F9 |                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
1575c 0c7 09 70 77 F0 |                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
15760 0c8 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
15764 0c9 01 70 77 F0 |                 shl     htmp, #1                wc
15768 0ca 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
1576c 0cb 01 70 77 F0 |                 shl     htmp, #1                wc
15770 0cc 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
15774 0cd 1F BA 66 F5 |                 xor     crc, #$1f                       ' Final XOR value
15778 0ce 13 BA 66 F0 |                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
1577c 0cf 5D BD 42 05 |         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
15780 0d0             | 
15780 0d0             | '------------------------------------------------------------------------------
15780 0d0             | ' Full-speed/low-speed frame timing interrupt service routine.
15780 0d0             | '------------------------------------------------------------------------------
15780 0d0             | isr1_fsframe
15780 0d0 1A 92 62 FD |                 getct   iframe_ct_base
15784 0d1 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
15788 0d2 B3 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
1578c 0d3 23 6D 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
15790 0d4             | .wait
15790 0d4 40 48 72 FD |                 testp   dp                      wc
15794 0d5 F8 FF 9F 3D |         if_nc   jmp     #.wait
15798 0d6 24 03 08 FC |                 akpin   dp
1579c 0d7 A5 A4 06 F6 |                 mov     utx, #PID_SOF
157a0 0d8 23 01 29 FC |                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
157a4 0d9 4C FF BF FD |                 call    #utx_byte                       ' Send token PID byte
157a8 0da 1F B6 06 F6 |                 mov     icrc, #$1f                      ' Prime the CRC5 pump
157ac 0db 59 B5 02 F6 |                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
157b0 0dc 69 B4 62 FD |                 rev     sof_pkt                         ' Input data reflected
157b4 0dd 28 B4 62 FD |                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
157b8 0de 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY
157bc 0df 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
157c0 0e0 59 A5 E2 F8 |                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
157c4 0e1 2C FF BF FD |                 call    #utx_byte
157c8 0e2 08 B4 66 F0 |                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
157cc 0e3 03 04 DC FC |                 rep     #2, #3                          ' Three data bits left to process
157d0 0e4 01 B4 76 F0 |                 shl     sof_pkt, #1             wc
157d4 0e5 14 B6 D6 F9 |                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
157d8 0e6 1F B6 66 F5 |                 xor     icrc, #$1f                      ' Final XOR value
157dc 0e7 59 A5 EA F8 |                 getbyte utx, frame, #1                  ' Send remaining frame number bits
157e0 0e8 03 B6 66 F0 |                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
157e4 0e9 5B A5 42 F5 |                 or      utx, icrc
157e8 0ea 08 FF BF FD |                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
157ec 0eb A3 81 03 F6 |                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
157f0 0ec 20 00 90 FD |                 jmp     #isr1_wait
157f4 0ed             | isr1_lsframe
157f4 0ed 1A 92 62 FD |                 getct   iframe_ct_base
157f8 0ee 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
157fc 0ef B3 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
15800 0f0             | .wait
15800 0f0 40 48 72 FD |                 testp   dp                      wc
15804 0f1 F8 FF 9F 3D |         if_nc   jmp     #.wait
15808 0f2 24 03 08 FC |                 akpin   dp
1580c 0f3 23 09 28 FC |                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
15810 0f4 A2 81 03 F6 |                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
15814 0f5             | isr1_wait
15814 0f5 23 A5 82 FA |                 rqpin   utx, dm
15818 0f6 04 A4 16 F4 |                 testb   utx, #SOPB                 wc
1581c 0f7 F4 FF 9F CD |         if_c    jmp     #isr1_wait
15820 0f8 01 B2 06 F1 |                 add     frame, #1                       ' Next frame# and check for wrap around
15824 0f9 03 00 00 FF 
15828 0fa FF B3 06 F5 |                 and     frame, ##$7ff
1582c 0fb 1F 80 63 FD |                 waitx   isrtmp1                         ' Make sure bus is idle
15830 0fc F5 FF 3B FB |                 reti1
15834 0fd             | 
15834 0fd             | '------------------------------------------------------------------------------
15834 0fd             | ' Wait for a window within the 1ms frame boundary that will ensure that a
15834 0fd             | ' transaction will complete before the next frame is triggered.
15834 0fd             | '------------------------------------------------------------------------------
15834 0fd             | ' On entry:
15834 0fd             | ' On exit:
15834 0fd             | '------------------------------------------------------------------------------
15834 0fd             | wait_txn_ok
15834 0fd 1A 74 63 FD |                 getct   htmp2
15838 0fe 49 75 83 F1 |                 sub     htmp2, iframe_ct_base
1583c 0ff 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
15840 100 A0 75 1B C2 |         if_c    cmp     htmp2, _txn_ok_ls_      wcz
15844 101 A1 75 1B 32 |         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
15848 102 E8 FF 9F 1D |         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
1584c 103 2D 00 64 FD |                 ret
15850 104             | 
15850 104             | '------------------------------------------------------------------------------
15850 104             | ' A device connection was detected, or a bus reset was requested by the USB
15850 104             | ' client. Set the appropriate smart pin FS/LS speed mode to match the device
15850 104             | ' and perform a reset sequence prior to device enumeration.
15850 104             | '------------------------------------------------------------------------------
15850 104             | dev_reset
15850 104 23 A7 82 FA |                 rqpin   urx, dm
15854 105 01 A6 16 F4 |                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
15858 106 F4 03 B0 CD |         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
1585c 107 E0 03 B0 3D |         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
15860 108             | reset
15860 108 25 00 64 FD |                 setint1 #0                              ' Don't want frame interrupt while in reset
15864 109 23 03 28 FC |                 wypin   #OUT_SE0, dm                    ' Assert bus reset
15868 10a 1F 5A 63 FD |                 waitx   _reset_hold_                    ' Spec is >= 10ms
1586c 10b 23 01 28 FC |                 wypin   #OUT_IDLE, dm
15870 10c 00 B2 06 F6 |                 mov     frame, #0                       ' Reset the frame timespan count
15874 10d 1A 92 62 FD |                 getct   iframe_ct_base
15878 10e 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
1587c 10f B3 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
15880 110 59 71 03 F6 |                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
15884 111 24 70 07 F1 |                 add     htmp, #36
15888 112 25 02 64 FD |                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
1588c 113             | .framewait
1588c 113 B8 B3 1A F2 |                 cmp     frame, htmp             wcz
15890 114 F8 FF 9F CD |         if_b    jmp     #.framewait
15894 115 2D 00 64 FD |                 ret
15898 116             | 
15898 116             | '------------------------------------------------------------------------------
15898 116             | ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
15898 116             | '------------------------------------------------------------------------------
15898 116             | ' On entry:
15898 116             | '   PTRA - source address.
15898 116             | '   PB - destination address.
15898 116             | '   hr0 - length of copy, in bytes.
15898 116             | ' On exit:
15898 116             | '------------------------------------------------------------------------------
15898 116             | hmemcpy
15898 116 61 71 C7 FA |                 rdbyte  htmp, ptra++
1589c 117 F7 71 43 FC |                 wrbyte  htmp, pb
158a0 118 01 EE 07 F1 |                 add     pb, #1
158a4 119 FC 85 6F 0B |         _ret_   djnz    hr0, #hmemcpy
158a8 11a             | 
158a8 11a             | '------------------------------------------------------------------------------
158a8 11a             | ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
158a8 11a             | ' loop until the errant device is disconnected.
158a8 11a             | '------------------------------------------------------------------------------
158a8 11a             | ' On entry:
158a8 11a             | ' On exit:
158a8 11a             | '------------------------------------------------------------------------------
158a8 11a             | host_error
158a8 11a             |           if ERROR_LED >= 0
158a8 11a 58 4C 62 FD |                 drvl    host_error_led
158ac 11b             |           end
158ac 11b 9C 07 90 FD |                 jmp     #host_reset                     ' See if it works...
158b0 11c             | 
158b0 11c             | '------------------------------------------------------------------------------
158b0 11c             | ' Get HID descriptor buffer for current port
158b0 11c             | '------------------------------------------------------------------------------
158b0 11c             | ' On entry:
158b0 11c             | ' On exit:
158b0 11c             | '   PB - HID descriptor buffer pointer
158b0 11c             | '------------------------------------------------------------------------------
158b0 11c             | get_hid_descr_buffer
158b0 11c 2F EF 03 F6 |                 mov     pb, hdev_port
158b4 11d 01 EE E7 F2 |                 cmpsub  pb, #1
158b8 11e 00 EF 07 FA |                 mul     pb, #HID_DESCR_LEN
158bc 11f 27 EF 03 01 |         _ret_   add     pb, hid_descr_p
158c0 120             | 
158c0 120             | 
158c0 120 01 A0 00 00 | usb16_poly_r    long    USB16_POLY
158c4 121             | 
158c4 121             | ' USB commands and error codes
158c4 121 00 00 00 00 | cmd_data        long    0
158c8 122 00 00 00 00 | usb_err_code    long    ERR_NONE
158cc 123             | 
158cc 123             | ' Parameters block assigned at cog startup
158cc 123 12 00 00 00 | dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
158d0 124 13 00 00 00 | dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
158d4 125 FF FF FF FF | usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
158d8 126             | if ACTIVITY_LED >= 0
158d8 126             | host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
158d8 126             | end
158d8 126             | if ERROR_LED >= 0
158d8 126 38 00 00 00 | host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
158dc 127             | end
158dc 127 00 00 00 00 | hid_descr_p     long    0
158e0 128             | 'hid_report_p    long    0, 0[MAX_DEVICES]
158e0 128             | 'hkbd_report_p   long    0
158e0 128 00 00 00 00 | hub_descr_p     long    0
158e4 129 00 00 00 00 | urx_buff_p      long    0
158e8 12a 00 00 00 00 | dev_desc_buff_p long    0
158ec 12b 00 00 00 00 | con_desc_buff_p long    0
158f0 12c 00 00 00 00 | cache_start_p   long    0
158f4 12d 00 00 00 00 | cache_end_p     long    0
158f8 12e             | if EMUPAD_MAX_PLAYER > 0
158f8 12e             | emupad_out_ptr  long    0
158f8 12e             | end
158f8 12e 00 00 00 00 | save_sysclk     long    0         ' Save the current sysclock as the client may change it
158fc 12f             | 
158fc 12f             | hdev_init_start
158fc 12f             | hdev_port       res     1
158fc 12f             | hdev_port       res     1
158fc 12f             | hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
158fc 12f             | hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
158fc 12f             | kbm_next_datax  res     1
158fc 12f             | kbm_next_datax  res     1
158fc 12f             | hub_intf_num    res     1
158fc 12f             | hub_intf_num    res     1
158fc 12f             | hub_next_datax  res     1
158fc 12f             | hub_next_datax  res     1
158fc 12f             | hub_status_chg  res     1
158fc 12f             | hub_status_chg  res     1
158fc 12f             | hub_port_status res     1
158fc 12f             | hub_port_status res     1
158fc 12f             | if HAVE_MOUSE
158fc 12f             | ms_intf_num     res     1
158fc 12f             | ms_in_max_pkt   res     1
158fc 12f             | end
158fc 12f             | kb_intf_num     res     1
158fc 12f             | kb_intf_num     res     1
158fc 12f             | kb_interval     res     1
158fc 12f             | kb_interval     res     1
158fc 12f             | kb_in_max_pkt   res     1
158fc 12f             | kb_in_max_pkt   res     1
158fc 12f             | kb_max_index    res     1
158fc 12f             | kb_max_index    res     1
158fc 12f             | kb_led_states   res     1
158fc 12f             | kb_led_states   res     1
158fc 12f             | gp_intf_num     res     1
158fc 12f             | gp_intf_num     res     1
158fc 12f             | gp_interval     res     1
158fc 12f             | gp_interval     res     1
158fc 12f             | gp_max_index    res     1
158fc 12f             | gp_max_index    res     1
158fc 12f             | gp_descr_len    res     1+MAX_DEVICES
158fc 12f             | gp_descr_len    res     1+MAX_DEVICES
158fc 12f             | hdev_init_end
158fc 12f             | 
158fc 12f             | ' Initialized at cog startup:
158fc 12f             | hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
158fc 12f             | hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
158fc 12f             | iframe_ct_new   res     1
158fc 12f             | iframe_ct_new   res     1
158fc 12f             | iframe_ct_base  res     1
158fc 12f             | iframe_ct_base  res     1
158fc 12f             | utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
158fc 12f             | utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
158fc 12f             | 
158fc 12f             | ' This register block is reset to zero when a USB device connects
158fc 12f             | hreg_init_start
158fc 12f             | hstatus         res     1         ' Host status flags
158fc 12f             | hstatus         res     1         ' Host status flags
158fc 12f             | hctwait         res     1         ' Poll-based wait clocks
158fc 12f             | hctwait         res     1         ' Poll-based wait clocks
158fc 12f             | ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
158fc 12f             | ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
158fc 12f             | tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
158fc 12f             | tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
158fc 12f             | nak_retry       res     1         ' NAK retry count, unlimited retries if zero
158fc 12f             | nak_retry       res     1         ' NAK retry count, unlimited retries if zero
158fc 12f             | xfer_retry      res     1         ' Control transfer retry count
158fc 12f             | xfer_retry      res     1         ' Control transfer retry count
158fc 12f             | retry           res     1         ' Transaction retry count
158fc 12f             | retry           res     1         ' Transaction retry count
158fc 12f             | utx             res     1         ' Byte to transmit on USB
158fc 12f             | utx             res     1         ' Byte to transmit on USB
158fc 12f             | urx             res     1         ' LSByte receiver status flags, MSByte received data
158fc 12f             | urx             res     1         ' LSByte receiver status flags, MSByte received data
158fc 12f             | newb_flg        res     1         ' Receive "new byte" bit toggle detector
158fc 12f             | newb_flg        res     1         ' Receive "new byte" bit toggle detector
158fc 12f             | max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
158fc 12f             | max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
158fc 12f             | total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
158fc 12f             | total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
158fc 12f             | stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
158fc 12f             | stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
158fc 12f             | pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
158fc 12f             | pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
158fc 12f             | frame           res     1         ' USB 1ms frame counter value
158fc 12f             | frame           res     1         ' USB 1ms frame counter value
158fc 12f             | sof_pkt         res     1         ' ISR frame# packet and CRC5
158fc 12f             | sof_pkt         res     1         ' ISR frame# packet and CRC5
158fc 12f             | icrc            res     1         ' Only used by the 1ms frame output ISR routine
158fc 12f             | icrc            res     1         ' Only used by the 1ms frame output ISR routine
158fc 12f             | pkt_cnt         res     1         ' Count of DATAx packet payload bytes
158fc 12f             | pkt_cnt         res     1         ' Count of DATAx packet payload bytes
158fc 12f             | crc             res     1         ' Used for CRC16 calculation
158fc 12f             | crc             res     1         ' Used for CRC16 calculation
158fc 12f             | ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
158fc 12f             | ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
158fc 12f             | retval          res     1         ' Global success/fail return parameter
158fc 12f             | retval          res     1         ' Global success/fail return parameter
158fc 12f             | context_retval  res     1         ' Operation contextual return parameter
158fc 12f             | context_retval  res     1         ' Operation contextual return parameter
158fc 12f             | ' Device stuff
158fc 12f             | hdev_id         res     1+MAX_DEVICES
158fc 12f             | hdev_id         res     1+MAX_DEVICES
158fc 12f             | hdev_bcd        res     1
158fc 12f             | hdev_bcd        res     1
158fc 12f             | hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
158fc 12f             | hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
158fc 12f             | ' Keyboard/mouse stuff
158fc 12f             | hctrl_ep_addr   res     1
158fc 12f             | hctrl_ep_addr   res     1
158fc 12f             | hctrl_max_pkt   res     1
158fc 12f             | hctrl_max_pkt   res     1
158fc 12f             | hconfig_base    res     1
158fc 12f             | hconfig_base    res     1
158fc 12f             | hcon_tot_len    res     1         ' Size of the complete config descriptor chain
158fc 12f             | hcon_tot_len    res     1         ' Size of the complete config descriptor chain
158fc 12f             | hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
158fc 12f             | hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
158fc 12f             | hdev_class      res     1
158fc 12f             | hdev_class      res     1
158fc 12f             | hdev_subclass   res     1
158fc 12f             | hdev_subclass   res     1
158fc 12f             | hdev_protocol   res     1
158fc 12f             | hdev_protocol   res     1
158fc 12f             | hsearch_key     res     1         ' Descriptor type to search for in the config chain
158fc 12f             | hsearch_key     res     1         ' Descriptor type to search for in the config chain
158fc 12f             | hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
158fc 12f             | hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
158fc 12f             | hhub_ctrl_ep    res     1         ' Hub control endpoint address
158fc 12f             | hhub_ctrl_ep    res     1         ' Hub control endpoint address
158fc 12f             | hhub_ep_addr    res     1         ' Hub interface endpoint address
158fc 12f             | hhub_ep_addr    res     1         ' Hub interface endpoint address
158fc 12f             | hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
158fc 12f             | hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
158fc 12f             | hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
158fc 12f             | hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
158fc 12f             | if HAVE_MOUSE
158fc 12f             | hmouse_ep_addr  res     1 ' Mouse interface endpoint address
158fc 12f             | end
158fc 12f             | hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
158fc 12f             | hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
158fc 12f             | hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
158fc 12f             | hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
158fc 12f             | hdev_ep_addr    res     1+MAX_DEVICES
158fc 12f             | hdev_ep_addr    res     1+MAX_DEVICES
158fc 12f             | hdev_out_addr   res     1
158fc 12f             | hdev_out_addr   res     1
158fc 12f             | 
158fc 12f             | if EMUPAD_MAX_PLAYER > 0
158fc 12f             | hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
158fc 12f             | hpad_emupad_buffer res EMUPAD_MAX_PLAYER
158fc 12f             | hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
158fc 12f             | end
158fc 12f             | 
158fc 12f             | hreg_init_end
158fc 12f             | 
158fc 12f             | hidr_start
158fc 12f             | hidr_usage      res     1 ' <- can get trashed after parsing
158fc 12f             | hidr_usage      res     1 ' <- can get trashed after parsing
158fc 12f             | hidr_flags      res     1
158fc 12f             | hidr_flags      res     1
158fc 12f             | hidr_axis       res     4
158fc 12f             | hidr_axis       res     4
158fc 12f             | hidr_buttons    res     1
158fc 12f             | hidr_buttons    res     1
158fc 12f             | hidr_hats       res     1
158fc 12f             | hidr_hats       res     1
158fc 12f             | '' Above are actually useful values, 6 longs
158fc 12f             | hidr_type       res     1
158fc 12f             | hidr_type       res     1
158fc 12f             | hidr_id         res     1
158fc 12f             | hidr_id         res     1
158fc 12f             | hidr_offset     res     1
158fc 12f             | hidr_offset     res     1
158fc 12f             | hidr_usage_idx  res     1
158fc 12f             | hidr_usage_idx  res     1
158fc 12f             | ' below need to be push/pop'd
158fc 12f             | hidr_state      res     1
158fc 12f             | hidr_state      res     1
158fc 12f             | hidr_size       res     1
158fc 12f             | hidr_size       res     1
158fc 12f             | hidr_count      res     1
158fc 12f             | hidr_count      res     1
158fc 12f             | hidr_lminmax    res     1
158fc 12f             | hidr_lminmax    res     1
158fc 12f             | hidr_pminmax    res     1
158fc 12f             | hidr_pminmax    res     1
158fc 12f             | hidr_end
158fc 12f             | 
158fc 12f             | ' Variables dependent on the system freqency
158fc 12f             | _var_64_lower_  res     1
158fc 12f             | _var_64_lower_  res     1
158fc 12f             | _var_64_upper_  res     1
158fc 12f             | _var_64_upper_  res     1
158fc 12f             | _12Mbps_        res     1
158fc 12f             | _12Mbps_        res     1
158fc 12f             | _1_5Mbps_       res     1
158fc 12f             | _1_5Mbps_       res     1
158fc 12f             | _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
158fc 12f             | _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
158fc 12f             | _1us_           res     1         ' 1us
158fc 12f             | _1us_           res     1         ' 1us
158fc 12f             | _10us_          res     1         ' 10us
158fc 12f             | _10us_          res     1         ' 10us
158fc 12f             | _33us_          res     1         ' 33us
158fc 12f             | _33us_          res     1         ' 33us
158fc 12f             | _txn_err_       res     1         ' 250us
158fc 12f             | _txn_err_       res     1         ' 250us
158fc 12f             | _500us_         res     1         ' 500us
158fc 12f             | _500us_         res     1         ' 500us
158fc 12f             | _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
158fc 12f             | _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
158fc 12f             | _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
158fc 12f             | _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
158fc 12f             | _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
158fc 12f             | _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
158fc 12f             | _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
158fc 12f             | _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
158fc 12f             | _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
158fc 12f             | _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
158fc 12f             | _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
158fc 12f             | _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
158fc 12f             | _preamble_wait_ res     1
158fc 12f             | _preamble_wait_ res     1
158fc 12f             | _1ms_           res     1         ' 1ms
158fc 12f             | _1ms_           res     1         ' 1ms
158fc 12f             | _2ms_           res     1         ' 2ms
158fc 12f             | _2ms_           res     1         ' 2ms
158fc 12f             | _suspend_wait_  res     1         ' 3ms
158fc 12f             | _suspend_wait_  res     1         ' 3ms
158fc 12f             | _4ms_           res     1         ' 4ms
158fc 12f             | _4ms_           res     1         ' 4ms
158fc 12f             | _xfer_wait_     res     1         ' 5ms
158fc 12f             | _xfer_wait_     res     1         ' 5ms
158fc 12f             | _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
158fc 12f             | _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
158fc 12f             | _reset_hold_    res     1         ' 15ms
158fc 12f             | _reset_hold_    res     1         ' 15ms
158fc 12f             | _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
158fc 12f             | _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
158fc 12f             | _21ms_          res     1         ' 21ms
158fc 12f             | _21ms_          res     1         ' 21ms
158fc 12f             | _100ms_         res     1         ' 100ms
158fc 12f             | _100ms_         res     1         ' 100ms
158fc 12f             | _500ms_         res     1         ' 500ms
158fc 12f             | _500ms_         res     1         ' 500ms
158fc 12f             | _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
158fc 12f             | _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
158fc 12f             | _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
158fc 12f             | _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
158fc 12f             | '------------------------------------------------------------------------------
158fc 12f             | _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
158fc 12f             | _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
158fc 12f             | _usb_d_ls_nco_  res     1
158fc 12f             | _usb_d_ls_nco_  res     1
158fc 12f             | _usb_h_fs_nco_  res     1
158fc 12f             | _usb_h_fs_nco_  res     1
158fc 12f             | _usb_d_fs_nco_  res     1
158fc 12f             | _usb_d_fs_nco_  res     1
158fc 12f             | '------------------------------------------------------------------------------
158fc 12f             | ' Scratch registers
158fc 12f             | htmp            res     1         ' Scratch registers whose context remains within the same code block
158fc 12f             | htmp            res     1         ' Scratch registers whose context remains within the same code block
158fc 12f             | htmp1           res     1
158fc 12f             | htmp1           res     1
158fc 12f             | htmp2           res     1
158fc 12f             | htmp2           res     1
158fc 12f             | htmp3           res     1
158fc 12f             | htmp3           res     1
158fc 12f             | hrep            res     1         ' Repeat count
158fc 12f             | hrep            res     1         ' Repeat count
158fc 12f             | hsave0          res     1         ' Subroutine parameter saves
158fc 12f             | hsave0          res     1         ' Subroutine parameter saves
158fc 12f             | hsave1          res     1
158fc 12f             | hsave1          res     1
158fc 12f             | hsave2          res     1
158fc 12f             | hsave2          res     1
158fc 12f             | isrtmp1         res     1
158fc 12f             | isrtmp1         res     1
158fc 12f             | pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
158fc 12f             | pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
158fc 12f             | hr0             res     1         ' Multi-purpose registers
158fc 12f             | hr0             res     1         ' Multi-purpose registers
158fc 12f             | hr1             res     1
158fc 12f             | hr1             res     1
158fc 12f             | hr2             res     1
158fc 12f             | hr2             res     1
158fc 12f             | hr3             res     1
158fc 12f             | hr3             res     1
158fc 12f             | hpar1           res     1         ' Routine entry/exit parameters
158fc 12f             | hpar1           res     1         ' Routine entry/exit parameters
158fc 12f             | hpar2           res     1
158fc 12f             | hpar2           res     1
158fc 12f             | hpar3           res     1
158fc 12f             | hpar3           res     1
158fc 12f             | hct2            res     1         ' Function response bus turn-around timer
158fc 12f             | hct2            res     1         ' Function response bus turn-around timer
158fc 12f             | hct3            res     1         ' Keyboard/mouse poll timer
158fc 12f             | hct3            res     1         ' Keyboard/mouse poll timer
158fc 12f             | mod_cnt         res     1         ' Used in idle loops
158fc 12f             | mod_cnt         res     1         ' Used in idle loops
158fc 12f             | 
158fc 12f             |                 fit     $1F0
158fc 12f             |                 fit     $1F0
158fc 12f             |                 org     $200
158fc 200             | hlut_start
158fc 200             | 
158fc 200             | '------------------------------------------------------------------------------
158fc 200             | ' Full-speed is the host's native speed, so all that is needed is to set the FS
158fc 200             | ' settings to startup defaults.
158fc 200             | '------------------------------------------------------------------------------
158fc 200             | ' On entry:
158fc 200             | ' On exit: Save/restore caller C flag state if C is changed in this routine!
158fc 200             | '------------------------------------------------------------------------------
158fc 200             | set_speed_full
158fc 200 D0 E8 07 F6 |                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
15900 201 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
15904 202 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
15908 203 A3 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
1590c 204             | '                ret                             wcz     ' Restore caller flags on exit
1590c 204             | 
1590c 204             | '------------------------------------------------------------------------------
1590c 204             | ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
1590c 204             | ' is a downstream hub connected (not yet implemented), the baud generator
1590c 204             | ' remains set at the full-speed rate, but signaling is switched to low-speed,
1590c 204             | ' which reverses the D-/D+ polarity. The polarity can be changed without
1590c 204             | ' putting the smart pins into reset.
1590c 204             | '------------------------------------------------------------------------------
1590c 204             | ' On entry:
1590c 204             | ' On exit: CZ flags restored to caller states
1590c 204             | '------------------------------------------------------------------------------
1590c 204             | set_speed_low
1590c 204 80 96 CE F7 |                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
15910 205 ED E8 07 A6 |         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
15914 206 23 69 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
15918 207 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
1591c 208 A4 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
15920 209 A2 9B 02 F6 |                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
15924 20a 02 96 26 F4 |                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
15928 20b 2D 00 7C FD |                 ret                             wcz     ' Restore caller flags on exit
1592c 20c             | 
1592c 20c             | '------------------------------------------------------------------------------
1592c 20c             | ' Perform configuration stuff required when a device intitially connects.
1592c 20c             | '------------------------------------------------------------------------------
1592c 20c             | ' On entry:
1592c 20c             | ' On exit:
1592c 20c             | '------------------------------------------------------------------------------
1592c 20c             | on_connect
1592c 20c 02 84 07 F6 |                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
15930 20d D8 FB BF FD |                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
15934 20e             | .retry
15934 20e 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
15938 20f 01 8C 07 C6 |         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
1593c 210 02 8C 07 36 |         if_nc   mov     hpar1, #USB_SPEED_FULL
15940 211 00 08 00 FF 
15944 212 00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
15948 213 2C 15 C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
1594c 214 47 F1 03 F1 |                 add     ptra, hcog_base_addr
15950 215 03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
15954 216 2A EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
15958 217 F4 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
1595c 218 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15960 219 18 00 90 AD |         if_z    jmp     #.get_dev_desc
15964 21a B1 99 02 F6 |                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
15968 21b 4C 03 B0 FD |                 call    #poll_waitx
1596c 21c 01 84 8F F1 |                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
15970 21d F0 FB 9F AD |         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
15974 21e A4 FB BF FD |                 call    #reset                          ' Try another reset to see if the device responds
15978 21f B8 FF 9F FD |                 jmp     #.retry
1597c 220             | .get_dev_desc
1597c 220 2A ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
15980 221 07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
15984 222 F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
15988 223 A7 99 02 F6 |                 mov     hctwait, _1ms_
1598c 224 28 03 B0 FD |                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
15990 225 88 FB BF FD |                 call    #reset
15994 226 44 15 C0 FE |                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
15998 227 47 F1 03 F1 |                 add     ptra, hcog_base_addr
1599c 228 01 11 5C FC |                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
159a0 229 D8 01 B0 FD |                 call    #control_write                  ' Execute SetAddress()
159a4 22a D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
159a8 22b 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
159ac 22c AC 99 02 F6 |                 mov     hctwait, _8ms_
159b0 22d 04 03 B0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
159b4 22e 04 00 00 FF 
159b8 22f 00 BC 06 F6 |                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
159bc 230 34 FA BF FD |                 call    #calc_crc5
159c0 231 2C 15 C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
159c4 232 47 F1 03 F1 |                 add     ptra, hcog_base_addr
159c8 233 2A EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
159cc 234 F7 AD C2 FA |                 rdbyte  total_data, pb
159d0 235 03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
159d4 236 78 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
159d8 237 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
159dc 238 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
159e0 239 5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
159e4 23a 2A F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
159e8 23b 07 DB C6 FA |                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
159ec 23c 9F 99 02 F6 |                 mov     hctwait, _500us_
159f0 23d C4 02 B0 FD |                 call    #poll_waitx
159f4 23e 34 15 C0 FE |                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
159f8 23f 47 F1 03 F1 |                 add     ptra, hcog_base_addr
159fc 240 03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
15a00 241 2B EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
15a04 242 48 00 B0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
15a08 243 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15a0c 244 2D 00 64 5D |         if_nz   ret
15a10 245 2B F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
15a14 246 F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
15a18 247 61 85 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
15a1c 248 61 87 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
15a20 249 00 71 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
15a24 24a 09 84 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
15a28 24b 02 86 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
15a2c 24c 56 71 1B A2 |         if_z    cmp     htmp, total_data        wcz
15a30 24d 0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
15a34 24e 2C FB 9F CD |         if_b    jmp     #host_error
15a38 24f A0 10 80 FE |                 loc     pa, #@init_kbdm_data - @usb_host_start
15a3c 250 47 ED 03 F1 |                 add     pa, hcog_base_addr
15a40 251 2D EC 63 FD |                 call    pa
15a44 252 94 0D 80 FE |                 loc     pa, #@hparse_con_desc - @usb_host_start
15a48 253 47 ED 03 F1 |                 add     pa, hcog_base_addr
15a4c 254 2C EC 63 FD |                 jmp     pa
15a50 255             | 
15a50 255             | '------------------------------------------------------------------------------
15a50 255             | ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
15a50 255             | ' Status reporting is always in the function-to-host direction.
15a50 255             | '------------------------------------------------------------------------------
15a50 255             | ' On entry:
15a50 255             | '   PTRA - start address of the SETUP data in hub.
15a50 255             | '   PB - start address of the buffer/struct to be written to during the IN data
15a50 255             | '     stage.
15a50 255             | '   ep_addr_pid - device address, endpoint and CRC5.
15a50 255             | ' On exit:
15a50 255             | '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
15a50 255             | '     contains the count of data stage bytes actually received, which must
15a50 255             | '     always be <= the count requested.
15a50 255             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
15a50 255             | '     more specific USB operation error code.
15a50 255             | '------------------------------------------------------------------------------
15a50 255             | control_read
15a50 255 5E 8D 03 F6 |                 mov     hpar1, ep_addr_pid
15a54 256 F8 8F 03 F6 |                 mov     hpar2, ptra
15a58 257 F7 91 03 F6 |                 mov     hpar3, pb                       ' Save dest buffer pointer
15a5c 258 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
15a60 259             | .xfer_start
15a60 259 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
15a64 25a C0 F6 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
15a68 25b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15a6c 25c 2D 00 64 5D |         if_nz   ret                                     ' Back to caller to handle error
15a70 25d 00 AC 0E F2 |                 cmp     total_data, #0          wz
15a74 25e 90 01 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
15a78 25f 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
15a7c 260 61 00 00 FF 
15a80 261 50 9F 06 F6 |                 mov     nak_retry, ##IN_NAK_RETRIES
15a84 262 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
15a88 263             | .data
15a88 263 56 B1 02 F6 |                 mov     pkt_data, total_data
15a8c 264 57 B1 82 F1 |                 sub     pkt_data, stage_data
15a90 265 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
15a94 266 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
15a98 267             | .nak_retry
15a98 267 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
15a9c 268             | .in_retry
15a9c 268 BC F6 BF FD |                 call    #txn_in
15aa0 269 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
15aa4 26a 28 00 90 AD |         if_z    jmp     #.commit
15aa8 26b 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
15aac 26c A8 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
15ab0 26d 14 02 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
15ab4 26e 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
15ab8 26f DC FF 9F AD |         if_z    jmp     #.nak_retry                     ' Function not ready to send data
15abc 270 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
15ac0 271 94 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
15ac4 272 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
15ac8 273 D0 FF 9F 5D |         if_nz   jmp     #.in_retry                      ' Bus error retry
15acc 274 2D 00 64 FD |                 ret                                     ' The transfer has failed
15ad0 275             | .commit
15ad0 275 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
15ad4 276 38 00 90 AD |         if_z    jmp     #.pre_status                    ' and also end-of-data
15ad8 277 29 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
15adc 278 5C 85 03 F6 |                 mov     hr0, pkt_cnt
15ae0 279 F7 F1 0B F2 |                 cmp     ptra, pb                wz
15ae4 27a 6C FA BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
15ae8 27b 5C AF 02 F1 |                 add     stage_data, pkt_cnt             ' Update bytes received on commit
15aec 27c 56 AF 0A F2 |                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
15af0 27d 1C 00 90 AD |         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
15af4 27e 58 B9 1A F2 |                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
15af8 27f 14 00 90 CD |         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
15afc 280 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET
15b00 281 5F C1 02 16 |         if_a    mov     context_retval, retval          ' In this case overall and context are the same
15b04 282 2D 00 64 1D |         if_a    ret                                     ' Caller must handle ERR_PACKET
15b08 283 03 96 E6 F4 |                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
15b0c 284 78 FF 9F FD |                 jmp     #.data                          ' Start next IN transaction
15b10 285             | .pre_status
15b10 285 57 AD 02 F6 |                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
15b14 286 E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0
15b18 287 00 B0 06 F6 |                 mov     pkt_data, #0
15b1c 288 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
15b20 289 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
15b24 28a 61 00 00 FF 
15b28 28b 50 9F 06 F6 |                 mov     nak_retry, ##OUT_NAK_RETRIES
15b2c 28c             | .out_retry
15b2c 28c 34 F7 BF FD |                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
15b30 28d D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15b34 28e 2D 00 64 AD |         if_z    ret                                     ' All is good when ACK
15b38 28f 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
15b3c 290 18 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
15b40 291 84 01 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
15b44 292 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
15b48 293 0C 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
15b4c 294 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
15b50 295 D8 FF 9F 5D |         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
15b54 296 2D 00 64 FD |                 ret                                     ' Caller must handle transfer retirement
15b58 297             | ' I've encountered transfer STALL, even though the data looks correct, and
15b58 297             | ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
15b58 297             | ' ControlRead() transfer gets things unstuck most of the time...
15b58 297             | .xfer_retry
15b58 297 AB 99 02 F6 |                 mov     hctwait, _xfer_wait_
15b5c 298 58 01 B0 FD |                 call    #poll_waitx
15b60 299 8C F9 BF FD |                 call    #wait_txn_ok
15b64 29a C6 BD 02 F6 |                 mov     ep_addr_pid, hpar1
15b68 29b C7 F1 03 F6 |                 mov     ptra, hpar2
15b6c 29c C8 EF 03 F6 |                 mov     pb, hpar3
15b70 29d BB A1 6E FB |                 djnz    xfer_retry, #.xfer_start
15b74 29e 5F C1 02 F6 |                 mov     context_retval, retval          ' Preserve the USB error code
15b78 29f 07 BE 06 06 |         _ret_   mov     retval, #ERR_XFER_RETRY
15b7c 2a0             | 
15b7c 2a0             | '------------------------------------------------------------------------------
15b7c 2a0             | ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
15b7c 2a0             | ' reporting is always in the function-to-host direction. It is assumed that
15b7c 2a0             | ' the SETUP data struct is filled with the required values.
15b7c 2a0             | '------------------------------------------------------------------------------
15b7c 2a0             | ' On entry:
15b7c 2a0             | '   PTRA - points to the start of the struct for the SETUP data.
15b7c 2a0             | '   PB - the start address of the struct/buffer to be read for the OUT data
15b7c 2a0             | '     stage.
15b7c 2a0             | '   ep_addr_pid - the proper CRC'd address and endpoint to use.
15b7c 2a0             | ' On exit:
15b7c 2a0             | '   retval - used to convey the success/failure of each stage.
15b7c 2a0             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
15b7c 2a0             | '     more specific USB operation error code.
15b7c 2a0             | '------------------------------------------------------------------------------
15b7c 2a0             | control_write
15b7c 2a0 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
15b80 2a1 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
15b84 2a2 0E 68 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
15b88 2a3             | 
15b88 2a3 5E 8D 03 F6 |                 mov     hpar1, ep_addr_pid
15b8c 2a4 F8 8F 03 F6 |                 mov     hpar2, ptra
15b90 2a5 F7 91 03 F6 |                 mov     hpar3, pb
15b94 2a6 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
15b98 2a7             | .xfer_start
15b98 2a7 00 9E 06 F6 |                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
15b9c 2a8 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
15ba0 2a9 84 F5 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
15ba4 2aa D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15ba8 2ab EC 00 90 5D |         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
15bac 2ac 00 AC 0E F2 |                 cmp     total_data, #0          wz
15bb0 2ad 54 00 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
15bb4 2ae 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
15bb8 2af E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
15bbc 2b0 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
15bc0 2b1 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
15bc4 2b2             | .data
15bc4 2b2 56 B1 02 F6 |                 mov     pkt_data, total_data
15bc8 2b3 57 B1 82 F1 |                 sub     pkt_data, stage_data
15bcc 2b4 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
15bd0 2b5 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
15bd4 2b6             | .out_retry
15bd4 2b6 F7 F1 03 F6 |                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
15bd8 2b7 88 F6 BF FD |                 call    #txn_out
15bdc 2b8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15be0 2b9 10 00 90 AD |         if_z    jmp     #.commit                        ' Function got the data
15be4 2ba E0 00 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
15be8 2bb 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
15bec 2bc E4 FF 9F 5D |         if_nz   jmp     #.out_retry
15bf0 2bd A4 00 90 FD |                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
15bf4 2be             | .commit
15bf4 2be F8 EF 03 F6 |                 mov     pb, ptra                        ' Save the current buffer/struct location
15bf8 2bf 58 AF 02 F1 |                 add     stage_data, pkt_data
15bfc 2c0 56 AF 0A F2 |                 cmp     stage_data, total_data  wz
15c00 2c1 03 96 E6 54 |         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
15c04 2c2 BC FF 9F 5D |         if_nz   jmp     #.data                          ' More data to send
15c08 2c3             | pre_status_in
15c08 2c3 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
15c0c 2c4 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
15c10 2c5             | .status_retry
15c10 2c5 00 B0 06 F6 |                 mov     pkt_data, #0
15c14 2c6 44 F5 BF FD |                 call    #txn_in
15c18 2c7 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
15c1c 2c8 00 B0 0E A2 |         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
15c20 2c9 74 00 90 AD |         if_z    jmp     #dwnstream_reset                ' Control Write finished
15c24 2ca 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
15c28 2cb 2D 00 64 AD |         if_z    ret
15c2c 2cc 98 00 B0 FD |                 call    #retry_wait                     ' NAK or bus error, so delay a bit
15c30 2cd 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
15c34 2ce D8 FF 9F 5D |         if_nz   jmp     #.status_retry
15c38 2cf             | '               ret                                     ' Caller must handle transfer retirement
15c38 2cf             | 
15c38 2cf             | '------------------------------------------------------------------------------
15c38 2cf             | ' Execute an IN interrupt transaction.
15c38 2cf             | '------------------------------------------------------------------------------
15c38 2cf             | ' On entry:
15c38 2cf             | '   ep_addr_pid - The function address and endpoint for the IN request.
15c38 2cf             | '   hpar2 - Address of the IN data buffer
15c38 2cf             | '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
15c38 2cf             | ' On exit:
15c38 2cf             | '   retval - the result of the operation.
15c38 2cf             | '   hpar3 - the count of IN data bytes actually received.
15c38 2cf             | '------------------------------------------------------------------------------
15c38 2cf             | do_int_in
15c38 2cf 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
15c3c 2d0 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
15c40 2d1 0E 68 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
15c44 2d2             | 
15c44 2d2 C8 71 33 F9 |                 getword htmp, hpar3, #0
15c48 2d3 C3 70 0F F2 |                 cmp     htmp, #PID_DATA0        wz
15c4c 2d4 03 96 A6 F4 |                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
15c50 2d5 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES
15c54 2d6             | .retry
15c54 2d6 C8 B1 3A F9 |                 getword pkt_data, hpar3, #1             ' IN max packet length
15c58 2d7 00 F5 BF FD |                 call    #txn_in
15c5c 2d8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK if data received
15c60 2d9 1C 00 90 AD |         if_z    jmp     #.commit
15c64 2da 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
15c68 2db 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
15c6c 2dc 24 00 90 AD |         if_z    jmp     #.post_ret                      ' The caller must handle either
15c70 2dd 54 00 B0 FD |                 call    #retry_wait
15c74 2de 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
15c78 2df 18 00 90 AD |         if_z    jmp     #.post_ret
15c7c 2e0 D4 FF 9F FD |                 jmp     #.retry
15c80 2e1             | .commit
15c80 2e1 29 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy the rx buffer
15c84 2e2 C7 EF 03 F6 |                 mov     pb, hpar2                       ' to the destination buffer
15c88 2e3 5C 85 0B F6 |                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
15c8c 2e4 F7 F1 0B 52 |         if_nz   cmp     ptra, pb                wz
15c90 2e5 C0 F8 BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
15c94 2e6             | .post_ret
15c94 2e6 5C 91 03 F6 |                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
15c98 2e7             | 
15c98 2e7             | 
15c98 2e7             | '------------------------------------------------------------------------------
15c98 2e7             | ' Resets the downstream hub port to FS
15c98 2e7             | '------------------------------------------------------------------------------
15c98 2e7             | dwnstream_reset
15c98 2e7 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
15c9c 2e8 2D 00 64 3D |         if_nc   ret                                     ' No LS device, reset not needed
15ca0 2e9             | 
15ca0 2e9 0E 68 07 F4 |                 bitl    _usb_h_ls_nco_, #14
15ca4 2ea 07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
15ca8 2eb 23 6D 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
15cac 2ec 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
15cb0 2ed A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
15cb4 2ee A3 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
15cb8 2ef             | 
15cb8 2ef             | '------------------------------------------------------------------------------
15cb8 2ef             | ' The one millisecond frame timer is implemented as an interrupt service
15cb8 2ef             | ' routine. Since this timing is critical, care must be taken to avoid any
15cb8 2ef             | ' instructions that can delay the interrupt branch, which will likely upset
15cb8 2ef             | ' the timer. WAITX is among those instructions, so any time you're inside
15cb8 2ef             | ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
15cb8 2ef             | '------------------------------------------------------------------------------
15cb8 2ef             | ' On entry:
15cb8 2ef             | '   hctwait - wait interval in sysclocks.
15cb8 2ef             | ' On exit:
15cb8 2ef             | '------------------------------------------------------------------------------
15cb8 2ef             | poll_waitx
15cb8 2ef 1A 92 63 FD |                 getct   hct2
15cbc 2f0 4C 93 6B FA |                 addct2  hct2, hctwait
15cc0 2f1             | .wait
15cc0 2f1 FF 25 CC FB |                 jnct2   #.wait
15cc4 2f2 2D 00 64 FD |                 ret
15cc8 2f3             | 
15cc8 2f3             | '------------------------------------------------------------------------------
15cc8 2f3             | ' Transaction retry handling for NAK/STALL or bus error.
15cc8 2f3             | '------------------------------------------------------------------------------
15cc8 2f3             | ' On entry:
15cc8 2f3             | '   retval - transaction response PID or error code.
15cc8 2f3             | ' On exit:
15cc8 2f3             | '------------------------------------------------------------------------------
15cc8 2f3             | retry_wait
15cc8 2f3 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
15ccc 2f4 2D 00 64 AD |         if_z    ret                                     ' STALL is special case
15cd0 2f5 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
15cd4 2f6 14 00 90 AD |         if_z    jmp     #.nak
15cd8 2f7 9E 99 02 F6 |                 mov     hctwait, _txn_err_              ' Transaction error wait...
15cdc 2f8 D8 FF BF FD |                 call    #poll_waitx
15ce0 2f9             | .dec
15ce0 2f9 01 A2 8E F1 |                 sub     retry, #1               wz
15ce4 2fa 06 BE 06 A6 |         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
15ce8 2fb 2D 00 64 FD |                 ret                                     ' Retry result to caller
15cec 2fc             | .nak
15cec 2fc 9D 99 02 F6 |                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
15cf0 2fd C4 FF BF FD |                 call    #poll_waitx
15cf4 2fe 00 9E 0E F2 |                 cmp     nak_retry, #NAK_NOLIMIT wz
15cf8 2ff 2D 00 64 AD |         if_z    ret                                     ' Indefinite NAK retries
15cfc 300 01 9E 8E F1 |                 sub     nak_retry, #1           wz
15d00 301 08 BE 06 A6 |         if_z    mov     retval, #ERR_NAK
15d04 302 2D 00 64 FD |                 ret
15d08 303             | 
15d08 303             | host_reset
15d08 303 25 00 64 FD |                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
15d0c 304 14 70 07 FB |                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
15d10 305             | ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
15d10 305 BD 01 05 FF 
15d14 306 00 70 1F F2 |                 cmp     htmp, ##168_000_000     wcz
15d18 307 00 94 06 E6 |         if_be   mov     utx_tweak, #0
15d1c 308 03 94 06 16 |         if_a    mov     utx_tweak, #3   '#20
15d20 309             | ' Check to see if the system clock has been changed.
15d20 309 2E 71 0B F2 |                 cmp     htmp, save_sysclk       wz
15d24 30a A0 0B A0 5E |         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
15d28 30b 47 EF 03 51 |         if_nz   add     pb, hcog_base_addr
15d2c 30c 2D EE 63 5D |         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
15d30 30d 40 46 62 FD |                 dirl    dm                              ' Put smart pins into reset
15d34 30e 40 48 62 FD |                 dirl    dp
15d38 30f             | 
15d38 30f 28 02 64 FD |                 setq    #1
15d3c 310 80 00 80 FF 
15d40 311 23 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
15d44 312 23 6D 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
15d48 313             | .enable
15d48 313 41 46 62 FD |                 dirh    dm                              ' Crank them smart pins up
15d4c 314 41 48 62 FD |                 dirh    dp
15d50 315 1F 36 63 FD |                 waitx   _1us_
15d54 316 23 01 28 FC |                 wypin   #OUT_IDLE, dm
15d58 317             | 
15d58 317             |                 ' Handle Port protection enable and startup delay
15d58 317 00 4A 56 F2 |                 cmps    usb_enable_pin, #0      wc
15d5c 318 58 4A 62 3D |         if_ae   drvl    usb_enable_pin                 ' disable port
15d60 319 1F 5E 63 FD |                 waitx   _21ms_                          ' Wait a while for everything to turn off
15d64 31a 59 4A 62 3D |         if_ae   drvh    usb_enable_pin                  ' Enable the port
15d68 31b 1F 5E 63 FD |                 waitx   _21ms_                          ' Hold to let the idle state get settled
15d6c 31c             | 
15d6c 31c             |                 'call #dev_reset ' TODO THINK ABOUT THIS
15d6c 31c             | 
15d6c 31c             | discon_entry
15d6c 31c 03 96 07 F6 |                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
15d70 31d             | 
15d70 31d 4B ED B7 F9 |                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
15d74 31e 3A 04 DC FC |                 rep     @.regloop,#hreg_init_end - hreg_init_start
15d78 31f 38 EC A7 F9 |                 alti    pa, #%000_111_000
15d7c 320 00 00 04 F6 |                 mov     0-0, #0
15d80 321             | .regloop
15d80 321             |               
15d80 321             |         if HAVE_HIDPAD
15d80 321             |         end
15d80 321             |         if EMUPAD_MAX_PLAYER > 0
15d80 321             |         end
15d80 321             | 
15d80 321             |                 ' Fall through to disconnected loop
15d80 321             | 
15d80 321             | '-----------------------------------------------------------------------------------------------------------------
15d80 321             | ' Device connect handling (Section 7.1.7.3).
15d80 321             | '-----------------------------------------------------------------------------------------------------------------
15d80 321             | ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
15d80 321             | ' device to connect (Section 7.1.7.3).
15d80 321             | '-----------------------------------------------------------------------------------------------------------------
15d80 321             | disconnected
15d80 321 14 86 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
15d84 322 2E 87 0B F2 |                 cmp     hr1, save_sysclk        wz
15d88 323 7C FF 9F 5D |         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
15d8c 324 03 86 47 F0 |                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
15d90 325 1F 86 63 FD |                 waitx   hr1                             ' it down to smaller wait chunks
15d94 326             |         if ACTIVITY_LED >= 0
15d94 326             |         end
15d94 326 23 A7 82 FA |                 rqpin   urx, dm
15d98 327 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
15d9c 328 E0 FF 9F AD |         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
15da0 329 28 00 90 5D |         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
15da4 32a             | .se1_test
15da4 32a B0 99 02 F6 |                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
15da8 32b 0C FF BF FD |                 call    #poll_waitx
15dac 32c 23 A7 82 FA |                 rqpin   urx, dm
15db0 32d 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
15db4 32e 00 BE 06 56 |         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
15db8 32f B0 FF 9F 5D |         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
15dbc 330             | .se1            'SE1 is a fatal error condition
15dbc 330 B0 99 02 F6 |                 mov     hctwait, _100ms_
15dc0 331 F4 FE BF FD |                 call    #poll_waitx
15dc4 332 03 BE 06 F6 |                 mov     retval, #ERR_SE1
15dc8 333 98 F7 BF FD |                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
15dcc 334             | .connect_test                                           ' Test lines until stable J/K state seen
15dcc 334 1F 60 63 FD |                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
15dd0 335 23 A7 82 FA |                 rqpin   urx, dm
15dd4 336 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
15dd8 337 90 FF 9F AD |         if_z    jmp     #discon_entry                   ' D+ and D- low
15ddc 338 C4 FF 9F AD |         if_e    jmp     #.se1_test                      ' D+ and D- high
15de0 339             | connected
15de0 339 01 96 26 F4 |                 bith    hstatus, #CONNECTEDB            ' Device plugged in
15de4 33a 44 FB BF FD |                 call    #on_connect                     ' Initial device configuration
15de8 33b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
15dec 33c 7C FF 9F 5D |         if_nz   jmp     #discon_entry
15df0 33d             | .set_pulse
15df0 33d 1A 64 63 FD |                 getct   _pulse_time_
15df4 33e B1 65 03 F1 |                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
15df8 33f             | ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
15df8 33f             | ' of 1ms and make a correction, if necessary.
15df8 33f             | '                mov     htmp, _1ms_
15df8 33f             | '                subs    htmp, iframe_delta
15df8 33f             | '                adds    _frame1ms_clks_, htmp
15df8 33f             | '                debug(udec(_frame1ms_clks_))
15df8 33f             | 
15df8 33f             |                 ' Fall through to idle/processing loop
15df8 33f 07 5E 1E F2 |                 cmp     hdev_port, #MAX_DEVICES wcz
15dfc 340 00 5E 06 16 |         if_a    mov     hdev_port, #0 
15e00 341             | 
15e00 341             | hidle
15e00 341 23 A7 82 FA |                 rqpin   urx, dm
15e04 342 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
15e08 343 78 00 90 CD |         if_c    jmp     #.se0_test
15e0c 344 24 06 70 FD |                 pollct3                         wc
15e10 345 48 00 90 3D |         if_nc   jmp     #.nopoll
15e14 346 1A 94 63 FD |                 getct   hct3
15e18 347 A7 95 73 FA |                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
15e1c 348             | 
15e1c 348 6A 5F 6E F9 |                 altgb   hdev_port, #hdev_type
15e20 349 00 70 E3 F8 |                 getbyte htmp
15e24 34a             | 
15e24 34a 09 70 0F F2 |                 cmp     htmp, #HUB_READY        wz
15e28 34b C0 12 80 AE |         if_z    loc     pa, #@hget_hub_status - @usb_host_start
15e2c 34c 20 00 90 AD |         if_z    jmp     #.poll
15e30 34d             | 
15e30 34d             |         if _HAVE_GAMEPAD
15e30 34d             |         end
15e30 34d             | 
15e30 34d             |         if HAVE_MOUSE
15e30 34d             |         end
15e30 34d             | 
15e30 34d 03 70 0F F2 |                 cmp     htmp, #KB_READY         wz
15e34 34e 28 11 80 AE |         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
15e38 34f 14 00 90 AD |         if_z    jmp     #.poll
15e3c 350             | 
15e3c 350 05 70 0F F2 |                 cmp     htmp, #KBM_READY        wz
15e40 351 14 00 90 5D |         if_nz   jmp     #.skip_poll
15e44 352 09 96 FE F4 |                 bitnot  hstatus, #KBM_TOGGLEB   wcz
15e48 353 28 11 80 3E |         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
15e4c 354             |         if HAVE_MOUSE
15e4c 354             |         else
15e4c 354 08 00 90 CD |         if_c    jmp     #.skip_poll
15e50 355             |         end
15e50 355             | 
15e50 355             | .poll
15e50 355 47 ED 03 F1 |                 add     pa, hcog_base_addr
15e54 356 2D EC 63 FD |                 call    pa
15e58 357             | .skip_poll
15e58 357             | 
15e58 357 07 5E 06 F7 |                 incmod  hdev_port, #MAX_DEVICES
15e5c 358             | 
15e5c 358             | .nopoll
15e5c 358 0E 42 0E F2 |                 cmp     cmd_data, #CMD_SUSPEND  wz
15e60 359 44 00 90 AD |         if_z    jmp     #hsuspend
15e64 35a 10 42 0E F2 |                 cmp     cmd_data, #CMD_RESET    wz
15e68 35b 00 42 06 A6 |         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
15e6c 35c 98 FE 9F AD |         if_z    jmp     #host_reset                     ' See if it works...
15e70 35d 1A 84 63 FD |                 getct   hr0
15e74 35e B2 85 1B F2 |                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
15e78 35f             |         if ACTIVITY_LED >= 0
15e78 35f             |         end
15e78 35f 1A 64 63 3D |         if_ae   getct   _pulse_time_
15e7c 360 B1 65 03 31 |         if_ae   add     _pulse_time_, _500ms_
15e80 361 7C FF 9F FD |                 jmp     #hidle
15e84 362             | ' Check for extended SE0 state on the bus
15e84 362             | .se0_test
15e84 362 A7 99 02 F6 |                 mov     hctwait, _1ms_
15e88 363 2C FE BF FD |                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
15e8c 364 23 A7 82 FA |                 rqpin   urx, dm
15e90 365 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
15e94 366 68 FF 9F 3D |         if_nc   jmp     #hidle                          ' Bus still IDLE
15e98 367 54 F6 BF FD |                 call    #wait_txn_ok
15e9c 368 00 00 80 FF 
15ea0 369 23 01 28 FC |                 wypin   ##OUT_IDLE, dm                  ' Float USB
15ea4 36a             |                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
15ea4 36a C4 FE 9F FD |                 jmp     #discon_entry                   ' Device disconnected
15ea8 36b             | 
15ea8 36b             | hsuspend
15ea8 36b 44 F6 BF FD |                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
15eac 36c 25 00 64 FD |                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
15eb0 36d 1F 52 63 FD |                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
15eb4 36e 23 01 28 FC |                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
15eb8 36f 00 42 06 F6 |                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
15ebc 370 00 96 07 F6 |                 mov     mod_cnt, #0
15ec0 371             | 
15ec0 371             |                 ' Fall through to resume wait loop
15ec0 371             | 
15ec0 371             | hwait_resume
15ec0 371 14 86 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
15ec4 372 02 86 47 F0 |                 shr     hr1, #2
15ec8 373 1F 86 63 FD |                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
15ecc 374             |         if ACTIVITY_LED >= 0
15ecc 374             |         end
15ecc 374 0F 42 0E F2 |                 cmp     cmd_data, #CMD_RESUME   wz
15ed0 375 EC FF 9F 5D |         if_nz   jmp     #hwait_resume
15ed4 376 14 70 07 FB |                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
15ed8 377 2E 71 0B F2 |                 cmp     htmp, save_sysclk       wz
15edc 378 18 00 90 AD |         if_z    jmp     #.resume
15ee0 379 A0 0B A0 FE |                 loc     pb, #@hinit_usb_timings - @usb_host_start
15ee4 37a 47 EF 03 F1 |                 add     pb, hcog_base_addr
15ee8 37b 2D EE 63 FD |                 call    pb                              ' Recalculate sysclk dependent timing values
15eec 37c 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
15ef0 37d 23 6D 13 3C |         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
15ef4 37e 23 69 13 CC |         if_c    wxpin   _usb_h_ls_nco_, dm
15ef8 37f             | .resume
15ef8 37f 23 05 28 FC |                 wypin   #OUT_K, dm
15efc 380 1F 5C 63 FD |                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
15f00 381 23 03 28 FC |                 wypin   #OUT_SE0, dm
15f04 382 A2 71 03 F6 |                 mov     htmp, _ip_delay_ls_
15f08 383 01 70 47 F0 |                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
15f0c 384 1F 70 63 FD |                 waitx   htmp
15f10 385 23 07 28 FC |                 wypin   #OUT_J, dm
15f14 386 01 70 47 F0 |                 shr     htmp, #1
15f18 387 1F 70 63 FD |                 waitx   htmp
15f1c 388 23 01 28 FC |                 wypin   #OUT_IDLE, dm
15f20 389 1A 92 62 FD |                 getct   iframe_ct_base
15f24 38a 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
15f28 38b B3 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
15f2c 38c 25 02 64 FD |                 setint1 #1                              ' Enable the 1ms frame ISR
15f30 38d AA 99 02 F6 |                 mov     hctwait, _4ms_
15f34 38e 80 FD BF FD |                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
15f38 38f 00 42 06 06 |         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
15f3c 390             | 
15f3c 390             | '------------------------------------------------------------------------------
15f3c 390             | ' Send preamble to enable low-speed HUB ports
15f3c 390             | '------------------------------------------------------------------------------
15f3c 390             | ' On entry:
15f3c 390             | ' On exit:
15f3c 390             | '   USB baud rate set to low-speed
15f3c 390             | '------------------------------------------------------------------------------
15f3c 390             | utx_pre
15f3c 390 40 46 62 FD |                 dirl    dm                              ' Put smart pins into reset
15f40 391 40 48 62 FD |                 dirl    dp
15f44 392 28 02 64 FD |                 setq    #1
15f48 393 23 01 08 FC |                 wrpin   #0, dm                          ' Disable smartpin mode
15f4c 394 58 46 62 FD |                 drvl    dm
15f50 395 59 48 62 FD |                 drvh    dp
15f54 396             | 
15f54 396 1E 00 00 FF 
15f58 397 80 70 07 F6 |                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
15f5c 398             | 
15f5c 398 11 08 DC FC |                 rep     @.l1, #16 + 1
15f60 399 01 70 57 F0 |                 shr     htmp, #1        wc
15f64 39a 28 02 64 3D |         if_nc   setq    #1
15f68 39b 4F 46 62 3D |         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
15f6c 39c 1F 4C 63 FD |                 waitx   _preamble_wait_
15f70 39d             | .l1
15f70 39d             | 
15f70 39d 40 46 62 FD |                 dirl    dm                              ' Put smart pins into reset
15f74 39e 40 48 62 FD |                 dirl    dp
15f78 39f 28 02 64 FD |                 setq    #1
15f7c 3a0 80 00 80 FF 
15f80 3a1 23 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
15f84 3a2 23 69 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
15f88 3a3 41 46 62 FD |                 dirh    dm                              ' Crank them smart pins up
15f8c 3a4 41 48 62 FD |                 dirh    dp
15f90 3a5 23 01 28 FC |                 wypin   #OUT_IDLE, dm
15f94 3a6             | 
15f94 3a6 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
15f98 3a7 A4 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
15f9c 3a8 A2 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
15fa0 3a9             | 
15fa0 3a9             | hlut_end
15fa0 3a9             |                 fit     $400
15fa0 3a9             |                 fit     $400
15fa0 3a9             |                 orgh
15fa0                 | if OVERLAP_MEMORY
15fa0                 |                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
15fa0                 | end
15fa0                 | '------------------------------------------------------------------------------
15fa0                 | ' Routines called from cog space.
15fa0                 | '------------------------------------------------------------------------------
15fa0                 | ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
15fa0                 | '------------------------------------------------------------------------------
15fa0                 | 
15fa0                 | '------------------------------------------------------------------------------
15fa0                 | ' USB host cog initialization.
15fa0                 | '------------------------------------------------------------------------------
15fa0                 | usb_host_init
15fa0                 |                 ' Initialize buffer pointers
15fa0                 |         if OVERLAP_MEMORY
15fa0                 |         else
15fa0     AC 0A B0 FE |                 loc     pb, #hid_descr
15fa4                 |         end
15fa4     F7 4F 02 F6 |                 mov     hid_descr_p, pb
15fa8                 |                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
15fa8                 |                 {
15fa8                 |                 }
15fa8                 |         
15fa8                 |                 {
15fa8                 |                 }
15fa8                 |                 'loc     pb,#hkbd_report
15fa8                 |                 'mov     hkbd_report_p,pb
15fa8                 | 
15fa8     C4 11 B0 FE |                 loc     pb, #hub_descr
15fac     F7 51 02 F6 |                 mov     hub_descr_p, pb
15fb0     C5 11 B0 FE |                 loc     pb, #urx_buff
15fb4     F7 53 02 F6 |                 mov     urx_buff_p, pb
15fb8     3D 12 B0 FE |                 loc     pb, #dev_desc_buff
15fbc     F7 55 02 F6 |                 mov     dev_desc_buff_p, pb
15fc0     47 12 B0 FE |                 loc     pb, #con_desc_buff
15fc4     F7 57 02 F6 |                 mov     con_desc_buff_p, pb
15fc8     84 0A B0 FE |                 loc     pb, #usb_cache_start
15fcc     F7 59 02 F6 |                 mov     cache_start_p, pb
15fd0     A5 11 B0 FE |                 loc     pb, #usb_cache_end
15fd4     F7 5B 02 F6 |                 mov     cache_end_p, pb
15fd8                 | 
15fd8                 |         if ERROR_LED >= 0
15fd8     59 4C 62 FD |                 drvh    host_error_led                  ' Ensure fatal error LED is inactive
15fdc                 |         end
15fdc                 | 
15fdc                 |                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
15fdc                 |                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
15fdc                 |                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
15fdc                 | ' Configure and enable the Serial Host USB port.
15fdc     03 03 80 FD |                 jmp     #host_reset                     ' Initialize host and enter main processing loop
15fe0                 | 
15fe0                 | '------------------------------------------------------------------------------
15fe0                 | ' Timing calculations happen before any interrupt(s) are enabled.
15fe0                 | '------------------------------------------------------------------------------
15fe0                 | ' On entry:
15fe0                 | '   htmp - current CLKFREQ value.
15fe0                 | '------------------------------------------------------------------------------
15fe0                 | hinit_usb_timings
15fe0                 | '                getct   htmp2
15fe0     B8 5D 02 F6 |                 mov     save_sysclk, htmp
15fe4     8D 5B 80 FF 
15fe8     2E 01 2A FD |                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
15fec     18 30 63 FD |                 getqx   _12Mbps_
15ff0     10 30 57 F0 |                 shr     _12Mbps_, #16           wc
15ff4     00 30 27 F1 |                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
15ff8     03 6C 07 F6 |                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
15ffc     0E 6C 67 F0 |                 shl     _usb_h_fs_nco_, #14
16000     98 6D 03 F1 |                 add     _usb_h_fs_nco_, _12Mbps_
16004     01 6E 07 F6 |                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
16008     0E 6E 67 F0 |                 shl     _usb_d_fs_nco_, #14
1600c     98 6F 03 F1 |                 add     _usb_d_fs_nco_, _12Mbps_
16010     98 33 03 F6 |                 mov     _1_5Mbps_, _12Mbps_
16014     03 32 47 F0 |                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
16018     02 68 07 F6 |                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
1601c     0E 68 67 F0 |                 shl     _usb_h_ls_nco_, #14
16020     99 69 03 F1 |                 add     _usb_h_ls_nco_, _1_5Mbps_
16024     99 6B 03 F6 |                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
16028     80 00 00 FF 
1602c     00 5C 06 FD |                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
16030     18 2C 63 FD |                 getqx   _var_64_lower_
16034     19 2E 63 FD |                 getqy   _var_64_upper_
16038     28 2C 63 FD |                 setq    _var_64_lower_
1603c     65 CD 1D FF 
16040     00 2E 27 FD |                 qfrac   _var_64_upper_, ##_1b
16044     18 34 63 FD |                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
16048     01 00 00 FF 
1604c     00 5C 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
16050     18 2C 63 FD |                 getqx   _var_64_lower_
16054     19 2E 63 FD |                 getqy   _var_64_upper_
16058     28 2C 63 FD |                 setq    _var_64_lower_
1605c     A1 07 00 FF 
16060     40 2E 27 FD |                 qfrac   _var_64_upper_, ##_1m
16064     18 36 63 FD |                 getqx   _1us_                           ' 1us as 32,9 fixed point
16068     9B 7B 03 F6 |                 mov     hsave0, _1us_                   ' Save it to compute other us values
1606c     09 36 57 F0 |                 shr     _1us_, #9               wc
16070     00 36 27 F1 |                 addx    _1us_, #0                       ' Round to final value
16074     0A 7A 07 FD |                 qmul    hsave0, #10                     ' Calc 10us
16078     18 38 63 FD |                 getqx   _10us_
1607c     09 38 57 F0 |                 shr     _10us_, #9              wc
16080     00 38 27 F1 |                 addx    _10us_, #0                      ' 10us
16084     21 7A 07 FD |                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
16088     18 3A 63 FD |                 getqx   _33us_
1608c     09 3A 57 F0 |                 shr     _33us_, #9              wc
16090     00 3A 27 F1 |                 addx    _33us_, #0                      ' 33us
16094     FA 7A 07 FD |                 qmul    hsave0, #250                    ' Calc 250us
16098     18 3C 63 FD |                 getqx   _txn_err_
1609c     09 3C 57 F0 |                 shr     _txn_err_, #9           wc
160a0     00 3C 27 F1 |                 addx    _txn_err_, #0                   ' 250us
160a4     F4 7B 07 FD |                 qmul    hsave0, #500                    ' Calc 500us
160a8     18 3E 63 FD |                 getqx   _500us_
160ac     09 3E 57 F0 |                 shr     _500us_, #9             wc
160b0     00 3E 27 F1 |                 addx    _500us_, #0                     ' 500us
160b4     01 00 00 FF 
160b8     9A 7A 07 FD |                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
160bc     18 40 63 FD |                 getqx   _txn_ok_ls_
160c0     09 40 57 F0 |                 shr     _txn_ok_ls_, #9         wc
160c4     00 40 27 F1 |                 addx    _txn_ok_ls_, #0                 ' 666us
160c8     01 00 00 FF 
160cc     52 7B 07 FD |                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
160d0     18 42 63 FD |                 getqx   _txn_ok_fs_
160d4     09 42 57 F0 |                 shr     _txn_ok_fs_, #9         wc
160d8     00 42 27 F1 |                 addx    _txn_ok_fs_, #0                 ' 850us
160dc     9A 45 03 F6 |                 mov     _ip_delay_ls_, _1ns16fp_
160e0     05 00 00 FF 
160e4     80 44 07 FA |                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
160e8     10 44 57 F0 |                 shr     _ip_delay_ls_, #16      wc
160ec     00 44 27 F1 |                 addx    _ip_delay_ls_, #0
160f0     9A 49 03 F6 |                 mov     _tat_wait_ls_, _1ns16fp_
160f4     1C 00 00 FF 
160f8     C0 49 07 FA |                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
160fc     10 48 57 F0 |                 shr     _tat_wait_ls_, #16      wc
16100     00 48 27 F1 |                 addx    _tat_wait_ls_, #0
16104     9A 47 03 F6 |                 mov     _ip_delay_fs_, _1ns16fp_
16108     00 00 00 FF 
1610c     4E 47 07 FA |                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
16110     10 46 57 F0 |                 shr     _ip_delay_fs_, #16      wc
16114     00 46 27 F1 |                 addx    _ip_delay_fs_, #0
16118     9A 4B 03 F6 |                 mov     _tat_wait_fs_, _1ns16fp_
1611c     04 00 00 FF 
16120     23 4B 07 FA |                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
16124     10 4A 57 F0 |                 shr     _tat_wait_fs_, #16      wc
16128     00 4A 27 F1 |                 addx    _tat_wait_fs_, #0
1612c     8D 5B 00 FF 
16130     00 5D 16 FD |                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
16134     18 4C 63 FD |                 getqx   _preamble_wait_
16138     08 4C 87 F1 |                 sub     _preamble_wait_,# 9 - 1
1613c     01 00 00 FF 
16140     00 5C 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
16144     18 2C 63 FD |                 getqx   _var_64_lower_
16148     19 2E 63 FD |                 getqy   _var_64_upper_
1614c     28 2C 63 FD |                 setq    _var_64_lower_
16150     01 00 00 FF 
16154     E8 2F 27 FD |                 qfrac   _var_64_upper_, ##_1thou
16158     18 4E 63 FD |                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
1615c     09 4E 57 F0 |                 shr     _1ms_, #9               wc
16160     00 4E 27 F1 |                 addx    _1ms_, #0                       ' 1ms
16164     FF FF 7F FF 
16168     F2 67 07 F6 |                 mov     _frame1ms_clks_, ##-14
1616c     A7 67 43 F1 |                 adds    _frame1ms_clks_, _1ms_
16170     A7 51 03 F6 |                 mov     _2ms_, _1ms_
16174     01 50 67 F0 |                 shl     _2ms_, #1                       ' 2ms
16178     A7 53 03 F6 |                 mov     _suspend_wait_, _1ms_
1617c     A7 53 03 F1 |                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
16180     A7 55 03 F6 |                 mov     _4ms_, _1ms_
16184     02 54 67 F0 |                 shl     _4ms_, #2                       ' 4ms
16188     AA 57 03 F6 |                 mov     _xfer_wait_, _4ms_
1618c     A7 57 03 F1 |                 add     _xfer_wait_, _1ms_              ' 5ms
16190     AB 5B 03 F6 |                 mov     _reset_hold_, _xfer_wait_       ' 5ms
16194     AD 5D 03 F6 |                 mov     _resume_hold_, _reset_hold_
16198     02 5C 67 F0 |                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
1619c     AE 61 03 F6 |                 mov     _100ms_, _resume_hold_          ' 20ms
161a0     01 60 67 F0 |                 shl     _100ms_, #1                     ' 40ms
161a4     A7 59 03 F6 |                 mov     _8ms_, _1ms_
161a8     03 58 67 F0 |                 shl     _8ms_, #3                       ' 8ms
161ac     01 5A 67 F0 |                 shl     _reset_hold_, #1                ' 10ms
161b0     AD 61 03 F1 |                 add     _100ms_, _reset_hold_           ' 50ms
161b4     AB 5B 03 F1 |                 add     _reset_hold_, _xfer_wait_       ' 15ms
161b8     AB 5F 03 F6 |                 mov     _21ms_, _xfer_wait_             ' 5ms
161bc     02 5E 67 F0 |                 shl     _21ms_, #2                      ' 20ms
161c0     A7 5F 03 F1 |                 add     _21ms_, _1ms_                   ' 21ms
161c4     B0 63 03 F6 |                 mov     _500ms_, _100ms_                ' 50ms
161c8     01 60 67 F0 |                 shl     _100ms_, #1                     ' 100ms
161cc     03 62 67 F0 |                 shl     _500ms_, #3                     ' 400ms
161d0     B0 63 03 01 |         _ret_   add     _500ms_, _100ms_                ' 500ms
161d4                 | '        _ret_   mov     _1sec_, save_sysclk
161d4                 | '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
161d4                 | '                ret
161d4                 | {
161d4                 | }
161d4                 | 
161d4                 | '------------------------------------------------------------------------------
161d4                 | ' Parse a configuration descriptor chain to see if the device is a recognized
161d4                 | ' one. If it is, start the task progression that will configure the device for
161d4                 | ' use.
161d4                 | '------------------------------------------------------------------------------
161d4                 | ' On entry:
161d4                 | '   hconfig_base - start address of the cached config descriptor chain.
161d4                 | ' On exit:
161d4                 | '------------------------------------------------------------------------------
161d4                 | hparse_con_desc
161d4     2A F3 03 F6 |                 mov     ptrb, dev_desc_buff_p
161d8     82 71 07 FB |                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
161dc     61 5F 86 F9 |                 altr    hdev_port,#hdev_id
161e0     4E 70 FF F9 |                 movbyts htmp,#%%1032
161e4     86 D3 E6 FA |                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
161e8                 |                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
161e8                 | 
161e8     02 EC 07 F6 |                 mov     pa, #CON_wTotalLen
161ec     6E ED 03 F1 |                 add     pa, hconfig_base
161f0     F6 DF E2 FA |                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
161f4                 |                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
161f4                 | ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
161f4                 | ' that defines a keyboard and/or mouse.
161f4     6E EB C2 FA |                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
161f8                 | .next_intf
161f8     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
161fc     84 01 90 3D |         if_ae   jmp     #hset_config
16200     6E F3 03 F6 |                 mov     ptrb, hconfig_base
16204     75 F3 03 F1 |                 add     ptrb, hnext_desc
16208     81 71 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
1620c     04 70 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
16210     0C 00 90 AD |         if_z    jmp     #.intf
16214     80 71 C7 FA |                 rdbyte  htmp, ptrb
16218     B8 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
1621c     D8 FF 9F FD |                 jmp     #.next_intf
16220                 | .intf
16220     00 8E 07 F6 |                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
16224     00 90 07 F6 |                 mov     hpar3, #0
16228     82 E1 C6 FA |                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
1622c     85 E3 C6 FA |                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
16230     86 E5 C6 FA |                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
16234     87 E7 C6 FA |                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
16238                 |                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
16238                 | 
16238                 | .endp
16238     80 71 C7 FA |                 rdbyte  htmp, ptrb
1623c     B8 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
16240     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
16244     78 00 90 3D |         if_ae   jmp     #.get_device
16248     6E F3 03 F6 |                 mov     ptrb, hconfig_base
1624c     75 F3 03 F1 |                 add     ptrb, hnext_desc
16250     81 71 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
16254     04 70 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
16258     64 00 90 AD |         if_z    jmp     #.get_device
1625c     05 70 0F F2 |                 cmp     htmp, #TYPE_ENDPOINT    wz
16260     04 00 90 AD |         if_z    jmp     #.get_ep
16264     D0 FF 9F FD |                 jmp     #.endp
16268                 | .get_ep
16268     82 87 C7 FA |                 rdbyte  hr1, ptrb[ENDP_bAddress]
1626c     07 86 17 F4 |                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
16270     0F 86 67 F0 |                 shl     hr1, #8 + 7
16274     6C 71 03 F6 |                 mov     htmp, hctrl_ep_addr
16278     3F 00 00 FF 
1627c     00 71 07 F5 |                 and     htmp, ##ADDR_MASK
16280     C3 71 43 F5 |                 or      htmp, hr1                       ' endpoint address
16284     00 8E 0F F2 |                 cmp     hpar2, #0               wz
16288     0C 00 90 8D |  if_z_and_c     jmp     #.in_ep
1628c     00 90 0F F2 |                 cmp     hpar3, #0               wz
16290     18 00 90 2D |  if_z_and_nc    jmp     #.out_ep
16294     A0 FF 9F FD |                 jmp     #.endp
16298                 | .in_ep
16298     B8 8F 03 F6 |                 mov     hpar2, htmp                     ' IN endpoint
1629c     84 89 C7 FA |                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
162a0                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
162a0     86 85 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
162a4     C2 89 DB F8 |                 setbyte hr2, hr0, #3
162a8     8C FF 9F FD |                 jmp     #.endp
162ac                 | .out_ep
162ac     B8 91 03 F6 |                 mov     hpar3, htmp                     ' OUT endpoint
162b0     84 8B C7 FA |                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
162b4                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
162b4     86 85 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
162b8     C2 8B DB F8 |                 setbyte hr3, hr0, #3
162bc     78 FF 9F FD |                 jmp     #.endp
162c0                 | 
162c0                 | .get_device
162c0     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
162c4     5D E4 0E A2 |         if_z    cmp     hdev_subclass, #$5D     wz
162c8     01 E6 0E A2 |         if_z    cmp     hdev_protocol, #$01     wz
162cc     44 00 90 AD |         if_z    jmp     #.gamepad
162d0     09 E2 0E F2 |                 cmp     hdev_class, #CLASS_HUB  wz
162d4     74 00 90 AD |         if_z    jmp     #.hub
162d8     03 E2 0E F2 |                 cmp     hdev_class, #CLASS_HID              wz
162dc     18 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No HID class, ignore
162e0     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
162e4     2C 00 90 AD |         if_z    jmp     #.gamepad
162e8     01 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
162ec     08 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
162f0                 | .keyboard
162f0     01 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
162f4                 |         if HAVE_MOUSE
162f4                 |         else
162f4     00 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No Keyboard
162f8                 |         end
162f8     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0    wz
162fc     F8 FE 9F 5D |         if_nz   jmp     #.next_intf
16300     70 6F E2 F8 |                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
16304     C4 71 FA F8 |                 getbyte kb_interval, hr2, #3
16308     C4 73 E2 F8 |                 getbyte kb_in_max_pkt, hr2, #0
1630c     C7 F3 02 F6 |                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
16310                 |                 'debug(udec(kb_intf_num))
16310                 |                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
16310     E4 FE 9F FD |                 jmp     #.next_intf
16314                 | if HAVE_MOUSE
16314                 | .mouse
16314                 | end
16314                 | .gamepad
16314     79 71 03 F6 |                 mov     htmp, hkbd_ep_addr
16318     C7 71 63 F5 |                 xor     htmp, hpar2
1631c     3F 00 00 FF 
16320     00 71 0F F5 |                 and     htmp, ##ADDR_MASK       wz
16324     D0 FE 9F AD |         if_z    jmp     #.next_intf
16328                 |         if HAVE_MOUSE
16328                 |         end
16328     7C 5F 8E F9 |                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
1632c     00 00 0C F2 |                 cmp     0-0, #0                 wz      ' |
16330     C4 FE 9F 5D |         if_nz   jmp     #.next_intf
16334                 | 
16334     70 79 E2 F8 |                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
16338     C4 7B FA F8 |                 getbyte gp_interval, hr2, #3
1633c     7C 5F 8E F9 |                 altd    hdev_port, #hdev_ep_addr
16340     C7 01 00 F6 |                 mov     0-0, hpar2                      ' IN endpoint address
16344     C8 09 03 F6 |                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
16348                 |                 'debug(udec(gp_intf_num))
16348                 |                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
16348     AC FE 9F FD |                 jmp     #.next_intf
1634c                 | .hub
1634c     00 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
16350     A4 FE 9F 5D |         if_nz   jmp     #.next_intf
16354     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
16358     02 E6 0E 52 |         if_nz   cmp     hdev_protocol, #2                   wz
1635c     98 FE 9F 5D |         if_nz   jmp     #.next_intf
16360     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
16364     90 FE 9F 5D |         if_nz   jmp     #.next_intf
16368     70 67 E2 F8 |                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
1636c     6C ED 02 F6 |                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
16370     C7 BD 02 F6 |                 mov     ep_addr_pid, hpar2              ' IN endpoint address
16374     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
16378     5E EF 02 F6 |                 mov     hhub_ep_addr, ep_addr_pid
1637c     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
16380                 |                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
16380     74 FE 9F FD |                 jmp     #.next_intf
16384                 | 
16384                 | '------------------------------------------------------------------------------
16384                 | ' If a newly-connected device is recognized, do whatever is needed to configure
16384                 | ' it according to its function, or functions. In the case of this boot protocol
16384                 | ' keyboard/mouse class driver:
16384                 | ' - SetConfiguration(config_num)
16384                 | ' - SetProtocol(boot)
16384                 | ' - SetIdle(indefinite)
16384                 | ' - Enter the device interrupt IN polling task stage.
16384                 | '------------------------------------------------------------------------------
16384                 | ' On entry:
16384                 | ' On exit:
16384                 | '------------------------------------------------------------------------------
16384                 | hset_config
16384                 | '                mov     hkbd_ep_addr, #0                ' DEBUG
16384                 | '                mov     hmouse_ep_addr, #0              ' DEBUG
16384     02 74 07 F6 |                 mov     htmp2, #DEV_UNKNOWN
16388     7C 5F 8E F9 |                 altd    hdev_port, #hdev_ep_addr
1638c     00 00 0C F2 |                 cmp     0-0, #0                 wz
16390     00 F2 0E A2 |         if_z    cmp     hkbd_ep_addr, #0        wz
16394                 |         if HAVE_MOUSE
16394                 |         end
16394     00 EE 0E A2 |         if_z    cmp     hhub_ep_addr, #0        wz
16398     38 01 90 AD |         if_z    jmp     #.notify_client                 ' No known device
1639c                 | .set_config
1639c     DC 05 D0 FE |                 loc     ptra, #set_config
163a0     05 EC 07 F6 |                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
163a4     6E ED 03 F1 |                 add     pa, hconfig_base
163a8     F6 8D C3 FA |                 rdbyte  hpar1, pa
163ac                 |                 debug("SetConfiguration: ",udec_(hpar1))
163ac     01 8D 57 FC |                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
163b0     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
163b4     00 EE 07 F6 |                 mov     pb, #0                          ' SetConfiguration() has no data stage
163b8     A0 02 A0 FD |                 call    #control_write
163bc     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
163c0     2D 00 64 5D |         if_nz   ret
163c4                 | .kbd_config
163c4     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0        wz
163c8     9C 00 90 AD |         if_z    jmp     #.mouse_config                  ' No keyboard
163cc                 | 
163cc     79 71 03 F6 |                 mov     htmp, hkbd_ep_addr
163d0     5E 71 63 F5 |                 xor     htmp, ep_addr_pid
163d4     3F 00 00 FF 
163d8     00 71 0F F5 |                 and     htmp, ##ADDR_MASK       wz
163dc     88 00 90 5D |         if_nz   jmp     #.mouse_config                  ' No keyboard
163e0                 | 
163e0     37 71 E3 F8 |                 getbyte htmp, kb_intf_num, #0
163e4     A4 05 D0 FE |                 loc     ptra, #set_protocol
163e8     01 01 5C FC |                 wrword  #BOOT_PROTOCOL, ptra[wValue]
163ec     02 71 57 FC |                 wrword  htmp, ptra[wIndex]
163f0     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
163f4     A0 02 A0 FD |                 call    #control_write
163f8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
163fc     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
16400     D0 00 90 5D |         if_nz   jmp     #.notify_client
16404     00 8C 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
16408     37 8F E3 F8 |                 getbyte hpar2, kb_intf_num, #0
1640c     1C 01 B0 FD |                 call    #hset_idle
16410                 |                 'cmp     retval, #PID_ACK        wz
16410                 |         'if_nz   mov     hkbd_ep_addr, #0
16410                 |         'if_nz   jmp     #.notify_client
16410     A8 99 02 F6 |                 mov     hctwait, _2ms_
16414     EF 02 A0 FD |                 call    #poll_waitx
16418     01 76 06 F6 |                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
1641c                 |         if NUMLOCK_DEFAULT_STATE && RPI_KEYBOARD_NUMLOCK_HACK
1641c                 |         end
1641c     3B F7 02 F6 |                 mov     hkbd_ledstates, kb_led_states
16420     34 0D 90 FE |                 loc     pa, #hkbd_led_rep
16424     F6 F7 42 FC |                 wrbyte  hkbd_ledstates,pa
16428     18 01 B0 FD |                 call    #hset_kbdled_report
1642c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
16430     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
16434     9C 00 90 5D |         if_nz   jmp     #.notify_client
16438     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
1643c     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
16440     09 6C 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
16444     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
16448     5E F3 02 F6 |                 mov     hkbd_ep_addr, ep_addr_pid
1644c     6C F1 02 F6 |                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
16450     1F F0 46 F4 |                 bitc    hkbd_ctrl_ep, #31
16454     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
16458     00 F4 06 F6 |                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
1645c     C3 64 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
16460     03 74 07 F6 |                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
16464                 |         if !!HAVE_MOUSE
16464                 |                 '' If we could have a mouse, fall through into mouse config to detect combo dev
16464     6C 00 90 FD |                 jmp     #.notify_client
16468                 |         end
16468                 | 
16468                 | .mouse_config
16468                 | if HAVE_MOUSE
16468                 | end
16468                 | .gamepad_config
16468                 | if _HAVE_GAMEPAD
16468                 | 
16468                 |                 if EMUPAD_MAX_PLAYER > 0
16468                 |                 
16468                 | .rule_loop           
16468                 |                 end
16468                 | .xinput
16468                 | .ps3
16468                 | end
16468                 | 
16468                 | .hub_config
16468     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
1646c     64 00 90 AD |         if_z    jmp     #.notify_client                 ' No HUB
16470     77 71 03 F6 |                 mov     htmp, hhub_ep_addr
16474     5E 71 63 F5 |                 xor     htmp, ep_addr_pid
16478     3F 00 00 FF 
1647c     00 71 0F F5 |                 and     htmp, ##ADDR_MASK       wz
16480     50 00 90 5D |         if_nz   jmp     #.notify_client                 ' No HUB
16484                 | 
16484     24 05 D0 FE |                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
16488     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]
1648c     28 EF 03 F6 |                 mov     pb, hub_descr_p
16490     55 02 A0 FD |                 call    #control_read
16494     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
16498     00 EE 06 56 |         if_nz   mov     hhub_ep_addr, #0
1649c     34 00 90 5D |         if_nz   jmp     #.notify_client
164a0                 |                 debug(uhex_byte_array(hub_descr_p,total_data))
164a0                 | 
164a0     28 F1 03 F6 |                 mov     ptra, hub_descr_p
164a4     02 77 C7 FA |                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
164a8     07 76 27 F3 |                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
164ac                 |                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
164ac                 | .pwr_loop
164ac     04 05 D0 FE |                 loc     ptra, #set_port_feat            ' Power on ports
164b0     01 11 5C FC |                 wrword  #HUB_PORT_POWER, ptra[wValue]
164b4     02 77 57 FC |                 wrword  htmp3, ptra[wIndex]
164b8     A0 02 A0 FD |                 call    #control_write
164bc     FB 77 6F FB |                 djnz    htmp3, #.pwr_loop
164c0                 | 
164c0     B1 99 02 F6 |                 mov     hctwait, _500ms_
164c4     B0 99 02 F1 |                 add     hctwait, _100ms_
164c8     EF 02 A0 FD |                 call    #poll_waitx
164cc                 | 
164cc     09 74 07 F6 |                 mov     htmp2, #HUB_READY               ' Hub ready
164d0     00 00 90 FD |                 jmp     #.notify_client
164d4                 | 
164d4                 | .notify_client
164d4     6A 5F 66 F9 |                 altsb   hdev_port, #hdev_type
164d8     BA 01 C0 F8 |                 setbyte htmp2                           ' Save device ready
164dc                 |                 debug(uhex_long(hdev_type,hdev_type+1))
164dc                 |         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
164dc     2D 00 64 FD |                 ret
164e0                 | 
164e0                 | '------------------------------------------------------------------------------
164e0                 | ' Initialize the keyboard/mouse data area to start-up values.
164e0                 | '------------------------------------------------------------------------------
164e0                 | ' On entry:
164e0                 | ' On exit:
164e0                 | '------------------------------------------------------------------------------
164e0                 | init_kbdm_data
164e0     00 F2 06 F6 |                 mov     hkbd_ep_addr, #0
164e4     00 F8 06 F6 |                 mov     hdev_ep_addr, #0
164e8                 | 
164e8     2C F1 03 F6 |                 mov     ptra, cache_start_p         ' Clear cached data buffers
164ec     2D ED 03 F6 |                 mov     pa, cache_end_p
164f0                 | .loop
164f0     61 01 4C FC |                 wrbyte  #0, ptra++
164f4     F6 F1 1B F2 |                 cmp     ptra, pa                wcz
164f8     F4 FF 9F CD |         if_b    jmp     #.loop
164fc                 |         
164fc                 |         if EMUPAD_MAX_PLAYER > 0
164fc                 |         end
164fc                 | 
164fc                 | 
164fc     2F ED 07 F6 |                 mov     pa, #hdev_init_start        ' Clear device data registers
16500                 | .regloop
16500     00 EC 8F F9 |                 altd    pa
16504     00 00 04 F6 |                 mov     0-0, #0
16508     01 EC 07 F1 |                 add     pa, #1
1650c     47 ED 0F F2 |                 cmp     pa, #hdev_init_end      wz
16510     EC FF 9F 5D |         if_nz   jmp     #.regloop
16514                 | 
16514     E1 E1 61 FF 
16518     C3 61 06 F6 |                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
1651c     30 63 02 F6 |                 mov     hdev_next_datax + 1,hdev_next_datax
16520     C3 64 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0
16524     C3 64 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1
16528                 | 
16528     C3 68 06 06 |         _ret_   mov     hub_next_datax, #PID_DATA0
1652c                 | 
1652c                 | '------------------------------------------------------------------------------
1652c                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
1652c                 | ' function.
1652c                 | '------------------------------------------------------------------------------
1652c                 | ' On entry:
1652c                 | '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
1652c                 | '   hpar2 - index number of the target interface.
1652c                 | ' On exit:
1652c                 | '------------------------------------------------------------------------------
1652c                 | hset_idle
1652c     A8 99 02 F6 |                 mov     hctwait, _2ms_
16530     EF 02 A0 FD |                 call    #poll_waitx
16534     5C 04 D0 FE |                 loc     ptra, #set_idle
16538     01 8D 57 FC |                 wrword  hpar1, ptra[wValue]
1653c     02 8F 57 FC |                 wrword  hpar2, ptra[wIndex]
16540     A0 02 80 FD |                 jmp     #control_write
16544                 | 
16544                 | '------------------------------------------------------------------------------
16544                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
16544                 | ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
16544                 | '------------------------------------------------------------------------------
16544                 | ' On entry:
16544                 | '   ep_addr_pid - device address and enpoint for the request.
16544                 | ' On exit:
16544                 | '   retval - transaction result.
16544                 | '------------------------------------------------------------------------------
16544                 | hset_kbdled_report
16544     37 71 E3 F8 |                 getbyte htmp, kb_intf_num, #0
16548     50 04 D0 FE |                 loc     ptra, #set_report
1654c     01 00 80 FF 
16550     01 01 5C FC |                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
16554     02 71 57 FC |                 wrword  htmp, ptra[wIndex]
16558     03 03 5C FC |                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
1655c     29 EF 03 F6 |                 mov     pb, urx_buff_p
16560     F7 77 42 FC |                 wrbyte  kb_led_states, pb
16564     A0 02 80 FD |                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
16568                 | 
16568                 | '------------------------------------------------------------------------------
16568                 | ' Execute an IN interrupt transaction to poll for keyboard activity.
16568                 | '------------------------------------------------------------------------------
16568                 | ' On entry:
16568                 | ' On exit:
16568                 | '------------------------------------------------------------------------------
16568                 | hget_kbd_in_report
16568     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
1656c     29 8F 03 F6 |                 mov     hpar2, urx_buff_p
16570     32 91 E3 F8 |                 getbyte hpar3, kbm_next_datax, #0
16574     39 91 2B F9 |                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
16578     CF 02 A0 FD |                 call    #do_int_in
1657c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
16580     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
16584                 | 
16584     00 90 0F F2 |                 cmp     hpar3, #0               wz
16588     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
1658c                 | 
1658c     32 71 E3 F8 |                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
16590     C3 70 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
16594     4B 64 C6 A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
16598     C3 64 C6 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
1659c                 | 
1659c     C8 75 02 F6 |                 mov     kb_max_index, hpar3             ' Save actual bytes read
165a0     18 00 B0 FD |                 call    #hkbd_compare
165a4                 |         if EMUPAD_MAX_PLAYER > 0
165a4                 |         end
165a4                 | 
165a4                 | .led_check
165a4     3B 71 03 F6 |                 mov     htmp, kb_led_states
165a8     B8 F7 0A F2 |                 cmp     hkbd_ledstates, htmp    wz
165ac     2D 00 64 AD |         if_z    ret                                     ' No toggle key indicator changes, so we're done
165b0     7B 77 02 F6 |                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
165b4     78 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ctrl_ep
165b8     88 FF 9F FD |                 jmp     #hset_kbdled_report             ' Set report and ignore errors
165bc                 | 
165bc                 | '------------------------------------------------------------------------------
165bc                 | ' Compare current and previous keyboard data buffers for keypress changes.
165bc                 | '------------------------------------------------------------------------------
165bc                 | hkbd_compare
165bc     29 F1 03 F6 |                 mov     ptra, urx_buff_p
165c0     8C 0B F0 FE |                 loc     ptrb, #hkbd_report
165c4     61 73 07 FB |                 rdlong  htmp1, ptra++
165c8     E1 75 07 FB |                 rdlong  htmp2, ptrb++
165cc     BA 73 0B F2 |                 cmp     htmp1, htmp2    wz
165d0     61 73 07 FB |                 rdlong  htmp1, ptra++
165d4     E1 75 07 FB |                 rdlong  htmp2, ptrb++
165d8     BA 73 0B A2 |         if_z    cmp     htmp1, htmp2    wz
165dc     2D 00 64 AD |         if_z    ret
165e0                 | 
165e0     6C 0B D0 FE |                 loc     ptra, #hkbd_report
165e4                 | 
165e4                 |                 ' Handle modifiers
165e4     29 8F C3 FA |                 rdbyte  hpar2, urx_buff_p
165e8     00 87 C7 FA |                 rdbyte  hr1, ptra
165ec     C7 87 43 F9 |                 rolword hr1,hpar2,#0
165f0     63 86 63 FD |                 mergew  hr1
165f4     08 EC 07 F6 |                 mov     pa,#8
165f8                 | .modloop
165f8     6A 86 7B FD |                 rczr    hr1     wcz ' New value in C, old value in Z
165fc     E8 8C 07 F6 |                 mov     hpar1,#$E8
16600     F6 8D 83 F1 |                 sub     hpar1,pa
16604     A0 00 B0 6D |       if_c_ne_z call    #hkbd_translate
16608     FB ED 6F FB |                 djnz    pa,#.modloop
1660c                 | 
1660c     6F E0 75 FD | .release        modc    _set    wc
16610                 |                 'alts    hdev_port, #hid_report_p
16610                 |                 'mov     ptra, hid_report_p
16610     02 F0 07 F1 |                 add     ptra, #2
16614     06 EC 07 F6 |                 mov     pa, #6
16618     61 8D CF FA | .rl1            rdbyte  hpar1, ptra++   wz
1661c     20 00 90 AD |         if_z    jmp     #.rl3
16620     29 F3 03 F6 |                 mov     ptrb, urx_buff_p
16624     02 F2 07 F1 |                 add     ptrb, #2
16628     06 EE 07 F6 |                 mov     pb, #6
1662c     E1 71 C7 FA | .rl2            rdbyte  htmp, ptrb++
16630     B8 8D 0B F2 |                 cmp     hpar1, htmp     wz
16634     08 00 90 AD |         if_z    jmp     #.rl3
16638     FC EF 6F FB |                 djnz    pb, #.rl2
1663c     68 00 B0 FD |                 call    #hkbd_translate
16640     F5 ED 6F FB | .rl3            djnz    pa, #.rl1
16644                 | 
16644     00 90 07 F6 |                 mov     hpar3, #0
16648     1F 90 27 F4 |                 bith    hpar3, #31
1664c                 | 
1664c     6F 00 74 FD | .press          modc    _clr    wc
16650     29 F1 03 F6 |                 mov     ptra, urx_buff_p
16654     02 F0 07 F1 |                 add     ptra, #2
16658     06 EC 07 F6 |                 mov     pa, #6
1665c     61 8D CF FA | .pl1            rdbyte  hpar1, ptra++   wz
16660     20 00 90 AD |         if_z    jmp     #.pl3
16664     E8 0A F0 FE |                 loc     ptrb, #hkbd_report
16668     02 F2 07 F1 |                 add     ptrb, #2
1666c     06 EE 07 F6 |                 mov     pb, #6
16670     E1 71 C7 FA | .pl2            rdbyte  htmp, ptrb++
16674     B8 8D 0B F2 |                 cmp     hpar1, htmp     wz
16678     08 00 90 AD |         if_z    jmp     #.pl3
1667c     FC EF 6F FB |                 djnz    pb, #.pl2
16680     24 00 B0 FD |                 call    #hkbd_translate
16684     F5 ED 6F FB | .pl3            djnz    pa, #.pl1
16688                 | 
16688     29 F1 03 F6 | .copy           mov     ptra, urx_buff_p
1668c     C0 0A F0 FE |                 loc     ptrb, #hkbd_report
16690     28 02 64 FD |                 setq #1
16694     61 73 07 FB |                 rdlong  htmp1, ptra++
16698     28 02 64 FD |                 setq #1
1669c     E1 73 67 FC |                 wrlong  htmp1, ptrb++
166a0     E1 F7 46 FC |                 wrbyte  hkbd_ledstates,ptrb++
166a4                 | 
166a4     2D 00 64 FD |                 ret
166a8                 | 
166a8                 | '------------------------------------------------------------------------------
166a8                 | ' Translate keyboard scancode to ASCII
166a8                 | '------------------------------------------------------------------------------
166a8                 | ' On entry:
166a8                 | '   hpar1 - scancode
166a8                 | '   hpar2 - key modifiers state
166a8                 | '       c - pressed (0) or released (1) flag
166a8                 | ' On exit:
166a8                 | '   hpar1 - bit     31 = 0 pressed, 1 released
166a8                 | '               30..17 = unused
166a8                 | '                   18 = scroll-lock state 
166a8                 | '                   17 = caps-lock state
166a8                 | '                   16 = num-lock state 
166a8                 | '                15..8 = key modifiers state
166a8                 | '                 7..0 = scancode
166a8                 | '------------------------------------------------------------------------------
166a8                 | hkbd_translate
166a8     39 8C 0F F2 |                 cmp     hpar1, #KEY_CAPSLOCK    wz
166ac     01 F6 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
166b0     53 8C 0F F2 |                 cmp     hpar1, #KEY_NUMLOCK     wz
166b4     00 F6 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
166b8     47 8C 0F F2 |                 cmp     hpar1, #KEY_SCROLLLOCK  wz
166bc     02 F6 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
166c0                 | 
166c0                 |         if EMUPAD_MAX_PLAYER > 0
166c0                 | 
166c0                 |         if EMUPAD_BT0_BIT >= 0
166c0                 |         end
166c0                 |         if EMUPAD_BT1_BIT >= 0
166c0                 |         end
166c0                 |         if EMUPAD_BT2_BIT >= 0
166c0                 |         end
166c0                 |         if EMUPAD_BT3_BIT >= 0
166c0                 |         end
166c0                 |         if EMUPAD_BT4_BIT >= 0
166c0                 |         end
166c0                 |         if EMUPAD_BT5_BIT >= 0
166c0                 |         end
166c0                 |         if EMUPAD_BT6_BIT >= 0
166c0                 |         end
166c0                 |         if EMUPAD_BT7_BIT >= 0
166c0                 |         end
166c0                 |         if EMUPAD_BT8_BIT >= 0
166c0                 |         end
166c0                 |         if EMUPAD_BT9_BIT >= 0
166c0                 |         end
166c0                 | 
166c0                 |         end
166c0     C7 8D CB F8 |                 setbyte hpar1, hpar2, #1
166c4     7B 8D D3 F8 |                 setbyte hpar1, hkbd_ledstates,#2
166c8     1F 8C 47 F4 |                 bitc    hpar1, #31
166cc                 |         if KEYQUEUE_SIZE > 0
166cc     FC 02 B0 FE |                 loc pb,#keyq_head
166d0     F7 71 E3 FA |                 rdword htmp,pb
166d4     B8 73 EB F8 |                 getbyte htmp1,htmp,#1 ' tail
166d8     B8 71 E3 F8 |                 getbyte htmp,htmp,#0 ' head
166dc     B8 75 03 F6 |                 mov htmp2,htmp
166e0     04 74 07 FA |                 mul htmp2,#4
166e4     F7 75 03 F1 |                 add htmp2,pb
166e8     02 74 07 F1 |                 add htmp2,#2
166ec     1F 70 07 F7 |                 incmod htmp,#KEYQUEUE_SIZE - 1
166f0     B8 73 0B F2 |                 cmp htmp1,htmp wz ' check buffer overflow
166f4     BA 8D 63 5C |         if_nz   wrlong hpar1,htmp2
166f8     F7 71 43 5C |         if_nz   wrbyte htmp,pb
166fc                 |         end
166fc     2D 00 7C FD |                 ret wcz
16700                 | 
16700                 | if HAVE_MOUSE
16700                 | '------------------------------------------------------------------------------
16700                 | ' Execute an IN interrupt transaction to poll for mouse activity.
16700                 | '------------------------------------------------------------------------------
16700                 | ' On entry:
16700                 | ' On exit:
16700                 | '------------------------------------------------------------------------------
16700                 | hget_mouse_in_report
16700                 | 
16700                 |         'debug(uhex_byte_array(urx_buff_p,hpar3))
16700                 | 
16700                 |         if MOUSE_FULL_PROTOCOL
16700                 |         else
16700                 |         end
16700                 | 
16700                 |         if MOUSE_FULL_PROTOCOL
16700                 |         else
16700                 |                 { ' Currently not used
16700                 |                 '}
16700                 |         end
16700                 | 
16700                 |         if MOUSE_FULL_PROTOCOL
16700                 |         else
16700                 |         end
16700                 | 
16700                 |         if MOUSE_FULL_PROTOCOL
16700                 |         else
16700                 |         end
16700                 |                 
16700                 |         if MOUSE_FULL_PROTOCOL
16700                 |         else    
16700                 |         end
16700                 | end
16700                 | 
16700                 | '------------------------------------------------------------------------------
16700                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
16700                 | '------------------------------------------------------------------------------
16700                 | ' On entry:
16700                 | ' On exit:
16700                 | '------------------------------------------------------------------------------
16700                 | if _HAVE_GAMEPAD
16700                 | hget_gp_in_report
16700                 | 
16700                 |                 ' FALL THROUGH !!!!
16700                 | end
16700                 | if _HAVE_GAMEPAD || MOUSE_FULL_PROTOCOL
16700                 | '------------------------------------------------------------------------------
16700                 | ' Decode controller report
16700                 | '------------------------------------------------------------------------------
16700                 | hid_decode
16700                 |         if _HAVE_GAMEPAD
16700                 |         end
16700                 |                 
16700                 | 
16700                 | '------------------------------------------------------------------------------
16700                 | ' Handle HID controller (or mouse now
16700                 | ' On entry:
16700                 | '   ptrb - controller report
16700                 | '------------------------------------------------------------------------------
16700                 | hpad_hid
16700                 | 
16700                 | .next
16700                 | .skip
16700                 | .axes
16700                 | .l1
16700                 | .hats
16700                 | .buttons
16700                 | .report_id
16700                 | .usage_page
16700                 | .usage
16700                 | .usage_axis
16700                 | .pushpop
16700                 | 
16700                 | '------------------------------------------------------------------------------
16700                 | ' Read bits from report data buffer
16700                 | '------------------------------------------------------------------------------
16700                 | ' On entry:
16700                 | '   PTRB - report buffer
16700                 | '   hpar1 - start bit
16700                 | '   hpar2 - number of bits
16700                 | ' On exit:
16700                 | '   retval - bits
16700                 | '------------------------------------------------------------------------------
16700                 | hpad_getbits
16700                 | .l1
16700                 | 
16700                 | '------------------------------------------------------------------------------
16700                 | ' Normalize value to signed word (-32768 / 32767)
16700                 | '------------------------------------------------------------------------------
16700                 | ' On entry:
16700                 | '   retval - value to normalize
16700                 | '   hidr_lminmax - min (word 1) max (word 0) value range
16700                 | '   - or -
16700                 | '   hidr_pminmax - min (word 1) max (word 0) value range
16700                 | '   hidr_size - value bits length
16700                 | ' On exit:
16700                 | '   retval - normalized value
16700                 | '------------------------------------------------------------------------------
16700                 | hpad_normalize
16700                 | end
16700                 | 
16700                 | if _HAVE_GAMEPAD
16700                 | '------------------------------------------------------------------------------
16700                 | ' Handle XInput controller
16700                 | ' On entry:
16700                 | '   ptrb - controller report
16700                 | '------------------------------------------------------------------------------
16700                 | '   Default implementation translates the report to a pseudo-defacto hid
16700                 | '   standard and jumps to hpad_translate for actions.
16700                 | '   Implementors may take specific actions for this kind of controller.
16700                 | '------------------------------------------------------------------------------
16700                 | hpad_xinput
16700                 | 
16700                 | '------------------------------------------------------------------------------
16700                 | ' Handle PS3 controller
16700                 | ' On entry:
16700                 | '   ptrb - controller report
16700                 | '------------------------------------------------------------------------------
16700                 | '   Default implementation translates the report to a pseudo-defacto hid
16700                 | '   standard and jumps to hpad_translate for actions.
16700                 | '   Implementors may take specific actions for this kind of controller.
16700                 | '------------------------------------------------------------------------------
16700                 | hpad_ps3
16700                 | 
16700                 | 
16700                 | '------------------------------------------------------------------------------
16700                 | ' Perform controller actions
16700                 | ' On entry:
16700                 | '    hidr_id        report id
16700                 | '    hidr_axis      axis value (signed word, 2 axes per long)
16700                 | '                      X = hidr_axis+0, #0
16700                 | '                      Y = hidr_axis+0, #1
16700                 | '                      Z = hidr_axis+1, #0
16700                 | '                     RX = hidr_axis+1, #1
16700                 | '                     RY = hidr_axis+2, #0
16700                 | '                     RZ = hidr_axis+2, #1
16700                 | '                     Sl = hidr_axis+3, #0
16700                 | '                     Wh = hidr_axis+3, #1
16700                 | '    hidr_buttons   buttons state (bits 0 to 31)
16700                 | '    hidr_hats      hats state (byte 0, 1, 2, 3)
16700                 | '
16700                 | '                     -------3 -------2 -------1 -------0 byte
16700                 | '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
16700                 | '    hidr_flags       xxxxxxxx_wsrrrzyx_hhhhaaaa_bbbbbbbb
16700                 | '                              hlzyx||| |||||||| ++++++++ n. buttons
16700                 | '                              |||||||| ||||++++--------- n. axes
16700                 | '                              |||||||| ++++------------- n. hats
16700                 | '                              ++++++++------------------ valid axes
16700                 | '------------------------------------------------------------------------------
16700                 | hpad_translate
16700                 | 
16700                 | 
16700                 |         if HAVE_HIDPAD
16700                 |         end
16700                 | 
16700                 | 
16700                 |         if EMUPAD_MAX_PLAYER > 0
16700                 | .emupad_no_hat
16700                 |         if EMUPAD_BT0_BIT >= 0
16700                 |         end
16700                 |         if EMUPAD_BT1_BIT >= 0
16700                 |         end
16700                 |         if EMUPAD_BT2_BIT >= 0
16700                 |         end
16700                 |         if EMUPAD_BT3_BIT >= 0
16700                 |         end
16700                 |         if EMUPAD_BT4_BIT >= 0
16700                 |         end
16700                 |         if EMUPAD_BT5_BIT >= 0
16700                 |         end
16700                 |         if EMUPAD_BT6_BIT >= 0
16700                 |         end
16700                 |         if EMUPAD_BT7_BIT >= 0
16700                 |         end
16700                 |         if EMUPAD_BT8_BIT >= 0
16700                 |         end
16700                 |         if EMUPAD_BT9_BIT >= 0
16700                 |         end
16700                 | .emupad_slot_over
16700                 |         end
16700                 | 
16700                 |         if 0
16700                 |                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
16700                 | 
16700                 |                 debug("    btn: ", ubin_long_(hidr_buttons))
16700                 | 
16700                 |         end
16700                 | end
16700                 | 
16700                 | if EMUPAD_MAX_PLAYER > 0
16700                 | '------------------------------------------------------------------------------
16700                 | ' Clear EmuPad state
16700                 | '------------------------------------------------------------------------------
16700                 | emupad_reset
16700                 | 
16700                 | '------------------------------------------------------------------------------
16700                 | ' Get EmuPad Player number for current device (into retval)
16700                 | ' Z flag is also set if current device is valid
16700                 | ' (Value may be larger than EMUPAD_MAX_PLAYER !)
16700                 | '------------------------------------------------------------------------------
16700                 | emupad_getnum
16700                 | .loop
16700                 | '------------------------------------------------------------------------------
16700                 | ' Handle disconnect of device (call after emupad_getnum returns with Z set)
16700                 | '------------------------------------------------------------------------------
16700                 | emupad_discon
16700                 | .loop         
16700                 |         
16700                 |         ' FALL THROUGH!!!
16700                 | 
16700                 | '------------------------------------------------------------------------------
16700                 | ' Update EmuPad reports (all of them...)
16700                 | '------------------------------------------------------------------------------
16700                 | emupad_write_reports
16700                 | .devloop
16700                 | 
16700                 | end
16700                 | 
16700                 | 
16700                 | '------------------------------------------------------------------------------
16700                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
16700                 | '------------------------------------------------------------------------------
16700                 | ' On entry:
16700                 | ' On exit:
16700                 | '------------------------------------------------------------------------------
16700                 | hget_hub_status
16700     77 BD 02 F6 |                 mov     ep_addr_pid, hhub_ep_addr
16704     29 8F 03 F6 |                 mov     hpar2, urx_buff_p
16708     34 91 23 F9 |                 setword hpar3, hub_next_datax, #0
1670c     01 90 2F F9 |                 setword hpar3, #1, #1
16710     CF 02 A0 FD |                 call    #do_int_in
16714     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
16718     0C 00 90 AD |         if_z    jmp     #.data
1671c     5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
16720     1A 01 80 5D |         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
16724     2D 00 64 FD |                 ret
16728                 | .data
16728     00 90 0F F2 |                 cmp     hpar3, #0               wz
1672c     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
16730                 | 
16730     C3 68 0E F2 |                 cmp     hub_next_datax, #PID_DATA0  wz
16734     4B 68 06 A6 |         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
16738     C3 68 06 56 |         if_nz   mov     hub_next_datax, #PID_DATA0
1673c     29 6B 02 FB |                 rdlong  hub_status_chg, urx_buff_p
16740                 |                 debug(ubin_long(hub_status_chg))
16740                 | 
16740     01 5E 06 F6 |                 mov     hdev_port, #1
16744                 | .loop
16744     2F 6B 0A F4 |                 testb   hub_status_chg, hdev_port wz
16748     0C 00 B0 AD |         if_x1   call    #hub_port_handler
1674c     07 5E 1E F7 |                 incmod  hdev_port, #7           wcz
16750     F0 FF 9F 3D |         if_nc   jmp     #.loop
16754     2D 00 64 FD |                 ret
16758                 | 
16758                 | hub_port_handler
16758     76 BD 02 F6 |                 mov     ep_addr_pid, hhub_ctrl_ep
1675c     64 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
16760     29 EF 03 F6 |                 mov     pb, urx_buff_p
16764     02 5F 56 FC |                 wrword  hdev_port, ptra[wIndex]
16768     55 02 A0 FD |                 call    #control_read
1676c     29 6D 02 FB |                 rdlong  hub_port_status, urx_buff_p
16770                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
16770                 | 
16770     10 6C 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
16774     50 01 90 5D |         if_x0   jmp     #.other
16778     40 02 D0 FE |                 loc     ptra, #clr_port_feat
1677c     01 21 5C FC |                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
16780     02 5F 56 FC |                 wrword  hdev_port, ptra[wIndex]
16784     A0 02 A0 FD |                 call    #control_write
16788     00 6C 0E F4 |                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
1678c     7C 01 90 5D |         if_x0   jmp     #.disconnect
16790     B0 99 02 F6 |                 mov     hctwait, _100ms_
16794     EF 02 A0 FD |                 call    #poll_waitx
16798                 | 
16798     18 02 D0 FE |                 loc     ptra, #set_port_feat            ' reset port
1679c     01 09 5C FC |                 wrword  #HUB_PORT_RESET, ptra[wValue]
167a0     02 5F 56 FC |                 wrword  hdev_port, ptra[wIndex]
167a4     A0 02 A0 FD |                 call    #control_write
167a8                 | 
167a8     02 76 07 F6 |                 mov     htmp3, #2
167ac                 | .wait_reset
167ac     AC 99 02 F6 |                 mov     hctwait, _8ms_
167b0     EF 02 A0 FD |                 call    #poll_waitx
167b4     0C 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
167b8     29 EF 03 F6 |                 mov     pb, urx_buff_p
167bc     02 5F 56 FC |                 wrword  hdev_port, ptra[wIndex]
167c0     55 02 A0 FD |                 call    #control_read
167c4     29 6D 02 FB |                 rdlong  hub_port_status, urx_buff_p
167c8     14 6C 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
167cc     F7 77 6F 5B |         if_x0   djnz    htmp3, #.wait_reset
167d0                 | 
167d0     E8 01 D0 FE |                 loc     ptra, #clr_port_feat
167d4     01 29 5C FC |                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
167d8     02 5F 56 FC |                 wrword  hdev_port, ptra[wIndex]
167dc     A0 02 A0 FD |                 call    #control_write
167e0                 | 
167e0     24 70 07 F6 |                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
167e4                 | .wait_recover
167e4     A7 99 02 F6 |                 mov     hctwait, _1ms_
167e8     EF 02 A0 FD |                 call    #poll_waitx
167ec     FD 71 6F FB |                 djnz    htmp,#.wait_recover
167f0                 | 
167f0     09 6C 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
167f4     07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
167f8     0E 68 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
167fc                 | 
167fc     00 08 00 FF 
16800     00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
16804     64 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
16808     03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
1680c     2A EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
16810     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
16814     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
16818     20 01 90 5D |         if_nz   jmp     #.done
1681c                 | .get_dev_desc
1681c     2A ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
16820     07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
16824     F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
16828     58 01 D0 FE |                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
1682c     2F 71 03 F6 |                 mov     htmp, hdev_port             ' Address is hub port number
16830     01 71 57 FC |                 wrword  htmp, ptra[wValue]
16834     A0 02 A0 FD |                 call    #control_write                  ' Execute SetAddress()
16838     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
1683c     FC 00 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
16840     AC 99 02 F6 |                 mov     hctwait, _8ms_
16844     EF 02 A0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
16848     2F BD 02 F6 |                 mov     ep_addr_pid, hdev_port
1684c     08 BC 66 F0 |                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
16850     BE 00 A0 FD |                 call    #calc_crc5
16854     14 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
16858     2A EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
1685c     F7 AD C2 FA |                 rdbyte  total_data, pb
16860     03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
16864     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
16868     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
1686c     CC 00 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
16870     5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
16874     2A F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
16878                 |                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
16878     9F 99 02 F6 |                 mov     hctwait, _500us_
1687c     EF 02 A0 FD |                 call    #poll_waitx
16880     F0 00 D0 FE |                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
16884     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
16888     2B EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
1688c     55 02 A0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
16890     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
16894     A4 00 90 5D |         if_nz   jmp     #.done
16898     2B F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
1689c     F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
168a0     61 85 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
168a4     61 87 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
168a8     00 71 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
168ac     09 84 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
168b0     02 86 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
168b4     56 71 1B A2 |         if_z    cmp     htmp, total_data        wcz
168b8     0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
168bc     7C 00 90 CD |         if_b    jmp     #.done
168c0     10 F9 BF FD |                 call    #hparse_con_desc
168c4     74 00 90 FD |                 jmp     #.done
168c8                 | 
168c8                 | .other
168c8     14 6C 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz
168cc     01 29 5C AC |         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
168d0     28 00 90 AD |         if_x1   jmp     #.reset_feature
168d4     11 6C 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
168d8     01 23 5C AC |         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
168dc     1C 00 90 AD |         if_x1   jmp     #.reset_feature
168e0     12 6C 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
168e4     01 25 5C AC |         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
168e8     10 00 90 AD |         if_x1   jmp     #.reset_feature
168ec     13 6C 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
168f0     01 27 5C AC |         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
168f4     04 00 90 AD |         if_x1   jmp     #.reset_feature
168f8     40 00 90 FD |                 jmp     #.done
168fc                 | .reset_feature
168fc     BC 00 D0 FE |                 loc     ptra, #clr_port_feat
16900     02 5F 56 FC |                 wrword  hdev_port, ptra[wIndex]
16904     A0 02 A0 FD |                 call    #control_write
16908     30 00 90 FD |                 jmp     #.done
1690c                 | .disconnect
1690c                 | 
1690c     6A 5F 6E F9 |                 altgb   hdev_port, #hdev_type
16910     00 70 E3 F8 |                 getbyte htmp
16914     03 70 0F F2 |                 cmp     htmp,#KB_READY wz
16918     05 70 0F 52 |         if_nz   cmp     htmp,#KBM_READY wz
1691c     00 F2 06 A6 |         if_z    mov     hkbd_ep_addr, #0
16920     00 F0 06 A6 |         if_z    mov     hkbd_ctrl_ep, #0
16924     00 76 06 A6 |         if_z    mov     kb_led_states, #0
16928     3B F7 02 A6 |         if_z    mov     hkbd_ledstates, kb_led_states
1692c                 |         if EMUPAD_MAX_PLAYER > 0
1692c                 |         end
1692c                 |         if HAVE_MOUSE
1692c                 |         end
1692c                 |         if HAVE_HIDPAD
1692c                 |         end
1692c                 | 
1692c     6A 5F 66 F9 |                 altsb   hdev_port, #hdev_type
16930     00 00 C4 F8 |                 setbyte #0
16934     7C 5F 8E F9 |                 altd    hdev_port, #hdev_ep_addr
16938     00 00 04 F6 |                 mov     0-0, #0
1693c                 | 
1693c                 | .done
1693c     0E 68 1F F4 |                 bitl    _usb_h_ls_nco_, #14     wcz
16940     07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
16944     23 6D 13 CC |         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
16948     40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
1694c     A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
16950     A3 9B 02 F6 |                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
16954                 | 
16954     6C 00 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
16958     29 EF 03 F6 |                 mov     pb, urx_buff_p
1695c     02 5F 56 FC |                 wrword  hdev_port, ptra[wIndex]
16960     55 02 A0 FD |                 call    #control_read
16964     00 6D 06 FB |                 rdlong  hub_port_status, ptra
16968                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
16968     2D 00 64 FD |                 ret
1696c                 | 
1696c                 | '------------------------------------------------------------------------------
1696c                 | ' Partially populated SETUP packets
1696c                 | '------------------------------------------------------------------------------
1696c     80          | get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
1696d     06          |                 byte    REQ_GET_DESC
1696e     00 01       |                 word    TYPE_DEVICE << 8
16970     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
16972     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
16974     80          | get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
16975     06          |                 byte    REQ_GET_DESC
16976     00 02       |                 word    TYPE_CONFIG << 8
16978     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
1697a     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
1697c     00          | set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
1697d     09          |                 byte    REQ_SET_CONFIG
1697e     00 00       |                 word    0       ' Configuration value
16980     00 00       |                 word    0       ' Zero
16982     00 00       |                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
16984     00          | set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
16985     05          |                 byte    REQ_SET_ADDR
16986     00 00       |                 word    0       ' Zero
16988     00 00       |                 word    0       ' Zero
1698a     00 00       |                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
1698c                 | '------------------------------------------------------------------------------
1698c                 | ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
1698c                 | ' wValue field dictates which protocol should be used.
1698c                 | '
1698c                 | ' When initialized, all devices default to report protocol. However the host
1698c                 | ' should not make any assumptions about the device state and should set the
1698c                 | ' desired protocol whenever initializing a device.
1698c                 | '------------------------------------------------------------------------------
1698c     21          | set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
1698d     0B          |                 byte    HID_SET_PROTO
1698e     00 00       |                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
16990                 |                                                 ' (HID 1.11 Section 7.2.6).
16990     00 00       |                 word    0               ' Interface index number.
16992     00 00       |                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
16994                 | '------------------------------------------------------------------------------
16994     21          | set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
16995     0A          |                 byte    HID_SET_IDLE
16996     00 00       |                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
16998                 |                                         ' reporting until a change is detected in the report data
16998                 | 
16998                 |                                         ' (HID 1.11 Section 7.2.4).
16998     00 00       |                 word    0       ' Interface index number.
1699a     00 00       |                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
1699c     21          | set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
1699d     09          |                 byte    HID_SET_REPORT
1699e     00 00       |                 word    0       ' Byte1 = report type, byte0 = ReportID.
169a0                 |                                         ' (HID 1.11 Section 7.2.2).
169a0     00 00       |                 word    0       ' Interface index number.
169a2     00 00       |                 word    0       ' Size of the report, in bytes.
169a4     81          | get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
169a5     06          |                 byte    REQ_GET_DESC
169a6     00 22       |                 word    TYPE_REPORT << 8
169a8     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
169aa     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
169ac                 | '------------------------------------------------------------------------------
169ac     A0          | get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
169ad     06          |                 byte    REQ_GET_DESC
169ae     00 29       |                 word    TYPE_HUB << 8
169b0     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
169b2     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
169b4     23          | set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
169b5     03          |                 byte    REQ_SET_FEATURE
169b6     00 00       |                 word    0       ' port power
169b8     01 00       |                 word    1       ' Port index number (1+)
169ba     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
169bc     23          | clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
169bd     01          |                 byte    REQ_CLEAR_FEATURE
169be     00 00       |                 word    0       ' port power
169c0     01 00       |                 word    1       ' Port index number (1+)
169c2     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
169c4     A3          | get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
169c5     00          |                 byte    REQ_GET_STATUS
169c6     00 00       |                 word    0
169c8     01 00       |                 word    1       ' Port index number (1+)
169ca     04 00       |                 word    4       ' Number of bytes to transfer if there is a data stage
169cc                 | '------------------------------------------------------------------------------
169cc                 | if _HAVE_GAMEPAD
169cc                 | ps3_enable_cmd  byte    $42, $0C, $00, $00
169cc                 | ps3_command_buff
169cc                 |                 byte    $00, $00, $00, $00, $00
169cc                 |                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
169cc                 |                 byte    $FF, $27, $10, $00, $32
169cc                 |                 byte    $FF, $27, $10, $00, $32
169cc                 |                 byte    $FF, $27, $10, $00, $32
169cc                 |                 byte    $FF, $27, $10, $00, $32
169cc                 |                 byte    $00, $00, $00, $00, $00
169cc                 |                 byte    $00, $00, $00, $00, $00
169cc                 |                 byte    $00, $00, $00, $00, $00
169cc                 |                 byte    $00, $00, $00
169cc                 | '------------------------------------------------------------------------------
169cc                 | xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
169cc                 |                                         ' 0x01 All blinking
169cc                 |                                         ' 0x02 1 flashes, then on
169cc                 |                                         ' 0x03 2 flashes, then on
169cc                 |                                         ' 0x04 3 flashes, then on
169cc                 |                                         ' 0x05 4 flashes, then on
169cc                 |                                         ' 0x06 1 on
169cc                 |                                         ' 0x07 2 on
169cc                 |                                         ' 0x08 3 on
169cc                 |                                         ' 0x09 4 on
169cc                 |                                         ' 0x0A Rotating (e.g. 1-2-4-3)
169cc                 |                                         ' 0x0B Blinking*
169cc                 |                                         ' 0x0C Slow blinking*
169cc                 |                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
169cc                 | xinp_rumble_cmd byte    $00, $08, $00
169cc                 |                 byte    $00             ' Left rumble
169cc                 |                 byte    $00             ' Right rumble
169cc                 |                 byte    $00, $00, $00
169cc                 | 
169cc                 | xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
169cc                 |                 '' of certain wired 8bitdo gamepads.
169cc                 |                 byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
169cc                 |                 byte    REQ_GET_DESC
169cc                 |                 word    TYPE_STRING << 8 + 4
169cc                 |                 word    $0409   ' Zero or Language ID (Section 9.6.7)
169cc                 |                 word    2       ' Number of bytes to transfer if there is a data stage
169cc                 | end
169cc                 | alignl
169cc                 | 
169cc                 | if HAVE_MOUSE
169cc                 | mouse_limits long 0[2]
169cc                 | mouse_outptr long 0
169cc                 | end
169cc                 | 
169cc                 | if KEYQUEUE_SIZE > 0
169cc     00          | keyq_head byte 0
169cd     00          | keyq_tail byte 0
169ce     00 00 00 00 
      ...             
16a4a     00 00 00 00 
16a4e     00 00       | keyq_data long 0[KEYQUEUE_SIZE]
16a50                 | alignl
16a50                 | end
16a50                 | 
16a50                 | if EMUPAD_MAX_PLAYER > 0
16a50                 | emupad_rule_buffer
16a50                 | if EMUPAD_BUILTIN_RULES
16a50                 | file "padmap_builtin.dat"
16a50                 | end
16a50                 | byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
16a50                 | '' Default rule directly follows!
16a50                 | byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
16a50                 | end
16a50                 | 
16a50                 | '------------------------------------------------------------------------------
16a50                 | ' The USB data cache area gets zero-filled at every device disconnect
16a50                 | '------------------------------------------------------------------------------
16a50                 | usb_cache_start
16a50                 | 
16a50                 | ' HID descriptor and report buffers
16a50                 | if !!OVERLAP_MEMORY
16a50     00 00 00 00 
      ...             
17148     00 00 00 00 
1714c     00 00 00 00 | hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
17150                 | end
17150     00 00 00 00 
17154     00 00 00 00 | hkbd_report     byte    0[8]
17158     00 00 00 00 | hkbd_led_rep    byte    0
1715c                 | alignl
1715c                 | 
1715c     00 00 00 00 
17160     00 00 00 00 
17164     00 00 00 00 
17168     00 00 00 00 
1716c     00 00 00 00 | hid_stack       long 0[(hidr_end - hidr_state) * 1]
17170                 | 
17170                 | if HAVE_HIDPAD
17170                 | hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
17170                 | end
17170                 | 
17170                 | ' HUB descriptor
17170     00          | hub_descr       byte    0   ' bDescLength
17171     00          |                 byte    0   ' bDescriptorType
17172     00          |                 byte    0   ' bNbrPorts
17173     00 00       |                 word    0   ' wHubCharacteristics
17175     00          |                 byte    0   ' bPwrOn2PwrGood
17176     00          |                 byte    0   ' bHubContrCurrent
17177     00          |                 byte    0   ' DeviceRemoveable
17178     00          |                 byte    0   ' PortPwrCtrlMask
17179                 | 
17179                 | usb_cache_end
17179                 | 
17179                 | if HAVE_MOUSE
17179                 | mouse_xacc      long 0
17179                 | mouse_yacc      long 0
17179                 | mouse_zacc      long 0
17179                 | mouse_bstate    byte 0
17179                 | mouse_lpending  byte 0
17179                 | mouse_rpending  byte 0
17179                 | mouse_mpending  byte 0
17179                 | mouse_lock      byte 0
17179                 |                 byte 0[3] ' padding
17179                 | end
17179                 | 
17179     00 00 00 00 
      ...             
171f1     00 00 00 00 
171f5     00 00 00 00 | urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
171f9     00 00 00 00 
171fd     00 00 00 00 
17201     00 00 00 00 
17205     00 00 00 00 
17209     00 00       | dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
1720b     00 00 00 00 
      ...             
17303     00 00 00 00 
17307     00 00 00 00 | con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
1730b                 | 
1730b     00          | driver_cog      byte    0                       ' Current driver cog + 1
1730c                 | 	alignl
1730c                 | _fs9p_cc_dat_
1730c     18 04 00 00 
17310     00 00 00 00 
17314     00 00 00 00 
17318     00 00 00 00 | 	byte	$18, $04, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
1731c     00 00 00 00 
      ...             
17720     00 00 00 00 
17724     00 00 00 00 | 	byte	$00[1036]
17728                 | 	alignl
17728                 | __system__dat_
17728     00 00 00 00 
1772c     00 00 00 00 | 	byte	$00[8]
17730     03 00 00 00 
17734     00 00 00 00 
17738     00 00 00 00 
1773c     00 00 00 00 | 	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
17740     00 00 00 00 
      ...             
179cc     00 00 00 00 
179d0     00 00 00 00 | 	byte	$00[660]
179d4     00 00 30 01 | 	long	(19 {__system____root_opendir})<<20
179d8     00 00 40 01 | 	long	(20 {__system____root_closedir})<<20
179dc     00 00 50 01 | 	long	(21 {__system____root_readdir})<<20
179e0     00 00 60 01 | 	long	(22 {__system____root_stat})<<20
179e4     00 00 00 00 
179e8     00 00 00 00 
179ec     00 00 00 00 
179f0     00 00 00 00 
179f4     00 00 00 00 
179f8     00 00 00 00 
179fc     00 00 00 00 | 	byte	$00[28]
17a00                 | __methodtable__
17a00     40 D2 00 00 | 	long	@_hostfs_sendrecv
17a04     8C 79 00 00 | 	long	@_fatfs_cc_v_close
17a08     8C 7D 00 00 | 	long	@_fatfs_cc_v_read
17a0c     A0 7E 00 00 | 	long	@_fatfs_cc_v_write
17a10     80 7F 00 00 | 	long	@_fatfs_cc_v_lseek
17a14     08 80 00 00 | 	long	@_fatfs_cc_v_ioctl
17a18     34 81 00 00 | 	long	@_fatfs_cc_v_flush
17a1c     5C 80 00 00 | 	long	@_fatfs_cc_v_open
17a20     F8 78 00 00 | 	long	@_fatfs_cc_v_creat
17a24     C8 79 00 00 | 	long	@_fatfs_cc_v_opendir
17a28     3C 7A 00 00 | 	long	@_fatfs_cc_v_closedir
17a2c     7C 7A 00 00 | 	long	@_fatfs_cc_v_readdir
17a30     9C 7B 00 00 | 	long	@_fatfs_cc_v_stat
17a34     1C 80 00 00 | 	long	@_fatfs_cc_v_mkdir
17a38     3C 80 00 00 | 	long	@_fatfs_cc_v_rmdir
17a3c     2C 80 00 00 | 	long	@_fatfs_cc_v_remove
17a40     4C 80 00 00 | 	long	@_fatfs_cc_v_rename
17a44     64 81 00 00 | 	long	@_fatfs_cc_v_init
17a48     6C 81 00 00 | 	long	@_fatfs_cc_v_deinit
17a4c     B0 F6 00 00 | 	long	@__system____root_opendir
17a50     4C F7 00 00 | 	long	@__system____root_closedir
17a54     C8 F6 00 00 | 	long	@__system____root_readdir
17a58     54 F7 00 00 | 	long	@__system____root_stat
17a5c     74 11 00 00 | 	long	@_libc_a___default_putc
17a60     F8 10 00 00 | 	long	@_libc_a___default_getc
17a64     1C 12 00 00 | 	long	@_libc_a___default_flush
17a68     FC E4 00 00 | 	long	@__system___tx
17a6c     3C E5 00 00 | 	long	@__system___rx
17a70     4C 16 00 00 | 	long	@_libc_a__rxtxioctl_0726
17a74     A4 16 00 00 | 	long	@_libc_a___dummy_flush_0727
17a78                 | __heap_base
17a78     00 00 00 00 
      ...             
191e8     00 00 00 00 
191ec     00 00 00 00 | 	long	0[1502]
191f0                 | objmem
191f0     00 00 00 00 
      ...             
718a8     00 00 00 00 
718ac     00 00 00 00 | 	long	0[90544]
718b0                 | stackspace
718b0     00 00 00 00 | 	long	0[1]
718b4 0d5             | 	org	COG_BSS_START
718b4 0d5             | _var01
718b4 0d5             | 	res	1
718b4 0d6             | _var02
718b4 0d6             | 	res	1
718b4 0d7             | _var03
718b4 0d7             | 	res	1
718b4 0d8             | _var04
718b4 0d8             | 	res	1
718b4 0d9             | _var05
718b4 0d9             | 	res	1
718b4 0da             | _var06
718b4 0da             | 	res	1
718b4 0db             | _var07
718b4 0db             | 	res	1
718b4 0dc             | _var08
718b4 0dc             | 	res	1
718b4 0dd             | _var09
718b4 0dd             | 	res	1
718b4 0de             | _var10
718b4 0de             | 	res	1
718b4 0df             | _var11
718b4 0df             | 	res	1
718b4 0e0             | _var12
718b4 0e0             | 	res	1
718b4 0e1             | arg01
718b4 0e1             | 	res	1
718b4 0e2             | arg02
718b4 0e2             | 	res	1
718b4 0e3             | arg03
718b4 0e3             | 	res	1
718b4 0e4             | arg04
718b4 0e4             | 	res	1
718b4 0e5             | arg05
718b4 0e5             | 	res	1
718b4 0e6             | arg06
718b4 0e6             | 	res	1
718b4 0e7             | arg07
718b4 0e7             | 	res	1
718b4 0e8             | arg08
718b4 0e8             | 	res	1
718b4 0e9             | arg09
718b4 0e9             | 	res	1
718b4 0ea             | arg10
718b4 0ea             | 	res	1
718b4 0eb             | arg11
718b4 0eb             | 	res	1
718b4 0ec             | local01
718b4 0ec             | 	res	1
718b4 0ed             | local02
718b4 0ed             | 	res	1
718b4 0ee             | local03
718b4 0ee             | 	res	1
718b4 0ef             | local04
718b4 0ef             | 	res	1
718b4 0f0             | local05
718b4 0f0             | 	res	1
718b4 0f1             | local06
718b4 0f1             | 	res	1
718b4 0f2             | local07
718b4 0f2             | 	res	1
718b4 0f3             | local08
718b4 0f3             | 	res	1
718b4 0f4             | local09
718b4 0f4             | 	res	1
718b4 0f5             | local10
718b4 0f5             | 	res	1
718b4 0f6             | local11
718b4 0f6             | 	res	1
718b4 0f7             | local12
718b4 0f7             | 	res	1
718b4 0f8             | local13
718b4 0f8             | 	res	1
718b4 0f9             | local14
718b4 0f9             | 	res	1
718b4 0fa             | local15
718b4 0fa             | 	res	1
718b4 0fb             | local16
718b4 0fb             | 	res	1
718b4 0fc             | local17
718b4 0fc             | 	res	1
718b4 0fd             | local18
718b4 0fd             | 	res	1
718b4 0fe             | local19
718b4 0fe             | 	res	1
718b4 0ff             | local20
718b4 0ff             | 	res	1
718b4 100             | local21
718b4 100             | 	res	1
718b4 101             | local22
718b4 101             | 	res	1
718b4 102             | local23
718b4 102             | 	res	1
718b4 103             | local24
718b4 103             | 	res	1
718b4 104             | local25
718b4 104             | 	res	1
718b4 105             | local26
718b4 105             | 	res	1
718b4 106             | local27
718b4 106             | 	res	1
718b4 107             | local28
718b4 107             | 	res	1
718b4 108             | local29
718b4 108             | 	res	1
718b4 109             | local30
718b4 109             | 	res	1
718b4 10a             | local31
718b4 10a             | 	res	1
718b4 10b             | local32
718b4 10b             | 	res	1
718b4 10c             | local33
718b4 10c             | 	res	1
718b4 10d             | local34
718b4 10d             | 	res	1
718b4 10e             | local35
718b4 10e             | 	res	1
718b4 10f             | local36
718b4 10f             | 	res	1
718b4 110             | local37
718b4 110             | 	res	1
718b4 111             | local38
718b4 111             | 	res	1
718b4 112             | muldiva_
718b4 112             | 	res	1
718b4 113             | muldivb_
718b4 113             | 	res	1
718b4 114             | 	fit	480
718b4 114             | 
