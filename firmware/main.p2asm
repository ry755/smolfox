con
	_clkfreq = 160000000
	_clkmode = 16779259
'     _clkfreq = 160_000_000
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 160000000
	long	0 ' clock mode: will default to $10007fb
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##16779256
	waitx	##200000
	mov	pa, ##16779259
	hubset	pa
	wrlong	pa, #24
	wrlong	##160000000, #20
	jmp	#skip_clock_set_
	orgf	128
skip_clock_set_
	call	#_Main
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    mov	fcache_tmpb_,ptrb
    pop	ptrb
    altd	pa,ret_instr_
    mov	 0-0, ret_instr_
    setq	pa
    rdlong	$0, ptrb++
    push	ptrb
    mov ptrb,fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    _ret_ cmp inb,#0
fcache_tmpb_
    long 0
fcache_load_ptr_
    long FCACHE_LOAD_
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret
COUNT_
    long 0
RETADDR_
    long 0
fp
    long 0
pushregs_
    pop  pa
    pop  RETADDR_
    tjz  COUNT_, #pushregs_done_
    altd  COUNT_, #511
    setq #0-0
    wrlong local01, ptra++
pushregs_done_
    setq #2 ' push 3 registers starting at COUNT_
    wrlong COUNT_, ptra++
    mov    fp, ptra
    jmp  pa
 popregs_
    pop    pa
    setq   #2
    rdlong COUNT_, --ptra
    djf    COUNT_, #popregs__ret
    setq   COUNT_
    rdlong local01, --ptra
popregs__ret
    push   RETADDR_
    jmp    pa

divide_
       abs     muldivb_,muldivb_     wcz      'abs(y)
       wrc     itmp2_                         'store sign of y
       abs     muldiva_,muldiva_     wc       'abs(x)
       qdiv    muldiva_, muldivb_             'queue divide
 if_c  xor     itmp2_,#1                      'store sign of x
       getqx   muldivb_                       'get quotient
       getqy   muldiva_                       'get remainder
       negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
       testb   itmp2_,#0             wc       'restore sign, division result
 _ret_ negc    muldivb_,muldivb_     

__heap_ptr
	long	@__heap_base
__methods__
	long	@__methodtable__
itmp1_
	long	0
itmp2_
	long	0
objptr
	long	@objmem
ptr___system__dat__
	long	@__system__dat_
ptr__bus_dat__
	long	@_bus_dat_
ptr__fatfs_cc_dat__
	long	@_fatfs_cc_dat_
ptr__fs9p_cc_dat__
	long	@_fs9p_cc_dat_
ptr__libc_a_dat__
	long	@_libc_a_dat_
ptr__memory_dat__
	long	@_memory_dat_
ptr__p2textdrv_dat__
	long	@_p2textdrv_dat_
ptr__p2videodrv_dat__
	long	@_p2videodrv_dat_
ptr__usbnew_0016_dat__
	long	@_usbnew_0016_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
result2
	long	1
COG_BSS_START
	fit	480
	orgh
hubentry

' 
' PUB Main
_Main
	mov	COUNT_, #1
	call	#pushregs_
'     _mount(@"/sd", c._vfs_open_sdcard())
	mov	local01, ##@LR__2094
' _vfs_open_sdcard()
' {
'     return _vfs_open_sdcardx(61, 60, 59, 58);
	mov	arg01, #61
	mov	arg02, #60
	mov	arg03, #59
	mov	arg04, #58
	call	#_libc_a__vfs_open_sdcardx
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___mount
'     hostfs.GetDiskFromHost
	add	objptr, ##361080
	call	#_hostfs_GetDiskFromHost
	sub	objptr, ##361080
'     cpu.Initialize
	call	#_cpu_Initialize
' 
'     repeat
LR__0001
'         cpu.Execute($FFFFFFFF)
	neg	arg01, #1
	call	#_cpu_Execute
	jmp	#LR__0001
	mov	ptra, fp
	call	#popregs_
_Main_ret
	ret

_libc_a__vfs_open_sdcardx
	mov	COUNT_, #11
	call	#pushregs_
	mov	local03, arg01
	mov	local04, arg02
	mov	local05, arg03
	mov	local06, arg04
	mov	arg01, #40
	call	#__system___gc_alloc_managed
	mov	local07, result1
	mov	arg01, ##560
	call	#__system___gc_alloc_managed
	mov	local08, result1
	mov	arg04, local03
	sar	arg04, #31
	mov	arg03, local03
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	local01, result1
	mov	local09, result2
	mov	arg04, local04
	sar	arg04, #31
	mov	arg03, local04
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local09, result2
	mov	arg04, local05
	sar	arg04, #31
	mov	arg03, local05
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local09, result2
	mov	arg04, local06
	sar	arg04, #31
	mov	arg03, local06
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	arg02, local09
	or	local01, result1
	or	result2, arg02
	mov	local02, result2
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___usepins
	cmp	result1, #0 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#22, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
'         _seterror( 22 );
'         return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__0012
	mov	local10, local01
	mov	local09, local02
	add	local07, #8
	wrlong	local10, local07
	add	local07, #4
	wrlong	local09, local07
	sub	local07, #12
	mov	arg05, local06
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local05
	mov	local10, objptr
	mov	objptr, local07
	call	#_fatfs_cc_disk_setpins
	mov	objptr, local10
	mov	local11, result1 wz
 if_ne	jmp	#LR__0010
	mov	arg02, ##@LR__2095
	mov	arg01, local08
	mov	arg03, #0
	mov	local11, objptr
	mov	objptr, local07
	call	#_fatfs_cc_f_mount
	mov	objptr, local11
	mov	local11, result1
LR__0010
	cmp	local11, #0 wz
 if_e	jmp	#LR__0011
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___freepins
	neg	arg01, local11 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
' #line 39 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs_vfs.c"
'        _freepins(pmask);
'        _seterror(-r);
'        return 0;
	mov	result1, #0
	jmp	#LR__0012
LR__0011
	mov	arg01, local07
	mov	local11, objptr
	mov	objptr, local07
	call	#_fatfs_cc_get_vfs
	mov	objptr, local11
'     }
'     v = FFS->get_vfs(FFS);
' #line 50 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs_vfs.c"
'     return v;
LR__0012
	mov	ptra, fp
	call	#popregs_
_libc_a__vfs_open_sdcardx_ret
	ret

_libc_a_fflush
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, #0
	add	arg01, #44
	rdlong	result1, arg01 wz
	sub	arg01, #44
 if_e	jmp	#LR__0020
	add	arg01, #44
	rdlong	local01, arg01
	mov	local02, local01
	sub	arg01, #44
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	local01, result1
LR__0020
'         r = (*f->flush)(f);
'     }
'     return r;
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_libc_a_fflush_ret
	ret

_libc_a_fgetc
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	add	local01, #16
	rdlong	result1, local01 wz
	sub	local01, #16
 if_ne	add	local01, #16
 if_ne	rdlong	local02, local01
 if_ne	sub	local02, #1
 if_ne	wrlong	#0, local01
 if_ne	jmp	#LR__0030
	add	local01, #32
	rdlong	local02, local01
	mov	local03, local02
	sub	local01, #32
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local01
	mov	local02, result1
LR__0030
'         c = f->getcf(f);
'     }
'     return c;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_libc_a_fgetc_ret
	ret

_libc_a_fopen
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#_libc_a__find_free_file
	mov	arg03, result1
	cmps	arg03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__0040
	mov	arg01, arg03
	call	#_libc_a___getftab
	mov	arg03, result1
' 
'     ftab = __getftab(fd);
'     return _fopenraw(pathname, mode, ftab);
	mov	arg01, local01
	mov	arg02, local02
	call	#_libc_a__fopenraw
LR__0040
	mov	ptra, fp
	call	#popregs_
_libc_a_fopen_ret
	ret

_libc_a_fseek
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
' {
'     return (f -  __getftab(0) );
	mov	arg03, local01
	mov	arg01, #0
	call	#_libc_a___getftab
	sub	arg03, result1
	qdiv	arg03, #52
	mov	arg01, local01
	getqx	local04
	call	#_libc_a_fflush
	add	local01, #16
	wrlong	#0, local01
	mov	arg01, local04
	mov	arg02, local02
	mov	arg03, local03
	call	#_libc_a_lseek
	cmp	result1, ##-1 wz
 if_ne	mov	result1, #0
'         r = 0;
'     }
'     return r;
	mov	ptra, fp
	call	#popregs_
_libc_a_fseek_ret
	ret

_libc_a_ftell
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' {
'     return (f -  __getftab(0) );
	mov	arg03, arg01
	mov	arg01, #0
	call	#_libc_a___getftab
	sub	arg03, result1
	qdiv	arg03, #52
	mov	arg01, local01
	getqx	local02
	call	#_libc_a_fflush
	mov	arg01, local02
	mov	arg02, #0
	mov	arg03, #1
	call	#_libc_a_lseek
	add	local01, #16
	rdlong	local02, local01 wz
 if_ne	cmps	result1, #1 wc
 if_a	sub	result1, #1
'         --r;
'     }
'     return r;
	mov	ptra, fp
	call	#popregs_
_libc_a_ftell_ret
	ret

_libc_a_fwrite
	mov	COUNT_, #3
	call	#pushregs_
	qmul	arg02, arg03
	mov	local01, arg01
	mov	local02, arg04
	mov	arg01, local02
	getqx	local03
	call	#_libc_a_fflush
' {
'     size *= n;
'     fflush(f);
'     return _vfswrite(f, ptr, size);
	mov	arg01, local02
	mov	arg02, local01
	mov	arg03, local03
	call	#_libc_a__vfswrite
	mov	ptra, fp
	call	#popregs_
_libc_a_fwrite_ret
	ret

_libc_a_fread
	mov	COUNT_, #6
	call	#pushregs_
	qmul	arg02, arg03
	mov	local01, arg01
	mov	local02, arg04
	mov	local03, #0
	add	local02, #8
	rdlong	local04, local02
	sub	local02, #8
	test	local04, #256 wz
	getqx	local05
 if_e	jmp	#LR__0052
	mov	local06, local01
'         while (size > 0) {
LR__0050
	cmp	local05, #1 wc
 if_b	jmp	#LR__0051
	mov	arg01, local02
	call	#_libc_a_fgetc
	cmps	result1, #0 wc
 if_ae	wrbyte	result1, local06
 if_ae	add	local03, #1
 if_ae	add	local06, #1
 if_ae	jmp	#LR__0050
LR__0051
'             *dst++ = c;
'             r++;
'         }
'         return r;
	mov	result1, local03
	jmp	#LR__0054
LR__0052
	add	local02, #16
	rdlong	local04, local02 wz
	sub	local02, #16
 if_ne	cmp	local05, #0 wz
 if_e	jmp	#LR__0053
	mov	local04, local01
	mov	arg01, local02
	add	local01, #1
	call	#_libc_a_fgetc
	wrbyte	result1, local04
	sub	local05, #1
	add	local03, #1
LR__0053
	cmp	local05, #0 wz
 if_e	mov	result1, local03
 if_e	jmp	#LR__0054
	mov	arg01, local02
	call	#_libc_a_fflush
	mov	arg01, local02
	mov	arg02, local01
	mov	arg03, local05
	call	#_libc_a__vfsread
'     fflush(f);
'     r += _vfsread(f, ptr, size);
' #line 44 "C:/Users/ryans/Documents/flexprop/include/libc/stdio/fwrite.c"
'     return r;
	add	result1, local03
LR__0054
	mov	ptra, fp
	call	#popregs_
_libc_a_fread_ret
	ret

_libc_a__openraw
	mov	COUNT_, #21
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, #4
	mov	local06, local01
	mov	local07, #0
	mov	local08, ptr___system__dat__
	add	local08, #388
	mov	arg01, local08
	mov	arg02, local02
	mov	arg03, #0
	call	#__system____getvfsforfile
	mov	local09, result1 wz
 if_e	jmp	#LR__0060
	add	local09, #32
	rdlong	result1, local09 wz
	sub	local09, #32
 if_ne	jmp	#LR__0061
LR__0060
' #line 121 "C:/Users/ryans/Documents/flexprop/include/libc/unix/posixio.c"
'         return _seterror( 16 );
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__0074
LR__0061
	mov	arg01, local06
	mov	arg02, #0
	mov	arg03, #52
	mov	local10, arg01
	call	#\builtin_bytefill_
	add	local09, #32
	rdlong	local11, local09
	mov	local12, local11
	mov	local13, local11
	sub	local09, #32
	mov	local14, local13
	zerox	local12, #19
	shr	local14, #20
	shl	local14, #2
	add	local14, __methods__
	rdlong	local14, local14
	mov	local15, local06
	mov	local16, local08
	mov	local17, local03
	mov	arg01, local15
	mov	arg02, local16
	mov	arg03, local17
	mov	local18, objptr
	mov	objptr, local12
	call	local14
	mov	objptr, local18
	mov	local19, result1 wz
 if_ne	test	local03, #4 wz
 if_e	jmp	#LR__0062
	add	local09, #36
	rdlong	local11, local09
	mov	local12, local11
	mov	local13, local11
	sub	local09, #36
	mov	local14, local13
	zerox	local12, #19
	shr	local14, #20
	shl	local14, #2
	add	local14, __methods__
	rdlong	local14, local14
	mov	local15, local06
	mov	local16, local08
	mov	local17, local04
	mov	arg01, local15
	mov	arg02, local16
	mov	arg03, local17
	mov	local18, objptr
	mov	objptr, local12
	call	local14
	mov	objptr, local18
	mov	local19, result1
LR__0062
	cmp	local19, #0 wz
 if_ne	jmp	#LR__0072
	mov	local20, local03
	and	local20, #3 wz
 if_ne	or	local05, #2
	cmp	local20, #1 wz
 if_ne	or	local05, #1
	test	local03, #32 wz
 if_ne	or	local05, #192
	add	local06, #8
	wrlong	local05, local06
	add	local06, #12
	rdlong	local21, local06 wz
	sub	local06, #20
 if_ne	jmp	#LR__0063
	add	local09, #4
	rdlong	local21, local09
	sub	local09, #4
	add	local06, #20
	wrlong	local21, local06
	sub	local06, #20
LR__0063
	add	local06, #24
	rdlong	local21, local06 wz
	sub	local06, #24
 if_ne	jmp	#LR__0064
	add	local09, #8
	rdlong	local21, local09
	sub	local09, #8
	add	local06, #24
	wrlong	local21, local06
	sub	local06, #24
LR__0064
	add	local06, #36
	rdlong	local21, local06 wz
	sub	local06, #36
 if_e	rdlong	local21, local09
 if_e	add	local06, #36
 if_e	wrlong	local21, local06
 if_e	sub	local06, #36
	add	local06, #40
	rdlong	local21, local06 wz
	sub	local06, #40
 if_ne	jmp	#LR__0065
	add	local09, #16
	rdlong	local21, local09
	sub	local09, #16
	add	local06, #40
	wrlong	local21, local06
	sub	local06, #40
LR__0065
	add	local06, #48
	rdlong	local21, local06 wz
	sub	local06, #48
 if_ne	jmp	#LR__0066
	add	local09, #12
	rdlong	local21, local09
	sub	local09, #12
	add	local06, #48
	wrlong	local21, local06
	sub	local06, #48
LR__0066
	add	local06, #28
	rdlong	local21, local06 wz
	sub	local06, #28
 if_ne	jmp	#LR__0067
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##24117248
	add	local06, #28
	wrlong	arg01, local06
	sub	local06, #28
LR__0067
	add	local06, #32
	rdlong	local21, local06 wz
	sub	local06, #32
 if_ne	jmp	#LR__0068
	mov	local07, #1
	mov	arg01, objptr
	bith	arg01, #55
	add	local06, #32
	wrlong	arg01, local06
	sub	local06, #32
LR__0068
	add	local06, #44
	rdlong	local21, local06 wz
	sub	local06, #44
 if_ne	jmp	#LR__0071
	add	local09, #20
	rdlong	local21, local09 wz
	sub	local09, #20
 if_e	jmp	#LR__0069
	add	local09, #20
	rdlong	local21, local09
	add	local06, #44
	wrlong	local21, local06
	sub	local06, #44
	jmp	#LR__0070
LR__0069
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##26214400
	add	local06, #44
	wrlong	arg01, local06
	sub	local06, #44
LR__0070
LR__0071
LR__0072
	cmp	local07, #0 wz
 if_ne	mov	arg01, local06
 if_ne	call	#_libc_a___default_buffer_init
	cmp	local19, #0 wz
 if_e	mov	arg01, #0
 if_ne	jmp	#LR__0073
	cmps	arg01, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
LR__0073
'     return r;
	mov	result1, local19
LR__0074
	mov	ptra, fp
	call	#popregs_
_libc_a__openraw_ret
	ret

_libc_a__closeraw
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0082
	add	local01, #44
	rdlong	result1, local01 wz
	sub	local01, #44
 if_e	jmp	#LR__0080
	add	local01, #44
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #44
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
LR__0080
	add	local01, #36
	rdlong	local05, local01 wz
	sub	local01, #36
 if_e	jmp	#LR__0081
	add	local01, #36
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #36
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local02, result1
LR__0081
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
'     return r;
	mov	result1, local02
LR__0082
	mov	ptra, fp
	call	#popregs_
_libc_a__closeraw_ret
	ret

_libc_a_lseek
	mov	COUNT_, #6
	call	#pushregs_
	cmp	arg01, #10 wc
'         return _seterror( 5 );
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__0091
	qmul	arg01, #52
	mov	arg01, ptr__libc_a_dat__
	add	arg01, #4
'         return _seterror( 16 );
	getqx	local01
	add	local01, arg01
	add	local01, #48
	rdlong	arg01, local01 wz
	sub	local01, #48
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#16, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0091
	add	local01, #8
	rdlong	local02, local01
	sub	local01, #8
	test	local02, #64 wz
 if_ne	add	local01, #8
 if_ne	rdlong	local02, local01
 if_ne	or	local02, #128
 if_ne	wrlong	local02, local01
 if_ne	sub	local01, #8
	add	local01, #48
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #48
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local06, result1
	cmps	local06, #0 wc
 if_ae	jmp	#LR__0090
'         return _seterror(-r);
	neg	arg01, local06 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__0091
LR__0090
'     }
'     return r;
	mov	result1, local06
LR__0091
	mov	ptra, fp
	call	#popregs_
_libc_a_lseek_ret
	ret

_libc_a___default_getc
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #8
	rdlong	local03, local02
	test	local03, #2 wz
 if_ne	mov	arg01, local01
 if_ne	call	#_libc_a___default_flush
	rdlong	local03, local02
	or	local03, #1
	wrlong	local03, local02
	sub	local02, #8
	rdlong	local03, local02 wz
 if_ne	jmp	#LR__0100
	mov	arg01, local01
	call	#_libc_a___default_filbuf
	mov	local03, result1
LR__0100
	cmps	local03, #1 wc
'         return -1;
 if_b	neg	result1, #1
 if_b	jmp	#LR__0101
	sub	local03, #1
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	rdbyte	result1, local03
	add	local03, #1
	wrlong	local03, local02
'     }
'     b->cnt = i-1;
'     ptr = b->ptr;
'     i = *ptr++;
'     b->ptr = ptr;
'     return i;
LR__0101
	mov	ptra, fp
	call	#popregs_
_libc_a___default_getc_ret
	ret

_libc_a___default_putc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local02
	add	local03, #8
	rdlong	result1, local03
	test	result1, #1 wz
 if_ne	mov	arg01, local02
 if_ne	call	#_libc_a___default_flush
	rdlong	local04, local03
	or	local04, #2
	wrlong	local04, local03
	sub	local03, #8
	rdlong	local05, local03
	add	local03, #16
	rdlong	arg02, local03
	sub	local03, #16
	mov	result1, local05
	add	result1, arg02
	wrbyte	local01, result1
	getbyte	local01, local01, #0
	add	local05, #1
	wrlong	local05, local03
	add	local02, #6
	rdword	local06, local02 wz
	sub	local02, #6
 if_ne	add	local03, #12
 if_ne	rdlong	local04, local03
 if_ne	cmp	local05, local04 wz
 if_e	jmp	#LR__0110
	cmp	local01, #10 wz
 if_e	cmp	local06, #1 wz
 if_ne	jmp	#LR__0111
LR__0110
	mov	arg01, local02
	call	#_libc_a___default_flush
	cmp	result1, #0 wz
 if_ne	neg	local01, #1
LR__0111
'             c = -1;
'         }
'     }
'     return c;
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_libc_a___default_putc_ret
	ret

_libc_a___default_flush
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	rdlong	local03, local02
	add	local02, #8
	rdlong	result1, local02
	sub	local02, #8
	test	result1, #2 wz
 if_e	jmp	#LR__0122
	cmps	local03, #1 wc
 if_b	jmp	#LR__0124
	add	local01, #8
	rdlong	result1, local01
	sub	local01, #8
	test	result1, #64 wz
 if_e	jmp	#LR__0121
	add	local01, #8
	rdlong	arg03, local01
	sub	local01, #8
	test	arg03, #128 wz
 if_e	jmp	#LR__0120
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #2
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	add	local01, #8
	rdlong	local06, local01
	andn	local06, #128
	wrlong	local06, local01
	sub	local01, #8
LR__0120
LR__0121
	add	local01, #24
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #24
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	add	local02, #16
	rdlong	arg02, local02
	sub	local02, #16
	mov	arg01, local01
	mov	arg03, local03
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	jmp	#LR__0124
LR__0122
	add	local02, #8
	rdlong	local06, local02
	sub	local02, #8
	test	local06, #1 wz
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__0123
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	neg	arg02, local03
	mov	arg03, #1
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
LR__0123
LR__0124
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
'     }
'     b->cnt = 0;
'     b->ptr = 0;
'     b->flags = 0;
'     return 0;
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_libc_a___default_flush_ret
	ret

_libc_a___default_buffer_init
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	call	#_libc_a__isatty
	cmp	result1, #0 wz
 if_ne	add	local01, #6
 if_ne	wrword	#5, local01
 if_e	add	local01, #6
 if_e	wrword	#6, local01
	add	local02, #20
	mov	local01, local02
	sub	local02, #4
	wrlong	local01, local02
	sub	local02, #4
	wrlong	##1024, local02
'         f->bufmode =  (0x2)  |  (0x4) ;
'     }
'     b->bufptr = &b->bufdata[0];
'     b->bufsiz =  1024 ;
'     return 0;
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_libc_a___default_buffer_init_ret
	ret

_libc_a__ioctl
	mov	COUNT_, #3
	call	#pushregs_
	cmps	arg01, #0 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0131
	add	arg01, #40
	rdlong	local01, arg01
	mov	local02, local01
	sub	arg01, #40
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	arg01, result1 wz
 if_e	jmp	#LR__0130
'         return _seterror(r);
	cmps	arg01, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__0131
LR__0130
'     }
'     return 0;
	mov	result1, #0
LR__0131
	mov	ptra, fp
	call	#popregs_
_libc_a__ioctl_ret
	ret

_libc_a__isatty
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg03, fp
	sub	fp, #8
	mov	arg02, #256
	call	#_libc_a__ioctl
	cmp	result1, #0 wz
'         return 1;
 if_e	mov	result1, #1
'     }
'     return 0;
 if_ne	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_libc_a__isatty_ret
	ret

_libc_a___getftab
	cmp	arg01, #10 wc
 if_b	qmul	arg01, #52
'         return 0;
 if_ae	mov	result1, #0
'     }
'     return &__filetab[i];
 if_b	mov	arg01, ptr__libc_a_dat__
 if_b	add	arg01, #4
 if_b	getqx	result1
 if_b	add	result1, arg01
_libc_a___getftab_ret
	ret

_libc_a__fopenraw
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, #0
	mov	local05, #0
	mov	local06, #0
	mov	local07, #0
	mov	local08, #0
	mov	local09, #0
' 
'     while ((c = *mode++) != 0) {
LR__0140
	rdbyte	local10, local02
	mov	local11, local10 wz
	add	local02, #1
 if_e	jmp	#LR__0147
'         switch (c) {
	mov	local12, local11
	cmp	local12, #114 wz
 if_e	jmp	#LR__0141
	cmp	local12, #119 wz
 if_e	jmp	#LR__0142
	cmp	local12, #97 wz
 if_e	jmp	#LR__0143
	cmp	local12, #98 wz
 if_e	jmp	#LR__0144
	cmp	local12, #43 wz
 if_e	jmp	#LR__0145
	jmp	#LR__0146
LR__0141
	mov	local04, #1
'             want_read = 1;
'             break;
	jmp	#LR__0140
LR__0142
	mov	local08, #1
	mov	local09, #1
	mov	local05, #1
'             want_create = 1;
'             want_trunc = 1;
'             want_write = 1;
'             break;
	jmp	#LR__0140
LR__0143
	mov	local05, #1
	mov	local08, #1
	mov	local06, #1
'             want_write = 1;
'             want_create = 1;
'             want_append = 1;
'             break;
	jmp	#LR__0140
LR__0144
	mov	local07, #1
'             want_binary = 1;
'             break;
	jmp	#LR__0140
LR__0145
	cmp	local04, #0 wz
 if_ne	mov	local05, #1
 if_ne	jmp	#LR__0140
	cmp	local05, #0 wz
 if_ne	mov	local04, #1
'                 want_read = 1;
'                 break;
 if_ne	jmp	#LR__0140
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
'                 _seterror( 10 );
'                 return 0;
	mov	result1, #0
	jmp	#LR__0150
'             }
'             break;
LR__0146
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
'             _seterror( 10 );
'             return 0;
	mov	result1, #0
	jmp	#LR__0150
LR__0147
	cmp	local04, #0 wz
 if_e	jmp	#LR__0148
	cmp	local05, #0 wz
 if_ne	mov	local13, #2
 if_ne	jmp	#LR__0149
	mov	local13, #0
	jmp	#LR__0149
LR__0148
	cmp	local05, #0 wz
 if_ne	mov	local13, #1
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#10, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
'         _seterror( 10 );
'         return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__0150
LR__0149
	cmp	local06, #0 wz
 if_ne	or	local13, #32
	cmp	local08, #0 wz
 if_ne	or	local13, #4
	cmp	local09, #0 wz
 if_ne	or	local13, #8
	mov	arg02, local01
	mov	arg03, local13
	mov	arg01, local03
	mov	arg04, #438
	call	#_libc_a__openraw
	cmp	result1, #0 wz
' #line 80 "C:/Users/ryans/Documents/flexprop/include/libc/stdio/fopen.c"
'         return 0;
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0150
	mov	arg01, local03
	call	#_libc_a__isatty
	cmp	result1, #0 wz
 if_ne	add	local03, #8
 if_ne	rdlong	local10, local03
 if_ne	or	local10, #256
 if_ne	wrlong	local10, local03
 if_ne	sub	local03, #8
'         ftab->state |=  (0x100) ;
'     }
' #line 88 "C:/Users/ryans/Documents/flexprop/include/libc/stdio/fopen.c"
'     return ftab;
	mov	result1, local03
LR__0150
	mov	ptra, fp
	call	#popregs_
_libc_a__fopenraw_ret
	ret

_libc_a__rxtxioctl_0726
'     switch (req) {
	cmp	arg02, #256 wz
 if_e	jmp	#LR__0160
	cmp	arg02, #257 wz
 if_e	jmp	#LR__0161
	jmp	#LR__0162
LR__0160
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	wrlong	result1, arg03
'         *argl = _getrxtxflags();
'         return 0;
	mov	result1, #0
	jmp	#LR__0163
LR__0161
	rdlong	arg01, arg03
	add	ptr___system__dat__, #8
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
'         _setrxtxflags(*argl);
'         return 0;
	mov	result1, #0
	jmp	#LR__0163
LR__0162
'         return _seterror( 10 );
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
LR__0163
_libc_a__rxtxioctl_0726_ret
	ret

_libc_a___dummy_flush_0727
' {
'     return 0;
	mov	result1, #0
_libc_a___dummy_flush_0727_ret
	ret

_libc_a__find_free_file
	mov	_var01, ptr__libc_a_dat__
	add	_var01, #4
' 
'     for (fd = 0; fd <  10 ; fd++) {
	mov	_var02, #0
	callpa	#(@LR__0171-@LR__0170)>>2,fcache_load_ptr_
LR__0170
	cmps	_var02, #10 wc
 if_ae	jmp	#LR__0172
	qmul	_var02, #52
	getqx	result1
	add	result1, _var01
	add	result1, #8
	rdlong	result1, result1 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__0170
LR__0171
LR__0172
	cmp	_var02, #10 wz
'         return _seterror( 11 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#11, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
'     }
'     return fd;
 if_ne	mov	result1, _var02
_libc_a__find_free_file_ret
	ret

_libc_a__vfswrite
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, local02
	add	local01, #8
	rdlong	arg01, local01
	sub	local01, #8
	test	arg01, #2 wz
'         return _seterror( 6 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0186
	add	local01, #8
	rdlong	result1, local01
	sub	local01, #8
	test	result1, #64 wz
 if_e	jmp	#LR__0181
	add	local01, #8
	rdlong	arg02, local01
	sub	local01, #8
	test	arg02, #128 wz
 if_e	jmp	#LR__0180
	add	local01, #48
	rdlong	local05, local01
	mov	local06, local05
	sub	local01, #48
	zerox	local06, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #2
	mov	local07, objptr
	mov	objptr, local06
	call	local05
	mov	objptr, local07
	add	local01, #8
	rdlong	local07, local01
	andn	local07, #128
	wrlong	local07, local01
	sub	local01, #8
LR__0180
LR__0181
	add	local01, #24
	rdlong	local07, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__0183
	add	local01, #24
	rdlong	local05, local01
	mov	local06, local05
	sub	local01, #24
	zerox	local06, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg02, local02
	mov	arg03, local03
	mov	arg01, local01
	mov	local07, objptr
	mov	objptr, local06
	call	local05
	mov	objptr, local07
	mov	local08, result1
	cmps	local08, #0 wc
 if_ae	jmp	#LR__0182
	add	local01, #8
	rdlong	local07, local01
	or	local07, #32
	wrlong	local07, local01
'             f->state |=  (0x20) ;
'             return _seterror(r);
	cmps	local08, #0 wz
	add	ptr___system__dat__, #32
	wrlong	local08, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__0186
LR__0182
'         }
'         return r;
	mov	result1, local08
	jmp	#LR__0186
LR__0183
	add	local01, #28
	rdlong	local09, local01 wz
	sub	local01, #28
'         return _seterror( 6 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0186
	mov	local08, #0
'     }
'     r = 0;
'     while (count > 0) {
LR__0184
	cmp	local03, #1 wc
 if_b	jmp	#LR__0185
	mov	local05, local09
	mov	local07, local09
	zerox	local05, #19
	shr	local07, #20
	shl	local07, #2
	add	local07, __methods__
	rdlong	local07, local07
	rdbyte	arg01, local04
	mov	arg02, local01
	mov	local06, objptr
	mov	objptr, local05
	add	local04, #1
	call	local07
	mov	objptr, local06
	add	local08, result1
	sub	local03, #1
	jmp	#LR__0184
LR__0185
'         r += (*tx)(*buf++, f);
'         --count;
'     }
'     return r;
	mov	result1, local08
LR__0186
	mov	ptra, fp
	call	#popregs_
_libc_a__vfswrite_ret
	ret

_libc_a__vfsread
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #40
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #4
	rdlong	result1, fp
	add	fp, #20
	wrlong	result1, fp
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #28
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #8
	rdlong	result1, arg01
	test	result1, #1 wz
' #line 334 "C:/Users/ryans/Documents/flexprop/include/libc/unix/posixio.c"
'         return _seterror( 6 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0196
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #20
	rdlong	result1, arg01 wz
 if_e	jmp	#LR__0191
	add	fp, #4
	rdlong	arg01, fp
	mov	arg03, arg01
	add	arg03, #20
	rdlong	local01, arg03
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #12
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmps	result1, #0 wc
 if_ae	jmp	#LR__0190
	add	fp, #4
	rdlong	local03, fp
	mov	local01, local03
	add	local03, #8
	rdlong	local02, local03
	or	local02, #32
	add	local01, #8
	wrlong	local02, local01
'             f->state |=  (0x20) ;
'             return _seterror(r);
	add	fp, #12
	rdlong	arg01, fp wz
	sub	fp, #16
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__0196
LR__0190
'         }
'         return r;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
	jmp	#LR__0196
LR__0191
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #32
	rdlong	arg01, arg01 wz
	add	fp, #20
	wrlong	arg01, fp
	sub	fp, #24
'         return _seterror( 6 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0196
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #40
	rdlong	local02, local03 wz
 if_e	jmp	#LR__0193
	add	fp, #4
	rdlong	arg01, fp
	mov	local03, arg01
	add	local03, #40
	rdlong	local01, local03
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	add	fp, #32
	mov	arg03, fp
	sub	fp, #36
	mov	arg02, #256
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	add	fp, #16
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #16
 if_ne	jmp	#LR__0192
	add	fp, #36
	rdlong	local02, fp
	sub	fp, #36
	test	local02, #2 wz
 if_ne	add	fp, #32
 if_ne	wrlong	#1, fp
 if_ne	sub	fp, #32
LR__0192
LR__0193
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #16
'             break_on_nl = 1;
'         }
'     }
'     r = 0;
'     while (count > 0) {
LR__0194
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local03, #1 wc
 if_b	jmp	#LR__0195
	add	fp, #24
	rdlong	local02, fp
	mov	local03, local02
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	sub	fp, #20
	rdlong	arg01, fp
	sub	fp, #4
	mov	local01, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local01
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmps	result1, #0 wc
 if_b	jmp	#LR__0195
	add	fp, #28
	rdlong	local03, fp
	mov	local02, local03
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #8
	rdlong	local02, fp
	wrbyte	local02, local03
	sub	fp, #4
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #4
	rdlong	local03, fp
	sub	local03, #1
	wrlong	local03, fp
	add	fp, #20
	rdlong	local03, fp wz
	sub	fp, #32
 if_e	jmp	#LR__0194
	add	fp, #20
	rdlong	local02, fp
	sub	fp, #20
	cmp	local02, #10 wz
'             break;
 if_ne	jmp	#LR__0194
LR__0195
'         }
'     }
'     return r;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
LR__0196
	mov	ptra, fp
	call	#popregs_
_libc_a__vfsread_ret
	ret

_libc_a___default_filbuf
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #12
	rdlong	result1, local02 wz
	sub	local02, #12
 if_ne	jmp	#LR__0200
	add	local02, #20
	mov	result1, local02
	sub	local02, #4
	wrlong	result1, local02
	sub	local02, #4
	wrlong	##1024, local02
	sub	local02, #12
LR__0200
	add	local01, #20
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #20
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	add	local02, #16
	rdlong	arg02, local02
	sub	local02, #4
	rdlong	arg03, local02
	sub	local02, #12
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local01
	mov	local04, result1
	cmps	local04, #0 wc
'         return -1;
 if_b	neg	result1, #1
 if_b	jmp	#LR__0201
	wrlong	local04, local02
	add	local02, #16
	rdlong	local03, local02
	sub	local02, #12
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	or	local03, #1
	wrlong	local03, local02
'     }
'     b->cnt = r;
'     b->ptr = &b->bufptr[0];
'     b->flags |=  (0x01) ;
'     return r;
	mov	result1, local04
LR__0201
	mov	ptra, fp
	call	#popregs_
_libc_a___default_filbuf_ret
	ret

_fatfs_cc_memcmp
' 	for (n = size; n > 0; n--)
	cmp	arg03, #0 wz
 if_e	jmp	#LR__0211
LR__0210
	rdbyte	_var01, arg01
	rdbyte	_var02, arg02
	cmp	_var01, _var02 wz
 if_e	add	arg01, #1
 if_e	add	arg02, #1
' 			return( ((unsigned char)(*scan1))  -  ((unsigned char)(*scan2)) );
 if_ne	rdbyte	result1, arg01
 if_ne	rdbyte	_var02, arg02
 if_ne	sub	result1, _var02
 if_ne	jmp	#_fatfs_cc_memcmp_ret
	djnz	arg03, #LR__0210
LR__0211
' 
' 	return(0);
	mov	result1, #0
_fatfs_cc_memcmp_ret
	ret

_fatfs_cc_strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__0220
' 		return scan2 ? -1 : 0;
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#_fatfs_cc_strncmp_ret
LR__0220
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__0222-@LR__0221)>>2,fcache_load_ptr_
' 	count = n;
' 	do {
LR__0221
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__0223
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__0221
LR__0222
LR__0223
	cmps	_var03, #0 wc
' 		return(0);
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, _var06 wz
' 		return(0);
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, #0 wz
' 		return(-1);
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var06, #0 wz
' 		return(1);
 if_e	mov	result1, #1
' 		return(c1 - c2);
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
_fatfs_cc_strncmp_ret
	ret

_fatfs_cc_strchr
' #line 16 "C:/Users/ryans/Documents/flexprop/include/libc/string/strchr.c"
' 	while ((c = *s++) != (char) charwanted)
LR__0230
	mov	_var01, arg01
	rdbyte	_var02, _var01
	getbyte	_var03, _var02, #0
	getbyte	_var04, arg02, #0
	cmp	_var03, _var04 wz
	add	arg01, #1
 if_e	jmp	#LR__0231
	mov	_var03, _var02
	zerox	_var03, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strchr_ret
	jmp	#LR__0230
LR__0231
' 	return((char *)--s);
	sub	arg01, #1
	mov	result1, arg01
_fatfs_cc_strchr_ret
	ret

_fatfs_cc_disk_initialize
	mov	COUNT_, #15
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, ptra
	add	objptr, #16
	rdlong	local03, objptr
	add	objptr, #4
	rdlong	local04, objptr
	add	objptr, #4
	rdlong	local05, objptr
	add	objptr, #4
	rdlong	local06, objptr
	add	objptr, #8
	wrbyte	#1, objptr
	sub	objptr, #36
' #line 538 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
' 		return RES_NOTRDY;
	add	ptra, #12
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__0260
	mov	arg01, ##10000
	call	#__system___waitus
	mov	arg04, local03
	sub	arg04, local05
	abs	arg04, arg04
	cmps	arg04, #4 wc
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__0260
	mov	local07, local03
	sub	local07, local06
	abs	local07, local07
	cmps	local07, #4 wc
 if_ae	jmp	#LR__0240
	mov	local08, local03
	sub	local08, local06
	and	local08, #7
	shl	local08, #24
	or	local08, ##21114
	mov	local09, local06
	add	objptr, #28
	wrlong	local09, objptr
	add	objptr, #4
	wrlong	local09, objptr
	sub	objptr, #32
	jmp	#LR__0243
LR__0240
	cmps	local03, local06 wcz
 if_be	jmp	#LR__0241
	mov	local09, local03
	sub	local09, #3
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_e	add	local09, #1
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_ne	jmp	#LR__0242
	add	local09, #1
	jmp	#LR__0242
LR__0241
	mov	local09, local03
	add	local09, #3
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_e	sub	local09, #1
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_e	sub	local09, #1
LR__0242
	mov	local07, local06
	sub	local07, local09
	abs	local07, local07
	cmps	local07, #4 wc
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__0260
	mov	local08, local06
	sub	local08, local09
	and	local08, #7
	shl	local08, #28
	mov	local07, local03
	sub	local07, local09
	and	local07, #7
	shl	local07, #24
	or	local08, local07
	or	local08, #58
	add	objptr, #32
	wrlong	local06, objptr
	sub	objptr, #4
	wrlong	local09, objptr
	sub	objptr, #28
LR__0243
	wrpin	#0, local04
	drvh	local04
	mov	local10, ##1048608
	dirl	local03
	wrpin	##475208, local03
	wxpin	##1048608, local03
	wypin	#0, local03
	dirh	local03
	mov	local07, local03
	sub	local07, local05
	and	local07, #7
	shl	local07, #24
	mov	local11, #120
	or	local11, local07
	mov	arg02, local11
	bith	arg02, #16
	dirl	local05
	wrpin	arg02, local05
	wxpin	#31, local05
	wypin	##-1, local05
	dirh	local05
	wrpin	##20992, local06
	dirl	local09
	wrpin	local08, local09
	wxpin	#39, local09
	wypin	#0, local09
	dirh	local09
	mov	arg01, local02
	mov	arg02, #10
	call	#_fatfs_cc_rcvr_mmc_0641
	mov	arg01, #0
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_0664
	call	#_fatfs_cc_deselect_0651
	mov	arg01, #100
	call	#__system___waitus
	mov	arg01, local02
	mov	arg02, #10
	call	#_fatfs_cc_rcvr_mmc_0641
	mov	local12, #0
	mov	arg01, #0
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_0664
	getbyte	local07, result1, #0
	cmp	local07, #1 wz
 if_ne	jmp	#LR__0259
	mov	arg01, #8
	mov	arg02, #426
	call	#_fatfs_cc_send_cmd_0664
	getbyte	result1, result1, #0
	cmp	result1, #1 wz
 if_ne	jmp	#LR__0248
	mov	arg01, local02
	mov	arg02, #4
	call	#_fatfs_cc_rcvr_mmc_0641
	add	local02, #2
	rdbyte	local07, local02
	sub	local02, #2
	cmp	local07, #1 wz
 if_e	add	local02, #3
 if_e	rdbyte	local13, local02
 if_e	sub	local02, #3
 if_e	cmp	local13, #170 wz
 if_ne	jmp	#LR__0258
' 				for (tmr = 1000; tmr; tmr--) {
	mov	local14, ##1000
LR__0244
	mov	arg01, #169
	decod	arg02, #30
	call	#_fatfs_cc_send_cmd_0664
	mov	local07, result1
	zerox	local07, #7 wz
 if_e	jmp	#LR__0245
	mov	arg01, ##1000
	call	#__system___waitus
	mov	local07, local14
	sub	local14, #1 wz
 if_ne	jmp	#LR__0244
LR__0245
	cmp	local14, #0 wz
 if_e	jmp	#LR__0246
	mov	arg01, #58
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_0664
	mov	local07, result1
	zerox	local07, #7 wz
 if_ne	jmp	#LR__0246
	mov	arg01, local02
	mov	arg02, #4
	call	#_fatfs_cc_rcvr_mmc_0641
	rdbyte	local14, local02
	test	local14, #64 wz
 if_ne	mov	local07, #12
 if_e	mov	local07, #4
	mov	local12, local07
LR__0246
	rdlong	local14, #20
	cmp	local14, ##100000001 wc
 if_b	mov	local07, local11
 if_b	bith	local07, #27
 if_b	mov	local11, local07
 if_b	jmp	#LR__0247
	cmp	local14, ##200000001 wc
 if_b	or	local11, ##134283264
LR__0247
	cmp	local14, ##100000001 wc
 if_b	mov	local10, ##131076
 if_b	jmp	#LR__0258
	cmp	local14, ##150000001 wc
 if_b	mov	local10, ##196614
 if_b	jmp	#LR__0258
	cmp	local14, ##200000001 wc
 if_b	mov	local10, ##262152
 if_b	jmp	#LR__0258
	cmp	local14, ##250000001 wc
 if_b	mov	local10, ##327690
 if_b	jmp	#LR__0258
	mov	local10, ##393228
	jmp	#LR__0258
LR__0248
	mov	arg01, #169
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_0664
	getbyte	local07, result1, #0
	cmp	local07, #2 wc
 if_b	mov	local12, #2
 if_b	mov	local15, #169
 if_ae	mov	local12, #1
 if_ae	mov	local15, #1
' 				ty =  0x01 ; cmd =  (1) ;
' 			}
' 			for (tmr = 1000; tmr; tmr--) {
	mov	local14, ##1000
LR__0249
	mov	arg01, local15
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_0664
	mov	local07, result1
	zerox	local07, #7 wz
 if_e	jmp	#LR__0250
	mov	arg01, ##1000
	call	#__system___waitus
	mov	local07, local14
	sub	local14, #1 wz
 if_ne	jmp	#LR__0249
LR__0250
	cmp	local14, #0 wz
 if_e	jmp	#LR__0251
	mov	arg01, #16
	decod	arg02, #9
	call	#_fatfs_cc_send_cmd_0664
	mov	local07, result1
	zerox	local07, #7 wz
 if_e	jmp	#LR__0252
LR__0251
	mov	local12, #0
LR__0252
	rdlong	local14, #20
	cmp	local14, ##100000001 wc
 if_b	mov	local07, local11
 if_b	bith	local07, #27
 if_b	mov	local11, local07
 if_b	jmp	#LR__0253
	cmp	local14, ##200000001 wc
 if_b	or	local11, ##134283264
LR__0253
	cmp	local14, ##100000001 wc
 if_b	mov	local10, ##131076
 if_b	jmp	#LR__0257
	cmp	local14, ##150000001 wc
 if_b	mov	local10, ##196614
 if_b	jmp	#LR__0256
	cmp	local14, ##200000001 wc
 if_b	mov	local10, ##262152
 if_b	jmp	#LR__0255
	cmp	local14, ##250000001 wc
 if_b	mov	local10, ##327690
 if_b	jmp	#LR__0254
	cmp	local14, ##300000001 wc
 if_b	mov	local10, ##393228
 if_ae	mov	local10, ##458766
LR__0254
LR__0255
LR__0256
LR__0257
LR__0258
LR__0259
	add	objptr, #37
	wrbyte	local12, objptr
	cmp	local12, #0 wz
 if_ne	mov	local07, #0
 if_e	mov	local07, #1
	sub	objptr, #1
	wrbyte	local07, objptr
	sub	objptr, #36
	call	#_fatfs_cc_deselect_0651
	wxpin	local10, local03
	wrpin	local11, local05
' #line 681 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
' 		}
' 	}
' #line 686 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
' 	CardType = ty;
' 	s = ty ? 0 :  0x01 ;
' 	Stat = s;
' 
' 	deselect();
' 
' 
' 	_wxpin( PIN_CLK, ck_div );
' 	_wrpin( PIN_DI, spm_tx );
' #line 699 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
' 	return s;
	mov	result1, local07
LR__0260
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_initialize_ret
	ret

_fatfs_cc_disk_read
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #36
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #36
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__0272
	add	objptr, #37
	rdbyte	local04, objptr
	sub	objptr, #37
	test	local04, #8 wz
 if_e	shl	local02, #9
	cmp	local03, #2 wc
 if_ae	mov	local04, #18
 if_b	mov	local04, #17
	mov	arg02, local02
	mov	arg01, local04
	call	#_fatfs_cc_send_cmd_0664
	mov	local05, result1
	zerox	local05, #7 wz
 if_ne	jmp	#LR__0271
' 		do {
LR__0270
	mov	arg01, local01
	decod	arg02, #9
	call	#_fatfs_cc_rcvr_datablock_0659
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local03, #LR__0270
	getbyte	local04, local04, #0
	cmp	local04, #18 wz
 if_e	mov	arg01, #12
 if_e	mov	arg02, #0
 if_e	call	#_fatfs_cc_send_cmd_0664
LR__0271
	call	#_fatfs_cc_deselect_0651
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local03, #0 wz
 if_ne	mov	local05, #1
 if_e	mov	local05, #0
	mov	result1, local05
LR__0272
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_read_ret
	ret

_fatfs_cc_disk_write
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg04
	mov	local03, arg03
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #36
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #36
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__0284
	add	objptr, #37
	rdbyte	arg03, objptr
	sub	objptr, #37
	test	arg03, #8 wz
 if_e	shl	local03, #9
	cmp	local02, #1 wz
 if_ne	jmp	#LR__0280
	mov	arg01, #24
	mov	arg02, local03
	call	#_fatfs_cc_send_cmd_0664
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__0283
	mov	arg01, local01
	mov	arg02, #254
	call	#_fatfs_cc_xmit_datablock_0661
	cmp	result1, #0 wz
 if_ne	mov	local02, #0
	jmp	#LR__0283
LR__0280
	add	objptr, #37
	rdbyte	local04, objptr
	sub	objptr, #37
	test	local04, #6 wz
 if_ne	mov	arg01, #151
 if_ne	mov	arg02, local02
 if_ne	call	#_fatfs_cc_send_cmd_0664
	mov	arg02, local03
	mov	arg01, #25
	call	#_fatfs_cc_send_cmd_0664
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__0282
' 			do {
LR__0281
	mov	arg01, local01
	mov	arg02, #252
	call	#_fatfs_cc_xmit_datablock_0661
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local02, #LR__0281
	mov	arg01, #0
	mov	arg02, #253
	call	#_fatfs_cc_xmit_datablock_0661
	cmp	result1, #0 wz
 if_e	mov	local02, #1
LR__0282
LR__0283
	call	#_fatfs_cc_deselect_0651
' 				count = 1;
' 		}
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local02, #0 wz
 if_ne	mov	local04, #1
 if_e	mov	local04, #0
	mov	result1, local04
LR__0284
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_write_ret
	ret

_fatfs_cc_disk_ioctl
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #48
	add	fp, #4
	wrbyte	arg01, fp
	add	fp, #4
	wrbyte	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdbyte	arg01, fp wz
	sub	fp, #4
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #36
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #36
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__0298
	add	fp, #16
	wrlong	#1, fp
' 
' 	res = RES_ERROR;
' 	switch (ctrl) {
	sub	fp, #8
	rdbyte	local01, fp
	sub	fp, #8
	fle	local01, #4
	jmprel	local01
LR__0290
	jmp	#LR__0291
	jmp	#LR__0292
	jmp	#LR__0296
	jmp	#LR__0295
	jmp	#LR__0296
LR__0291
	call	#_fatfs_cc_select_0655
	cmp	result1, #0 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#0, fp
 if_ne	sub	fp, #16
' 			break;
	jmp	#LR__0297
LR__0292
	mov	arg01, #9
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_0664
	mov	local01, result1
	zerox	local01, #7 wz
 if_ne	jmp	#LR__0297
	mov	arg01, fp
	add	arg01, #24
	mov	arg02, #16
	call	#_fatfs_cc_rcvr_datablock_0659
	cmp	result1, #0 wz
 if_e	jmp	#LR__0297
	add	fp, #24
	rdbyte	local01, fp
	sub	fp, #24
	shr	local01, #6
	cmp	local01, #1 wz
 if_ne	jmp	#LR__0293
	add	fp, #33
	rdbyte	local01, fp
	sub	fp, #1
	rdbyte	result1, fp
	getword	result1, result1, #0
	shl	result1, #8
	add	local01, result1
	sub	fp, #1
	rdbyte	result1, fp
	and	result1, #63
	shl	result1, #16
	add	local01, result1
	add	local01, #1
	add	fp, #9
	wrlong	local01, fp
	sub	fp, #28
	rdlong	local01, fp
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #40
	shl	result1, #10
	wrlong	result1, local01
	jmp	#LR__0294
LR__0293
	add	fp, #29
	rdbyte	local01, fp
	getnib	local01, local01, #0
	add	fp, #5
	rdbyte	result1, fp
	and	result1, #128
	sar	result1, #7
	add	local01, result1
	sub	fp, #1
	rdbyte	result1, fp
	and	result1, #3
	shl	result1, #1
	add	local01, result1
	add	local01, #2
	sub	fp, #13
	wrbyte	local01, fp
	add	fp, #12
	rdbyte	local01, fp
	shr	local01, #6
	sub	fp, #1
	rdbyte	result1, fp
	getword	result1, result1, #0
	shl	result1, #2
	add	local01, result1
	sub	fp, #1
	rdbyte	result1, fp
	and	result1, #3
	getword	result1, result1, #0
	shl	result1, #10
	add	local01, result1
	add	local01, #1
	add	fp, #10
	wrlong	local01, fp
	sub	fp, #28
	rdlong	local01, fp
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #20
	rdbyte	arg03, fp
	sub	fp, #20
	sub	arg03, #9
	shl	result1, arg03
	wrlong	result1, local01
LR__0294
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #16
' 					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
' 					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
' 					*(LBA_t*)buff = cs << (n - 9);
' 				}
' 				res = RES_OK;
' 			}
' 			break;
	jmp	#LR__0297
LR__0295
	add	fp, #12
	rdlong	local01, fp
	wrlong	#128, local01
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #16
' 			*(DWORD*)buff = 128;
' 			res = RES_OK;
' 			break;
	jmp	#LR__0297
LR__0296
	add	fp, #16
	wrlong	#4, fp
	sub	fp, #16
LR__0297
	call	#_fatfs_cc_deselect_0651
' 			res = RES_PARERR;
' 	}
' 
' 	deselect();
' 
' 	return res;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
LR__0298
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_ioctl_ret
	ret

_fatfs_cc_disk_setpins
	cmp	arg01, #0 wz
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_disk_setpins_ret
	add	objptr, #16
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	arg04, objptr
	add	objptr, #4
	wrlong	arg05, objptr
	sub	objptr, #28
	mov	result1, #0
_fatfs_cc_disk_setpins_ret
	ret

_fatfs_cc_sync_window
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #3
	rdbyte	result1, local01 wz
	sub	local01, #3
 if_e	jmp	#LR__0302
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #47
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #44
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0300
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #41
	rdlong	result1, local01
	sub	local01, #12
	rdlong	arg04, local01
	sub	result1, arg04
	sub	local01, #8
	rdlong	arg04, local01
	sub	local01, #24
	cmp	result1, arg04 wc
 if_ae	jmp	#LR__0301
	add	local01, #2
	rdbyte	arg04, local01
	sub	local01, #2
	cmp	arg04, #2 wz
 if_ne	jmp	#LR__0301
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #47
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #20
	rdlong	local01, local01
	add	arg03, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	jmp	#LR__0301
LR__0300
	mov	local02, #1
LR__0301
LR__0302
' 			res = FR_DISK_ERR;
' 		}
' 	}
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_window_ret
	ret

_fatfs_cc_move_window
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	add	local01, #44
	rdlong	arg04, local01
	sub	local01, #44
	cmp	local02, arg04 wz
 if_e	jmp	#LR__0311
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__0310
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #47
	mov	arg02, local01
	mov	arg03, local02
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	neg	local02, #1
 if_ne	mov	local03, #1
	sub	local01, #4
	wrlong	local02, local01
LR__0310
LR__0311
' 				sect = (LBA_t)0 - 1;
' 				res = FR_DISK_ERR;
' 			}
' 			fs->winsect = sect;
' 		}
' 	}
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_move_window_ret
	ret

_fatfs_cc_sync_fs
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	call	#_fatfs_cc_sync_window
	mov	local02, result1 wz
 if_ne	jmp	#LR__0321
	rdbyte	arg04, local01
	cmp	arg04, #3 wz
 if_e	add	local01, #4
 if_e	rdbyte	arg04, local01
 if_e	sub	local01, #4
 if_e	cmp	arg04, #1 wz
 if_ne	jmp	#LR__0320
	add	local01, #48
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	arg01, local01
	add	arg01, #510
	wrword	##43605, arg01
	wrlong	##1096897106, local01
	mov	arg01, local01
	add	arg01, #484
	wrlong	##1631679090, arg01
	mov	arg01, local01
	add	arg01, #488
	sub	local01, #32
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #32
	mov	arg01, local01
	add	arg01, #492
	sub	local01, #36
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #16
	rdlong	arg03, local01
	add	arg03, #1
	add	local01, #16
	wrlong	arg03, local01
	sub	local01, #43
	rdbyte	arg01, local01
	add	local01, #47
	mov	arg02, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	sub	local01, #44
	wrbyte	#0, local01
	sub	local01, #4
LR__0320
	add	local01, #1
	rdbyte	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	call	#_fatfs_cc_disk_ioctl
	cmp	result1, #0 wz
 if_ne	mov	local02, #1
LR__0321
' 	}
' 
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_fs_ret
	ret

_fatfs_cc_clst2sect
	sub	arg02, #2
	add	arg01, #20
	rdlong	_var01, arg01
	sub	arg01, #20
	sub	_var01, #2
	cmp	arg02, _var01 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#_fatfs_cc_clst2sect_ret
	add	arg01, #10
	rdword	_var01, arg01
	qmul	_var01, arg02
' 	return fs->database + (LBA_t)fs->csize * clst;
	add	arg01, #30
	rdlong	result1, arg01
	getqx	_var01
	add	result1, _var01
_fatfs_cc_clst2sect_ret
	ret

_fatfs_cc_get_fat
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg02
	rdlong	local02, arg01
	cmp	local01, #2 wc
 if_b	jmp	#LR__0330
	add	local02, #20
	rdlong	local03, local02
	sub	local02, #20
	cmp	local01, local03 wc
 if_b	jmp	#LR__0331
LR__0330
	mov	local04, #1
	jmp	#LR__0338
LR__0331
	neg	local04, #1
' 		val = 0xFFFFFFFF;
' 
' 		switch (fs->fs_type) {
	rdbyte	local05, local02
	sub	local05, #1
	fle	local05, #3
	jmprel	local05
LR__0332
	jmp	#LR__0333
	jmp	#LR__0334
	jmp	#LR__0335
	jmp	#LR__0336
LR__0333
	mov	local05, local01
	mov	arg01, local01
	shr	arg01, #1
	add	local05, arg01
	mov	arg01, local02
	mov	local06, local05
	shr	local06, #9
	add	local02, #32
	rdlong	arg02, local02
	sub	local02, #32
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0337
	mov	local06, local05
	and	local06, #511
	mov	arg01, local02
	add	arg01, #48
	add	local06, arg01
	rdbyte	local07, local06
	mov	arg01, local02
	add	local05, #1
	mov	local06, local05
	shr	local06, #9
	add	local02, #32
	rdlong	arg02, local02
	sub	local02, #32
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0337
	and	local05, #511
	add	local02, #48
	add	local05, local02
	rdbyte	local06, local05
	shl	local06, #8
	or	local07, local06
	test	local01, #1 wz
 if_ne	shr	local07, #4
 if_ne	mov	local03, local07
 if_e	zerox	local07, #11
 if_e	mov	local03, local07
	mov	local04, local03
' 			wc |= fs->win[bc %  ((UINT) 512 ) ] << 8;
' 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
' 			break;
	jmp	#LR__0337
LR__0334
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #8
	add	local02, #32
	rdlong	arg02, local02
	sub	local02, #32
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0337
	add	local02, #48
	shl	local01, #1
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, local02
	getword	local04, result1, #0
' 			val = ld_word(fs->win + clst * 2 %  ((UINT) 512 ) );
' 			break;
	jmp	#LR__0337
LR__0335
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #7
	add	local02, #32
	rdlong	arg02, local02
	sub	local02, #32
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0337
	add	local02, #48
	shl	local01, #2
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local04, local02
	bitl	local04, #124
' 			val = ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0x0FFFFFFF;
' 			break;
	jmp	#LR__0337
LR__0336
	mov	local04, #1
LR__0337
LR__0338
' 			val = 1;
' 		}
' 	}
' 
' 	return val;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_fat_ret
	ret

_fatfs_cc_put_fat
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, #2
	cmp	local02, #2 wc
 if_b	jmp	#LR__0347
	add	local01, #20
	rdlong	local05, local01
	sub	local01, #20
	cmp	local02, local05 wc
 if_ae	jmp	#LR__0347
' 		switch (fs->fs_type) {
	rdbyte	local06, local01
	sub	local06, #1
	fle	local06, #3
	jmprel	local06
LR__0340
	jmp	#LR__0341
	jmp	#LR__0344
	jmp	#LR__0345
	jmp	#LR__0346
LR__0341
	mov	local07, local02
	mov	local05, local02
	shr	local05, #1
	add	local07, local05
	mov	arg01, local01
	mov	local06, local07
	shr	local06, #9
	add	local01, #32
	rdlong	arg02, local01
	sub	local01, #32
	add	arg02, local06
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__0346
	mov	local08, local01
	add	local08, #48
	mov	local05, local07
	and	local05, #511
	add	local08, local05
	test	local02, #1 wz
	add	local07, #1
 if_e	jmp	#LR__0342
	rdbyte	local05, local08
	getnib	local05, local05, #0
	getbyte	local06, local03, #0
	shl	local06, #4
	or	local05, local06
	jmp	#LR__0343
LR__0342
	mov	local05, local03
LR__0343
	wrbyte	local05, local08
	add	local01, #3
	wrbyte	#1, local01
	sub	local01, #3
	mov	arg01, local01
	mov	local08, local07
	shr	local08, #9
	add	local01, #32
	rdlong	arg02, local01
	sub	local01, #32
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__0346
	mov	local08, local01
	add	local08, #48
	and	local07, #511
	add	local08, local07
	test	local02, #1 wz
 if_ne	shr	local03, #4
 if_ne	mov	local05, local03
 if_e	rdbyte	local05, local08
 if_e	and	local05, #240
 if_e	getbyte	local03, local03, #1
 if_e	getnib	local03, local03, #0
 if_e	or	local05, local03
	wrbyte	local05, local08
	add	local01, #3
	wrbyte	#1, local01
' 			p = fs->win + bc %  ((UINT) 512 ) ;
' 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__0346
LR__0344
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #8
	add	local01, #32
	rdlong	arg02, local01
	sub	local01, #32
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__0346
	add	local01, #48
	mov	arg01, local01
	shl	local02, #1
	and	local02, #511
	add	arg01, local02
	wrword	local03, arg01
	sub	local01, #45
	wrbyte	#1, local01
' 			st_word(fs->win + clst * 2 %  ((UINT) 512 ) , (WORD)val);
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__0346
LR__0345
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #7
	add	local01, #32
	rdlong	arg02, local01
	sub	local01, #32
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__0346
	bitl	local03, #124
	mov	arg01, local01
	add	arg01, #48
	mov	local08, local02
	shl	local08, #2
	and	local08, #511
	add	arg01, local08
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local08, arg01
	and	local08, ##-268435456
	or	local03, local08
	add	local01, #48
	mov	arg01, local01
	shl	local02, #2
	and	local02, #511
	add	arg01, local02
	wrlong	local03, arg01
	sub	local01, #45
	wrbyte	#1, local01
' 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0xF0000000);
' 			}
' 			st_dword(fs->win + clst * 4 %  ((UINT) 512 ) , val);
' 			fs->wflag = 1;
' 			break;
LR__0346
LR__0347
' 		}
' 	}
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_put_fat_ret
	ret

_fatfs_cc_remove_chain
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	rdlong	local04, local01
	cmp	local02, #2 wc
 if_b	jmp	#LR__0350
	add	local04, #20
	rdlong	result1, local04
	sub	local04, #20
	cmp	local02, result1 wc
 if_b	jmp	#LR__0351
LR__0350
	mov	result1, #2
	jmp	#LR__0356
LR__0351
	cmp	local03, #0 wz
 if_e	jmp	#LR__0352
	mov	arg02, local03
	mov	arg01, local04
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0356
LR__0352
' 	}
' 
' 
' 	do {
LR__0353
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1 wz
 if_e	jmp	#LR__0355
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__0356
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__0356
	mov	arg02, local02
	mov	arg01, local04
	mov	arg03, #0
	call	#_fatfs_cc_put_fat
	mov	local03, result1 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__0356
	add	local04, #20
	rdlong	local03, local04
	sub	local03, #2
	sub	local04, #4
	rdlong	local02, local04
	sub	local04, #16
	cmp	local02, local03 wc
 if_ae	jmp	#LR__0354
	add	local04, #16
	rdlong	local03, local04
	add	local03, #1
	wrlong	local03, local04
	sub	local04, #12
	rdbyte	local03, local04
	or	local03, #1
	wrbyte	local03, local04
	sub	local04, #4
LR__0354
	mov	local02, local05
	add	local04, #20
	rdlong	local05, local04
	sub	local04, #20
	cmp	local02, local05 wc
 if_b	jmp	#LR__0353
LR__0355
' #line 1500 "ff.c"
' 	return FR_OK;
	mov	result1, #0
LR__0356
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_remove_chain_ret
	ret

_fatfs_cc_create_chain
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	rdlong	local03, local01
 if_ne	jmp	#LR__0360
	add	local03, #12
	rdlong	local04, local03 wz
	sub	local03, #12
 if_ne	add	local03, #20
 if_ne	rdlong	local05, local03
 if_ne	sub	local03, #20
 if_ne	cmp	local04, local05 wc
 if_c_and_nz	jmp	#LR__0361
	mov	local04, #1
	jmp	#LR__0361
LR__0360
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, #2 wc
 if_b	mov	result1, #1
 if_b	jmp	#LR__0371
	cmp	local04, ##-1 wz
 if_e	mov	result1, local04
 if_e	jmp	#LR__0371
	add	local03, #20
	rdlong	local05, local03
	sub	local03, #20
	cmp	local04, local05 wc
 if_b	mov	result1, local04
 if_b	jmp	#LR__0371
	mov	local04, local02
LR__0361
	add	local03, #16
	rdlong	local05, local03 wz
	sub	local03, #16
 if_e	mov	result1, #0
 if_e	jmp	#LR__0371
	mov	local06, #0
	cmp	local04, local02 wz
 if_ne	jmp	#LR__0364
	mov	local06, local04
	add	local06, #1
	add	local03, #20
	rdlong	local05, local03
	sub	local03, #20
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #1 wz
 if_ne	cmp	local05, ##-1 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__0371
	cmp	local05, #0 wz
 if_e	jmp	#LR__0363
	add	local03, #12
	rdlong	local07, local03
	sub	local03, #12
	cmp	local07, #2 wc
 if_b	jmp	#LR__0362
	add	local03, #20
	rdlong	local05, local03
	sub	local03, #20
	cmp	local07, local05 wc
 if_b	mov	local04, local07
LR__0362
	mov	local06, #0
LR__0363
LR__0364
	cmp	local06, #0 wz
 if_ne	jmp	#LR__0367
	mov	local06, local04
' 			ncl = scl;
' 			for (;;) {
LR__0365
	add	local06, #1
	add	local03, #20
	rdlong	local05, local03
	sub	local03, #20
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
 if_ae	cmp	local06, local04 wcz
 if_a	mov	result1, #0
 if_a	jmp	#LR__0371
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local07, result1 wz
 if_e	jmp	#LR__0366
	cmp	local07, #1 wz
 if_ne	cmp	local07, ##-1 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__0371
	cmp	local06, local04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0371
	jmp	#LR__0365
LR__0366
LR__0367
	mov	arg01, local03
	mov	arg02, local06
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	mov	local08, result1 wz
 if_ne	jmp	#LR__0368
	cmp	local02, #0 wz
 if_e	jmp	#LR__0368
	mov	arg01, local03
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_put_fat
	mov	local08, result1
LR__0368
	cmp	local08, #0 wz
 if_ne	jmp	#LR__0369
	add	local03, #12
	wrlong	local06, local03
	add	local03, #8
	rdlong	local05, local03
	sub	local05, #2
	sub	local03, #4
	rdlong	local09, local03
	sub	local03, #16
	cmp	local09, local05 wcz
 if_be	add	local03, #16
 if_be	rdlong	local09, local03
 if_be	sub	local09, #1
 if_be	wrlong	local09, local03
 if_be	sub	local03, #16
	add	local03, #4
	rdbyte	local05, local03
	or	local05, #1
	wrbyte	local05, local03
	jmp	#LR__0370
LR__0369
	cmp	local08, #1 wz
	negz	local06, #1
LR__0370
' 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
' 	}
' 
' 	return ncl;
	mov	result1, local06
LR__0371
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_chain_ret
	ret

_fatfs_cc_dir_clear
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__0382
	mov	arg01, local01
	mov	arg02, local02
	call	#_fatfs_cc_clst2sect
	mov	local03, result1
	add	local01, #44
	wrlong	local03, local01
	add	local01, #4
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	local04, local01
' #line 1667 "ff.c"
' 	{
' 		ibuf = fs->win; szb = 1;
' 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
	mov	local05, #0
	sub	local01, #48
LR__0380
	add	local01, #10
	rdword	local06, local01
	sub	local01, #10
	cmp	local05, local06 wc
 if_ae	jmp	#LR__0381
	add	local01, #1
	rdbyte	arg01, local01
	sub	local01, #1
	mov	arg02, local04
	mov	arg03, local03
	add	arg03, local05
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	add	local05, #1
 if_e	jmp	#LR__0380
LR__0381
' 	}
' 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
	add	local01, #10
	rdword	local04, local01
	cmp	local05, local04 wz
 if_e	mov	local06, #0
 if_ne	mov	local06, #1
	mov	result1, local06
LR__0382
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_clear_ret
	ret

_fatfs_cc_dir_sdi
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	cmp	local02, ##2097152 wc
 if_b	test	local02, #31 wz
' 		return FR_INT_ERR;
 if_nc_or_nz	mov	result1, #2
 if_nc_or_nz	jmp	#LR__0396
	add	local01, #16
	wrlong	local02, local01
	sub	local01, #8
	rdlong	local04, local01 wz
	sub	local01, #8
 if_e	rdbyte	local05, local03
 if_e	cmp	local05, #3 wc
 if_nc_and_z	add	local03, #36
 if_nc_and_z	rdlong	local04, local03
 if_nc_and_z	sub	local03, #36
	cmp	local04, #0 wz
 if_ne	jmp	#LR__0390
	mov	local05, local02
	shr	local05, #5
	add	local03, #8
	rdword	arg02, local03
	sub	local03, #8
	cmp	local05, arg02 wc
 if_ae	mov	result1, #2
 if_ae	jmp	#LR__0396
	add	local03, #36
	rdlong	local05, local03
	sub	local03, #36
	add	local01, #24
	wrlong	local05, local01
	sub	local01, #24
	jmp	#LR__0395
LR__0390
	add	local03, #10
	rdword	local06, local03
	sub	local03, #10
	shl	local06, #9
' 		csz = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 		while (ofs >= csz) {
LR__0391
	cmp	local02, local06 wc
 if_b	jmp	#LR__0394
	mov	arg01, local01
	mov	arg02, local04
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__0396
	cmp	local04, #2 wc
 if_b	jmp	#LR__0392
	add	local03, #20
	rdlong	local05, local03
	sub	local03, #20
	cmp	local04, local05 wc
 if_b	jmp	#LR__0393
LR__0392
	mov	result1, #2
	jmp	#LR__0396
LR__0393
	sub	local02, local06
	jmp	#LR__0391
LR__0394
	mov	arg01, local03
	mov	arg02, local04
	call	#_fatfs_cc_clst2sect
	add	local01, #24
	wrlong	result1, local01
	sub	local01, #24
LR__0395
	add	local01, #20
	wrlong	local04, local01
	add	local01, #4
	rdlong	local05, local01 wz
	sub	local01, #24
 if_e	mov	result1, #2
 if_e	jmp	#LR__0396
	mov	local06, local02
	shr	local06, #9
	add	local01, #24
	rdlong	local05, local01
	add	local05, local06
	wrlong	local05, local01
	add	local03, #48
	and	local02, #511
	add	local03, local02
	add	local01, #4
	wrlong	local03, local01
' 	dp->sect += ofs /  ((UINT) 512 ) ;
' 	dp->dir = fs->win + (ofs %  ((UINT) 512 ) );
' 
' 	return FR_OK;
	mov	result1, #0
LR__0396
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_sdi_ret
	ret

_fatfs_cc_dir_next
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	add	local01, #16
	rdlong	local04, local01
	sub	local01, #16
	add	local04, #32
	cmp	local04, ##2097152 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
 if_ae	sub	local01, #24
	add	local01, #24
	rdlong	arg02, local01 wz
	sub	local01, #24
 if_e	mov	result1, #4
 if_e	jmp	#LR__0405
	test	local04, #511 wz
 if_ne	jmp	#LR__0404
	add	local01, #24
	rdlong	arg02, local01
	add	arg02, #1
	wrlong	arg02, local01
	sub	local01, #4
	rdlong	arg02, local01 wz
	sub	local01, #20
 if_ne	jmp	#LR__0400
	mov	arg02, local04
	shr	arg02, #5
	add	local03, #8
	rdword	local02, local03
	sub	local03, #8
	cmp	arg02, local02 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
' 				dp->sect = 0; return FR_NO_FILE;
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__0405
	jmp	#LR__0403
LR__0400
	mov	arg01, local04
	shr	arg01, #9
	add	local03, #10
	rdword	arg02, local03
	sub	local03, #10
	sub	arg02, #1
	test	arg01, arg02 wz
 if_ne	jmp	#LR__0402
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #2 wc
 if_b	mov	result1, #2
 if_b	jmp	#LR__0405
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__0405
	add	local03, #20
	rdlong	arg02, local03
	sub	local03, #20
	cmp	local05, arg02 wc
 if_b	jmp	#LR__0401
	cmp	local02, #0 wz
 if_e	add	local01, #24
 if_e	wrlong	#0, local01
' 						dp->sect = 0; return FR_NO_FILE;
 if_e	mov	result1, #4
 if_e	jmp	#LR__0405
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_create_chain
	mov	local05, result1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__0405
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__0405
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__0405
	mov	arg02, local05
	mov	arg01, local03
	call	#_fatfs_cc_dir_clear
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__0405
LR__0401
	add	local01, #20
	wrlong	local05, local01
	mov	arg01, local03
	mov	arg02, local05
	call	#_fatfs_cc_clst2sect
	add	local01, #4
	wrlong	result1, local01
	sub	local01, #24
LR__0402
LR__0403
LR__0404
	add	local01, #16
	wrlong	local04, local01
	add	local03, #48
	and	local04, #511
	add	local03, local04
	add	local01, #12
	wrlong	local03, local01
' #line 1771 "ff.c"
' 				}
' 				dp->clust = clst;
' 				dp->sect = clst2sect(fs, clst);
' 			}
' 		}
' 	}
' 	dp->dptr = ofs;
' 	dp->dir = fs->win + ofs %  ((UINT) 512 ) ;
' 
' 	return FR_OK;
	mov	result1, #0
LR__0405
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_next_ret
	ret

_fatfs_cc_dir_alloc
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local04, result1 wz
 if_ne	jmp	#LR__0414
	mov	local05, #0
' 		n = 0;
' 		do {
LR__0410
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local03
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__0413
	add	local01, #28
	rdlong	local06, local01
	sub	local01, #28
	rdbyte	local06, local06
	cmp	local06, #229 wz
 if_ne	add	local01, #28
 if_ne	rdlong	local07, local01
 if_ne	sub	local01, #28
 if_ne	rdbyte	local08, local07 wz
 if_ne	jmp	#LR__0411
	add	local05, #1
	cmp	local05, local02 wz
 if_e	jmp	#LR__0413
	jmp	#LR__0412
LR__0411
	mov	local05, #0
LR__0412
	mov	arg01, local01
	mov	arg02, #1
	call	#_fatfs_cc_dir_next
	mov	local04, result1 wz
 if_e	jmp	#LR__0410
LR__0413
LR__0414
	cmp	local04, #4 wz
 if_e	mov	local04, #7
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_alloc_ret
	ret

_fatfs_cc_ld_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	arg01, result1, #0
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
' {
' 
' 	return *((WORD*)ptr);
 if_e	rdword	result1, arg02
 if_e	shl	result1, #16
 if_e	or	arg01, result1
' 		cl |= (DWORD)ld_word(dir +  20 ) << 16;
' 	}
' 
' 	return cl;
	mov	result1, arg01
_fatfs_cc_ld_clust_ret
	ret

_fatfs_cc_st_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
	wrword	arg03, arg01
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
 if_e	shr	arg03, #16
 if_e	wrword	arg03, arg02
_fatfs_cc_st_clust_ret
	ret

_fatfs_cc_dir_read
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #4
	rdlong	local04, local01
' )
' {
' 	FRESULT res = FR_NO_FILE;
' 	FATFS *fs = dp->obj.fs;
' 	BYTE attr, b;
' #line 2303 "ff.c"
' 	while (dp->sect) {
LR__0420
	add	local01, #24
	rdlong	result1, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__0422
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local04
	call	#_fatfs_cc_move_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__0422
	add	local01, #28
	rdlong	result1, local01
	sub	local01, #28
	rdbyte	local05, result1
	mov	result1, local05
	zerox	result1, #7 wz
 if_e	mov	local03, #4
' 			res = FR_NO_FILE; break;
 if_e	jmp	#LR__0422
	add	local01, #28
	rdlong	local06, local01
	add	local06, #11
	rdbyte	local07, local06
	and	local07, #63
	sub	local01, #22
	wrbyte	local07, local01
	sub	local01, #6
	getbyte	result1, local05, #0
	cmp	result1, #229 wz
 if_ne	mov	local06, local05
 if_ne	getbyte	local06, local06, #0
 if_ne	cmp	local06, #46 wz
 if_ne	mov	local08, local07
 if_ne	getbyte	local08, local08, #0
 if_ne	cmp	local08, #15 wz
 if_e	jmp	#LR__0421
	mov	local09, #0
	getbyte	local07, local07, #0
	andn	local07, #32
	cmp	local07, #8 wz
 if_e	mov	local09, #1
	cmp	local09, local02 wz
' 				break;
 if_e	jmp	#LR__0422
LR__0421
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local03, result1 wz
 if_e	jmp	#LR__0420
LR__0422
	cmp	local03, #0 wz
 if_ne	add	local01, #24
 if_ne	wrlong	#0, local01
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_read_ret
	ret

_fatfs_cc_dir_find
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0433
' #line 2406 "ff.c"
' 	do {
LR__0430
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__0432
	add	local01, #28
	rdlong	arg03, local01
	sub	local01, #28
	rdbyte	arg03, arg03 wz
 if_e	mov	local03, #4
 if_e	jmp	#LR__0432
	add	local01, #28
	rdlong	arg03, local01
	add	arg03, #11
	rdbyte	arg03, arg03
	and	arg03, #63
	sub	local01, #22
	wrbyte	arg03, local01
	add	local01, #22
	rdlong	arg03, local01
	sub	local01, #28
	add	arg03, #11
	rdbyte	arg03, arg03
	test	arg03, #8 wz
 if_ne	jmp	#LR__0431
	add	local01, #28
	rdlong	arg01, local01
	add	local01, #4
	mov	arg02, local01
	sub	local01, #32
	mov	arg03, #11
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0432
LR__0431
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local03, result1 wz
 if_e	jmp	#LR__0430
LR__0432
' 
' 	return res;
	mov	result1, local03
LR__0433
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_find_ret
	ret

_fatfs_cc_dir_register
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	mov	arg02, #1
	call	#_fatfs_cc_dir_alloc
	mov	local03, result1 wz
 if_ne	jmp	#LR__0441
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__0440
	add	local01, #28
	rdlong	arg01, local01
	mov	arg02, #0
	mov	arg03, #32
	call	#\builtin_bytefill_
	rdlong	arg01, local01
	add	local01, #4
	mov	arg02, local01
	mov	arg03, #11
	call	#__system____builtin_memmove
	add	local02, #3
	wrbyte	#1, local02
LR__0440
LR__0441
' 			__builtin_memset(dp->dir, 0, 32 ) ;
' 			__builtin_memcpy(dp->dir + 0 , dp->fn, 11) ;
' #line 2540 "ff.c"
' 			fs->wflag = 1;
' 		}
' 	}
' 
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_register_ret
	ret

_fatfs_cc_dir_remove
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	cmps	result1, #0 wz
 if_e	add	local01, #28
 if_e	rdlong	local01, local01
 if_e	wrbyte	#229, local01
 if_e	add	local02, #3
 if_e	wrbyte	#1, local02
' 		dp->dir[ 0 ] =  0xE5 ;
' 		fs->wflag = 1;
' 	}
' 
' 
' 	return res;
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_remove_ret
	ret

_fatfs_cc_get_fileinfo
	mov	_var01, arg01
	add	arg02, #12
	wrbyte	#0, arg02
	sub	arg02, #12
	add	_var01, #24
	rdlong	result1, _var01 wz
	sub	_var01, #24
 if_e	jmp	#LR__0453
	mov	_var02, #0
	mov	_var03, #0
' #line 2708 "ff.c"
' 	si = di = 0;
' 	while (si < 11) {
LR__0450
	cmp	_var03, #11 wc
 if_ae	jmp	#LR__0452
	add	_var01, #28
	rdlong	result1, _var01
	sub	_var01, #28
	mov	arg01, _var03
	add	arg01, result1
	rdbyte	_var04, arg01
	getbyte	result1, _var04, #0
	cmp	result1, #32 wz
	add	_var03, #1
 if_e	jmp	#LR__0450
	getbyte	result1, _var04, #0
	cmp	result1, #5 wz
 if_e	mov	_var04, #229
	cmp	_var03, #9 wz
 if_ne	jmp	#LR__0451
	mov	result1, _var02
	mov	arg01, arg02
	add	arg01, #12
	add	result1, arg01
	wrbyte	#46, result1
	add	_var02, #1
LR__0451
	mov	result1, _var02
	mov	arg01, arg02
	add	arg01, #12
	add	result1, arg01
	wrbyte	_var04, result1
	add	_var02, #1
	jmp	#LR__0450
LR__0452
	add	arg02, #12
	add	_var02, arg02
	wrbyte	#0, _var02
	add	_var01, #28
	rdlong	_var04, _var01
	add	_var04, #11
	rdbyte	_var04, _var04
	and	_var04, #63
	sub	arg02, #4
	wrbyte	_var04, arg02
	sub	arg02, #8
	rdlong	arg01, _var01
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	wrlong	result1, arg02
	rdlong	arg01, _var01
	add	arg01, #22
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	arg02, #6
	wrword	result1, arg02
	rdlong	arg01, _var01
	add	arg01, #24
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	arg02, #2
	wrword	result1, arg02
LR__0453
_fatfs_cc_get_fileinfo_ret
	ret

_fatfs_cc_create_name
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg02
	rdlong	local02, local01
	mov	local03, arg01
	add	local03, #32
	mov	arg01, local03
	mov	arg02, #32
	mov	arg03, #11
	mov	local04, arg01
	call	#\builtin_bytefill_
	mov	result1, local04
	mov	local05, #0
	mov	local06, #0
	mov	local07, #8
' 
' 
' 	p = *path; sfn = dp->fn;
' 	__builtin_memset(sfn, ' ', 11) ;
' 	si = i = 0; ni = 8;
' #line 2970 "ff.c"
' 	for (;;) {
LR__0460
	mov	local08, local06
	mov	local09, local02
	add	local08, local02
	rdbyte	local08, local08
	getbyte	arg03, local08, #0
	cmp	arg03, #33 wc
	add	local06, #1
 if_b	jmp	#LR__0468
	getbyte	arg03, local08, #0
	cmp	arg03, #47 wz
 if_ne	mov	local10, local08
 if_ne	getbyte	local10, local10, #0
 if_ne	cmp	local10, #92 wz
 if_ne	jmp	#LR__0462
' 			while ( ((p[si]) == '/' || (p[si]) == '\\') ) si++;
LR__0461
	mov	local10, local06
	add	local10, local02
	rdbyte	local10, local10
	cmp	local10, #47 wz
 if_ne	mov	local11, local06
 if_ne	add	local11, local02
 if_ne	rdbyte	local09, local11
 if_ne	cmp	local09, #92 wz
 if_ne	jmp	#LR__0468
	add	local06, #1
	jmp	#LR__0461
' 			break;
LR__0462
	getbyte	local09, local08, #0
	cmp	local09, #46 wz
 if_ne	cmp	local05, local07 wc
 if_c_and_nz	jmp	#LR__0465
	cmp	local07, #11 wz
 if_e	jmp	#LR__0463
	getbyte	local08, local08, #0
	cmp	local08, #46 wz
 if_e	jmp	#LR__0464
LR__0463
	mov	result1, #6
	jmp	#LR__0469
LR__0464
	mov	local05, #8
	mov	local07, #11
' 			i = 8; ni = 11;
' 			continue;
	jmp	#LR__0460
LR__0465
	getbyte	local09, local08, #0
	cmp	local09, #128 wc
 if_ae	getbyte	local08, local08, #0
 if_ae	and	local08, #127
 if_ae	add	local08, ptr__fatfs_cc_dat__
 if_ae	rdbyte	local08, local08
	mov	arg01, local08
	zerox	arg01, #7 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0466
	mov	local09, local06
	add	local09, local02
	rdbyte	local12, local09
	mov	arg01, local12
	add	local06, #1
	zerox	arg01, #7 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_ne	mov	local10, local07
 if_ne	sub	local10, #1
 if_ne	cmp	local05, local10 wc
 if_nc_or_z	mov	result1, #6
 if_nc_or_z	jmp	#LR__0469
	mov	local09, local05
	add	local09, local03
	wrbyte	local08, local09
	add	local05, #1
	mov	local09, local05
	add	local09, local03
	wrbyte	local12, local09
	add	local05, #1
	jmp	#LR__0460
LR__0466
	mov	arg01, ##@LR__2096
	getbyte	arg02, local08, #0
	call	#_fatfs_cc_strchr
	cmp	result1, #0 wz
 if_ne	mov	result1, #6
 if_ne	jmp	#LR__0469
	getbyte	local09, local08, #0
	cmp	local09, #97 wc
 if_b	jmp	#LR__0467
	getbyte	local10, local08, #0
	cmp	local10, #123 wc
 if_b	getbyte	local08, local08, #0
 if_b	sub	local08, #32
LR__0467
	mov	local09, local05
	add	local09, local03
	wrbyte	local08, local09
	add	local05, #1
	jmp	#LR__0460
LR__0468
	mov	local13, local06
	add	local13, local02
	wrlong	local13, local01
	cmp	local05, #0 wz
 if_e	mov	result1, #6
 if_e	jmp	#LR__0469
	rdbyte	local14, local03
	cmp	local14, #229 wz
 if_e	wrbyte	#5, local03
	getbyte	local10, local08, #0
	cmp	local10, #33 wc
 if_ae	add	local06, local02
 if_ae	rdbyte	local13, local06
 if_ae	cmp	local13, #33 wc
 if_b	mov	local14, #4
 if_ae	mov	local14, #0
	add	local03, #11
	wrbyte	local14, local03
' 	sfn[ 11 ] = (c <= ' ' || p[si] <= ' ') ?  0x04  : 0;
' 
' 	return FR_OK;
	mov	result1, #0
LR__0469
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_name_ret
	ret

_fatfs_cc_follow_path
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	result1, fp
	rdlong	local01, result1
	add	fp, #16
	wrlong	local01, fp
	sub	fp, #20
	callpa	#(@LR__0472-@LR__0470)>>2,fcache_load_ptr_
' )
' {
' 	FRESULT res;
' 	BYTE ns;
' 	FATFS *fs = dp->obj.fs;
' #line 3034 "ff.c"
' 	{
' 		while ( ((*path) == '/' || (*path) == '\\') ) path++;
LR__0470
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	rdbyte	local01, local01
	cmp	local01, #47 wz
 if_e	jmp	#LR__0471
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	rdbyte	local01, local01
	cmp	local01, #92 wz
 if_ne	jmp	#LR__0473
LR__0471
	add	fp, #8
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	sub	fp, #8
	jmp	#LR__0470
LR__0472
LR__0473
	add	fp, #4
	rdlong	local01, fp
	add	local01, #8
	wrlong	#0, local01
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #8
	rdbyte	local01, local01
	cmp	local01, #32 wc
 if_ae	jmp	#LR__0474
	add	fp, #4
	rdlong	local01, fp
	add	local01, #43
	wrbyte	#128, local01
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	jmp	#LR__0478
LR__0474
' 		for (;;) {
LR__0475
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	mov	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_create_name
	add	fp, #12
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #12
 if_ne	jmp	#LR__0477
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	call	#_fatfs_cc_dir_find
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #8
	rdlong	local01, fp
	add	local01, #43
	rdbyte	local01, local01
	add	fp, #12
	wrbyte	local01, fp
	sub	fp, #4
	rdlong	local01, fp wz
	sub	fp, #12
 if_e	jmp	#LR__0476
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #4 wz
 if_ne	jmp	#LR__0477
	add	fp, #16
	rdbyte	local01, fp
	sub	fp, #16
	test	local01, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#5, fp
 if_e	sub	fp, #12
' 					}
' 				}
' 				break;
	jmp	#LR__0477
LR__0476
	add	fp, #16
	rdbyte	local01, fp
	sub	fp, #16
	test	local01, #4 wz
 if_ne	jmp	#LR__0477
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #6
	rdbyte	local01, local01
	test	local01, #16 wz
 if_e	add	fp, #12
 if_e	wrlong	#5, fp
 if_e	sub	fp, #12
' 				res = FR_NO_PATH; break;
 if_e	jmp	#LR__0477
	add	fp, #4
	rdlong	local02, fp
	mov	local01, local02
	add	fp, #16
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg02, #48
	sub	fp, #20
	add	local02, #16
	rdlong	local02, local02
	and	local02, #511
	add	arg02, local02
	call	#_fatfs_cc_ld_clust
	add	local01, #8
	wrlong	result1, local01
	jmp	#LR__0475
LR__0477
LR__0478
' 			}
' #line 3090 "ff.c"
' 			{
' 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr %  ((UINT) 512 ) );
' 			}
' 		}
' 	}
' 
' 	return res;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_follow_path_ret
	ret

_fatfs_cc_get_ldnumber
	neg	_var01, #1
	rdlong	_var02, arg01 wz
	mov	_var03, _var02
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_get_ldnumber_ret
	callpa	#(@LR__0481-@LR__0480)>>2,fcache_load_ptr_
' 	do tc = *tt++; while (! ((UINT)(tc) < ( 0 ? ' ' : '!'))  && tc != ':');
LR__0480
	rdbyte	_var04, _var03
	getbyte	result1, _var04, #0
	cmp	result1, #33 wc
	add	_var03, #1
 if_ae	mov	_var05, _var04
 if_ae	getbyte	_var05, _var05, #0
 if_ae	cmp	_var05, #58 wz
 if_a	jmp	#LR__0480
LR__0481
	getbyte	_var04, _var04, #0
	cmp	_var04, #58 wz
 if_ne	jmp	#LR__0483
	mov	_var06, #1
	rdbyte	_var05, _var02
	cmp	_var05, #48 wc
 if_b	jmp	#LR__0482
	rdbyte	_var05, _var02
	cmp	_var05, #58 wc
 if_b	mov	_var07, _var02
 if_b	add	_var07, #2
 if_b	cmp	_var07, _var03 wz
 if_c_and_z	mov	_var06, _var05
 if_c_and_z	sub	_var06, #48
LR__0482
	cmps	_var06, #1 wc
 if_b	mov	_var01, _var06
 if_b	wrlong	_var03, arg01
' 			vol = i;
' 			*path = tt;
' 		}
' 		return vol;
	mov	result1, _var01
	jmp	#_fatfs_cc_get_ldnumber_ret
LR__0483
' 	}
' #line 3170 "ff.c"
' 	vol = 0;
' 
' 	return vol;
	mov	result1, #0
_fatfs_cc_get_ldnumber_ret
	ret

_fatfs_cc_check_fs
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #41
	wrlong	##-1, local01
	sub	local01, #44
	mov	arg01, local01
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #4
 if_ne	jmp	#LR__0493
	add	local01, #48
	mov	arg01, local01
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	local02, arg01
	rdbyte	local03, local01
	sub	local01, #48
	getbyte	local04, local03, #0
	cmp	local04, #235 wz
 if_ne	mov	arg03, local03
 if_ne	getbyte	arg03, arg03, #0
 if_ne	cmp	arg03, #233 wz
 if_ne	getbyte	local03, local03, #0
 if_ne	cmp	local03, #232 wz
 if_ne	jmp	#LR__0492
	getword	local04, local02, #0
	cmp	local04, ##43605 wz
 if_ne	jmp	#LR__0490
	mov	arg01, local01
	add	arg01, #130
	mov	arg02, ##@LR__2097
	mov	arg03, #8
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
' 			return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__0493
LR__0490
	add	local01, #48
	mov	arg01, local01
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	local01, #13
	rdbyte	local03, local01
	sub	local01, #61
	getword	local04, result1, #0
	getword	arg02, result1, #0
	sub	arg02, #1
	test	local04, arg02 wz
 if_ne	jmp	#LR__0491
	getword	arg02, result1, #0
	cmp	arg02, ##512 wc
 if_b	jmp	#LR__0491
	getword	arg02, result1, #0
	cmp	arg02, ##513 wc
 if_ae	jmp	#LR__0491
	mov	arg01, local03
	zerox	arg01, #7 wz
 if_e	jmp	#LR__0491
	getbyte	arg01, local03, #0
	getbyte	local03, local03, #0
	sub	local03, #1
	test	arg01, local03 wz
 if_ne	jmp	#LR__0491
	mov	arg01, local01
	add	arg01, #62
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__0491
	add	local01, #64
	rdbyte	arg01, local01
	sub	local01, #64
	sub	arg01, #1
	cmp	arg01, #2 wc
 if_ae	jmp	#LR__0491
	mov	arg01, local01
	add	arg01, #65
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__0491
	mov	arg01, local01
	add	arg01, #67
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local03, result1, #0
	cmp	local03, #128 wc
 if_b	mov	arg01, local01
 if_b	add	arg01, #80
' {
' 
' 	return *((DWORD*)ptr);
 if_b	rdlong	result1, arg01
 if_b	cmp	result1, ##65536 wc
 if_ae	add	local01, #70
' {
' 
' 	return *((WORD*)ptr);
 if_ae	rdword	result1, local01 wz
' 			&& b != 0 && (b & (b - 1)) == 0
' 			&& ld_word(fs->win +  14 ) != 0
' 			&& (UINT)fs->win[ 16 ] - 1 <= 1
' 			&& ld_word(fs->win +  17 ) != 0
' 			&& (ld_word(fs->win +  19 ) >= 128 || ld_dword(fs->win +  32 ) >= 0x10000)
' 			&& ld_word(fs->win +  22 ) != 0) {
' 				return 0;
 if_a	mov	result1, #0
 if_a	jmp	#LR__0493
LR__0491
LR__0492
' 		}
' 	}
' 	return sign == 0xAA55 ? 2 : 3;
	getword	local03, local02, #0
	cmp	local03, ##43605 wz
 if_e	mov	local04, #2
 if_ne	mov	local04, #3
	mov	result1, local04
LR__0493
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_check_fs_ret
	ret

_fatfs_cc_find_volume
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #36
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_check_fs
	cmp	result1, #2 wz
 if_e	jmp	#LR__0500
	cmp	result1, #3 wc
 if_b	cmp	local02, #0 wz
 if_nc_or_z	jmp	#LR__0508
LR__0500
' 	for (i = 0; i < 4; i++) {
	mov	local03, #0
	callpa	#(@LR__0502-@LR__0501)>>2,fcache_load_ptr_
LR__0501
	cmp	local03, #4 wc
 if_ae	jmp	#LR__0503
	mov	local04, local03
	shl	local04, #2
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	mov	arg01, local01
	add	arg01, #494
	mov	arg02, local03
	shl	arg02, #4
	add	arg01, arg02
	add	arg01, #8
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	wrlong	result1, local04
	add	local03, #1
	jmp	#LR__0501
LR__0502
LR__0503
	cmp	local02, #0 wz
 if_ne	mov	local04, local02
 if_ne	sub	local04, #1
 if_e	mov	local04, #0
	mov	local03, local04
' 		mbr_pt[i] = ld_dword(fs->win +  446  + i *  16  +  8 );
' 	}
' 	i = part ? part - 1 : 0;
' 	do {
LR__0504
	mov	local04, local03
	shl	local04, #2
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	rdlong	local04, local04 wz
 if_e	jmp	#LR__0505
	mov	local04, local03
	shl	local04, #2
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	rdlong	arg02, local04
	mov	arg01, local01
	call	#_fatfs_cc_check_fs
	mov	local04, result1
	jmp	#LR__0506
LR__0505
	mov	local04, #3
LR__0506
	mov	local05, local04
	cmp	local02, #0 wz
 if_e	cmp	local05, #2 wc
 if_c_and_z	jmp	#LR__0507
 if_e	add	local03, #1
 if_e	cmp	local03, #4 wc
 if_c_and_z	jmp	#LR__0504
LR__0507
' 	return fmt;
	mov	result1, local05
LR__0508
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_find_volume_ret
	ret

_fatfs_cc_mount_volume
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	wrlong	#0, local01
	call	#_fatfs_cc_get_ldnumber
	mov	local03, result1
	cmps	local03, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__0519
	mov	arg03, local03
	shl	arg03, #2
	add	arg03, objptr
	rdlong	local04, arg03 wz
 if_e	mov	result1, #12
 if_e	jmp	#LR__0519
	wrlong	local04, local01
	getbyte	local02, local02, #0
	and	local02, #254
	rdbyte	arg03, local04 wz
 if_e	jmp	#LR__0511
	add	local04, #1
	rdbyte	arg01, local04 wz
	sub	local04, #1
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #36
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #36
	getbyte	arg03, result1, #0
	test	arg03, #1 wz
 if_ne	jmp	#LR__0510
	cmp	local02, #0 wz
 if_ne	getbyte	result1, result1, #0
 if_ne	test	result1, #4 wz
' 				return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__0519
' 			}
' 			return FR_OK;
	mov	result1, #0
	jmp	#LR__0519
LR__0510
LR__0511
	wrbyte	#0, local04
	add	local04, #1
	wrbyte	local03, local04
	getbyte	arg01, local03, #0
	sub	local04, #1
	call	#_fatfs_cc_disk_initialize
	mov	arg03, result1
	getbyte	local05, arg03, #0
	test	local05, #1 wz
' 		return FR_NOT_READY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__0519
	cmp	local02, #0 wz
 if_ne	mov	local05, arg03
 if_ne	getbyte	local05, local05, #0
 if_ne	test	local05, #4 wz
' 		return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__0519
	mov	arg01, local04
	mov	arg02, #0
	call	#_fatfs_cc_find_volume
	mov	arg01, result1
	cmp	arg01, #4 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__0519
	cmp	arg01, #2 wc
 if_ae	mov	result1, #13
 if_ae	jmp	#LR__0519
	add	local04, #44
	rdlong	local06, local04
	add	local04, #4
	mov	arg01, local04
	sub	local04, #48
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	cmp	result1, ##512 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__0519
	mov	arg01, local04
	add	arg01, #70
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local07, result1 wz
 if_e	mov	arg01, local04
 if_e	add	arg01, #84
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	mov	local07, result1
	add	local04, #24
	wrlong	local07, local04
	add	local04, #40
	rdbyte	local05, local04
	sub	local04, #62
	wrbyte	local05, local04
	getbyte	local05, local05, #0
	sub	local04, #2
	cmp	local05, #1 wz
 if_ne	add	local04, #2
 if_ne	rdbyte	local05, local04
 if_ne	sub	local04, #2
 if_ne	cmp	local05, #2 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__0519
	add	local04, #2
	rdbyte	local05, local04
	qmul	local07, local05
	add	local04, #59
	rdbyte	local05, local04
	sub	local04, #51
	wrword	local05, local04
	getword	local05, local05, #0
	sub	local04, #10
	zerox	local05, #15 wz
	getqx	local07
 if_e	jmp	#LR__0512
	add	local04, #10
	rdword	local05, local04
	getword	local03, local05, #0
	sub	local04, #10
	getword	local05, local05, #0
	sub	local05, #1
	test	local03, local05 wz
 if_e	jmp	#LR__0513
LR__0512
	mov	result1, #13
	jmp	#LR__0519
LR__0513
	add	local04, #48
	mov	arg01, local04
	add	arg01, #17
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	local04, #40
	wrword	result1, local04
	getword	local05, result1, #0
	sub	local04, #8
	abs	arg01, local05 wc
	getnib	arg01, arg01, #0
	negc	arg01, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__0519
	mov	arg01, local04
	add	arg01, #67
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local08, result1 wz
 if_e	mov	arg01, local04
 if_e	add	arg01, #80
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	local08, arg01
	mov	arg01, local04
	add	arg01, #62
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	arg01, result1
	mov	local05, arg01
	zerox	local05, #15 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__0519
	getword	local09, arg01, #0
	add	local09, local07
	add	local04, #8
	rdword	local05, local04
	sub	local04, #8
	abs	local05, local05 wc
	shr	local05, #4
	sumc	local09, local05
	cmp	local08, local09 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__0519
	sub	local08, local09
	add	local04, #10
	rdword	local05, local04
	qdiv	local08, local05
	sub	local04, #10
	getqx	local05
	cmp	local05, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__0519
	mov	local10, #0
	cmp	local05, ##268435446 wc
 if_b	mov	local10, #3
	cmp	local05, ##65526 wc
 if_b	mov	local10, #2
	cmp	local05, ##4086 wc
 if_b	mov	local10, #1
	cmp	local10, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__0519
	add	local05, #2
	add	local04, #20
	wrlong	local05, local04
	add	local04, #8
	wrlong	local06, local04
	mov	local05, local06
	getword	arg01, arg01, #0
	add	local05, arg01
	add	local04, #4
	wrlong	local05, local04
	mov	local05, local06
	add	local05, local09
	add	local04, #8
	wrlong	local05, local04
	sub	local04, #40
	cmp	local10, #3 wz
 if_ne	jmp	#LR__0514
	mov	arg01, local04
	add	arg01, #90
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__0519
	add	local04, #8
	rdword	local05, local04 wz
	sub	local04, #8
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__0519
	add	local04, #48
	mov	arg01, local04
	add	arg01, #44
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local04, #12
	wrlong	result1, local04
	sub	local04, #16
	rdlong	local11, local04
	sub	local04, #20
	shl	local11, #2
	jmp	#LR__0516
LR__0514
	add	local04, #8
	rdword	local05, local04 wz
	sub	local04, #8
 if_e	mov	result1, #13
 if_e	jmp	#LR__0519
	add	local04, #32
	rdlong	local05, local04
	add	local05, local07
	add	local04, #4
	wrlong	local05, local04
	sub	local04, #36
	cmp	local10, #2 wz
 if_e	add	local04, #20
 if_e	rdlong	local05, local04
 if_e	sub	local04, #20
 if_e	shl	local05, #1
 if_e	jmp	#LR__0515
	add	local04, #20
	rdlong	local11, local04
	mov	local05, local11
	shl	local05, #1
	add	local05, local11
	shr	local05, #1
	sub	local04, #20
	and	local11, #1
	add	local05, local11
LR__0515
	mov	local11, local05
LR__0516
	add	local11, #511
	shr	local11, #9
	add	local04, #24
	rdlong	arg03, local04
	sub	local04, #24
	cmp	arg03, local11 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__0519
	add	local04, #16
	wrlong	##-1, local04
	sub	local04, #4
	wrlong	##-1, local04
	sub	local04, #8
	wrbyte	#128, local04
	sub	local04, #4
	cmp	local10, #3 wz
 if_e	mov	arg01, local04
 if_e	add	arg01, #96
' {
' 
' 	return *((WORD*)ptr);
 if_e	rdword	result1, arg01
 if_e	getword	local05, result1, #0
 if_e	cmp	local05, #1 wz
 if_ne	jmp	#LR__0518
	add	local06, #1
	mov	arg01, local04
	mov	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0518
	add	local04, #4
	wrbyte	#0, local04
	add	local04, #44
	mov	arg01, local04
	sub	local04, #48
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local05, result1, #0
	cmp	local05, ##43605 wz
 if_e	mov	arg01, local04
 if_e	add	arg01, #48
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	cmp	result1, ##1096897106 wz
 if_e	mov	arg01, local04
 if_e	add	arg01, ##532
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	cmp	result1, ##1631679090 wz
 if_ne	jmp	#LR__0517
	add	local04, #48
	mov	arg01, local04
	add	arg01, #488
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local04, #32
	wrlong	result1, local04
	add	local04, #32
	mov	arg01, local04
	add	arg01, #492
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local04, #36
	wrlong	result1, local04
	sub	local04, #12
LR__0517
LR__0518
	wrbyte	local10, local04
	add	objptr, #4
	rdword	local05, objptr
	add	local05, #1
	wrword	local05, objptr
	getword	local11, local05, #0
	sub	objptr, #4
	add	local04, #6
	wrword	local11, local04
' 				&& ld_dword(fs->win +  0 ) == 0x41615252
' 				&& ld_dword(fs->win +  484 ) == 0x61417272)
' 			{
' 
' 				fs->free_clst = ld_dword(fs->win +  488 );
' 
' 
' 				fs->last_clst = ld_dword(fs->win +  492 );
' 
' 			}
' 		}
' 
' 
' 	}
' 
' 	fs->fs_type = (BYTE)fmt;
' 	fs->id = ++Fsid;
' #line 3567 "ff.c"
' 	return FR_OK;
	mov	result1, #0
LR__0519
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mount_volume_ret
	ret

_fatfs_cc_validate
	mov	_var01, arg01 wz
	mov	_var02, #9
 if_ne	rdlong	_var03, _var01 wz
 if_ne	rdbyte	_var04, _var03 wz
 if_e	jmp	#LR__0520
	add	_var01, #4
	rdword	_var04, _var01
	sub	_var01, #4
	rdlong	arg01, _var01
	add	arg01, #6
	rdword	result1, arg01
	cmp	_var04, result1 wz
 if_ne	jmp	#LR__0520
	rdlong	_var04, _var01
	add	_var04, #1
	rdbyte	arg01, _var04 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #36
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #36
	getbyte	_var03, result1, #0
	test	_var03, #1 wz
 if_e	mov	_var02, #0
LR__0520
	cmp	_var02, #0 wz
 if_e	rdlong	_var03, _var01
 if_ne	mov	_var03, #0
	wrlong	_var03, arg02
' 			res = FR_OK;
' 		}
' 
' 	}
' 	*rfs = (res == FR_OK) ? obj->fs : 0;
' 	return res;
	mov	result1, _var02
_fatfs_cc_validate_ret
	ret

_fatfs_cc_f_mount
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #32
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrbyte	arg03, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	fp, #20
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #28
	call	#_fatfs_cc_get_ldnumber
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmps	result1, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__0531
	add	fp, #20
	rdlong	arg03, fp
	shl	arg03, #2
	add	arg03, objptr
	rdlong	arg03, arg03 wz
	sub	fp, #4
	wrlong	arg03, fp
	sub	fp, #16
 if_e	jmp	#LR__0530
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #16
	add	arg03, #1
	rdbyte	arg01, arg03
	call	#_fatfs_cc_disk_deinitialize
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #16
	wrbyte	#0, arg03
LR__0530
	add	fp, #4
	rdlong	local01, fp wz
	sub	fp, #4
 if_ne	add	fp, #4
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #4
 if_ne	wrbyte	#0, local01
	add	fp, #20
	rdlong	local01, fp
	shl	local01, #2
	add	local01, objptr
	sub	fp, #16
	rdlong	arg03, fp
	wrlong	arg03, local01
	add	fp, #8
	rdbyte	local01, fp wz
	sub	fp, #12
 if_e	mov	result1, #0
 if_e	jmp	#LR__0531
	add	fp, #8
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, fp
	sub	fp, #4
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	add	fp, #24
	wrlong	result1, fp
' 
' 	res = mount_volume(&path, &fs, 0);
' 	return res ;
	sub	fp, #24
LR__0531
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mount_ret
	ret

_fatfs_cc_f_open
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #92
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrbyte	arg03, fp
	sub	fp, #8
	rdlong	arg04, fp wz
	sub	fp, #4
 if_e	mov	result1, #9
 if_e	jmp	#LR__0557
	add	fp, #12
	rdbyte	arg04, fp
	and	arg04, #63
	wrbyte	arg04, fp
	sub	fp, #4
	mov	arg01, fp
	add	fp, #56
	mov	arg02, fp
	getbyte	arg03, arg04, #0
	sub	fp, #64
	call	#_fatfs_cc_mount_volume
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0556
	add	fp, #64
	rdlong	arg04, fp
	sub	fp, #44
	wrlong	arg04, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #8
	mov	arg02, local01
	call	#_fatfs_cc_follow_path
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0540
	add	fp, #63
	rdbyte	arg04, fp
	sub	fp, #63
	test	arg04, #128 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #16
LR__0540
	add	fp, #12
	rdbyte	arg04, fp
	sub	fp, #12
	test	arg04, #28 wz
 if_e	jmp	#LR__0545
	add	fp, #16
	rdlong	local01, fp wz
	sub	fp, #16
 if_e	jmp	#LR__0542
	add	fp, #16
	rdlong	arg04, fp
	sub	fp, #16
	cmp	arg04, #4 wz
 if_ne	jmp	#LR__0541
	mov	arg01, fp
	add	arg01, #20
	call	#_fatfs_cc_dir_register
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
LR__0541
	add	fp, #12
	rdbyte	local01, fp
	or	local01, #8
	wrbyte	local01, fp
	sub	fp, #12
	jmp	#LR__0544
LR__0542
	add	fp, #26
	rdbyte	local01, fp
	sub	fp, #26
	test	local01, #17 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#7, fp
 if_ne	sub	fp, #16
 if_ne	jmp	#LR__0543
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	test	local01, #4 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#8, fp
 if_ne	sub	fp, #16
LR__0543
LR__0544
	add	fp, #16
	rdlong	local01, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__0548
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	test	local01, #8 wz
 if_e	jmp	#LR__0548
	call	#_fatfs_cc__get_fattime
	add	fp, #80
	wrlong	result1, fp
	sub	fp, #32
	rdlong	arg01, fp
	add	arg01, #14
	wrlong	result1, arg01
	rdlong	arg01, fp
	add	arg01, #22
	add	fp, #32
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	add	fp, #68
	wrlong	result1, fp
	sub	fp, #20
	rdlong	local01, fp
	add	local01, #11
	wrbyte	#32, local01
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	rdlong	arg02, fp
	sub	fp, #48
	mov	arg03, #0
	call	#_fatfs_cc_st_clust
	add	fp, #48
	rdlong	arg01, fp
	add	arg01, #28
	wrlong	#0, arg01
	add	fp, #16
	rdlong	local01, fp
	add	local01, #3
	wrbyte	#1, local01
	add	fp, #4
	rdlong	local01, fp wz
	sub	fp, #68
 if_e	jmp	#LR__0548
	add	fp, #64
	rdlong	local01, fp
	add	local01, #44
	rdlong	local01, local01
	add	fp, #20
	wrlong	local01, fp
	sub	fp, #64
	mov	arg01, fp
	add	fp, #48
	rdlong	arg02, fp
	sub	fp, #68
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0548
	add	fp, #64
	rdlong	arg01, fp
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #84
	call	#_fatfs_cc_move_window
	add	fp, #16
	wrlong	result1, fp
	add	fp, #48
	rdlong	arg04, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #68
	sub	local01, #1
	add	arg04, #12
	wrlong	local01, arg04
	jmp	#LR__0548
LR__0545
	add	fp, #16
	rdlong	arg04, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__0547
	add	fp, #26
	rdbyte	arg04, fp
	sub	fp, #26
	test	arg04, #16 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#4, fp
 if_ne	sub	fp, #16
 if_ne	jmp	#LR__0546
	add	fp, #12
	rdbyte	arg04, fp
	sub	fp, #12
	test	arg04, #2 wz
 if_ne	add	fp, #26
 if_ne	rdbyte	local01, fp
 if_ne	sub	fp, #26
 if_ne	test	local01, #1 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#7, fp
 if_ne	sub	fp, #16
LR__0546
LR__0547
LR__0548
	add	fp, #16
	rdlong	local01, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__0549
	add	fp, #12
	rdbyte	local02, fp
	sub	fp, #12
	test	local02, #8 wz
 if_ne	add	fp, #12
 if_ne	rdbyte	local02, fp
 if_ne	or	local02, #64
 if_ne	wrbyte	local02, fp
 if_ne	sub	fp, #12
	add	fp, #4
	rdlong	local02, fp
	add	fp, #60
	rdlong	local01, fp
	add	local01, #44
	rdlong	local01, local01
	add	local02, #32
	wrlong	local01, local02
	sub	fp, #60
	rdlong	local02, fp
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #48
	add	local02, #36
	wrlong	local01, local02
LR__0549
	add	fp, #16
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__0555
	add	fp, #4
	rdlong	local02, fp
	add	fp, #60
	rdlong	arg01, fp
	sub	fp, #16
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	add	local02, #8
	wrlong	result1, local02
	add	fp, #4
	rdlong	local02, fp
	add	fp, #44
	rdlong	arg01, fp
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	add	local02, #12
	wrlong	result1, local02
	sub	fp, #44
	rdlong	local02, fp
	add	fp, #60
	rdlong	local01, fp
	wrlong	local01, local02
	sub	fp, #60
	rdlong	local02, fp
	add	fp, #60
	rdlong	local01, fp
	add	local01, #6
	rdword	local01, local01
	add	local02, #4
	wrword	local01, local02
	sub	fp, #60
	rdlong	local02, fp
	add	fp, #8
	rdbyte	local01, fp
	add	local02, #16
	wrbyte	local01, local02
	sub	fp, #8
	rdlong	local02, fp
	add	local02, #17
	wrbyte	#0, local02
	rdlong	local02, fp
	add	local02, #28
	wrlong	#0, local02
	rdlong	local02, fp
	add	local02, #20
	wrlong	#0, local02
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #40
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	add	fp, #12
	rdbyte	local02, fp
	sub	fp, #12
	test	local02, #32 wz
 if_e	jmp	#LR__0554
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #12
	rdlong	local02, local01
	cmp	local02, #1 wc
 if_b	jmp	#LR__0554
	add	fp, #4
	rdlong	local01, fp
	mov	local02, local01
	add	local01, #12
	rdlong	local01, local01
	add	local02, #20
	wrlong	local01, local02
	add	fp, #60
	rdlong	local02, fp
	add	local02, #10
	rdword	local02, local02
	shl	local02, #9
	add	fp, #8
	wrlong	local02, fp
	sub	fp, #68
	rdlong	local02, fp
	add	local02, #8
	rdlong	local01, local02
	add	fp, #72
	wrlong	local01, fp
' 				fp->fptr = fp->obj.objsize;
' 				bcs = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 				clst = fp->obj.sclust;
' 				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
	sub	fp, #72
	rdlong	local02, fp
	add	local02, #12
	rdlong	local01, local02
	add	fp, #84
	wrlong	local01, fp
	sub	fp, #88
LR__0550
	add	fp, #16
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__0551
	add	fp, #88
	rdlong	local02, fp
	sub	fp, #16
	rdlong	local01, fp
	sub	fp, #72
	cmp	local02, local01 wcz
 if_be	jmp	#LR__0551
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #72
	rdlong	arg02, fp
	sub	fp, #76
	call	#_fatfs_cc_get_fat
	add	fp, #76
	wrlong	result1, fp
	sub	fp, #76
	cmp	result1, #2 wc
 if_b	add	fp, #16
 if_b	wrlong	#2, fp
 if_b	sub	fp, #16
	add	fp, #76
	rdlong	local02, fp
	sub	fp, #76
	cmp	local02, ##-1 wz
 if_e	add	fp, #16
 if_e	wrlong	#1, fp
 if_e	sub	fp, #16
	add	fp, #88
	rdlong	local02, fp
	sub	fp, #16
	rdlong	local01, fp
	sub	local02, local01
	add	fp, #16
	wrlong	local02, fp
	sub	fp, #88
	jmp	#LR__0550
LR__0551
	add	fp, #4
	rdlong	local02, fp
	add	fp, #72
	rdlong	local01, fp
	add	local02, #24
	wrlong	local01, local02
	sub	fp, #60
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__0553
	add	fp, #88
	rdlong	local01, fp
	sub	fp, #88
	test	local01, #511 wz
 if_e	jmp	#LR__0553
	add	fp, #64
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #76
	call	#_fatfs_cc_clst2sect
	add	fp, #84
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #84
 if_e	add	fp, #16
 if_e	wrlong	#2, fp
 if_e	sub	fp, #16
 if_e	jmp	#LR__0552
	add	fp, #4
	rdlong	local02, fp
	add	fp, #80
	rdlong	local01, fp
	add	fp, #4
	rdlong	arg04, fp
	shr	arg04, #9
	add	local01, arg04
	add	local02, #28
	wrlong	local01, local02
	sub	fp, #24
	rdlong	local02, fp
	add	local02, #1
	rdbyte	arg01, local02
	sub	fp, #60
	rdlong	local02, fp
	mov	arg02, local02
	add	arg02, #40
	sub	fp, #4
	add	local02, #28
	rdlong	arg03, local02
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#1, fp
 if_ne	sub	fp, #16
LR__0552
LR__0553
LR__0554
LR__0555
LR__0556
	add	fp, #16
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	add	fp, #4
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #4
 if_ne	wrlong	#0, local02
' 
' 	return res ;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
LR__0557
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_open_ret
	ret

_fatfs_cc_f_read
	mov	COUNT_, #14
	call	#pushregs_
	add	ptra, #56
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	rdlong	result1, fp
	add	fp, #44
	wrlong	result1, fp
	sub	fp, #36
	rdlong	result1, fp
	wrlong	#0, result1
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #20
	mov	arg02, fp
	sub	fp, #24
	call	#_fatfs_cc_validate
	add	fp, #20
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #20
 if_ne	jmp	#LR__0560
	add	fp, #4
	rdlong	arg02, fp
	add	arg02, #17
	rdbyte	arg02, arg02 wz
	add	fp, #16
	wrlong	arg02, fp
	sub	fp, #20
 if_e	jmp	#LR__0561
LR__0560
	add	fp, #20
	rdlong	result1, fp
	sub	fp, #20
	jmp	#LR__0580
LR__0561
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__0580
	add	fp, #4
	rdlong	local01, fp
	mov	local02, local01
	add	local02, #12
	rdlong	local03, local02
	add	local01, #20
	rdlong	local01, local01
	sub	local03, local01
	add	fp, #32
	wrlong	local03, fp
	sub	fp, #24
	rdlong	local04, fp
	sub	fp, #12
	cmp	local04, local03 wcz
 if_a	add	fp, #36
 if_a	rdlong	local04, fp
 if_a	sub	fp, #24
 if_a	wrlong	local04, fp
 if_a	sub	fp, #12
' 
' 	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
LR__0562
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	mov	local04, local02
	cmp	local04, #1 wc
 if_b	jmp	#LR__0579
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #20
	rdlong	local03, local03
	test	local03, #511 wz
 if_ne	jmp	#LR__0577
	add	fp, #4
	rdlong	local01, fp
	add	local01, #20
	rdlong	local03, local01
	shr	local03, #9
	add	fp, #20
	rdlong	local05, fp
	mov	local06, local05
	add	local06, #10
	rdword	local07, local06
	sub	local06, #10
	getword	local08, local07, #0
	sub	local08, #1
	and	local03, local08 wz
	add	fp, #24
	wrlong	local03, fp
	sub	fp, #48
 if_ne	jmp	#LR__0567
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #20
	rdlong	local03, local03 wz
 if_ne	jmp	#LR__0563
	add	fp, #4
	rdlong	local03, fp
	add	local03, #8
	rdlong	local03, local03
	add	fp, #24
	wrlong	local03, fp
	sub	fp, #28
	jmp	#LR__0564
LR__0563
	add	fp, #4
	rdlong	local08, fp
	mov	arg01, local08
	sub	fp, #4
	add	local08, #24
	rdlong	arg02, local08
	call	#_fatfs_cc_get_fat
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
LR__0564
	add	fp, #28
	rdlong	local03, fp
	sub	fp, #28
	cmp	local03, #2 wc
 if_ae	jmp	#LR__0565
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#2, local03
	mov	result1, #2
	jmp	#LR__0580
LR__0565
	add	fp, #28
	rdlong	local03, fp
	sub	fp, #28
	cmp	local03, ##-1 wz
 if_ne	jmp	#LR__0566
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__0580
LR__0566
	add	fp, #4
	rdlong	local03, fp
	add	fp, #24
	rdlong	local08, fp
	sub	fp, #28
	add	local03, #24
	wrlong	local08, local03
LR__0567
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #24
	rdlong	arg02, local03
	call	#_fatfs_cc_clst2sect
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0568
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#2, local03
	mov	result1, #2
	jmp	#LR__0580
LR__0568
	add	fp, #32
	rdlong	local03, fp
	add	fp, #16
	rdlong	local08, fp
	add	local03, local08
	sub	fp, #16
	wrlong	local03, fp
	sub	fp, #20
	rdlong	local03, fp
	shr	local03, #9
	add	fp, #32
	wrlong	local03, fp
	sub	fp, #44
	cmp	local03, #1 wc
 if_b	jmp	#LR__0572
	add	fp, #48
	rdlong	local03, fp
	sub	fp, #4
	rdlong	local08, fp
	add	local03, local08
	sub	fp, #20
	rdlong	local08, fp
	sub	fp, #24
	add	local08, #10
	rdword	local08, local08
	cmp	local03, local08 wcz
 if_be	jmp	#LR__0569
	add	fp, #24
	rdlong	local01, fp
	add	local01, #10
	rdword	local03, local01
	add	fp, #24
	rdlong	local08, fp
	sub	local03, local08
	sub	fp, #4
	wrlong	local03, fp
	sub	fp, #44
LR__0569
	add	fp, #24
	rdlong	local01, fp
	add	local01, #1
	rdbyte	arg01, local01
	add	fp, #28
	rdlong	arg02, fp
	sub	fp, #20
	rdlong	arg03, fp
	add	fp, #12
	rdlong	arg04, fp
	sub	fp, #44
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_e	jmp	#LR__0570
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__0580
LR__0570
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #16
	rdbyte	local03, local01
	test	local03, #128 wz
 if_e	jmp	#LR__0571
	add	fp, #4
	rdlong	local08, fp
	add	local08, #28
	rdlong	local08, local08
	add	fp, #28
	rdlong	local09, fp
	sub	local08, local09
	add	fp, #12
	rdlong	local10, fp
	sub	fp, #44
	mov	local11, local10
	cmp	local08, local11 wc
 if_ae	jmp	#LR__0571
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	local11, arg02
	add	local11, #28
	rdlong	local09, local11
	add	fp, #28
	rdlong	local05, fp
	sub	local09, local05
	shl	local09, #9
	mov	local11, local09
	add	arg01, local09
	sub	fp, #32
	add	arg02, #40
	decod	arg03, #9
	call	#__system____builtin_memmove
LR__0571
	add	fp, #44
	rdlong	local03, fp
	shl	local03, #9
	sub	fp, #4
	wrlong	local03, fp
	sub	fp, #40
' 					__builtin_memcpy(rbuff + ((fp->sect - sect) * ((UINT) 512 ) ), fp->buf, ((UINT) 512 ) ) ;
' 				}
' 
' 
' 				rcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__0578
LR__0572
	add	fp, #4
	rdlong	local03, fp
	add	local03, #28
	rdlong	local03, local03
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #32
	cmp	local03, local01 wz
 if_e	jmp	#LR__0576
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #16
	rdbyte	local03, local01
	test	local03, #128 wz
 if_e	jmp	#LR__0574
	add	fp, #24
	rdlong	local01, fp
	add	local01, #1
	rdbyte	arg01, local01
	sub	fp, #20
	rdlong	local03, fp
	mov	arg02, local03
	add	arg02, #40
	sub	fp, #4
	add	local03, #28
	rdlong	arg03, local03
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__0573
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__0580
LR__0573
	add	fp, #4
	rdlong	local11, fp
	mov	local03, local11
	sub	fp, #4
	add	local11, #16
	rdbyte	local11, local11
	and	local11, #127
	add	local03, #16
	wrbyte	local11, local03
LR__0574
	add	fp, #24
	rdlong	local01, fp
	add	local01, #1
	rdbyte	arg01, local01
	sub	fp, #20
	rdlong	arg02, fp
	add	arg02, #40
	add	fp, #28
	rdlong	arg03, fp
	sub	fp, #32
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_e	jmp	#LR__0575
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__0580
LR__0575
LR__0576
	add	fp, #4
	rdlong	local03, fp
	add	fp, #28
	rdlong	local11, fp
	sub	fp, #32
	add	local03, #28
	wrlong	local11, local03
LR__0577
	add	fp, #4
	rdlong	local01, fp
	add	local01, #20
	rdlong	local11, local01
	and	local11, #511
	decod	local03, #9
	sub	local03, local11
	add	fp, #36
	wrlong	local03, fp
	sub	fp, #28
	rdlong	local11, fp
	sub	fp, #12
	cmp	local03, local11 wcz
 if_a	add	fp, #12
 if_a	rdlong	local03, fp
 if_a	add	fp, #28
 if_a	wrlong	local03, fp
 if_a	sub	fp, #40
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	local06, fp
	mov	arg02, local06
	add	arg02, #40
	add	local06, #20
	rdlong	local11, local06
	mov	local09, local11
	mov	local10, local09
	and	local10, #511
	add	arg02, local10
	add	fp, #36
	rdlong	arg03, fp
	sub	fp, #40
	call	#__system____builtin_memmove
LR__0578
	add	fp, #12
	rdlong	local03, fp
	add	fp, #28
	rdlong	local08, fp
	sub	local03, local08
	sub	fp, #28
	wrlong	local03, fp
	add	fp, #4
	rdlong	local01, fp
	rdlong	local07, local01
	add	fp, #24
	rdlong	local08, fp
	add	local07, local08
	wrlong	local07, local01
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local12, fp
	add	local03, local12
	add	fp, #12
	wrlong	local03, fp
	sub	fp, #48
	rdlong	local13, fp
	mov	local03, local13
	add	local13, #20
	rdlong	local14, local13
	add	fp, #36
	rdlong	local06, fp
	sub	fp, #40
	add	local14, local06
	add	local03, #20
	wrlong	local14, local03
	jmp	#LR__0562
LR__0579
' 
' 
' 
' 
' 		__builtin_memcpy(rbuff, fp->buf + fp->fptr % ((UINT) 512 ) , rcnt) ;
' 
' 	}
' 
' 	return FR_OK ;
	mov	result1, #0
LR__0580
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_read_ret
	ret

_fatfs_cc_f_write
	mov	COUNT_, #21
	call	#pushregs_
	add	ptra, #52
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	rdlong	result1, fp
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #32
	rdlong	result1, fp
	wrlong	#0, result1
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #20
	mov	arg02, fp
	sub	fp, #24
	call	#_fatfs_cc_validate
	add	fp, #20
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #20
 if_ne	jmp	#LR__0590
	add	fp, #4
	rdlong	arg02, fp
	add	arg02, #17
	rdbyte	arg02, arg02 wz
	add	fp, #16
	wrlong	arg02, fp
	sub	fp, #20
 if_e	jmp	#LR__0591
LR__0590
	add	fp, #20
	rdlong	result1, fp
	sub	fp, #20
	jmp	#LR__0613
LR__0591
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	add	arg02, #16
	rdbyte	arg02, arg02
	test	arg02, #2 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__0613
	add	fp, #4
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg01, #20
	rdlong	arg01, arg01
	add	fp, #8
	rdlong	result1, fp
	add	arg01, result1
	sub	fp, #12
	add	arg02, #20
	rdlong	result1, arg02
	cmp	arg01, result1 wc
 if_ae	jmp	#LR__0592
	add	fp, #4
	rdlong	arg02, fp
	neg	result1, #1
	add	arg02, #20
	rdlong	arg02, arg02
	sub	result1, arg02
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #12
LR__0592
' 		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
' 	}
' 
' 	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
LR__0593
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	cmp	result1, #1 wc
 if_b	jmp	#LR__0612
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #20
	rdlong	result1, result1
	test	result1, #511 wz
 if_ne	jmp	#LR__0608
	add	fp, #4
	rdlong	result1, fp
	add	result1, #20
	rdlong	result1, result1
	shr	result1, #9
	add	fp, #20
	rdlong	arg02, fp
	add	arg02, #10
	rdword	arg04, arg02
	getword	arg02, arg04, #0
	sub	arg02, #1
	and	result1, arg02 wz
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #44
 if_ne	jmp	#LR__0599
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #20
	rdlong	arg02, result1 wz
 if_ne	jmp	#LR__0594
	add	fp, #4
	rdlong	arg02, fp
	add	arg02, #8
	rdlong	arg02, arg02 wz
	add	fp, #24
	wrlong	arg02, fp
	sub	fp, #28
 if_ne	jmp	#LR__0595
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	jmp	#LR__0595
LR__0594
	add	fp, #4
	rdlong	arg04, fp
	mov	arg01, arg04
	sub	fp, #4
	add	arg04, #24
	rdlong	arg02, arg04
	call	#_fatfs_cc_create_chain
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
LR__0595
	add	fp, #28
	rdlong	result1, fp wz
	sub	fp, #28
 if_e	jmp	#LR__0612
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #28
	cmp	result1, #1 wz
 if_ne	jmp	#LR__0596
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#2, result1
	mov	result1, #2
	jmp	#LR__0613
LR__0596
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #28
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__0597
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#1, result1
	mov	result1, #1
	jmp	#LR__0613
LR__0597
	add	fp, #4
	rdlong	result1, fp
	add	fp, #24
	rdlong	arg04, fp
	add	result1, #24
	wrlong	arg04, result1
	sub	fp, #24
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #8
	rdlong	result1, result1 wz
 if_ne	jmp	#LR__0598
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #28
	add	arg04, #8
	wrlong	result1, arg04
LR__0598
LR__0599
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #128 wz
 if_e	jmp	#LR__0601
	add	fp, #24
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	sub	fp, #20
	rdlong	arg04, fp
	mov	arg02, arg04
	add	arg02, #40
	sub	fp, #4
	add	arg04, #28
	rdlong	arg03, arg04
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__0600
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#1, result1
	mov	result1, #1
	jmp	#LR__0613
LR__0600
	add	fp, #4
	rdlong	arg04, fp
	mov	result1, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	result1, #16
	wrbyte	arg04, result1
LR__0601
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #4
	add	arg02, #24
	rdlong	arg02, arg02
	call	#_fatfs_cc_clst2sect
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0602
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#2, result1
	mov	result1, #2
	jmp	#LR__0613
LR__0602
	add	fp, #32
	rdlong	result1, fp
	add	fp, #12
	rdlong	local01, fp
	add	result1, local01
	sub	fp, #12
	wrlong	result1, fp
	sub	fp, #20
	rdlong	result1, fp
	shr	result1, #9
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #40
	cmp	result1, #1 wc
 if_b	jmp	#LR__0606
	add	fp, #44
	rdlong	result1, fp
	sub	fp, #4
	rdlong	arg04, fp
	add	result1, arg04
	sub	fp, #16
	rdlong	arg04, fp
	sub	fp, #24
	add	arg04, #10
	rdword	arg04, arg04
	cmp	result1, arg04 wcz
 if_be	jmp	#LR__0603
	add	fp, #24
	rdlong	result1, fp
	add	result1, #10
	rdword	result1, result1
	add	fp, #20
	rdlong	arg04, fp
	sub	result1, arg04
	sub	fp, #4
	wrlong	result1, fp
	sub	fp, #40
LR__0603
	add	fp, #24
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	add	fp, #24
	rdlong	arg02, fp
	sub	fp, #16
	rdlong	arg03, fp
	add	fp, #8
	rdlong	arg04, fp
	sub	fp, #40
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__0604
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #17
	wrbyte	#1, local01
	mov	result1, #1
	jmp	#LR__0613
LR__0604
	add	fp, #4
	rdlong	result1, fp
	add	result1, #28
	rdlong	result1, result1
	add	fp, #28
	rdlong	local02, fp
	sub	result1, local02
	add	fp, #8
	rdlong	arg04, fp
	sub	fp, #40
	cmp	result1, arg04 wc
 if_ae	jmp	#LR__0605
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #40
	add	fp, #44
	rdlong	arg02, fp
	sub	fp, #44
	rdlong	result1, fp
	add	result1, #28
	rdlong	local03, result1
	add	fp, #28
	rdlong	arg04, fp
	sub	fp, #32
	sub	local03, arg04
	shl	local03, #9
	add	arg02, local03
	decod	arg03, #9
	call	#__system____builtin_memmove
	add	fp, #4
	rdlong	arg04, fp
	mov	result1, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	result1, #16
	wrbyte	arg04, result1
LR__0605
	add	fp, #40
	rdlong	result1, fp
	shl	result1, #9
	sub	fp, #4
	wrlong	result1, fp
	sub	fp, #36
' 					__builtin_memcpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT) 512 ) ), ((UINT) 512 ) ) ;
' 					fp->flag &= (BYTE)~ 0x80 ;
' 				}
' 
' 
' 				wcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__0609
LR__0606
	add	fp, #4
	rdlong	local02, fp
	add	local02, #28
	rdlong	result1, local02
	add	fp, #28
	rdlong	local02, fp
	sub	fp, #32
	cmp	result1, local02 wz
 if_e	jmp	#LR__0607
	add	fp, #4
	rdlong	result1, fp
	mov	local03, result1
	sub	fp, #4
	add	local03, #20
	rdlong	local03, local03
	add	result1, #12
	rdlong	local04, result1
	mov	local05, local04
	cmp	local03, local05 wc
 if_ae	jmp	#LR__0607
	add	fp, #24
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	sub	fp, #20
	rdlong	local06, fp
	add	local06, #40
	mov	local07, local06
	add	fp, #28
	rdlong	local08, fp
	sub	fp, #32
	mov	local09, #1
	mov	arg02, local07
	mov	arg03, local08
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	mov	local10, result1 wz
 if_e	jmp	#LR__0607
	add	fp, #4
	rdlong	local10, fp
	sub	fp, #4
	add	local10, #17
	wrbyte	#1, local10
' 				fp->fptr < fp->obj.objsize &&
' 				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
' 					{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR ; } ;
	mov	result1, #1
	jmp	#LR__0613
LR__0607
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #32
	add	arg04, #28
	wrlong	result1, arg04
LR__0608
	add	fp, #4
	rdlong	result1, fp
	add	result1, #20
	rdlong	result1, result1
	and	result1, #511
	decod	local11, #9
	sub	local11, result1
	add	fp, #32
	wrlong	local11, fp
	sub	fp, #24
	rdlong	result1, fp
	sub	fp, #12
	cmp	local11, result1 wcz
 if_a	add	fp, #12
 if_a	rdlong	local11, fp
 if_a	add	fp, #24
 if_a	wrlong	local11, fp
 if_a	sub	fp, #36
	add	fp, #4
	rdlong	local11, fp
	mov	arg01, local11
	add	arg01, #40
	add	local11, #20
	rdlong	local11, local11
	and	local11, #511
	add	arg01, local11
	add	fp, #44
	rdlong	arg02, fp
	sub	fp, #12
	rdlong	arg03, fp
	sub	fp, #36
	call	#__system____builtin_memmove
	add	fp, #4
	rdlong	result1, fp
	mov	local11, result1
	sub	fp, #4
	add	result1, #16
	rdbyte	result1, result1
	or	result1, #128
	add	local11, #16
	wrbyte	result1, local11
LR__0609
	add	fp, #12
	rdlong	local11, fp
	add	fp, #24
	rdlong	result1, fp
	sub	local11, result1
	sub	fp, #24
	wrlong	local11, fp
	add	fp, #4
	rdlong	local12, fp
	rdlong	local11, local12
	add	fp, #20
	rdlong	local13, fp
	add	local11, local13
	wrlong	local11, local12
	add	fp, #12
	rdlong	local11, fp
	sub	fp, #12
	rdlong	local14, fp
	add	local11, local14
	add	fp, #12
	wrlong	local11, fp
	sub	fp, #44
	rdlong	local15, fp
	mov	local11, local15
	add	local15, #20
	rdlong	local15, local15
	add	fp, #32
	rdlong	local16, fp
	add	local15, local16
	add	local11, #20
	wrlong	local15, local11
	sub	fp, #32
	rdlong	local17, fp
	mov	local11, local17
	mov	local18, local17
	sub	fp, #4
	add	local17, #20
	rdlong	local19, local17
	add	local18, #12
	rdlong	local20, local18
	cmp	local19, local20 wcz
 if_be	jmp	#LR__0610
	add	fp, #4
	rdlong	local05, fp
	sub	fp, #4
	mov	local03, local05
	add	local03, #20
	rdlong	local04, local03
	sub	local03, #20
	mov	local21, local04
	jmp	#LR__0611
LR__0610
	add	fp, #4
	rdlong	local07, fp
	sub	fp, #4
	mov	local10, local07
	add	local10, #12
	rdlong	local08, local10
	sub	local10, #12
	mov	local21, local08
LR__0611
	add	local11, #12
	wrlong	local21, local11
	jmp	#LR__0593
LR__0612
	add	fp, #4
	rdlong	local12, fp
	mov	local01, local12
	sub	fp, #4
	add	local12, #16
	rdbyte	local11, local12
	or	local11, #64
	add	local01, #16
	wrbyte	local11, local01
' 
' 
' 
' 
' 
' 		__builtin_memcpy(fp->buf + fp->fptr % ((UINT) 512 ) , wbuff, wcnt) ;
' 		fp->flag |=  0x80 ;
' 
' 	}
' 
' 	fp->flag |=  0x40 ;
' 
' 	return FR_OK ;
	mov	result1, #0
LR__0613
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_write_ret
	ret

_fatfs_cc_f_sync
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #24
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_validate
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0623
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #64 wz
 if_e	jmp	#LR__0622
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #128 wz
 if_e	jmp	#LR__0620
	add	fp, #12
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	sub	fp, #8
	rdlong	arg04, fp
	mov	arg02, arg04
	add	arg02, #40
	sub	fp, #4
	add	arg04, #28
	rdlong	arg03, arg04
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__0624
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	arg03, #16
	wrbyte	arg04, arg03
LR__0620
	call	#_fatfs_cc__get_fattime
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #4
	rdlong	arg01, fp
	sub	fp, #8
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #32
	rdlong	arg02, arg04
	call	#_fatfs_cc_move_window
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0621
	add	fp, #4
	rdlong	arg04, fp
	add	arg04, #36
	rdlong	arg04, arg04
	add	fp, #16
	wrlong	arg04, fp
	mov	arg03, arg04
	add	arg03, #11
	rdbyte	arg03, arg03
	or	arg03, #32
	add	arg04, #11
	wrbyte	arg03, arg04
	sub	fp, #16
	rdlong	arg04, fp
	rdlong	arg01, arg04
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #20
	add	arg04, #8
	rdlong	arg03, arg04
	call	#_fatfs_cc_st_clust
	add	fp, #20
	rdlong	arg01, fp
	add	arg01, #28
	sub	fp, #16
	rdlong	arg04, fp
	add	arg04, #12
	rdlong	arg02, arg04
	wrlong	arg02, arg01
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, #22
	sub	fp, #4
	rdlong	arg02, fp
	wrlong	arg02, arg01
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #18
	wrword	#0, arg01
	sub	fp, #8
	rdlong	arg04, fp
	add	arg04, #3
	wrbyte	#1, arg04
	rdlong	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc_sync_fs
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #191
	add	arg03, #16
	wrbyte	arg04, arg03
LR__0621
LR__0622
LR__0623
' 					dir = fp->dir_ptr;
' 					dir[ 11 ] |=  0x20 ;
' 					st_clust(fp->obj.fs, dir, fp->obj.sclust);
' 					st_dword(dir +  28 , (DWORD)fp->obj.objsize);
' 					st_dword(dir +  22 , tm);
' 					st_word(dir +  18 , 0);
' 					fs->wflag = 1;
' 					res = sync_fs(fs);
' 					fp->flag &= (BYTE)~ 0x40 ;
' 				}
' 			}
' 		}
' 	}
' 
' 	return res ;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
LR__0624
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_sync_ret
	ret

_fatfs_cc_f_close
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #4
	call	#_fatfs_cc_f_sync
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0630
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_validate
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_e	add	fp, #4
 if_e	rdlong	local01, fp
 if_e	sub	fp, #4
 if_e	wrlong	#0, local01
LR__0630
' 
' 
' 
' 
' 			fp->obj.fs = 0;
' #line 4192 "ff.c"
' 		}
' 	}
' 	return res;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_close_ret
	ret

_fatfs_cc_f_lseek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #36
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc_validate
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0640
	add	fp, #4
	rdlong	arg04, fp
	add	arg04, #17
	rdbyte	arg04, arg04
	add	fp, #8
	wrlong	arg04, fp
	sub	fp, #12
LR__0640
	add	fp, #12
	rdlong	arg04, fp wz
	sub	fp, #12
 if_ne	add	fp, #12
 if_ne	rdlong	result1, fp
 if_ne	sub	fp, #12
 if_ne	jmp	#LR__0663
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #8
	add	arg04, #12
	rdlong	arg04, arg04
	cmp	arg03, arg04 wcz
 if_be	jmp	#LR__0641
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #16
	rdbyte	arg03, arg03
	getbyte	arg03, arg03, #0
	test	arg03, #2 wz
 if_ne	jmp	#LR__0641
	add	fp, #4
	rdlong	arg03, fp
	add	arg03, #12
	rdlong	arg03, arg03
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
LR__0641
	add	fp, #4
	rdlong	arg03, fp
	add	arg03, #20
	rdlong	arg03, arg03
	add	fp, #28
	wrlong	arg03, fp
	sub	fp, #28
	rdlong	arg03, fp
	add	fp, #24
	wrlong	#0, fp
	add	arg03, #20
	wrlong	#0, arg03
	sub	fp, #20
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #1 wc
 if_b	jmp	#LR__0657
	add	fp, #16
	rdlong	arg03, fp
	add	arg03, #10
	rdword	arg04, arg03
	shl	arg04, #9
	add	fp, #8
	wrlong	arg04, fp
	add	fp, #8
	rdlong	arg04, fp
	sub	fp, #32
	cmp	arg04, #1 wc
 if_b	jmp	#LR__0642
	add	fp, #8
	rdlong	arg04, fp
	sub	arg04, #1
	add	fp, #16
	rdlong	arg03, fp
	qdiv	arg04, arg03
	add	fp, #8
	rdlong	result1, fp
	sub	result1, #1
	getqx	arg04
	qdiv	result1, arg03
	sub	fp, #32
	getqx	arg03
	cmp	arg04, arg03 wc
 if_b	jmp	#LR__0642
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #28
	rdlong	result1, fp
	sub	result1, #1
	sub	fp, #8
	rdlong	arg04, fp
	sub	arg04, #1
	andn	result1, arg04
	add	arg03, #20
	wrlong	result1, arg03
	sub	fp, #16
	rdlong	arg03, fp
	sub	fp, #4
	rdlong	arg04, fp
	add	arg04, #20
	rdlong	arg04, arg04
	sub	arg03, arg04
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	arg03, #24
	rdlong	arg03, arg03
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #20
	jmp	#LR__0646
LR__0642
	add	fp, #4
	rdlong	arg03, fp
	add	arg03, #8
	rdlong	arg03, arg03 wz
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #20
 if_ne	jmp	#LR__0645
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmp	result1, #1 wz
 if_ne	jmp	#LR__0643
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#2, arg03
	mov	result1, #2
	jmp	#LR__0663
LR__0643
	add	fp, #20
	rdlong	result1, fp
	sub	fp, #20
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__0644
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__0663
LR__0644
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #16
	rdlong	arg04, fp
	sub	fp, #20
	add	arg03, #8
	wrlong	arg04, arg03
LR__0645
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #16
	rdlong	arg04, fp
	sub	fp, #20
	add	arg03, #24
	wrlong	arg04, arg03
LR__0646
	add	fp, #20
	rdlong	arg03, fp wz
	sub	fp, #20
 if_e	jmp	#LR__0656
' 				while (ofs > bcs) {
LR__0647
	add	fp, #8
	rdlong	arg04, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #24
	cmp	arg04, arg03 wcz
 if_be	jmp	#LR__0653
	add	fp, #8
	rdlong	arg04, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	arg04, arg03
	sub	fp, #16
	wrlong	arg04, fp
	sub	fp, #4
	rdlong	arg04, fp
	mov	result1, arg04
	add	arg04, #20
	rdlong	arg04, arg04
	add	fp, #20
	rdlong	arg03, fp
	add	arg04, arg03
	add	result1, #20
	wrlong	arg04, result1
	sub	fp, #20
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #16
	rdbyte	arg03, arg03
	test	arg03, #2 wz
 if_e	jmp	#LR__0648
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_create_chain
	add	fp, #20
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #20
 if_e	add	fp, #8
 if_e	wrlong	#0, fp
 if_e	sub	fp, #8
' 							ofs = 0; break;
 if_e	jmp	#LR__0653
	jmp	#LR__0649
LR__0648
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_get_fat
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
LR__0649
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, ##-1 wz
 if_ne	jmp	#LR__0650
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__0663
LR__0650
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, #2 wc
 if_b	jmp	#LR__0651
	add	fp, #16
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #20
	add	arg04, #20
	rdlong	arg04, arg04
	cmp	arg03, arg04 wc
 if_b	jmp	#LR__0652
LR__0651
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#2, arg03
	mov	result1, #2
	jmp	#LR__0663
LR__0652
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #20
	add	arg04, #24
	wrlong	arg03, arg04
	jmp	#LR__0647
LR__0653
	add	fp, #4
	rdlong	arg03, fp
	mov	arg01, arg03
	add	arg03, #20
	rdlong	arg02, arg03
	add	fp, #4
	rdlong	arg03, fp
	add	arg02, arg03
	add	arg01, #20
	wrlong	arg02, arg01
	rdlong	arg03, fp
	sub	fp, #8
	test	arg03, #511 wz
 if_e	jmp	#LR__0655
	add	fp, #16
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_clst2sect
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0654
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#2, arg03
	mov	result1, #2
	jmp	#LR__0663
LR__0654
	add	fp, #28
	rdlong	arg04, fp
	sub	fp, #20
	rdlong	arg03, fp
	shr	arg03, #9
	add	arg04, arg03
	add	fp, #20
	wrlong	arg04, fp
	sub	fp, #28
LR__0655
LR__0656
LR__0657
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg03, #20
	rdlong	arg03, arg03
	add	arg04, #12
	rdlong	arg04, arg04
	cmp	arg03, arg04 wcz
 if_be	jmp	#LR__0658
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	add	arg04, #20
	rdlong	arg04, arg04
	add	arg03, #12
	wrlong	arg04, arg03
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	or	arg04, #64
	add	arg03, #16
	wrbyte	arg04, arg03
LR__0658
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #20
	rdlong	arg03, arg03
	test	arg03, #511 wz
 if_e	jmp	#LR__0662
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #24
	rdlong	arg03, fp
	sub	fp, #28
	add	arg04, #28
	rdlong	arg04, arg04
	cmp	arg03, arg04 wz
 if_e	jmp	#LR__0662
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #16
	rdbyte	arg03, arg03
	test	arg03, #128 wz
 if_e	jmp	#LR__0660
	add	fp, #16
	rdlong	arg03, fp
	add	arg03, #1
	rdbyte	arg01, arg03
	sub	fp, #12
	rdlong	arg03, fp
	mov	arg02, arg03
	add	arg02, #40
	sub	fp, #4
	add	arg03, #28
	rdlong	arg03, arg03
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__0659
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__0663
LR__0659
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	arg03, #16
	wrbyte	arg04, arg03
LR__0660
	add	fp, #16
	rdlong	arg03, fp
	add	arg03, #1
	rdbyte	arg01, arg03
	sub	fp, #12
	rdlong	arg02, fp
	add	arg02, #40
	add	fp, #24
	rdlong	arg03, fp
	sub	fp, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_e	jmp	#LR__0661
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__0663
LR__0661
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #24
	rdlong	arg03, fp
	sub	fp, #28
	add	arg04, #28
	wrlong	arg03, arg04
LR__0662
' 
' 			fp->sect = nsect;
' 		}
' 	}
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
LR__0663
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_lseek_ret
	ret

_fatfs_cc_f_opendir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg03, fp wz
	sub	fp, #4
 if_e	mov	result1, #9
 if_e	jmp	#LR__0676
	add	fp, #8
	mov	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0675
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #12
	rdlong	result1, fp
	wrlong	result1, arg03
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0674
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #43
	rdbyte	arg03, arg03
	test	arg03, #128 wz
 if_ne	jmp	#LR__0672
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #6
	rdbyte	arg03, arg03
	test	arg03, #16 wz
 if_e	jmp	#LR__0670
	add	fp, #4
	rdlong	arg03, fp
	mov	local01, arg03
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #16
	add	arg03, #28
	rdlong	arg02, arg03
	call	#_fatfs_cc_ld_clust
	add	local01, #8
	wrlong	result1, local01
	jmp	#LR__0671
LR__0670
	add	fp, #12
	wrlong	#5, fp
	sub	fp, #12
LR__0671
LR__0672
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__0673
	add	fp, #4
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg03, fp
	add	arg03, #6
	rdword	arg03, arg03
	add	local01, #4
	wrword	arg03, local01
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__0673
LR__0674
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#5, fp
 if_e	sub	fp, #12
LR__0675
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	add	fp, #4
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #4
 if_ne	wrlong	#0, local01
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
LR__0676
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_opendir_ret
	ret

_fatfs_cc_f_closedir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_validate
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_e	add	fp, #4
 if_e	rdlong	result1, fp
 if_e	sub	fp, #4
 if_e	wrlong	#0, result1
' 
' 
' 
' 
' 		dp->obj.fs = 0;
' #line 4633 "ff.c"
' 	}
' 	return res;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_closedir_ret
	ret

_fatfs_cc_f_readdir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc_validate
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0683
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__0680
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	jmp	#LR__0682
LR__0680
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#0, fp
 if_e	sub	fp, #12
	add	fp, #12
	rdlong	result1, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__0681
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_get_fileinfo
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#0, fp
 if_e	sub	fp, #12
LR__0681
LR__0682
LR__0683
' 			}
' 			;
' 		}
' 	}
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_readdir_ret
	ret

_fatfs_cc_f_stat
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #60
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0693
	add	fp, #16
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0692
	add	fp, #59
	rdbyte	result1, fp
	sub	fp, #59
	test	result1, #128 wz
 if_ne	add	fp, #12
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #12
 if_ne	jmp	#LR__0691
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_e	jmp	#LR__0690
	add	fp, #16
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_get_fileinfo
LR__0690
LR__0691
LR__0692
LR__0693
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_stat_ret
	ret

_fatfs_cc_f_unlink
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #108
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #96
	wrlong	#0, fp
	sub	fp, #96
	mov	arg01, fp
	add	fp, #100
	mov	arg02, fp
	sub	fp, #104
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0708
	add	fp, #104
	rdlong	arg03, fp
	sub	fp, #92
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__0707
	add	fp, #55
	rdbyte	result1, fp
	sub	fp, #55
	test	result1, #128 wz
 if_ne	add	fp, #8
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__0700
	add	fp, #18
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #1 wz
 if_ne	add	fp, #8
 if_ne	wrlong	#7, fp
 if_ne	sub	fp, #8
LR__0700
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__0703
	add	fp, #104
	rdlong	arg01, fp
	sub	fp, #64
	rdlong	arg02, fp
	sub	fp, #40
	call	#_fatfs_cc_ld_clust
	add	fp, #100
	wrlong	result1, fp
	sub	fp, #82
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #16 wz
 if_e	jmp	#LR__0702
	add	fp, #104
	rdlong	result1, fp
	sub	fp, #48
	wrlong	result1, fp
	add	fp, #44
	rdlong	arg03, fp
	sub	fp, #36
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #56
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0701
	mov	arg01, fp
	add	arg01, #56
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_e	add	fp, #8
 if_e	wrlong	#7, fp
 if_e	sub	fp, #8
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	cmp	result1, #4 wz
 if_e	add	fp, #8
 if_e	wrlong	#0, fp
 if_e	sub	fp, #8
LR__0701
LR__0702
LR__0703
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__0706
	mov	arg01, fp
	add	arg01, #12
	call	#_fatfs_cc_dir_remove
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0704
	add	fp, #100
	rdlong	result1, fp wz
	sub	fp, #100
 if_e	jmp	#LR__0704
	add	fp, #12
	mov	arg01, fp
	add	fp, #88
	rdlong	arg02, fp
	sub	fp, #100
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
LR__0704
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__0705
	add	fp, #104
	rdlong	arg01, fp
	sub	fp, #104
	call	#_fatfs_cc_sync_fs
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
LR__0705
LR__0706
LR__0707
LR__0708
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_unlink_ret
	ret

_fatfs_cc_f_mkdir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #88
	add	fp, #4
	wrlong	arg01, fp
	mov	arg01, fp
	add	fp, #68
	mov	arg02, fp
	sub	fp, #72
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0715
	add	fp, #72
	rdlong	arg03, fp
	sub	fp, #60
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_e	add	fp, #8
 if_e	wrlong	#8, fp
 if_e	sub	fp, #8
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	cmp	result1, #4 wz
 if_ne	jmp	#LR__0714
	add	fp, #72
	rdlong	arg03, fp
	sub	fp, #16
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #56
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	add	fp, #76
	wrlong	result1, fp
	sub	fp, #68
	wrlong	#0, fp
	add	fp, #68
	rdlong	result1, fp wz
	sub	fp, #76
 if_e	add	fp, #8
 if_e	wrlong	#7, fp
 if_e	sub	fp, #8
	add	fp, #76
	rdlong	result1, fp
	sub	fp, #76
	cmp	result1, #1 wz
 if_e	add	fp, #8
 if_e	wrlong	#2, fp
 if_e	sub	fp, #8
	add	fp, #76
	rdlong	arg03, fp
	sub	fp, #76
	cmp	arg03, ##-1 wz
 if_e	add	fp, #8
 if_e	wrlong	#1, fp
 if_e	sub	fp, #8
	call	#_fatfs_cc__get_fattime
	add	fp, #84
	wrlong	result1, fp
	sub	fp, #76
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__0711
	add	fp, #72
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #76
	call	#_fatfs_cc_dir_clear
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__0710
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #72
	add	arg01, #48
	mov	arg02, #32
	mov	arg03, #11
	call	#\builtin_bytefill_
	add	fp, #72
	rdlong	result1, fp
	add	result1, #48
	wrbyte	#46, result1
	rdlong	arg03, fp
	add	arg03, #59
	wrbyte	#16, arg03
	rdlong	arg01, fp
	add	arg01, #70
	add	fp, #12
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #12
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg02, #48
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #76
	call	#_fatfs_cc_st_clust
	add	fp, #72
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg01, #80
	sub	fp, #72
	add	arg02, #48
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #72
	rdlong	arg03, fp
	add	arg03, #81
	wrbyte	#46, arg03
	sub	fp, #52
	rdlong	arg03, fp
	add	fp, #60
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg02, #80
	sub	fp, #72
	call	#_fatfs_cc_st_clust
	add	fp, #72
	rdlong	arg03, fp
	sub	fp, #72
	add	arg03, #3
	wrbyte	#1, arg03
	mov	arg01, fp
	add	arg01, #12
	call	#_fatfs_cc_dir_register
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
LR__0710
LR__0711
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__0712
	add	fp, #40
	rdlong	arg01, fp
	add	arg01, #22
	add	fp, #44
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #32
	rdlong	arg02, fp
	add	fp, #36
	rdlong	arg03, fp
	sub	fp, #76
	call	#_fatfs_cc_st_clust
	add	fp, #40
	rdlong	result1, fp
	add	result1, #11
	wrbyte	#16, result1
	add	fp, #32
	rdlong	result1, fp
	add	result1, #3
	wrbyte	#1, result1
	sub	fp, #64
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__0713
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #72
	call	#_fatfs_cc_sync_fs
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	jmp	#LR__0713
LR__0712
	add	fp, #56
	mov	arg01, fp
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #76
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
LR__0713
LR__0714
LR__0715
' 				remove_chain(&sobj, dcl, 0);
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mkdir_ret
	ret

_fatfs_cc_f_rename
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #148
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #8
	call	#_fatfs_cc_get_ldnumber
	add	fp, #4
	mov	arg01, fp
	add	fp, #100
	mov	arg02, fp
	sub	fp, #104
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0733
	add	fp, #104
	rdlong	arg03, fp
	sub	fp, #88
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #12
 if_ne	jmp	#LR__0720
	add	fp, #59
	rdbyte	result1, fp
	sub	fp, #59
	test	result1, #160 wz
 if_ne	add	fp, #12
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #12
LR__0720
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__0732
	add	fp, #108
	mov	arg01, fp
	sub	fp, #64
	rdlong	arg02, fp
	sub	fp, #44
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #60
	mov	arg01, fp
	sub	fp, #44
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #44
	call	#__system____builtin_memmove
	add	fp, #60
	mov	arg01, fp
	sub	fp, #52
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0723
	add	fp, #68
	rdlong	result1, fp
	sub	fp, #44
	rdlong	arg03, fp
	sub	fp, #24
	cmp	result1, arg03 wz
 if_ne	jmp	#LR__0721
	add	fp, #76
	rdlong	result1, fp
	sub	fp, #44
	rdlong	arg03, fp
	sub	fp, #32
	cmp	result1, arg03 wz
 if_e	mov	local01, #4
 if_e	jmp	#LR__0722
LR__0721
	mov	local01, #8
LR__0722
	add	fp, #12
	wrlong	local01, fp
	sub	fp, #12
LR__0723
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #4 wz
 if_ne	jmp	#LR__0729
	mov	arg01, fp
	add	arg01, #60
	call	#_fatfs_cc_dir_register
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0728
	add	fp, #88
	rdlong	arg01, fp
	add	fp, #52
	wrlong	arg01, fp
	add	arg01, #13
	sub	fp, #32
	mov	arg02, fp
	sub	fp, #108
	add	arg02, #13
	mov	arg03, #19
	call	#__system____builtin_memmove
	add	fp, #140
	rdlong	local01, fp
	sub	fp, #21
	rdbyte	result1, fp
	add	local01, #11
	wrbyte	result1, local01
	add	fp, #21
	rdlong	local01, fp
	sub	fp, #140
	add	local01, #11
	rdbyte	local01, local01
	test	local01, #16 wz
 if_ne	jmp	#LR__0724
	add	fp, #140
	rdlong	result1, fp
	mov	local01, result1
	sub	fp, #140
	add	result1, #11
	rdbyte	result1, result1
	or	result1, #32
	add	local01, #11
	wrbyte	result1, local01
LR__0724
	add	fp, #104
	rdlong	local01, fp
	add	local01, #3
	wrbyte	#1, local01
	add	fp, #36
	rdlong	local01, fp
	sub	fp, #140
	add	local01, #11
	rdbyte	local01, local01
	test	local01, #16 wz
 if_e	jmp	#LR__0727
	add	fp, #24
	rdlong	arg03, fp
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #68
	cmp	arg03, local01 wz
 if_e	jmp	#LR__0727
	add	fp, #104
	rdlong	arg01, fp
	mov	local01, arg01
	add	fp, #36
	rdlong	arg02, fp
	sub	fp, #140
	call	#_fatfs_cc_ld_clust
	mov	arg02, result1
	mov	arg01, local01
	call	#_fatfs_cc_clst2sect
	add	fp, #144
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #144
 if_e	add	fp, #12
 if_e	wrlong	#2, fp
 if_e	sub	fp, #12
 if_e	jmp	#LR__0726
	add	fp, #104
	rdlong	arg01, fp
	add	fp, #40
	rdlong	arg02, fp
	sub	fp, #144
	call	#_fatfs_cc_move_window
	add	fp, #12
	wrlong	result1, fp
	add	fp, #92
	rdlong	local01, fp
	add	local01, #80
	add	fp, #36
	wrlong	local01, fp
	sub	fp, #128
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__0725
	add	fp, #140
	rdlong	local01, fp
	sub	fp, #140
	add	local01, #1
	rdbyte	local01, local01
	cmp	local01, #46 wz
 if_ne	jmp	#LR__0725
	add	fp, #104
	rdlong	arg01, fp
	add	fp, #36
	rdlong	arg02, fp
	sub	fp, #72
	rdlong	arg03, fp
	sub	fp, #68
	call	#_fatfs_cc_st_clust
	add	fp, #104
	rdlong	local01, fp
	sub	fp, #104
	add	local01, #3
	wrbyte	#1, local01
LR__0725
LR__0726
LR__0727
LR__0728
LR__0729
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__0731
	mov	arg01, fp
	add	arg01, #16
	call	#_fatfs_cc_dir_remove
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0730
	add	fp, #104
	rdlong	arg01, fp
	sub	fp, #104
	call	#_fatfs_cc_sync_fs
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__0730
LR__0731
LR__0732
LR__0733
' 					res = sync_fs(fs);
' 				}
' 			}
' 
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_rename_ret
	ret

_fatfs_cc_time
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg01, fp
	sub	fp, #8
	mov	arg02, #0
	call	#_fatfs_cc_gettimeofday
	add	fp, #8
	rdlong	result1, fp
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #12
	rdlong	result1, fp wz
	sub	fp, #4
 if_e	jmp	#LR__0740
	add	fp, #4
	rdlong	result1, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #16
	wrlong	arg02, result1
LR__0740
'         *tp = now;
'     return now;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_time_ret
	ret

_fatfs_cc_mktime
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	add	local01, #20
	rdlong	arg01, local01
	sub	local01, #20
	cmps	arg01, #70 wc
'                 return (time_t) -1;
 if_b	neg	result1, #1
 if_b	jmp	#LR__0754
	mov	local02, ##1900
	add	local01, #20
	rdlong	result1, local01
	add	local02, result1
	sub	local01, #8
	rdlong	local03, local01
	sub	local03, #1
	add	local01, #4
	rdlong	arg01, local01
	sub	local01, #16
	shl	arg01, #2
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, #188
	add	arg01, result1
	rdlong	result1, arg01
	add	local03, result1
	mov	arg01, local02
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_e	jmp	#LR__0750
	mov	local04, #0
	add	local01, #16
	rdlong	result1, local01
	sub	local01, #16
	cmps	result1, #2 wc
 if_ae	mov	local04, #1
	jmp	#LR__0751
LR__0750
	mov	local04, #0
LR__0751
	add	local01, #4
	rdlong	arg01, local01
	sub	local01, #4
	rdlong	local05, local01
	add	local01, #8
	rdlong	result1, local01
	qmul	result1, ##3600
	add	local03, local04
	mov	local04, arg01
	shl	local04, #4
	sub	local04, arg01
	shl	local04, #2
	add	local05, local04
	sub	local01, #8
	getqx	local04
	qmul	local03, ##86400
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1970
	getqx	local04
	qmul	local03, ##31536000
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1969
	abs	local06, local03 wc
	shr	local06, #2
	negc	local06, local06
	cmps	local02, ##2001 wc
	getqx	local04
	add	local05, local04
 if_b	jmp	#LR__0752
	sub	local02, ##2000
	abs	local04, local02 wc
	qdiv	local04, #100
	getqx	local04
	sumnc	local06, local04
LR__0752
	qmul	local06, ##86400
	getqx	local06
	add	local05, local06
	call	#_fatfs_cc__tzset
	add	ptr__fatfs_cc_dat__, #136
	rdlong	local06, ptr__fatfs_cc_dat__
	add	local05, local06
	add	ptr__fatfs_cc_dat__, #104
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #240
	cmp	local03, #1 wz
 if_ne	jmp	#LR__0753
	mov	arg01, local01
	call	#_fatfs_cc___indst
	cmp	result1, #0 wz
 if_ne	sub	local05, ##3600
LR__0753
'                 s -=  (3600L) ;
' 
'         return s;
	mov	result1, local05
LR__0754
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mktime_ret
	ret

_fatfs_cc__gmtime_r
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, arg01
	qdiv	local01, ##86400
	getqx	result1
	add	result1, #4
	qdiv	result1, #7
	add	arg02, #24
	cmp	local01, ##1325376000 wc
 if_ae	sub	local01, ##1325376000
 if_ae	mov	local02, ##2012
 if_b	mov	local02, ##1970
' 	  year = 1970;
' 	}
' 
' 	for(;;) {
	getqy	result1
	wrlong	result1, arg02
	sub	arg02, #24
LR__0760
	mov	arg01, local02
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, ##31622400
 if_e	mov	local03, ##31536000
	cmp	local01, local03 wc
' 	    break;
 if_ae	add	local02, #1
 if_ae	sub	local01, local03
 if_ae	jmp	#LR__0760
	qdiv	local01, ##86400
	mov	local03, local02
	sub	local03, ##1900
	add	arg02, #20
	wrlong	local03, arg02
	add	arg02, #8
	mov	arg01, local02
	getqx	local02
	wrlong	local02, arg02
	sub	arg02, #28
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, #29
 if_e	mov	local03, #28
	add	ptr__fatfs_cc_dat__, #144
	wrlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #144
' 
'         days_per_mth[1] = _is_leap_year(year) ? 29 : 28;
'         for (i = 0; mday >= days_per_mth[i]; i++)
	mov	arg01, #0
	callpa	#(@LR__0762-@LR__0761)>>2,fcache_load_ptr_
LR__0761
	mov	local03, arg01
	shl	local03, #2
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, #140
	add	local03, result1
	rdlong	local03, local03
	cmps	local02, local03 wc
 if_b	jmp	#LR__0763
	mov	result1, arg01
	shl	result1, #2
	mov	local03, ptr__fatfs_cc_dat__
	add	local03, #140
	add	result1, local03
	rdlong	result1, result1
	sub	local02, result1
	add	arg01, #1
	jmp	#LR__0761
LR__0762
LR__0763
	qdiv	local01, ##86400
	add	arg02, #16
	wrlong	arg01, arg02
	add	local02, #1
	sub	arg02, #4
	wrlong	local02, arg02
	getqy	local01
	qdiv	local01, ##3600
	getqx	local03
	qdiv	local01, ##3600
	sub	arg02, #4
	wrlong	local03, arg02
	getqy	local01
	qdiv	local01, #60
	getqx	local03
	qdiv	local01, #60
	sub	arg02, #4
	wrlong	local03, arg02
	sub	arg02, #4
'         stm->tm_isdst = 0;
' 
' ;
'         return stm;
	mov	result1, arg02
	getqy	local03
	wrlong	local03, arg02
	add	arg02, #32
	wrlong	#0, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__gmtime_r_ret
	ret

_fatfs_cc__tzset
	mov	arg01, ##@LR__2098
	call	#_fatfs_cc_getenv
	mov	arg01, result1
	mov	arg02, ptr__fatfs_cc_dat__
	add	arg02, #240
	call	#_fatfs_cc___tzoffset
	add	ptr__fatfs_cc_dat__, #136
	wrlong	result1, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #136
_fatfs_cc__tzset_ret
	ret

_fatfs_cc_getenv
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0771-@LR__0770)>>2,fcache_load_ptr_
LR__0770
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0770
LR__0771
	sub	local02, arg01
	mov	result1, local02
	add	ptr__fatfs_cc_dat__, #320
	rdlong	arg03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, #320
'             return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__0774
' 
' 	for (var = _environ_ptr; (name = *var) != 0; var++) {
	add	ptr__fatfs_cc_dat__, #320
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #320
LR__0772
	rdlong	local04, local03 wz
 if_e	jmp	#LR__0773
	mov	arg01, local04
	mov	arg02, local01
	mov	arg03, local02
	call	#_fatfs_cc_strncmp
	cmp	result1, #0 wz
 if_e	mov	local05, local02
 if_e	add	local05, local04
 if_e	rdbyte	local06, local05
 if_e	cmp	local06, #61 wz
' 			return name+len+1;
 if_e	add	local04, local02
 if_e	add	local04, #1
 if_e	mov	result1, local04
 if_e	jmp	#LR__0774
	add	local03, #4
	jmp	#LR__0772
LR__0773
' 	}
' 	return 0;
	mov	result1, #0
LR__0774
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_getenv_ret
	ret

_fatfs_cc__get_fattime
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #52
	mov	arg01, #0
	call	#_fatfs_cc_time
	add	fp, #4
	wrlong	result1, fp
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc__gmtime_r
	add	fp, #36
	rdlong	arg02, fp
	sub	arg02, #80
	shl	arg02, #9
	sub	fp, #4
	rdlong	result1, fp
	add	result1, #1
	shl	result1, #5
	or	arg02, result1
	sub	fp, #4
	rdlong	result1, fp
	or	arg02, result1
	sub	fp, #20
	wrlong	arg02, fp
	add	fp, #16
	rdlong	arg02, fp
	shl	arg02, #11
	sub	fp, #4
	rdlong	result1, fp
	shl	result1, #5
	or	arg02, result1
	sub	fp, #4
	rdlong	result1, fp
	or	arg02, result1
	sub	fp, #4
	wrlong	arg02, fp
' 
'     now = time(0);
'     _gmtime_r (&now, &date);
'     ffdate = ((date.tm_year - 80) << 9) | ((date.tm_mon + 1) << 5) | ((date.tm_mday));
'     fftime = (date.tm_hour << 11) | (date.tm_min << 5) | (date.tm_sec);
'     return (ffdate << 16) | fftime;
	sub	fp, #4
	rdlong	result1, fp
	shl	result1, #16
	sub	fp, #8
	or	result1, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__get_fattime_ret
	ret

_fatfs_cc_unixtime_0464
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #52
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg02, fp
	shr	arg02, #9
	and	arg02, #127
	mov	result1, #80
	add	result1, arg02
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	rdlong	result1, fp
	shr	result1, #5
	getnib	result1, result1, #0
	sub	result1, #1
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	rdlong	result1, fp
	and	result1, #31
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #20
	rdlong	result1, fp
	shr	result1, #11
	and	result1, #31
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	rdlong	result1, fp
	shr	result1, #5
	and	result1, #63
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	rdlong	arg02, fp
	and	arg02, #31
	shl	arg02, #1
	add	fp, #8
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #16
	call	#_fatfs_cc_mktime
	add	fp, #12
	wrlong	result1, fp
' 
'     date.tm_year = 80 + ((dosdate >> 9) & 0x7f);
'     date.tm_mon = ((dosdate >> 5) & 0xf) - 1;
'     date.tm_mday = (dosdate & 0x1f);
'     date.tm_hour = (dostime >> 11) & 0x1f;
'     date.tm_min = (dostime >> 5) & 0x3f;
'     date.tm_sec = (dostime & 0x1f) << 1;
' 
'     t = mktime(&date);
' #line 60 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
'     return t;
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_unixtime_0464_ret
	ret

_fatfs_cc__set_dos_error_0466
	mov	_var01, arg01
' #line 74 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
'     switch (derr) {
	fle	_var01, #20
	jmprel	_var01
LR__0780
	jmp	#LR__0781
	jmp	#LR__0795
	jmp	#LR__0796
	jmp	#LR__0797
	jmp	#LR__0782
	jmp	#LR__0783
	jmp	#LR__0784
	jmp	#LR__0785
	jmp	#LR__0787
	jmp	#LR__0790
	jmp	#LR__0786
	jmp	#LR__0791
	jmp	#LR__0792
	jmp	#LR__0793
	jmp	#LR__0798
	jmp	#LR__0798
	jmp	#LR__0798
	jmp	#LR__0788
	jmp	#LR__0794
	jmp	#LR__0789
	jmp	#LR__0798
LR__0781
	mov	_var02, #0
'         r = 0;
'         break;
	jmp	#LR__0799
LR__0782
LR__0783
LR__0784
	mov	_var02, #4
'         r =  4 ;
'         break;
	jmp	#LR__0799
LR__0785
LR__0786
	mov	_var02, #6
'         r =  6 ;
'         break;
	jmp	#LR__0799
LR__0787
	mov	_var02, #9
'         r =  9 ;
'         break;
	jmp	#LR__0799
LR__0788
	mov	_var02, #7
'         r =  7 ;
'         break;
	jmp	#LR__0799
LR__0789
LR__0790
LR__0791
LR__0792
LR__0793
	mov	_var02, #10
'         r =  10 ;
'         break;
	jmp	#LR__0799
LR__0794
	mov	_var02, #11
'         r =  11 ;
'         break;
	jmp	#LR__0799
LR__0795
LR__0796
LR__0797
LR__0798
	mov	_var02, #12
'         r =  12 ;
'         break;
LR__0799
'     }
'     return _seterror(r);
	cmps	_var02, #0 wz
	add	ptr___system__dat__, #32
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
_fatfs_cc__set_dos_error_0466_ret
	ret

_fatfs_cc_v_creat
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, ##1596
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0801
	mov	arg01, local03
	mov	arg02, #0
	mov	arg03, ##1596
	call	#\builtin_bytefill_
	mov	arg01, local03
	add	arg01, ##1044
	mov	arg02, local02
	mov	arg03, #7
	call	#_fatfs_cc_f_open
	mov	local04, result1 wz
 if_e	jmp	#LR__0800
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_0466
	jmp	#LR__0801
LR__0800
	wrlong	local03, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__0801
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_creat_ret
	ret

_fatfs_cc_v_close
	mov	COUNT_, #2
	call	#pushregs_
	rdlong	local01, arg01
	mov	arg01, local01
	add	arg01, ##1044
	call	#_fatfs_cc_f_close
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
'     FAT_FIL *f = fil->vfsdata;
'     r=f_close(&f->fil);
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local02
	call	#_fatfs_cc__set_dos_error_0466
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_close_ret
	ret

_fatfs_cc_v_opendir
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, #44
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
' #line 158 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0811
	mov	arg02, local02
	mov	arg01, local03
	call	#_fatfs_cc_f_opendir
	mov	local04, result1 wz
 if_e	jmp	#LR__0810
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'         free(f);
'         return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_0466
	jmp	#LR__0811
LR__0810
	add	local01, #4
	wrlong	local03, local01
'     }
'     dir->vfsdata = f;
'     return 0;
	mov	result1, #0
LR__0811
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_opendir_ret
	ret

_fatfs_cc_v_closedir
	mov	COUNT_, #2
	call	#pushregs_
	add	arg01, #4
	rdlong	local01, arg01
	mov	arg01, local01
	call	#_fatfs_cc_f_closedir
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
	cmp	local02, #0 wz
 if_ne	mov	arg01, local02
 if_ne	call	#_fatfs_cc__set_dos_error_0466
'     return r;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_closedir_ret
	ret

_fatfs_cc_v_readdir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #44
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg02, fp
	add	arg02, #4
	rdlong	arg01, arg02
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_f_readdir
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #40
	cmp	result1, #0 wz
 if_e	jmp	#LR__0820
'         return _set_dos_error(r);
	add	fp, #40
	rdlong	arg01, fp
	sub	fp, #40
	call	#_fatfs_cc__set_dos_error_0466
	jmp	#LR__0823
LR__0820
	add	fp, #24
	rdbyte	arg02, fp wz
	sub	fp, #24
'         return -1;
 if_e	neg	result1, #1
 if_e	jmp	#LR__0823
	add	fp, #8
	rdlong	arg01, fp
	add	fp, #16
	mov	arg02, fp
	sub	fp, #24
	call	#__system____builtin_strcpy
	add	fp, #20
	rdbyte	result1, fp
	sub	fp, #20
	test	result1, #16 wz
 if_e	jmp	#LR__0821
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	add	result1, #80
	wrbyte	#1, result1
	jmp	#LR__0822
LR__0821
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	add	result1, #80
	wrbyte	#0, result1
LR__0822
	add	fp, #8
	rdlong	result1, fp
	add	fp, #4
	rdlong	arg02, fp
	add	result1, #72
	wrlong	arg02, result1
	sub	fp, #4
	rdlong	local01, fp
	add	fp, #8
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #18
	call	#_fatfs_cc_unixtime_0464
	add	local01, #76
	wrlong	result1, local01
'         ent->d_type =  (0) ;
'     }
'     ent->d_size = finfo.fsize;
'     ent->d_mtime = unixtime(finfo.fdate, finfo.ftime);
'     return 0;
	mov	result1, #0
LR__0823
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_readdir_ret
	ret

_fatfs_cc_v_stat
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, arg02
	mov	arg02, #0
	mov	arg03, #48
	call	#\builtin_bytefill_
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	rdbyte	result1, result1 wz
 if_e	jmp	#LR__0830
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	rdbyte	result1, result1
	cmp	result1, #46 wz
 if_e	add	fp, #4
 if_e	rdlong	local01, fp
 if_e	sub	fp, #4
 if_e	add	local01, #1
 if_e	rdbyte	local02, local01 wz
 if_ne	jmp	#LR__0831
LR__0830
	add	fp, #24
	wrbyte	#16, fp
	sub	fp, #12
	wrlong	#0, fp
	sub	fp, #12
	jmp	#LR__0832
LR__0831
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc_f_stat
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__0832
	add	fp, #12
	rdlong	local02, fp wz
	sub	fp, #12
 if_e	jmp	#LR__0833
'         return _set_dos_error(r);
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc__set_dos_error_0466
	jmp	#LR__0834
LR__0833
	add	fp, #44
	wrlong	#292, fp
	sub	fp, #20
	rdbyte	local03, fp
	sub	fp, #24
	test	local03, #1 wz
 if_e	add	fp, #44
 if_e	rdlong	local03, fp
 if_e	or	local03, #146
 if_e	wrlong	local03, fp
 if_e	sub	fp, #44
	add	fp, #24
	rdbyte	local03, fp
	sub	fp, #24
	test	local03, #16 wz
 if_ne	add	fp, #44
 if_ne	rdlong	local03, fp
 if_ne	or	local03, ##4169
 if_ne	wrlong	local03, fp
 if_ne	sub	fp, #44
	add	fp, #8
	rdlong	local03, fp
	add	fp, #36
	rdlong	local02, fp
	add	local03, #8
	wrlong	local02, local03
	sub	fp, #36
	rdlong	local03, fp
	add	local03, #12
	wrlong	#1, local03
	rdlong	local03, fp
	add	fp, #8
	rdlong	local02, fp
	add	local03, #24
	wrlong	local02, local03
	sub	fp, #8
	rdlong	local03, fp
	add	local03, #28
	wrlong	##512, local03
	rdlong	local02, fp
	mov	local03, local02
	add	local02, #24
	rdlong	local02, local02
	add	local02, #511
	abs	local02, local02 wc
	shr	local02, #9
	negc	local02, local02
	add	local03, #32
	wrlong	local02, local03
	rdlong	local02, fp
	mov	local03, local02
	mov	local01, local02
	add	fp, #12
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #22
	call	#_fatfs_cc_unixtime_0464
	add	local01, #44
	wrlong	result1, local01
	add	local02, #40
	wrlong	result1, local02
	add	local03, #36
	wrlong	result1, local03
'         mode |=  0010000  |  0100  |  0010  |  0001 ;
'     }
'     buf->st_mode = mode;
'     buf->st_nlink = 1;
'     buf->st_size = finfo.fsize;
'     buf->st_blksize = 512;
'     buf->st_blocks = (buf->st_size + 511) / 512;
'     buf->st_atime = buf->st_mtime = buf->st_ctime = unixtime(finfo.fdate, finfo.ftime);
' #line 249 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
'     return r;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
LR__0834
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_stat_ret
	ret

_fatfs_cc_v_read
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #28
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	rdlong	arg01, arg01 wz
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #16
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0842
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, ##1044
	sub	fp, #8
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #12
	mov	arg04, fp
	sub	fp, #24
	call	#_fatfs_cc_f_read
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmp	result1, #0 wz
 if_e	jmp	#LR__0840
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	add	arg04, #8
	rdlong	arg04, arg04
	or	arg04, #32
	add	arg03, #8
	wrlong	arg04, arg03
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	call	#_fatfs_cc__set_dos_error_0466
	jmp	#LR__0842
LR__0840
	add	fp, #24
	rdlong	result1, fp wz
	sub	fp, #24
 if_ne	jmp	#LR__0841
	add	fp, #4
	rdlong	result1, fp
	mov	arg04, result1
	sub	fp, #4
	add	result1, #8
	rdlong	result1, result1
	or	result1, #16
	add	arg04, #8
	wrlong	result1, arg04
LR__0841
'         fil->state |=  (0x10) ;
'     }
'     return x;
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #24
LR__0842
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_read_ret
	ret

_fatfs_cc_v_write
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #28
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	rdlong	arg01, arg01 wz
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #16
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0851
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, ##1044
	sub	fp, #8
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #12
	mov	arg04, fp
	sub	fp, #24
	call	#_fatfs_cc_f_write
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmp	result1, #0 wz
 if_e	jmp	#LR__0850
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	add	arg04, #8
	rdlong	arg04, arg04
	or	arg04, #32
	add	arg03, #8
	wrlong	arg04, arg03
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	call	#_fatfs_cc__set_dos_error_0466
	jmp	#LR__0851
LR__0850
'     }
'     return x;
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #24
LR__0851
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_write_ret
	ret

_fatfs_cc_v_lseek
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	rdlong	local03, arg01
	add	local03, ##1044 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0862
	cmp	local02, #0 wz
 if_e	jmp	#LR__0860
	cmp	local02, #1 wz
 if_e	add	local03, #20
 if_e	rdlong	local04, local03
 if_e	sub	local03, #20
 if_e	add	local01, local04
 if_ne	add	local03, #12
 if_ne	rdlong	local04, local03
 if_ne	sub	local03, #12
 if_ne	add	local01, local04
LR__0860
	mov	arg02, local01
	mov	arg01, local03
	call	#_fatfs_cc_f_lseek
	mov	arg01, result1 wz
 if_e	jmp	#LR__0861
'         return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_0466
	jmp	#LR__0862
LR__0861
'     }
'     return offset;
	mov	result1, local01
LR__0862
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_lseek_ret
	ret

_fatfs_cc_v_ioctl
' {
'     return _seterror( 10 );
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
_fatfs_cc_v_ioctl_ret
	ret

_fatfs_cc_v_mkdir
	call	#_fatfs_cc_f_mkdir
	mov	arg01, result1
' 
'     r = f_mkdir(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0466
_fatfs_cc_v_mkdir_ret
	ret

_fatfs_cc_v_remove
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0466
_fatfs_cc_v_remove_ret
	ret

_fatfs_cc_v_rmdir
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0466
_fatfs_cc_v_rmdir_ret
	ret

_fatfs_cc_v_rename
	call	#_fatfs_cc_f_rename
	mov	arg01, result1
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0466
_fatfs_cc_v_rename_ret
	ret

_fatfs_cc_v_open
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, ##1596
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local04, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0876
	mov	arg01, local04
	mov	arg02, #0
	mov	arg03, ##1596
	call	#\builtin_bytefill_
'   switch (flags & 3) {
	mov	local05, local03
	and	local05, #3 wz
 if_e	jmp	#LR__0870
	cmp	local05, #1 wz
 if_e	jmp	#LR__0871
	jmp	#LR__0872
LR__0870
	mov	local06, #1
'       fs_flags =  0x01 ;
'       break;
	jmp	#LR__0873
LR__0871
	mov	local06, #2
'       fs_flags =  0x02 ;
'       break;
	jmp	#LR__0873
LR__0872
	mov	local06, #3
'       fs_flags =  0x01  |  0x02 ;
'       break;
LR__0873
	test	local03, #8 wz
 if_ne	or	local06, #24
 if_ne	jmp	#LR__0874
	test	local03, #32 wz
 if_ne	or	local06, #48
LR__0874
	mov	arg01, local04
	add	arg01, ##1044
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_f_open
	mov	local07, result1 wz
 if_e	jmp	#LR__0875
	mov	arg01, local04
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
' #line 417 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(r);
	mov	arg01, local07
	call	#_fatfs_cc__set_dos_error_0466
	jmp	#LR__0876
LR__0875
	wrlong	local04, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__0876
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_open_ret
	ret

_fatfs_cc_v_flush
	rdlong	arg01, arg01
	add	arg01, ##1044 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0880
	call	#_fatfs_cc_f_sync
	mov	arg01, result1
'     }
' #line 437 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
'     result = f_sync(f);
' #line 441 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_0466
LR__0880
_fatfs_cc_v_flush_ret
	ret

_fatfs_cc_v_init
' {
'     return 0;
	mov	result1, #0
_fatfs_cc_v_init_ret
	ret

_fatfs_cc_v_deinit
	mov	arg02, ##@LR__2099
	mov	arg01, #0
	mov	arg03, #0
	call	#_fatfs_cc_f_mount
	add	objptr, #8
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, #12
	call	#__system___freepins
' #line 462 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/fatfs.cc"
'     _freepins(f_pinmask);
'     return 0;
	mov	result1, #0
_fatfs_cc_v_deinit_ret
	ret

_fatfs_cc_get_vfs
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #80
	call	#__system___gc_alloc_managed
	mov	arg01, result1
	mov	result1, objptr
	bith	result1, #20
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #21
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #52
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #22
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##5242880
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #53
	add	arg01, #4
	wrlong	result1, arg01
	add	arg01, #4
	wrlong	local01, arg01
	add	arg01, #4
	wrlong	#0, arg01
	mov	result1, objptr
	bith	result1, #84
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #23
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##9437184
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##10485760
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##11534336
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #54
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##13631488
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #85
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #116
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #24
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##17825792
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##18874368
	add	arg01, #4
	wrlong	result1, arg01
	sub	arg01, #76
' 
'     v->close = &v_close;
'     v->read = &v_read;
'     v->write = &v_write;
'     v->lseek = &v_lseek;
'     v->ioctl = &v_ioctl;
'     v->flush = &v_flush;
'     v->vfs_data = ptr;
'     v->reserved = 0;
' 
'     v->open = &v_open;
'     v->creat = &v_creat;
'     v->opendir = &v_opendir;
'     v->closedir = &v_closedir;
'     v->readdir = &v_readdir;
'     v->stat = &v_stat;
' 
'     v->mkdir = &v_mkdir;
'     v->rmdir = &v_rmdir;
' 
'     v->remove = &v_remove;
'     v->rename = &v_rename;
' 
'     v->init = &v_init;
'     v->deinit = &v_deinit;
' 
'     return v;
	mov	result1, arg01
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_vfs_ret
	ret

_fatfs_cc_xmit_mmc_0634
	add	objptr, #16
	rdlong	_var01, objptr
	add	objptr, #8
	rdlong	_var02, objptr
	sub	objptr, #24
	dirl	_var02
	setq	#1
	rdlong	_var03, arg01
	rev	_var03
	movbyts	_var03, #27
	wypin	_var03, _var02
	mov	_var03, arg02
	shr	arg02, #2 wz
	shl	_var03, #3
	wypin	_var03, _var01
	dirh	_var02
	add	arg01, #8
	rev	_var04
	movbyts	_var04, #27
LR__0890
 if_ne	wypin	_var04, _var02
 if_ne	rdlong	_var04, arg01
 if_ne	add	arg01, #4
 if_ne	rev	_var04
 if_ne	movbyts	_var04, #27
LR__0891
 if_ne	testp	_var02 wc
 if_a	jmp	#LR__0891
 if_ne	djnz	arg02, #LR__0890
LR__0892
	testp	_var01 wc
 if_ae	jmp	#LR__0892
	dirl	_var02
	wypin	##-1, _var02
	dirh	_var02
_fatfs_cc_xmit_mmc_0634_ret
	ret

_fatfs_cc_rcvr_mmc_0641
	add	objptr, #16
	rdlong	_var01, objptr
	add	objptr, #12
	rdlong	_var02, objptr
	sub	objptr, #28
	akpin	_var02
	mov	_var03, arg02 wz
	shr	_var03, #2 wz
 if_e	jmp	#LR__0902
	mov	_var04, _var03
	shl	_var04, #5
	wypin	_var04, _var01
	wxpin	#63, _var02
LR__0900
LR__0901
	testp	_var02 wc
 if_ae	jmp	#LR__0901
	rdpin	_var04, _var02
	rev	_var04
	movbyts	_var04, #27
	wrlong	_var04, arg01
	add	arg01, #4
	djnz	_var03, #LR__0900
LR__0902
	and	arg02, #3 wz
 if_e	jmp	#LR__0905
	wxpin	#39, _var02
LR__0903
	wypin	#8, _var01
LR__0904
	testp	_var02 wc
 if_ae	jmp	#LR__0904
	rdpin	_var04, _var02
	rev	_var04
	wrbyte	_var04, arg01
	add	arg01, #1
	djnz	arg02, #LR__0903
LR__0905
_fatfs_cc_rcvr_mmc_0641_ret
	ret

_fatfs_cc_wait_ready_0645
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, ptra
	getct	local02
	rdlong	local03, #20
	shr	local03, #1
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 1;
' 	for(;;) {
	add	ptra, #4
LR__0910
	mov	arg01, local01
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_0641
	rdbyte	arg02, local01
	cmp	arg02, #255 wz
 if_e	mov	result1, #1
 if_ne	getct	result1
 if_ne	sub	result1, local02
 if_ne	cmp	result1, local03 wc
 if_a	mov	result1, #0
 if_c_and_nz	jmp	#LR__0910
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_wait_ready_0645_ret
	ret

_fatfs_cc_deselect_0651
	mov	COUNT_, #0
	call	#pushregs_
	mov	arg02, ptra
	add	objptr, #20
	rdlong	arg01, objptr
	sub	objptr, #20
	add	ptra, #4
	drvh	arg01
	waitx	#16
	mov	arg01, arg02
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_0641
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_deselect_0651_ret
	ret

_fatfs_cc_select_0655
	mov	COUNT_, #1
	call	#pushregs_
	mov	arg02, ptra
	add	objptr, #20
	rdlong	arg01, objptr
	add	objptr, #8
	rdlong	local01, objptr
	sub	objptr, #28
	add	ptra, #4
	fltl	local01
	drvl	arg01
	waitx	#16
	dirh	local01
	mov	arg01, arg02
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_0641
	call	#_fatfs_cc_wait_ready_0645
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__0920
	call	#_fatfs_cc_deselect_0651
' 
' 	deselect();
' 	return 0;
	mov	result1, #0
LR__0920
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_select_0655_ret
	ret

_fatfs_cc_rcvr_datablock_0659
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, ptra
	getct	local04
	rdlong	local05, #20
	shr	local05, #3
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 3;
' 	for(;;) {
	add	ptra, #4
LR__0930
	mov	arg01, local03
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_0641
	rdbyte	arg02, local03
	cmp	arg02, #255 wz
 if_e	getct	result1
 if_e	mov	arg02, result1
 if_e	sub	arg02, local04
 if_e	cmp	arg02, local05 wc
 if_c_and_z	jmp	#LR__0930
	rdbyte	local05, local03
	cmp	local05, #254 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0931
	mov	arg01, local01
	mov	arg02, local02
	call	#_fatfs_cc_rcvr_mmc_0641
	mov	arg01, local03
	mov	arg02, #2
	call	#_fatfs_cc_rcvr_mmc_0641
' 
' 	rcvr_mmc(buff, btr);
' 	rcvr_mmc(d, 2);
' 
' 	return 1;
	mov	result1, #1
LR__0931
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_rcvr_datablock_0659_ret
	ret

_fatfs_cc_xmit_datablock_0661
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, ptra
	add	ptra, #4
	call	#_fatfs_cc_wait_ready_0645
	cmp	result1, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0941
	wrbyte	local02, local03
	mov	arg01, local03
	mov	arg02, #1
	call	#_fatfs_cc_xmit_mmc_0634
	getbyte	local02, local02, #0
	cmp	local02, #253 wz
 if_e	jmp	#LR__0940
	mov	arg01, local01
	decod	arg02, #9
	call	#_fatfs_cc_xmit_mmc_0634
	mov	arg01, local03
	mov	arg02, #2
	call	#_fatfs_cc_rcvr_mmc_0641
	mov	arg01, local03
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_0641
	rdbyte	local03, local03
	and	local03, #31
	cmp	local03, #5 wz
' 			return 0;
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0941
LR__0940
' 	}
' 
' 	return 1;
	mov	result1, #1
LR__0941
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_xmit_datablock_0661_ret
	ret

_fatfs_cc_send_cmd_0664
	mov	COUNT_, #4
	call	#pushregs_
_fatfs_cc_send_cmd_0664_enter
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, ptra
	getbyte	result1, local01, #0
	test	result1, #128 wz
	add	ptra, #8
 if_e	jmp	#LR__0950
	getbyte	local01, local01, #0
	and	local01, #127
	mov	arg01, #55
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_0664
	getbyte	arg02, result1, #0
	cmp	arg02, #2 wc
 if_ae	jmp	#LR__0953
LR__0950
	getbyte	result1, local01, #0
	cmp	result1, #12 wz
 if_e	jmp	#LR__0951
	call	#_fatfs_cc_deselect_0651
	call	#_fatfs_cc_select_0655
	cmp	result1, #0 wz
 if_e	mov	result1, #255
 if_e	jmp	#LR__0953
LR__0951
	getbyte	arg02, local01, #0
	mov	result1, #64
	or	result1, arg02
	wrbyte	result1, local03
	mov	arg02, local03
	add	arg02, #1
	movbyts	local02, #27
	wrlong	local02, arg02
	mov	local04, #1
	mov	local02, local01
	zerox	local02, #7 wz
 if_e	mov	local04, #149
	getbyte	local02, local01, #0
	cmp	local02, #8 wz
 if_e	mov	local04, #135
	add	local03, #5
	wrbyte	local04, local03
	sub	local03, #5
	mov	arg01, local03
	mov	arg02, #6
	call	#_fatfs_cc_xmit_mmc_0634
	getbyte	local01, local01, #0
	cmp	local01, #12 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #6
 if_e	mov	arg02, #1
 if_e	call	#_fatfs_cc_rcvr_mmc_0641
	mov	local04, #10
' 	n = 10;
' 	do
LR__0952
	mov	arg01, local03
	add	arg01, #6
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_0641
	add	local03, #6
	rdbyte	local02, local03
	sub	local03, #6
	test	local02, #128 wz
 if_ne	djnz	local04, #LR__0952
' 
' 	return buf[6];
	add	local03, #6
	rdbyte	result1, local03
LR__0953
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_send_cmd_0664_ret
	ret

_fatfs_cc_disk_deinitialize
	mov	COUNT_, #4
	call	#pushregs_
	cmps	arg01, #0 wz
	add	objptr, #16
	rdlong	local01, objptr
	add	objptr, #4
	rdlong	local02, objptr
	add	objptr, #4
	rdlong	local03, objptr
	add	objptr, #8
	rdlong	local04, objptr
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #28
' #line 855 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
'         return RES_NOTRDY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__0960
	fltl	arg01
	wrpin	#0, arg01
	fltl	local04
	wrpin	#0, local04
	fltl	local03
	wrpin	#0, local03
	fltl	local01
	wrpin	#0, local01
	fltl	local02
	wrpin	#0, local02
	mov	arg01, #10
	call	#__system___waitms
'     }
' #line 861 "C:/Users/ryans/Documents/flexprop/include/filesys/fatfs/sdmm.cc"
'     _pinclear(SMPIN_DO);
'     _pinclear(PIN_DO);
'     _pinclear(PIN_DI);
'     _pinclear(PIN_CLK);
'     _pinclear(PIN_SS);
' 
'     _waitms(10);
' 
'     return 0;
	mov	result1, #0
LR__0960
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_deinitialize_ret
	ret

_fatfs_cc_gettimeofday
	mov	COUNT_, #4
	call	#pushregs_
	call	#__system___getus
	mov	local01, result1
	add	ptr__fatfs_cc_dat__, #332
	rdlong	local02, ptr__fatfs_cc_dat__
	mov	result1, local01
	sub	result1, local02
	qdiv	result1, ##1000000
	sub	ptr__fatfs_cc_dat__, #332
	getqx	local02
	qdiv	result1, ##1000000
	cmp	local02, #0 wz
	getqy	local03
 if_e	jmp	#LR__0970
	add	ptr__fatfs_cc_dat__, #328
	rdlong	local04, ptr__fatfs_cc_dat__
	add	local04, local02
	wrlong	local04, ptr__fatfs_cc_dat__
	sub	local01, local03
	add	ptr__fatfs_cc_dat__, #4
	wrlong	local01, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #332
LR__0970
	add	ptr__fatfs_cc_dat__, #328
	rdlong	local04, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #328
	wrlong	local04, arg01
	add	arg01, #4
	wrlong	local03, arg01
'         lastsec += secs;
'         lastus = now - leftover;
'     }
'     tv->tv_sec = lastsec;
'     tv->tv_usec = leftover;
'     return 0;
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_gettimeofday_ret
	ret

_fatfs_cc__is_leap_year
	abs	result1, arg01 wc
	and	result1, #3
	negc	result1, result1 wz
 if_ne	jmp	#LR__0981
	abs	result1, arg01 wc
	qdiv	result1, #100
	getqy	result1
	negc	result1, result1 wz
 if_ne	jmp	#LR__0980
	abs	result1, arg01 wc
	qdiv	result1, #400
'       return (0 == y % 400);
	mov	result1, #0
	getqy	_var01
	negc	_var01, _var01 wz
 if_e	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__0980
'     return 1;
	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__0981
'   }
'   return 0;
	mov	result1, #0
_fatfs_cc__is_leap_year_ret
	ret

_fatfs_cc___tzoffset
	mov	_var01, arg01 wz
	wrlong	##-1, arg02
	mov	_var02, #1
 if_ne	rdbyte	_var03, _var01 wz
'                 return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__1007
	wrlong	#0, arg02
	mov	_var04, ptr__fatfs_cc_dat__
	add	_var04, #288
	callpa	#(@LR__0991-@LR__0990)>>2,fcache_load_ptr_
' 
'        *hasdst = 0;
' 
' 	n = stdname;
'         while (*s && isalpha(*s)) {
LR__0990
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__0992
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, #336
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #12 wz
 if_e	jmp	#LR__0992
	mov	_var05, _var01
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var05
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__0990
LR__0991
LR__0992
	wrbyte	#0, _var04
	mov	_var08, #0
	rdbyte	_var03, _var01
	cmp	_var03, #45 wz
 if_e	neg	_var02, #1
 if_e	add	_var01, #1
	callpa	#(@LR__0994-@LR__0993)>>2,fcache_load_ptr_
'                 sgn = -1;
'                 s++;
'         }
'         while (isdigit(*s)) {
LR__0993
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, #336
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #2 wz
 if_e	jmp	#LR__0995
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__0993
LR__0994
LR__0995
	qmul	_var08, ##3600
	rdbyte	_var03, _var01
	cmp	_var03, #58 wz
	getqx	_var09
 if_ne	jmp	#LR__0999
	mov	_var08, #0
	add	_var01, #1
	callpa	#(@LR__0997-@LR__0996)>>2,fcache_load_ptr_
'                 x = 0;
'                 s++;
'                 while (isdigit(*s)) {
LR__0996
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, #336
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #2 wz
 if_e	jmp	#LR__0998
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__0996
LR__0997
LR__0998
	mov	_var07, _var08
	shl	_var07, #4
	sub	_var07, _var08
	shl	_var07, #2
	add	_var09, _var07
LR__0999
	mov	_var04, ptr__fatfs_cc_dat__
	add	_var04, #297
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, #336
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #12 wz
 if_e	jmp	#LR__1002
	wrlong	#1, arg02
'                 *hasdst = 1;
' 		while (*s && isalpha(*s)) *n++ = *s++;
LR__1000
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__1001
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, #336
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #12 wz
 if_e	jmp	#LR__1001
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var01
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__1000
LR__1001
LR__1002
	wrbyte	#0, _var04
	add	ptr__fatfs_cc_dat__, #288
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, #288
 if_e	jmp	#LR__1003
	add	ptr__fatfs_cc_dat__, #288
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #8
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #280
	jmp	#LR__1004
LR__1003
	add	ptr__fatfs_cc_dat__, #306
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #26
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #280
LR__1004
	add	ptr__fatfs_cc_dat__, #297
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, #297
 if_e	jmp	#LR__1005
	add	ptr__fatfs_cc_dat__, #297
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #13
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #284
	jmp	#LR__1006
LR__1005
	add	ptr__fatfs_cc_dat__, #288
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #4
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #284
LR__1006
	qmul	_var02, _var09
' 		_tzname[1] = stdname;
' 
'         return sgn * off;
	getqx	result1
LR__1007
_fatfs_cc___tzoffset_ret
	ret

_fatfs_cc___indst
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #2 wz
 if_ne	jmp	#LR__1010
	mov	_var01, #7
	add	arg01, #24
	rdlong	_var02, arg01
	add	_var01, _var02
	sub	arg01, #12
	rdlong	_var03, arg01
	sub	_var01, _var03
	cmps	_var01, #0 wc
'                         return 1;
 if_b	mov	result1, #1
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 0;
	mov	result1, #0
	jmp	#_fatfs_cc___indst_ret
LR__1010
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #10 wz
 if_ne	jmp	#LR__1011
	add	arg01, #24
	rdlong	_var01, arg01
	sub	arg01, #12
	rdlong	_var04, arg01
	sub	_var01, _var04
	cmps	_var01, #0 wc
'                         return 0;
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 1;
	mov	result1, #1
	jmp	#_fatfs_cc___indst_ret
LR__1011
'         }
' 
'         return (t->tm_mon > 2 && t->tm_mon < 10);
	mov	_var01, #0
	add	arg01, #16
	rdlong	_var02, arg01
	sub	arg01, #16
	cmps	_var02, #3 wc
 if_b	jmp	#LR__1012
	add	arg01, #16
	rdlong	_var03, arg01
	cmps	_var03, #10 wc
 if_b	mov	_var01, #1
LR__1012
	mov	result1, _var01
_fatfs_cc___indst_ret
	ret

' 
' PUB Initialize
_cpu_Initialize
'     instructionPointer := $F0000000
	wrlong	##-268435456, objptr
'     stackPointer := 0
	add	objptr, #8
	wrlong	#0, objptr
'     debug := false
	add	objptr, #137
	wrbyte	#0, objptr
'     bus.Initialize
	add	objptr, #7
	call	#_bus_Initialize
	sub	objptr, #152
_cpu_Initialize_ret
	ret

'     'bus.DebugStr(string("vm info: fox32 ram at "))
'     'bus.DebugHex(bus.GetRamAddr, 8)
'     'bus.DebugChar(10)
' 
' PUB Execute(cycles) | instructionHalf, temp, temp2, savedSize, skip
_cpu_Execute
	mov	COUNT_, #38
	call	#pushregs_
	mov	local01, arg01
'     repeat cycles
	mov	local02, local01 wz
 if_e	jmp	#LR__1121
LR__1020
'         instructionHalf := bus.ReadHalf(instructionPointer)
	rdlong	arg01, objptr
'     return memory.ReadHalf(address)
	add	objptr, ##796
	call	#_memory_ReadHalf
	sub	objptr, ##796
	mov	local03, result1
'         instructionPointerMut := instructionPointer + SZ_HALF
	rdlong	muldivb_, objptr
	add	muldivb_, #2
	add	objptr, #4
	wrlong	muldivb_, objptr
' 
'         opcode := (instructionHalf >> 8) & 63
	mov	muldivb_, local03
	shr	muldivb_, #8
	and	muldivb_, #63
	add	objptr, #142
	wrbyte	muldivb_, objptr
'         condition := (instructionHalf >> 4) & 7
	mov	muldivb_, local03
	shr	muldivb_, #4
	and	muldivb_, #7
	add	objptr, #1
	wrbyte	muldivb_, objptr
'         offset := (instructionHalf >> 7) & 1
	mov	muldivb_, local03
	shr	muldivb_, #7
	and	muldivb_, #1
	add	objptr, #1
	wrbyte	muldivb_, objptr
'         target := (instructionHalf >> 2) & 3
	mov	muldivb_, local03
	shr	muldivb_, #2
	and	muldivb_, #3
	add	objptr, #1
	wrbyte	muldivb_, objptr
'         source := instructionHalf & 3
	mov	muldivb_, local03
	and	muldivb_, #3
	add	objptr, #1
	wrbyte	muldivb_, objptr
'         size := ((instructionHalf >> 14))
	mov	local04, local03
	shr	local04, #14
	add	objptr, #1
	wrbyte	local04, objptr
'         if (size == 0)
	getbyte	local04, local04, #0
	sub	objptr, #151
	cmp	local04, #0 wz
'             size := 1
 if_e	add	objptr, #151
 if_e	wrbyte	#1, objptr
	sumz	objptr, #151
'         else
'             size *= 2
 if_ne	rdbyte	local04, objptr
 if_ne	shl	local04, #1
 if_ne	wrbyte	local04, objptr
 if_ne	sub	objptr, #151
'         skip := ShouldSkip
	call	#_cpu_ShouldSkip
	mov	local05, result1
' 
'         if (instructionPointer == 0)
	rdlong	local04, objptr wz
'             'bus.DebugStr(string("vm warn: called non-existent jump table entry?"))
'             'bus.DebugChar(10)
'             debug := false
 if_e	add	objptr, #145
 if_e	wrbyte	#0, objptr
 if_e	sub	objptr, #145
' 
'         if (debug)
	add	objptr, #145
	rdbyte	local04, objptr wz
	sub	objptr, #145
 if_e	jmp	#LR__1021
'             bus.DebugHex(instructionPointer, 8)
	rdlong	arg01, objptr
	mov	arg02, #8
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##361080
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'             bus.DebugHex(instructionHalf, 4)
	mov	arg01, local03
	mov	arg02, #4
'     text.Hex(h, digits)
'     video.hex(val, digits)
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'             bus.DebugHex(opcode, 2)
	sub	objptr, ##360934
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360934
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'             bus.DebugHex(condition, 2)
	sub	objptr, ##360933
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360933
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'             bus.DebugHex(offset, 2)
	sub	objptr, ##360932
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360932
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'             bus.DebugHex(target, 2)
	sub	objptr, ##360931
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360931
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'             bus.DebugHex(source, 2)
	sub	objptr, ##360930
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360930
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'             bus.DebugHex(size, 2)
	sub	objptr, ##360929
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360929
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'             bus.DebugChar(10)
	mov	arg01, #10
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
	sub	objptr, ##361080
LR__1021
' 
'         case opcode
	add	objptr, #146
	rdbyte	local06, objptr
	sub	objptr, #146
	mov	local07, local06
	fle	local07, #58
	jmprel	local07
LR__1022
	jmp	#LR__1120
	jmp	#LR__1024
	jmp	#LR__1034
	jmp	#LR__1057
	jmp	#LR__1065
	jmp	#LR__1067
	jmp	#LR__1075
	jmp	#LR__1081
	jmp	#LR__1099
	jmp	#LR__1102
	jmp	#LR__1092
	jmp	#LR__1115
	jmp	#LR__1120
	jmp	#LR__1120
	jmp	#LR__1119
	jmp	#LR__1119
	jmp	#LR__1120
	jmp	#LR__1026
	jmp	#LR__1119
	jmp	#LR__1059
	jmp	#LR__1037
	jmp	#LR__1069
	jmp	#LR__1077
	jmp	#LR__1090
	jmp	#LR__1100
	jmp	#LR__1106
	jmp	#LR__1093
	jmp	#LR__1117
	jmp	#LR__1120
	jmp	#LR__1120
	jmp	#LR__1119
	jmp	#LR__1119
	jmp	#LR__1023
	jmp	#LR__1028
	jmp	#LR__1042
	jmp	#LR__1061
	jmp	#LR__1071
	jmp	#LR__1073
	jmp	#LR__1079
	jmp	#LR__1091
	jmp	#LR__1101
	jmp	#LR__1110
	jmp	#LR__1114
	jmp	#LR__1119
	jmp	#LR__1119
	jmp	#LR__1119
	jmp	#LR__1119
	jmp	#LR__1119
	jmp	#LR__1119
	jmp	#LR__1031
	jmp	#LR__1048
	jmp	#LR__1063
	jmp	#LR__1043
	jmp	#LR__1050
	jmp	#LR__1119
	jmp	#LR__1083
	jmp	#LR__1119
	jmp	#LR__1095
	jmp	#LR__1119
	jmp	#LR__1120
LR__1023
'             OP_NOP, OP_HALT, OP_ISE, OP_ICL, OP_MSE, OP_MCL: ' nothing!
'             OP_BRK:
'                 debug := !debug
	add	objptr, #145
	rdbyte	local07, objptr
	not	local08, local07
	wrbyte	local08, objptr
	sub	objptr, #145
	jmp	#LR__1120
LR__1024
'             OP_ADD:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1025
'                     temp2 := ReadTarget
	call	#_cpu_ReadTarget
	mov	local10, result1
'                     SetCarryFlag((temp2 > 0) and (temp +> $FFFFFFFF - temp2))
	mov	arg01, #0
	cmps	local10, #1 wc
 if_ae	neg	local11, #1
 if_ae	sub	local11, local10
 if_ae	cmp	local09, local11 wcz
 if_a	neg	arg01, #1
	call	#_cpu_SetCarryFlag
'                     temp += temp2
	add	local09, local10 wz
'                     SetZeroFlag(temp == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1025
'                 WriteTarget(temp, true, skip, false)
	mov	local11, local05
	mov	arg01, local09
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1026
'             OP_INC:
'                 temp := ReadSource(true)
	neg	arg01, #1
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1027
'                     temp2 := (1 << target)
	mov	local10, #1
	add	objptr, #149
	rdbyte	local08, objptr
	sub	objptr, #149
	shl	local10, local08
'                     SetCarryFlag((temp2 > 0) and (temp +> $FFFFFFFF - temp2))
	mov	arg01, #0
	cmps	local10, #1 wc
 if_ae	neg	local11, #1
 if_ae	sub	local11, local10
 if_ae	cmp	local09, local11 wcz
 if_a	neg	arg01, #1
	call	#_cpu_SetCarryFlag
'                     temp += temp2
	add	local09, local10 wz
'                     SetZeroFlag(temp == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1027
'                 target := source
	add	objptr, #150
	rdbyte	local08, objptr
	sub	objptr, #1
	wrbyte	local08, objptr
	sub	objptr, #149
'                 WriteTarget(temp, true, skip, false)
	mov	local11, local05
	mov	arg01, local09
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1028
'             OP_SUB:
'                 temp2 := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local10, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1030
'                     temp := ReadTarget
	call	#_cpu_ReadTarget
	mov	local09, result1
'                     SetCarryFlag((temp2 > 0) and (temp +< 0 + temp2))
	mov	local12, #0
	cmps	local10, #1 wc
 if_b	jmp	#LR__1029
	cmp	local09, local10 wc
 if_b	neg	local12, #1
LR__1029
	mov	arg01, local12
	call	#_cpu_SetCarryFlag
'                     temp -= temp2
	sub	local09, local10 wz
'                     SetZeroFlag(temp == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1030
'                 WriteTarget(temp, true, skip, false)
	neg	local12, #1
	mov	local11, local05
	mov	arg01, local09
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1031
'             OP_DEC:
'                 temp := ReadSource(true)
	neg	arg01, #1
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1033
'                     temp2 := (1 << target)
	mov	local10, #1
	add	objptr, #149
	rdbyte	local12, objptr
	sub	objptr, #149
	shl	local10, local12
'                     SetCarryFlag((temp2 > 0) and (temp +< 0 + temp2))
	mov	local12, #0
	cmps	local10, #1 wc
 if_b	jmp	#LR__1032
	cmp	local09, local10 wc
 if_b	neg	local12, #1
LR__1032
	mov	arg01, local12
	call	#_cpu_SetCarryFlag
'                     temp -= temp2
	sub	local09, local10 wz
'                     SetZeroFlag(temp == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1033
'                 target := source
	add	objptr, #150
	rdbyte	local08, objptr
	sub	objptr, #1
	wrbyte	local08, objptr
	sub	objptr, #149
'                 WriteTarget(temp, true, skip, false)
	neg	local12, #1
	mov	local11, local05
	mov	arg01, local09
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1034
'             OP_MUL:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1036
'                     temp2 := ReadTarget
	call	#_cpu_ReadTarget
	mov	local10, result1 wz
'                     SetCarryFlag((temp2 <> 0) and (temp +> $FFFFFFFF / temp2))
	mov	local12, #0
 if_e	jmp	#LR__1035
	abs	local11, local10 wc
	qdiv	#1, local11
	getqx	local11
	negnc	local11, local11
	cmp	local09, local11 wcz
 if_a	neg	local12, #1
LR__1035
	mov	arg01, local12
	call	#_cpu_SetCarryFlag
	qmul	local09, local10
'                     temp *= temp2
'                     SetZeroFlag(temp == 0)
	mov	arg01, #0
	getqx	local09
	cmp	local09, #0 wz
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1036
'                 WriteTarget(temp, true, skip, false)
	neg	local12, #1
	mov	local11, local05
	mov	arg01, local09
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1037
'             OP_IMUL: ' FIXME: is this correct? also need to implement carry flag
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 case size
	add	objptr, #151
	rdbyte	local13, objptr
	sub	objptr, #151
	cmp	local13, #1 wz
 if_e	jmp	#LR__1038
	cmp	local13, #2 wz
 if_e	jmp	#LR__1039
	jmp	#LR__1040
LR__1038
'                     SZ_BYTE: temp := ~temp ' sign extend 7
	signx	local09, #7
	mov	local14, local09
	jmp	#LR__1040
LR__1039
'                     SZ_HALF: temp := ~~temp ' sign extend 15
	signx	local09, #15
	mov	local15, local09
LR__1040
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1041
'                     temp2 := temp * ReadTarget
	call	#_cpu_ReadTarget
	qmul	local09, result1
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
	getqx	local10
	cmp	local10, #0 wz
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1041
'                 WriteTarget(temp2, true, skip, false)
	neg	local12, #1
	mov	local11, local05
	mov	arg01, local10
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1042
'             OP_DIV:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 WriteTarget(ReadTarget +/ temp, true, skip, false)
	call	#_cpu_ReadTarget
	qdiv	result1, local09
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	getqx	local08
	mov	arg01, local08
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1043
'             OP_IDIV: ' FIXME: is this correct?
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 case size
	add	objptr, #151
	rdbyte	local17, objptr
	sub	objptr, #151
	cmp	local17, #1 wz
 if_e	jmp	#LR__1044
	cmp	local17, #2 wz
 if_e	jmp	#LR__1045
	jmp	#LR__1046
LR__1044
'                     SZ_BYTE: temp := ~temp ' sign extend 7
	signx	local09, #7
	mov	local18, local09
	jmp	#LR__1046
LR__1045
'                     SZ_HALF: temp := ~~temp ' sign extend 15
	signx	local09, #15
	mov	local19, local09
LR__1046
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1047
'                     temp2 := ReadTarget / temp
	call	#_cpu_ReadTarget
	mov	muldiva_, result1
	mov	muldivb_, local09
	call	#divide_
	mov	local10, muldivb_ wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1047
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1048
'             OP_REM:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1049
'                     temp2 := ReadTarget +// temp
	call	#_cpu_ReadTarget
	qdiv	result1, local09
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
	getqy	local10
	cmp	local10, #0 wz
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1049
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1050
'             OP_IREM: ' FIXME: is this correct?
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1056
'                     case size
	add	objptr, #151
	rdbyte	local20, objptr
	sub	objptr, #151
	sub	local20, #1
	fle	local20, #4
	jmprel	local20
LR__1051
	jmp	#LR__1052
	jmp	#LR__1053
	jmp	#LR__1055
	jmp	#LR__1054
	jmp	#LR__1055
LR__1052
'                         SZ_BYTE:
'                             temp := ~temp ' sign extend 7
	signx	local09, #7
	mov	local21, local09
'                             temp2 := ReadTarget // temp
	call	#_cpu_ReadTarget
	mov	muldiva_, result1
	mov	muldivb_, local09
	call	#divide_
	mov	local10, muldiva_ wz
'                             SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
	jmp	#LR__1055
LR__1053
'                         SZ_HALF:
'                             temp := ~~temp ' sign extend 15
	signx	local09, #15
	mov	local22, local09
'                             temp2 := ReadTarget // temp
	call	#_cpu_ReadTarget
	mov	muldiva_, result1
	mov	muldivb_, local09
	call	#divide_
	mov	local10, muldiva_ wz
'                             SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
	jmp	#LR__1055
LR__1054
'                         SZ_WORD:
'                             temp2 := ReadTarget // temp
	call	#_cpu_ReadTarget
	mov	muldiva_, result1
	mov	muldivb_, local09
	call	#divide_
	mov	local10, muldiva_ wz
'                             SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1055
LR__1056
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1057
'             OP_AND:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1058
'                     temp2 := ReadTarget & temp
	call	#_cpu_ReadTarget
	mov	local10, result1
	and	local10, local09 wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1058
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1059
'             OP_OR:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1060
'                     temp2 := ReadTarget | temp
	call	#_cpu_ReadTarget
	mov	local10, result1
	or	local10, local09 wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1060
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1061
'             OP_XOR:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1062
'                     temp2 := ReadTarget ^ temp
	call	#_cpu_ReadTarget
	mov	local10, result1
	xor	local10, local09 wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1062
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1063
'             OP_NOT:
'                 temp := !ReadSource(true)
	neg	arg01, #1
	call	#_cpu_ReadSource
	not	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1064
'                     SetZeroFlag(temp == 0)
	mov	arg01, #0
	cmp	local09, #0 wz
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1064
'                 target := source
	add	objptr, #150
	rdbyte	local08, objptr
	sub	objptr, #1
	wrbyte	local08, objptr
	sub	objptr, #149
'                 WriteTarget(temp, true, skip, false)
	mov	local08, local09
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1065
'             OP_SLA: ' shifts & rotates always use an 8-bit source
'                 savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                 size := SZ_BYTE
	wrbyte	#1, objptr
	sub	objptr, #151
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1066
'                     temp2 := ReadTarget << temp
	call	#_cpu_ReadTarget
	mov	local10, result1
	shl	local10, local09 wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1066
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1067
'             OP_SRA: ' shifts & rotates always use an 8-bit source
'                 savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                 size := SZ_BYTE
	wrbyte	#1, objptr
	sub	objptr, #151
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1068
'                     temp2 := ReadTarget ~> temp
	call	#_cpu_ReadTarget
	mov	local10, result1
	sar	local10, local09 wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1068
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1069
'             OP_SRL: ' shifts & rotates always use an 8-bit source
'                 savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                 size := SZ_BYTE
	wrbyte	#1, objptr
	sub	objptr, #151
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1070
'                     temp2 := ReadTarget >> temp
	call	#_cpu_ReadTarget
	mov	local10, result1
	shr	local10, local09 wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1070
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1071
'             OP_ROL: ' shifts & rotates always use an 8-bit source
'                 savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                 size := SZ_BYTE
	wrbyte	#1, objptr
	sub	objptr, #151
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1072
'                     temp2 := ReadTarget <- temp
	call	#_cpu_ReadTarget
	mov	local10, result1
	rol	local10, local09
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
	cmp	local10, #0 wz
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1072
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1073
'             OP_ROR: ' shifts & rotates always use an 8-bit source
'                 savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                 size := SZ_BYTE
	wrbyte	#1, objptr
	sub	objptr, #151
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1074
'                     temp2 := ReadTarget -> temp
	call	#_cpu_ReadTarget
	mov	local10, result1
	ror	local10, local09
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
	cmp	local10, #0 wz
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1074
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1075
'             OP_BSE: ' bit operations always use an 8-bit source
'                 savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                 size := SZ_BYTE
	wrbyte	#1, objptr
	sub	objptr, #151
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1076
'                     temp2 := ReadTarget | (1 << temp)
	call	#_cpu_ReadTarget
	decod	local11, local09
	mov	local10, result1
	or	local10, local11 wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1076
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1077
'             OP_BCL: ' bit operations always use an 8-bit source
'                 savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                 size := SZ_BYTE
	wrbyte	#1, objptr
	sub	objptr, #151
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1078
'                     temp2 := ReadTarget & !(1 << temp)
	call	#_cpu_ReadTarget
	decod	local11, local09
	mov	local10, result1
	andn	local10, local11 wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1078
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1079
'             OP_BTS: ' bit operations always use an 8-bit source
'                 savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                 size := SZ_BYTE
	wrbyte	#1, objptr
	sub	objptr, #151
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1080
'                     temp2 := ReadTarget & (1 << temp)
	call	#_cpu_ReadTarget
	decod	local11, local09
	mov	local10, result1
	and	local10, local11 wz
'                     SetZeroFlag(temp2 == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1080
'                 WriteTarget(temp2, true, true, false) ' dummy write
	mov	local08, local10
	neg	local12, #1
	neg	local11, #1
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	neg	arg03, #1
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1081
'             OP_CMP:
'                 temp2 := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local10, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1082
'                     temp := ReadTarget
	call	#_cpu_ReadTarget
	mov	local09, result1
'                     SetCarryFlag(temp2 +> temp)
	mov	arg01, #0
	cmp	local10, local09 wcz
 if_a	neg	arg01, #1
	call	#_cpu_SetCarryFlag
'                     temp -= temp2
	sub	local09, local10 wz
'                     SetZeroFlag(temp == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1082
'                 WriteTarget(temp, true, true, false) ' dummy write
	mov	local08, local09
	neg	local12, #1
	neg	local11, #1
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	neg	arg03, #1
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1083
'             OP_ICMP:
'                 temp2 := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local10, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1089
'                     case size
	add	objptr, #151
	rdbyte	local24, objptr
	sub	objptr, #151
	sub	local24, #1
	fle	local24, #4
	jmprel	local24
LR__1084
	jmp	#LR__1085
	jmp	#LR__1086
	jmp	#LR__1088
	jmp	#LR__1087
	jmp	#LR__1088
LR__1085
'                         SZ_BYTE:
'                             temp2 := ~temp2 ' sign extend 7
	signx	local10, #7
	mov	local25, local10
'                             temp := ReadTarget
	call	#_cpu_ReadTarget
	mov	local09, result1
'                             SetCarryFlag(temp < temp2)
	cmps	local09, local10 wc
	subx	arg01, arg01
	call	#_cpu_SetCarryFlag
	jmp	#LR__1088
LR__1086
'                         SZ_HALF:
'                             temp2 := ~~temp2 ' sign extend 15
	signx	local10, #15
	mov	local26, local10
'                             temp := ReadTarget
	call	#_cpu_ReadTarget
	mov	local09, result1
'                             SetCarryFlag(temp < temp2)
	cmps	local09, local10 wc
	subx	arg01, arg01
	call	#_cpu_SetCarryFlag
	jmp	#LR__1088
LR__1087
'                         SZ_WORD:
'                             temp := ReadTarget
	call	#_cpu_ReadTarget
	mov	local09, result1
'                             SetCarryFlag(temp < temp2)
	cmps	local09, local10 wc
	subx	arg01, arg01
	call	#_cpu_SetCarryFlag
LR__1088
'                     temp -= temp2
	sub	local09, local10 wz
'                     SetZeroFlag(temp == 0)
	mov	arg01, #0
 if_e	neg	arg01, #1
	call	#_cpu_SetZeroFlag
LR__1089
'                 WriteTarget(temp, true, true, false) ' dummy write
	mov	local08, local09
	neg	local12, #1
	neg	local11, #1
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	neg	arg03, #1
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1090
'             OP_MOV: WriteTarget(ReadSource(false), true, skip, false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local08, result1
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1091
'             OP_MOVZ: WriteTarget(ReadSource(false), false, skip, false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local08, result1
	mov	local12, #0
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	mov	arg02, #0
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1092
'             OP_PUSH:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local08, result1
	mov	local09, local08
'                 if not (skip)
	cmp	local05, #0 wz
'                     Push(temp)
 if_e	mov	local08, local09
 if_e	mov	arg01, local08
 if_e	call	#_cpu_Push
	jmp	#LR__1120
LR__1093
'             OP_POP:
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1094
'                     temp := Pop
	call	#_cpu_Pop
	mov	local09, result1
LR__1094
'                 target := source
	add	objptr, #150
	rdbyte	local08, objptr
	sub	objptr, #1
	wrbyte	local08, objptr
	sub	objptr, #149
'                 WriteTarget(temp, true, skip, false)
	mov	local08, local09
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1095
'             OP_RTA:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 case size
	add	objptr, #151
	rdbyte	local27, objptr
	sub	objptr, #151
	cmp	local27, #1 wz
 if_e	jmp	#LR__1096
	cmp	local27, #2 wz
 if_e	jmp	#LR__1097
	jmp	#LR__1098
LR__1096
'                     SZ_BYTE:
'                         temp := ~temp ' sign extend 7
	signx	local09, #7
	mov	local28, local09
	jmp	#LR__1098
LR__1097
'                     SZ_HALF:
'                         temp := ~~temp ' sign extend 15
	signx	local09, #15
	mov	local29, local09
LR__1098
'                 savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                 size := SZ_WORD
	wrbyte	#4, objptr
	sub	objptr, #151
'                 WriteTarget(instructionPointer + temp, false, skip, false)
	rdlong	local08, objptr
	add	local08, local09
	mov	local12, #0
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	mov	arg02, #0
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
'                 size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
	jmp	#LR__1120
LR__1099
'             OP_JMP:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local08, result1
	mov	local09, local08
'                 if not (skip)
	cmp	local05, #0 wz
'                     instructionPointerMut := temp
 if_e	add	objptr, #4
 if_e	wrlong	local09, objptr
 if_e	sub	objptr, #4
	jmp	#LR__1120
LR__1100
'             OP_CALL:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local08, result1
	mov	local09, local08
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1120
'                     savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                     size := SZ_WORD
	wrbyte	#4, objptr
'                     Push(instructionPointerMut)
	sub	objptr, #147
	rdlong	local12, objptr
	sub	objptr, #4
	mov	local08, local12
	mov	arg01, local08
	call	#_cpu_Push
'                     size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
'                     instructionPointerMut := temp
	sub	objptr, #147
	wrlong	local09, objptr
	sub	objptr, #4
	jmp	#LR__1120
LR__1101
'             OP_LOOP:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local08, result1
	mov	local09, local08
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1120
'                     registers[31]--
	add	objptr, #140
	rdlong	local16, objptr
	mov	local11, local16
	sub	local11, #1
	wrlong	local11, objptr
'                     if (registers[31] <> 0)
	mov	local12, local11
	sub	objptr, #140
	mov	local08, local12 wz
'                         instructionPointerMut := temp
 if_ne	add	objptr, #4
 if_ne	wrlong	local09, objptr
 if_ne	sub	objptr, #4
	jmp	#LR__1120
LR__1102
'             OP_RJMP:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 case size
	add	objptr, #151
	rdbyte	local08, objptr
	sub	objptr, #151
	mov	local30, local08
	cmp	local30, #1 wz
 if_e	jmp	#LR__1103
	cmp	local30, #2 wz
 if_e	jmp	#LR__1104
	jmp	#LR__1105
LR__1103
'                     SZ_BYTE:
'                         temp := ~temp ' sign extend 7
	mov	local08, local09
	signx	local08, #7
	mov	local31, local08
	mov	local09, local31
	jmp	#LR__1105
LR__1104
'                     SZ_HALF:
'                         temp := ~~temp ' sign extend 15
	mov	local08, local09
	signx	local08, #15
	mov	local32, local08
	mov	local09, local32
LR__1105
'                 if not (skip)
	cmp	local05, #0 wz
'                     instructionPointerMut := instructionPointer + temp
 if_e	rdlong	local08, objptr
 if_e	add	local08, local09
 if_e	add	objptr, #4
 if_e	wrlong	local08, objptr
 if_e	sub	objptr, #4
	jmp	#LR__1120
LR__1106
'             OP_RCALL:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 case size
	add	objptr, #151
	rdbyte	local08, objptr
	sub	objptr, #151
	mov	local33, local08
	cmp	local33, #1 wz
 if_e	jmp	#LR__1107
	cmp	local33, #2 wz
 if_e	jmp	#LR__1108
	jmp	#LR__1109
LR__1107
'                     SZ_BYTE:
'                         temp := ~temp ' sign extend 7
	mov	local08, local09
	signx	local08, #7
	mov	local34, local08
	mov	local09, local34
	jmp	#LR__1109
LR__1108
'                     SZ_HALF:
'                         temp := ~~temp ' sign extend 15
	mov	local08, local09
	signx	local08, #15
	mov	local35, local08
	mov	local09, local35
LR__1109
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1120
'                     savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                     size := SZ_WORD
	wrbyte	#4, objptr
'                     Push(instructionPointerMut)
	sub	objptr, #147
	rdlong	local12, objptr
	sub	objptr, #4
	mov	arg01, local12
	call	#_cpu_Push
'                     size := savedSize
	add	objptr, #151
	wrbyte	local23, objptr
	sub	objptr, #151
'                     instructionPointerMut := instructionPointer + temp
	rdlong	local08, objptr
	add	local08, local09
	add	objptr, #4
	wrlong	local08, objptr
	sub	objptr, #4
	jmp	#LR__1120
LR__1110
'             OP_RLOOP:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 case size
	add	objptr, #151
	rdbyte	local08, objptr
	sub	objptr, #151
	mov	local36, local08
	cmp	local36, #1 wz
 if_e	jmp	#LR__1111
	cmp	local36, #2 wz
 if_e	jmp	#LR__1112
	jmp	#LR__1113
LR__1111
'                     SZ_BYTE:
'                         temp := ~temp ' sign extend 7
	mov	local08, local09
	signx	local08, #7
	mov	local37, local08
	mov	local09, local37
	jmp	#LR__1113
LR__1112
'                     SZ_HALF:
'                         temp := ~~temp ' sign extend 15
	mov	local08, local09
	signx	local08, #15
	mov	local38, local08
	mov	local09, local38
LR__1113
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1120
'                     registers[31]--
	add	objptr, #140
	rdlong	local16, objptr
	mov	local11, local16
	sub	local11, #1
	wrlong	local11, objptr
'                     if (registers[31] <> 0)
	mov	local12, local11
	sub	objptr, #140
	mov	local08, local12 wz
'                         instructionPointerMut := instructionPointer + temp
 if_ne	rdlong	local08, objptr
 if_ne	add	local08, local09
 if_ne	add	objptr, #4
 if_ne	wrlong	local08, objptr
 if_ne	sub	objptr, #4
	jmp	#LR__1120
LR__1114
'             OP_RET:
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1120
'                     savedSize := size
	add	objptr, #151
	rdbyte	local23, objptr
'                     size := SZ_WORD
	wrbyte	#4, objptr
	sub	objptr, #151
'                     instructionPointerMut := Pop
	call	#_cpu_Pop
	mov	local08, result1
	add	objptr, #4
	wrlong	local08, objptr
'                     size := savedSize
	add	objptr, #147
	wrbyte	local23, objptr
	sub	objptr, #151
	jmp	#LR__1120
LR__1115
'             OP_IN:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1116
'                     temp2 := bus.Read(temp)
	mov	arg01, local09
	add	objptr, #152
	call	#_bus_Read
	sub	objptr, #152
	mov	local10, result1
LR__1116
'                 WriteTarget(temp2, true, skip, false)
	mov	local08, local10
	neg	local12, #1
	mov	local11, local05
	mov	local16, #0
	mov	arg01, local08
	neg	arg02, #1
	mov	arg03, local11
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1117
'             OP_OUT:
'                 temp := ReadSource(false)
	mov	arg01, #0
	call	#_cpu_ReadSource
	mov	local09, result1
'                 temp2 := ReadTarget
	call	#_cpu_ReadTarget
	mov	local10, result1
'                 if not (skip)
	cmp	local05, #0 wz
 if_ne	jmp	#LR__1118
'                     bus.Write(temp2, temp)
	mov	arg01, local10
	mov	arg02, local09
	add	objptr, #152
	call	#_bus_Write
	sub	objptr, #152
LR__1118
'                 WriteTarget(0, true, true, false)
	mov	local08, #0
	neg	local12, #1
	neg	local11, #1
	mov	local16, #0
	mov	arg01, #0
	neg	arg02, #1
	neg	arg03, #1
	mov	arg04, #0
	call	#_cpu_WriteTarget
	jmp	#LR__1120
LR__1119
'             other: Panic(string("bad opcode"), opcode)
	mov	local08, ##@LR__2100
	add	objptr, #146
	rdbyte	local11, objptr
	sub	objptr, #146
	mov	arg01, local08
	mov	arg02, local11
	call	#_cpu_Panic
LR__1120
' 
'         instructionPointer := instructionPointerMut
	add	objptr, #4
	rdlong	local04, objptr
	sub	objptr, #4
	wrlong	local04, objptr
	sub	local02, #1 wz
 if_ne	jmp	#LR__1020
LR__1121
	mov	ptra, fp
	call	#popregs_
_cpu_Execute_ret
	ret

' 
' PRI Panic(message, arg)
_cpu_Panic
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'     bus.DebugStr(string("vm panic: "))
	mov	arg01, ##@LR__2101
'     text.PrintStr(s)
'     video.printStr(str)
	add	objptr, ##361080
	call	#_p2videodrv_printStr
'     bus.DebugStr(message)
	mov	arg01, local01
'     text.PrintStr(s)
'     video.printStr(str)
	call	#_p2videodrv_printStr
'     bus.DebugStr(string(" "))
	mov	arg01, ##@LR__2102
'     text.PrintStr(s)
'     video.printStr(str)
	call	#_p2videodrv_printStr
'     bus.DebugHex(arg, 8)
	mov	arg01, local02
	mov	arg02, #8
'     text.Hex(h, digits)
'     video.hex(val, digits)
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'     bus.DebugChar(10)
	mov	arg01, #10
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
	sub	objptr, ##361080
'     bus.DebugHex(instructionPointer, 8)
	rdlong	arg01, objptr
	mov	arg02, #8
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##361080
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'     bus.DebugHex(opcode, 2)
	sub	objptr, ##360934
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360934
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'     bus.DebugHex(condition, 2)
	sub	objptr, ##360933
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360933
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'     bus.DebugHex(offset, 2)
	sub	objptr, ##360932
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360932
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'     bus.DebugHex(target, 2)
	sub	objptr, ##360931
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360931
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'     bus.DebugHex(source, 2)
	sub	objptr, ##360930
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360930
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'     bus.DebugHex(size, 2)
	sub	objptr, ##360929
	rdbyte	arg01, objptr
	mov	arg02, #2
'     text.Hex(h, digits)
'     video.hex(val, digits)
	add	objptr, ##360929
	call	#_p2videodrv_hex
'     DebugChar(" ")
	mov	arg01, #32
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'     bus.DebugChar(10)
	mov	arg01, #10
'     text.Out(c)
'     video.out(ch)
	call	#_p2videodrv_out
'     repeat
LR__1130
	jmp	#LR__1130
	mov	ptra, fp
	call	#popregs_
_cpu_Panic_ret
	ret

' 
' PRI Push(value)
_cpu_Push
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
'     stackPointer -= size
	add	objptr, #8
	rdlong	local02, objptr
	add	objptr, #143
	rdbyte	local03, objptr
	sub	local02, local03
	sub	objptr, #143
	wrlong	local02, objptr
'     if (stackPointer & $80000000)
	sub	objptr, #8
	testbn	local02, #31 wz
'         Panic(string("stack pointer has high bit set???"), stackPointer)
 if_ne	mov	arg01, ##@LR__2103
 if_ne	add	objptr, #8
 if_ne	rdlong	arg02, objptr
 if_ne	sub	objptr, #8
 if_ne	call	#_cpu_Panic
'     case size
	add	objptr, #151
	rdbyte	local04, objptr
	sub	objptr, #151
	sub	local04, #1
	fle	local04, #4
	jmprel	local04
LR__1140
	jmp	#LR__1141
	jmp	#LR__1142
	jmp	#LR__1144
	jmp	#LR__1143
	jmp	#LR__1144
LR__1141
'         SZ_BYTE: bus.WriteByte(stackPointer, value)
	add	objptr, #8
	rdlong	arg01, objptr
	mov	arg02, local01
'     memory.WriteByte(address, value)
	add	objptr, ##788
	call	#_memory_WriteByte
	sub	objptr, ##796
	jmp	#LR__1145
LR__1142
'         SZ_HALF: bus.WriteHalf(stackPointer, value)
	add	objptr, #8
	rdlong	arg01, objptr
	mov	arg02, local01
'     memory.WriteHalf(address, value)
	add	objptr, ##788
	call	#_memory_WriteHalf
	sub	objptr, ##796
	jmp	#LR__1145
LR__1143
'         SZ_WORD: bus.WriteWord(stackPointer, value)
	add	objptr, #8
	rdlong	arg01, objptr
	mov	arg02, local01
'     memory.WriteWord(address, value)
	add	objptr, ##788
	call	#_memory_WriteWord
	sub	objptr, ##796
	jmp	#LR__1145
LR__1144
'         other: Panic(string("bad size"), size)
	mov	arg01, ##@LR__2104
	add	objptr, #151
	rdbyte	arg02, objptr
	sub	objptr, #151
	call	#_cpu_Panic
LR__1145
	mov	ptra, fp
	call	#popregs_
_cpu_Push_ret
	ret

' 
' PRI Pop
_cpu_Pop
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, #0
'     case size
	add	objptr, #151
	rdbyte	local02, objptr
	sub	objptr, #151
	sub	local02, #1
	fle	local02, #4
	jmprel	local02
LR__1150
	jmp	#LR__1151
	jmp	#LR__1152
	jmp	#LR__1154
	jmp	#LR__1153
	jmp	#LR__1154
LR__1151
'         SZ_BYTE: result := bus.ReadByte(stackPointer)
	add	objptr, #8
	rdlong	arg01, objptr
'     return memory.ReadByte(address)
	add	objptr, ##788
	call	#_memory_ReadByte
	sub	objptr, ##796
	mov	local01, result1
	jmp	#LR__1155
LR__1152
'         SZ_HALF: result := bus.ReadHalf(stackPointer)
	add	objptr, #8
	rdlong	arg01, objptr
'     return memory.ReadHalf(address)
	add	objptr, ##788
	call	#_memory_ReadHalf
	sub	objptr, ##796
	mov	local01, result1
	jmp	#LR__1155
LR__1153
'         SZ_WORD: result := bus.ReadWord(stackPointer)
	add	objptr, #8
	rdlong	arg01, objptr
'     return memory.ReadWord(address)
	add	objptr, ##788
	call	#_memory_ReadWord
	sub	objptr, ##796
	mov	local01, result1
	jmp	#LR__1155
LR__1154
'         other: Panic(string("bad size"), size)
	mov	arg01, ##@LR__2105
	add	objptr, #151
	rdbyte	arg02, objptr
	sub	objptr, #151
	call	#_cpu_Panic
LR__1155
'     stackPointer += size
	add	objptr, #8
	rdlong	local02, objptr
	add	objptr, #143
	rdbyte	result1, objptr
	add	local02, result1
	sub	objptr, #143
	wrlong	local02, objptr
'     if (stackPointer & $80000000)
	sub	objptr, #8
	testbn	local02, #31 wz
'         Panic(string("stack pointer has high bit set"), stackPointer)
 if_ne	mov	arg01, ##@LR__2106
 if_ne	add	objptr, #8
 if_ne	rdlong	arg02, objptr
 if_ne	sub	objptr, #8
 if_ne	call	#_cpu_Panic
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_cpu_Pop_ret
	ret

' 
' PRI ReadRegister(register)
_cpu_ReadRegister
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
'     case register
	mov	local02, local01
	cmps	local02, #0 wc
 if_b	jmp	#LR__1160
	cmps	local02, #32 wc
 if_b	jmp	#LR__1161
LR__1160
	cmp	local02, #32 wz
 if_e	jmp	#LR__1162
	cmp	local02, #34 wz
 if_e	jmp	#LR__1163
	jmp	#LR__1164
LR__1161
'         0..31: return registers[register]
	shl	local01, #2
	mov	local02, objptr
	add	local02, #16
	add	local01, local02
	rdlong	result1, local01
	jmp	#LR__1165
LR__1162
'         32: return stackPointer
	add	objptr, #8
	rdlong	result1, objptr
	sub	objptr, #8
	jmp	#LR__1165
LR__1163
'         '33: return 0 ' resp, not used here
'         34: return framePointer
	add	objptr, #12
	rdlong	result1, objptr
	sub	objptr, #12
	jmp	#LR__1165
LR__1164
'         other: Panic(string("bad register"), register)
	mov	arg01, ##@LR__2107
	mov	arg02, local01
	call	#_cpu_Panic
LR__1165
	mov	ptra, fp
	call	#popregs_
_cpu_ReadRegister_ret
	ret

' 
' PRI WriteRegister(register, value)
_cpu_WriteRegister
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'     case register
	cmps	local01, #0 wc
 if_b	jmp	#LR__1170
	cmps	local01, #32 wc
 if_b	jmp	#LR__1171
LR__1170
	cmp	local01, #32 wz
 if_e	jmp	#LR__1172
	cmp	local01, #34 wz
 if_e	jmp	#LR__1173
	jmp	#LR__1174
LR__1171
'         0..31: registers[register] := value
	shl	local01, #2
	mov	arg02, objptr
	add	arg02, #16
	add	local01, arg02
	wrlong	local02, local01
	jmp	#LR__1175
LR__1172
'         32: stackPointer := value
	add	objptr, #8
	wrlong	local02, objptr
	sub	objptr, #8
	jmp	#LR__1175
LR__1173
'         '33: return
'         34: framePointer := value
	add	objptr, #12
	wrlong	local02, objptr
	sub	objptr, #12
	jmp	#LR__1175
LR__1174
'         other: Panic(string("bad register"), register)
	mov	arg01, ##@LR__2108
	mov	arg02, local01
	call	#_cpu_Panic
LR__1175
	mov	ptra, fp
	call	#popregs_
_cpu_WriteRegister_ret
	ret

' 
' ' affects global state!
' PRI ReadSource(stay) | register, pointer, value
_cpu_ReadSource
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
'     case source
	add	objptr, #150
	rdbyte	local02, objptr
	sub	objptr, #150
	fle	local02, #4
	jmprel	local02
LR__1180
	jmp	#LR__1181
	jmp	#LR__1185
	jmp	#LR__1188
	jmp	#LR__1190
	jmp	#LR__1191
LR__1181
'         TY_REG:
'             register := bus.ReadByte(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadByte(address)
	add	objptr, ##792
	call	#_memory_ReadByte
	sub	objptr, ##796
	mov	arg01, result1
'             if not (stay)
	cmp	local01, #0 wz
'                 instructionPointerMut += SZ_BYTE
 if_e	add	objptr, #4
 if_e	rdlong	local03, objptr
 if_e	add	local03, #1
 if_e	wrlong	local03, objptr
 if_e	sub	objptr, #4
'             value := ReadRegister(register)
	call	#_cpu_ReadRegister
	mov	local04, result1
'             case size
	add	objptr, #151
	rdbyte	local05, objptr
	sub	objptr, #151
	cmp	local05, #1 wz
 if_e	jmp	#LR__1182
	cmp	local05, #2 wz
 if_e	jmp	#LR__1183
	jmp	#LR__1184
LR__1182
'                 SZ_BYTE: value &= $000000FF
	getbyte	local04, local04, #0
	jmp	#LR__1184
LR__1183
'                 SZ_HALF: value &= $0000FFFF
	getword	local04, local04, #0
LR__1184
'             return value
	mov	result1, local04
	jmp	#LR__1192
LR__1185
'         TY_REGPTR:
'             register := bus.ReadByte(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadByte(address)
	add	objptr, ##792
	call	#_memory_ReadByte
	sub	objptr, ##796
	mov	arg01, result1
'             pointer := ReadRegister(register)
	call	#_cpu_ReadRegister
	mov	local06, result1
'             instructionPointerMut += SZ_BYTE
	add	objptr, #4
	rdlong	local03, objptr
	add	local03, #1
	wrlong	local03, objptr
'             if (offset <> 0)
	add	objptr, #144
	rdbyte	local03, objptr wz
	sub	objptr, #148
 if_e	jmp	#LR__1186
'                 pointer += bus.ReadByte(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadByte(address)
	add	objptr, ##792
	call	#_memory_ReadByte
	add	local06, result1
'                 instructionPointerMut += SZ_BYTE
	sub	objptr, ##792
	rdlong	local03, objptr
	add	local03, #1
	wrlong	local03, objptr
	sub	objptr, #4
LR__1186
'             value := ReadWithSize(pointer)
	mov	arg01, local06
	call	#_cpu_ReadWithSize
	mov	local04, result1
'             if (stay)
	cmp	local01, #0 wz
 if_e	jmp	#LR__1187
'                 instructionPointerMut -= SZ_BYTE
	add	objptr, #4
	rdlong	local03, objptr
	sub	local03, #1
	wrlong	local03, objptr
'                 if (offset <> 0)
	add	objptr, #144
	rdbyte	local03, objptr wz
	sub	objptr, #148
'                     instructionPointerMut -= SZ_BYTE
 if_ne	add	objptr, #4
 if_ne	rdlong	local03, objptr
 if_ne	sub	local03, #1
 if_ne	wrlong	local03, objptr
 if_ne	sub	objptr, #4
LR__1187
'             return value
	mov	result1, local04
	jmp	#LR__1192
LR__1188
'         TY_IMM:
'             value := ReadWithSize(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	call	#_cpu_ReadWithSize
	mov	local04, result1
'             if not (stay)
	cmp	local01, #0 wz
 if_ne	jmp	#LR__1189
'                 instructionPointerMut += size
	add	objptr, #4
	rdlong	local03, objptr
	add	objptr, #147
	rdbyte	local06, objptr
	add	local03, local06
	sub	objptr, #147
	wrlong	local03, objptr
	sub	objptr, #4
LR__1189
'             return value
	mov	result1, local04
	jmp	#LR__1192
LR__1190
'         TY_IMMPTR:
'             pointer := bus.ReadWord(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadWord(address)
	add	objptr, ##792
	call	#_memory_ReadWord
	sub	objptr, ##796
	mov	arg01, result1
'             if not (stay)
	cmp	local01, #0 wz
'                 instructionPointerMut += SZ_WORD
 if_e	add	objptr, #4
 if_e	rdlong	local03, objptr
 if_e	add	local03, #4
 if_e	wrlong	local03, objptr
 if_e	sub	objptr, #4
'             return ReadWithSize(pointer)
	call	#_cpu_ReadWithSize
	jmp	#LR__1192
LR__1191
'         other: Panic(string("bad source"), source)
	mov	arg01, ##@LR__2109
	add	objptr, #150
	rdbyte	arg02, objptr
	sub	objptr, #150
	call	#_cpu_Panic
	mov	result1, #0
LR__1192
	mov	ptra, fp
	call	#popregs_
_cpu_ReadSource_ret
	ret

' 
' ' read target without affecting global state. must read source first before calling this
' PRI ReadTarget | register, pointer, value
_cpu_ReadTarget
	mov	COUNT_, #4
	call	#pushregs_
'     case target
	add	objptr, #149
	rdbyte	local01, objptr
	sub	objptr, #149
	fle	local01, #4
	jmprel	local01
LR__1200
	jmp	#LR__1201
	jmp	#LR__1205
	jmp	#LR__1207
	jmp	#LR__1208
	jmp	#LR__1209
LR__1201
'         TY_REG:
'             register := bus.ReadByte(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadByte(address)
	add	objptr, ##792
	call	#_memory_ReadByte
	sub	objptr, ##796
	mov	arg01, result1
'             value := ReadRegister(register)
	call	#_cpu_ReadRegister
	mov	local02, result1
'             case size
	add	objptr, #151
	rdbyte	local03, objptr
	sub	objptr, #151
	cmp	local03, #1 wz
 if_e	jmp	#LR__1202
	cmp	local03, #2 wz
 if_e	jmp	#LR__1203
	jmp	#LR__1204
LR__1202
'                 SZ_BYTE: value &= $000000FF
	getbyte	local02, local02, #0
	jmp	#LR__1204
LR__1203
'                 SZ_HALF: value &= $0000FFFF
	getword	local02, local02, #0
LR__1204
'             return value
	mov	result1, local02
	jmp	#LR__1210
LR__1205
'         TY_REGPTR:
'             pointer := ReadRegister(bus.ReadByte(instructionPointerMut))
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadByte(address)
	add	objptr, ##792
	call	#_memory_ReadByte
	sub	objptr, ##796
	mov	arg01, result1
	call	#_cpu_ReadRegister
	mov	local04, result1
'             if (offset <> 0)
	add	objptr, #148
	rdbyte	local03, objptr wz
	sub	objptr, #148
 if_e	jmp	#LR__1206
'                 pointer += bus.ReadByte(instructionPointerMut + SZ_BYTE)
	add	objptr, #4
	rdlong	arg01, objptr
	add	arg01, #1
'     return memory.ReadByte(address)
	add	objptr, ##792
	call	#_memory_ReadByte
	sub	objptr, ##796
	add	local04, result1
LR__1206
'             return ReadWithSize(pointer)
	mov	arg01, local04
	call	#_cpu_ReadWithSize
	jmp	#LR__1210
LR__1207
'         TY_IMM:
'             return ReadWithSize(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	call	#_cpu_ReadWithSize
	jmp	#LR__1210
LR__1208
'         TY_IMMPTR:
'             return ReadWithSize(bus.ReadWord(instructionPointerMut))
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadWord(address)
	add	objptr, ##792
	call	#_memory_ReadWord
	sub	objptr, ##796
	mov	arg01, result1
	call	#_cpu_ReadWithSize
	jmp	#LR__1210
LR__1209
'         other: Panic(string("bad target"), target)
	mov	arg01, ##@LR__2110
	add	objptr, #149
	rdbyte	arg02, objptr
	sub	objptr, #149
	call	#_cpu_Panic
	mov	result1, #0
LR__1210
	mov	ptra, fp
	call	#popregs_
_cpu_ReadTarget_ret
	ret

' 
' ' affects global state!
' PRI WriteTarget(value, keepUpperBits, skip, stay) | register, pointer, temp
_cpu_WriteTarget
	mov	COUNT_, #12
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
'     case target
	add	objptr, #149
	rdbyte	local05, objptr
	sub	objptr, #149
	fle	local05, #4
	jmprel	local05
LR__1220
	jmp	#LR__1221
	jmp	#LR__1228
	jmp	#LR__1236
	jmp	#LR__1237
	jmp	#LR__1244
LR__1221
'         TY_REG:
'             register := bus.ReadByte(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadByte(address)
	add	objptr, ##792
	call	#_memory_ReadByte
	sub	objptr, ##796
	mov	local06, result1
'             if not (stay)
	cmp	local04, #0 wz
'                 instructionPointerMut += SZ_BYTE
 if_e	add	objptr, #4
 if_e	rdlong	local07, objptr
 if_e	add	local07, #1
 if_e	wrlong	local07, objptr
 if_e	sub	objptr, #4
'             if (keepUpperBits)
	cmp	local02, #0 wz
 if_e	jmp	#LR__1227
'                 temp := ReadRegister(register)
	mov	arg01, local06
	call	#_cpu_ReadRegister
	mov	local08, result1
'                 case size
	add	objptr, #151
	rdbyte	local09, objptr
	sub	objptr, #151
	sub	local09, #1
	fle	local09, #4
	jmprel	local09
LR__1222
	jmp	#LR__1223
	jmp	#LR__1224
	jmp	#LR__1225
	jmp	#LR__1226
	jmp	#LR__1225
LR__1223
'                     SZ_BYTE: value := (temp & $FFFFFF00) | (value & $000000FF)
	andn	local08, #255
	getbyte	local01, local01, #0
	or	local01, local08
	jmp	#LR__1226
LR__1224
'                     SZ_HALF: value := (temp & $FFFF0000) | (value & $0000FFFF)
	bitl	local08, #480
	getword	local01, local01, #0
	or	local01, local08
	jmp	#LR__1226
LR__1225
'                     SZ_WORD:
'                     other: Panic(string("bad size"), size)
	mov	arg01, ##@LR__2111
	add	objptr, #151
	rdbyte	arg02, objptr
	sub	objptr, #151
	call	#_cpu_Panic
LR__1226
LR__1227
'             if not (skip)
	cmp	local03, #0 wz
'                 WriteRegister(register, value)
 if_e	mov	arg01, local06
 if_e	mov	arg02, local01
 if_e	call	#_cpu_WriteRegister
	jmp	#LR__1245
LR__1228
'         TY_REGPTR:
'             register := bus.ReadByte(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadByte(address)
	add	objptr, ##792
	call	#_memory_ReadByte
	sub	objptr, ##796
	mov	arg01, result1
'             pointer := ReadRegister(register)
	call	#_cpu_ReadRegister
	mov	local10, result1
'             instructionPointerMut += SZ_BYTE
	add	objptr, #4
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
'             if (offset <> 0)
	add	objptr, #144
	rdbyte	local07, objptr wz
	sub	objptr, #148
 if_e	jmp	#LR__1229
'                 pointer += bus.ReadByte(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadByte(address)
	add	objptr, ##792
	call	#_memory_ReadByte
	add	local10, result1
'                 instructionPointerMut += SZ_BYTE
	sub	objptr, ##792
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, #4
LR__1229
'             if (keepUpperBits)
	cmp	local02, #0 wz
 if_e	jmp	#LR__1234
'                 temp := bus.ReadWord(pointer)
	mov	arg01, local10
'     return memory.ReadWord(address)
	add	objptr, ##796
	call	#_memory_ReadWord
	mov	local08, result1
'                 case size
	sub	objptr, ##645
	rdbyte	local11, objptr
	sub	objptr, #151
	sub	local11, #1
	fle	local11, #4
	jmprel	local11
LR__1230
	jmp	#LR__1231
	jmp	#LR__1232
	jmp	#LR__1233
	jmp	#LR__1235
	jmp	#LR__1233
LR__1231
'                     SZ_BYTE: value := (temp & $FFFFFF00) | (value & $000000FF)
	andn	local08, #255
	getbyte	local01, local01, #0
	or	local01, local08
	jmp	#LR__1235
LR__1232
'                     SZ_HALF: value := (temp & $FFFF0000) | (value & $0000FFFF)
	bitl	local08, #480
	getword	local01, local01, #0
	or	local01, local08
	jmp	#LR__1235
LR__1233
'                     SZ_WORD:
'                     other: Panic(string("bad size"), size)
	mov	arg01, ##@LR__2112
	add	objptr, #151
	rdbyte	arg02, objptr
	sub	objptr, #151
	call	#_cpu_Panic
	jmp	#LR__1235
LR__1234
'             else
'                 size := SZ_WORD ' we need to write a full word to clear the upper bits
	add	objptr, #151
	wrbyte	#4, objptr
	sub	objptr, #151
LR__1235
'             if not (skip)
	cmp	local03, #0 wz
'                 WriteWithSize(pointer, value)
 if_e	mov	arg01, local10
 if_e	mov	arg02, local01
 if_e	call	#_cpu_WriteWithSize
'             if (stay)
	cmp	local04, #0 wz
 if_e	jmp	#LR__1245
'                 instructionPointerMut -= SZ_BYTE
	add	objptr, #4
	rdlong	local07, objptr
	sub	local07, #1
	wrlong	local07, objptr
'                 if (offset <> 0)
	add	objptr, #144
	rdbyte	local07, objptr wz
	sub	objptr, #148
 if_e	jmp	#LR__1245
'                     instructionPointerMut -= SZ_BYTE
	add	objptr, #4
	rdlong	local07, objptr
	sub	local07, #1
	wrlong	local07, objptr
	sub	objptr, #4
	jmp	#LR__1245
LR__1236
'         TY_IMM:
'             if not (stay)
	cmp	local04, #0 wz
 if_ne	jmp	#LR__1245
'                 instructionPointerMut += size
	add	objptr, #4
	rdlong	local07, objptr
	add	objptr, #147
	rdbyte	local11, objptr
	add	local07, local11
	sub	objptr, #147
	wrlong	local07, objptr
	sub	objptr, #4
	jmp	#LR__1245
LR__1237
'         TY_IMMPTR:
'             pointer := bus.ReadWord(instructionPointerMut)
	add	objptr, #4
	rdlong	arg01, objptr
'     return memory.ReadWord(address)
	add	objptr, ##792
	call	#_memory_ReadWord
	sub	objptr, ##796
	mov	local10, result1
'             if (keepUpperBits)
	cmp	local02, #0 wz
 if_e	jmp	#LR__1242
'                 temp := bus.ReadWord(pointer)
	mov	arg01, local10
'     return memory.ReadWord(address)
	add	objptr, ##796
	call	#_memory_ReadWord
	mov	local08, result1
'                 case size
	sub	objptr, ##645
	rdbyte	local12, objptr
	sub	objptr, #151
	sub	local12, #1
	fle	local12, #4
	jmprel	local12
LR__1238
	jmp	#LR__1239
	jmp	#LR__1240
	jmp	#LR__1241
	jmp	#LR__1243
	jmp	#LR__1241
LR__1239
'                     SZ_BYTE: value := (temp & $FFFFFF00) | (value & $000000FF)
	andn	local08, #255
	getbyte	local01, local01, #0
	or	local01, local08
	jmp	#LR__1243
LR__1240
'                     SZ_HALF: value := (temp & $FFFF0000) | (value & $0000FFFF)
	bitl	local08, #480
	getword	local01, local01, #0
	or	local01, local08
	jmp	#LR__1243
LR__1241
'                     SZ_WORD:
'                     other: Panic(string("bad size"), size)
	mov	arg01, ##@LR__2113
	add	objptr, #151
	rdbyte	arg02, objptr
	sub	objptr, #151
	call	#_cpu_Panic
	jmp	#LR__1243
LR__1242
'             else
'                 size := SZ_WORD ' we need to write a full word to clear the upper bits
	add	objptr, #151
	wrbyte	#4, objptr
	sub	objptr, #151
LR__1243
'             if not (stay)
	cmp	local04, #0 wz
'                 instructionPointerMut += SZ_WORD
 if_e	add	objptr, #4
 if_e	rdlong	local07, objptr
 if_e	add	local07, #4
 if_e	wrlong	local07, objptr
 if_e	sub	objptr, #4
'             if not (skip)
	cmp	local03, #0 wz
'                 WriteWithSize(pointer, value)
 if_e	mov	arg01, local10
 if_e	mov	arg02, local01
 if_e	call	#_cpu_WriteWithSize
	jmp	#LR__1245
LR__1244
'         other: Panic(string("bad target"), target)
	mov	arg01, ##@LR__2114
	add	objptr, #149
	rdbyte	arg02, objptr
	sub	objptr, #149
	call	#_cpu_Panic
LR__1245
	mov	ptra, fp
	call	#popregs_
_cpu_WriteTarget_ret
	ret

' 
' PRI ReadWithSize(address)
_cpu_ReadWithSize
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
'     case size
	add	objptr, #151
	rdbyte	local02, objptr
	sub	objptr, #151
	sub	local02, #1
	fle	local02, #4
	jmprel	local02
LR__1250
	jmp	#LR__1251
	jmp	#LR__1252
	jmp	#LR__1254
	jmp	#LR__1253
	jmp	#LR__1254
LR__1251
'         SZ_BYTE: return bus.ReadByte(address)
	mov	arg01, local01
'     return memory.ReadByte(address)
	add	objptr, ##796
	call	#_memory_ReadByte
	sub	objptr, ##796
	jmp	#LR__1255
LR__1252
'         SZ_HALF: return bus.ReadHalf(address)
	mov	arg01, local01
'     return memory.ReadHalf(address)
	add	objptr, ##796
	call	#_memory_ReadHalf
	sub	objptr, ##796
	jmp	#LR__1255
LR__1253
'         SZ_WORD: return bus.ReadWord(address)
	mov	arg01, local01
'     return memory.ReadWord(address)
	add	objptr, ##796
	call	#_memory_ReadWord
	sub	objptr, ##796
	jmp	#LR__1255
LR__1254
'         other: Panic(string("bad size"), size)
	mov	arg01, ##@LR__2115
	add	objptr, #151
	rdbyte	arg02, objptr
	sub	objptr, #151
	call	#_cpu_Panic
	mov	result1, #0
LR__1255
	mov	ptra, fp
	call	#popregs_
_cpu_ReadWithSize_ret
	ret

' 
' PRI WriteWithSize(address, value)
_cpu_WriteWithSize
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'     case size
	add	objptr, #151
	rdbyte	local03, objptr
	sub	objptr, #151
	sub	local03, #1
	fle	local03, #4
	jmprel	local03
LR__1260
	jmp	#LR__1261
	jmp	#LR__1262
	jmp	#LR__1264
	jmp	#LR__1263
	jmp	#LR__1264
LR__1261
'         SZ_BYTE: bus.WriteByte(address, value)
	mov	arg01, local01
	mov	arg02, local02
'     memory.WriteByte(address, value)
	add	objptr, ##796
	call	#_memory_WriteByte
	sub	objptr, ##796
	jmp	#LR__1265
LR__1262
'         SZ_HALF: bus.WriteHalf(address, value)
	mov	arg01, local01
	mov	arg02, local02
'     memory.WriteHalf(address, value)
	add	objptr, ##796
	call	#_memory_WriteHalf
	sub	objptr, ##796
	jmp	#LR__1265
LR__1263
'         SZ_WORD: bus.WriteWord(address, value)
	mov	arg01, local01
	mov	arg02, local02
'     memory.WriteWord(address, value)
	add	objptr, ##796
	call	#_memory_WriteWord
	sub	objptr, ##796
	jmp	#LR__1265
LR__1264
'         other: Panic(string("bad size"), size)
	mov	arg01, ##@LR__2116
	add	objptr, #151
	rdbyte	arg02, objptr
	sub	objptr, #151
	call	#_cpu_Panic
LR__1265
	mov	ptra, fp
	call	#popregs_
_cpu_WriteWithSize_ret
	ret

' 
' PRI ShouldSkip
_cpu_ShouldSkip
'     case condition
	add	objptr, #147
	rdbyte	_var01, objptr
	sub	objptr, #147
	fle	_var01, #7
	jmprel	_var01
LR__1270
	jmp	#LR__1271
	jmp	#LR__1272
	jmp	#LR__1273
	jmp	#LR__1274
	jmp	#LR__1275
	jmp	#LR__1276
	jmp	#LR__1279
	jmp	#LR__1281
LR__1271
'         CD_ALWAYS:
'             return false
	mov	result1, #0
	jmp	#LR__1282
LR__1272
'         CD_IFZ:
'             return ZeroFlag == false
	mov	_var02, #0
'     return ((flags & 1) <> 0)
	mov	result1, #0
	add	objptr, #144
	rdbyte	_var01, objptr
	sub	objptr, #144
	test	_var01, #1 wz
 if_ne	neg	result1, #1
	cmp	result1, #0 wz
 if_e	not	_var02, #0
	mov	result1, _var02
	jmp	#LR__1282
LR__1273
'         CD_IFNZ:
'             return ZeroFlag == true
	mov	_var02, #0
'     return ((flags & 1) <> 0)
	mov	result1, #0
	add	objptr, #144
	rdbyte	_var01, objptr
	sub	objptr, #144
	test	_var01, #1 wz
 if_ne	neg	result1, #1
	cmp	result1, ##-1 wz
 if_e	not	_var02, #0
	mov	result1, _var02
	jmp	#LR__1282
LR__1274
'         CD_IFC:
'             return CarryFlag == false
	mov	_var02, #0
'     return ((flags & 2) <> 0)
	mov	result1, #0
	add	objptr, #144
	rdbyte	_var01, objptr
	sub	objptr, #144
	test	_var01, #2 wz
 if_ne	neg	result1, #1
	cmp	result1, #0 wz
 if_e	not	_var02, #0
	mov	result1, _var02
	jmp	#LR__1282
LR__1275
'         CD_IFNC:
'             return CarryFlag == true
	mov	_var02, #0
'     return ((flags & 2) <> 0)
	mov	result1, #0
	add	objptr, #144
	rdbyte	_var01, objptr
	sub	objptr, #144
	test	_var01, #2 wz
 if_ne	neg	result1, #1
	cmp	result1, ##-1 wz
 if_e	not	_var02, #0
	mov	result1, _var02
	jmp	#LR__1282
LR__1276
'         CD_IFGT:
'             return (ZeroFlag == true) or (CarryFlag == true)
	mov	_var02, #0
'     return ((flags & 1) <> 0)
	mov	result1, #0
	add	objptr, #144
	rdbyte	_var01, objptr
	sub	objptr, #144
	test	_var01, #1 wz
 if_ne	neg	result1, #1
	cmp	result1, ##-1 wz
 if_e	jmp	#LR__1277
'     return ((flags & 2) <> 0)
	mov	result1, #0
	add	objptr, #144
	rdbyte	_var01, objptr
	sub	objptr, #144
	test	_var01, #2 wz
 if_ne	neg	result1, #1
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__1278
LR__1277
	not	_var02, _var02
LR__1278
	mov	result1, _var02
	jmp	#LR__1282
LR__1279
'         CD_IFLTEQ:
'             return (ZeroFlag == false) and (CarryFlag == false)
	mov	_var02, #0
'     return ((flags & 1) <> 0)
	mov	result1, #0
	add	objptr, #144
	rdbyte	_var01, objptr
	sub	objptr, #144
	test	_var01, #1 wz
 if_ne	neg	result1, #1
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1280
'     return ((flags & 2) <> 0)
	mov	result1, #0
	add	objptr, #144
	rdbyte	_var01, objptr
	sub	objptr, #144
	test	_var01, #2 wz
 if_ne	neg	result1, #1
	cmp	result1, #0 wz
 if_e	not	_var02, _var02
LR__1280
	mov	result1, _var02
	jmp	#LR__1282
LR__1281
	mov	result1, #0
LR__1282
_cpu_ShouldSkip_ret
	ret

' 
' PRI SetZeroFlag(set)
_cpu_SetZeroFlag
'     if (set)
	cmp	arg01, #0 wz
 if_e	jmp	#LR__1290
'         flags |= 1
	add	objptr, #144
	rdbyte	arg01, objptr
	or	arg01, #1
	wrbyte	arg01, objptr
	sub	objptr, #144
	jmp	#LR__1291
LR__1290
'     else
'         flags &= !1
	add	objptr, #144
	rdbyte	arg01, objptr
	andn	arg01, #1
	wrbyte	arg01, objptr
	sub	objptr, #144
LR__1291
_cpu_SetZeroFlag_ret
	ret

' PRI SetCarryFlag(set)
_cpu_SetCarryFlag
'     if (set)
	cmp	arg01, #0 wz
 if_e	jmp	#LR__1300
'         flags |= 2
	add	objptr, #144
	rdbyte	arg01, objptr
	or	arg01, #2
	wrbyte	arg01, objptr
	sub	objptr, #144
	jmp	#LR__1301
LR__1300
'     else
'         flags &= !2
	add	objptr, #144
	rdbyte	arg01, objptr
	andn	arg01, #2
	wrbyte	arg01, objptr
	sub	objptr, #144
LR__1301
_cpu_SetCarryFlag_ret
	ret

' 
' PUB Initialize()
_bus_Initialize
'     text.InitVga(-1, VGA_BASE_PIN, VGA_VSYNC_PIN, 0, text#VGA)
	neg	arg01, #1
	mov	arg02, #40
	mov	arg03, #44
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##262796
	call	#_p2textdrv_initVga
'     color := $F0
	sub	objptr, ##262684
	wrbyte	#240, objptr
'     text.SetTextColours(color >> 4, color & $F)
	getbyte	arg02, #240, #0
	getnib	arg02, arg02, #0
	mov	arg01, #15
	add	objptr, ##262684
'     video.setTextColours(fg, bg)
	call	#_p2videodrv_setTextColours
'     text.Clear
'     video.clear()
	add	objptr, ##98132
	call	#_p2videodrv_clear
	sub	objptr, ##360928
'     usb.Start
	call	#_usbnew_0016_start
'     disk.Initialize
	add	objptr, #116
	call	#_disk_Initialize
'     readState := 0
	sub	objptr, #8
	wrbyte	#0, objptr
'     printState := 0
	add	objptr, #1
	wrbyte	#0, objptr
	sub	objptr, #109
_bus_Initialize_ret
	ret

' 
' PUB Read(port): r | temp
_bus_Read
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01 wz
'     case port
 if_e	jmp	#LR__1311
	cmps	local01, ##-2147479552 wc
 if_b	jmp	#LR__1310
	cmps	local01, ##-2147479548 wc
 if_b	jmp	#LR__1314
LR__1310
	cmps	local01, ##-2147475456 wc
 if_b	jmp	#LR__1316
	cmps	local01, ##-2147475452 wc
 if_b	jmp	#LR__1315
	jmp	#LR__1316
LR__1311
'         $00000000:
'             if readState == 1
	add	objptr, #108
	rdbyte	result1, objptr
	sub	objptr, #108
	cmp	result1, #1 wz
 if_ne	jmp	#LR__1312
'                 readState := 2
	add	objptr, #108
	wrbyte	#2, objptr
'                 return ret0
	add	objptr, #5
	rdbyte	result1, objptr
	sub	objptr, #113
	jmp	#LR__1317
LR__1312
'             if readState == 2
	add	objptr, #108
	rdbyte	result1, objptr
	sub	objptr, #108
	cmp	result1, #2 wz
 if_ne	jmp	#LR__1313
'                 readState := 0
	add	objptr, #108
	wrbyte	#0, objptr
'                 return ret1
	add	objptr, #6
	rdbyte	result1, objptr
	sub	objptr, #114
	jmp	#LR__1317
LR__1313
'             if temp := usb.get_key
	call	#_usbnew_0016_get_key
	mov	local01, result1 wz
 if_e	jmp	#LR__1316
'                 if temp := Scan2Ascii(temp)
	mov	arg01, local01
	call	#_bus_Scan2Ascii
	cmp	result1, #0 wz
'                     return temp
 if_ne	jmp	#LR__1317
	jmp	#LR__1316
LR__1314
'         $80001000..$80001003:
'             return disk.Size(port & $0F)
	getnib	arg01, local01, #0
	add	objptr, #116
	call	#_disk_Size
	sub	objptr, #116
	jmp	#LR__1317
LR__1315
'         $80002000..$80002003:
'             return diskBufferPointer
	add	objptr, #104
	rdlong	result1, objptr
	sub	objptr, #104
	jmp	#LR__1317
LR__1316
'     return 0
	mov	result1, #0
LR__1317
	mov	ptra, fp
	call	#popregs_
_bus_Read_ret
	ret

' 
' PUB Write(port, value) | i, temp
_bus_Write
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, arg02
'     case port
 if_e	jmp	#LR__1322
	cmps	local01, ##-2147475456 wc
 if_b	jmp	#LR__1320
	cmps	local01, ##-2147475452 wc
 if_b	jmp	#LR__1323
LR__1320
	cmps	local01, ##-2147471360 wc
 if_b	jmp	#LR__1321
	cmps	local01, ##-2147471356 wc
 if_b	jmp	#LR__1324
LR__1321
	cmps	local01, ##-2147467264 wc
 if_b	jmp	#LR__1328
	cmps	local01, ##-2147467260 wc
 if_b	jmp	#LR__1326
	jmp	#LR__1328
LR__1322
'         $00000000:
'             value := ConvertChar(value & $FF)
	getbyte	arg01, local02, #0
	call	#_bus_ConvertChar
	mov	local02, result1 wz
'             if value <> 0
'                 DebugChar(value)
 if_ne	mov	arg01, local02
 if_e	jmp	#LR__1328
'     text.Out(c)
'     video.out(ch)
	add	objptr, ##360928
	call	#_p2videodrv_out
	sub	objptr, ##360928
	jmp	#LR__1328
LR__1323
'         $80002000..$80002003:
'             diskBufferPointer := value
	add	objptr, #104
	wrlong	local02, objptr
	sub	objptr, #104
	jmp	#LR__1328
LR__1324
'         $80003000..$80003003:
'             disk.Seek(port & $0F, value)
	getnib	arg01, local01, #0
	mov	arg02, local02
	add	objptr, #116
	call	#_disk_Seek
'             temp := disk.Read(port & $0F)
	getnib	arg01, local01, #0
	call	#_disk_Read
	sub	objptr, #116
	mov	local03, result1
'             repeat i from 0 to 511
	mov	local04, #0
LR__1325
'                 WriteByte(diskBufferPointer + i, byte[temp + i])
	add	objptr, #104
	rdlong	arg01, objptr
	add	arg01, local04
	mov	local02, local03
	add	local02, local04
	rdbyte	arg02, local02
'     memory.WriteByte(address, value)
	add	objptr, ##540
	call	#_memory_WriteByte
	sub	objptr, ##644
	add	local04, #1
	cmps	local04, ##512 wc
 if_b	jmp	#LR__1325
	jmp	#LR__1328
LR__1326
'         $80004000..$80004003:
'             disk.Seek(port & $0F, value)
	getnib	arg01, local01, #0
	mov	arg02, local02
	add	objptr, #116
	call	#_disk_Seek
	sub	objptr, #116
'             repeat i from 0 to 511
	mov	local04, #0
LR__1327
'                 disk.WriteBuffer(i, ReadByte(diskBufferPointer + i))
	add	objptr, #104
	rdlong	arg01, objptr
	add	arg01, local04
'     return memory.ReadByte(address)
	add	objptr, ##540
	call	#_memory_ReadByte
	mov	arg02, result1
	mov	arg01, local04
	sub	objptr, ##528
'     byte[@buffer][offset] := value
	mov	local03, objptr
	add	local03, #16
	add	arg01, local03
	wrbyte	arg02, arg01
	sub	objptr, #116
	add	local04, #1
	cmps	local04, ##512 wc
 if_b	jmp	#LR__1327
'             disk.Write(port & $0F)
	getnib	arg01, local01, #0
	add	objptr, #116
	call	#_disk_Write
'             disk.Sync(port & $0F)
	getnib	arg01, local01, #0
'     c.fflush(image[id])
	shl	arg01, #2
	add	arg01, objptr
	rdlong	arg01, arg01
	add	objptr, ##528
	call	#_libc_a_fflush
	sub	objptr, ##644
LR__1328
	mov	ptra, fp
	call	#popregs_
_bus_Write_ret
	ret

' 
' PUB ConvertChar(c): r | row, col
_bus_ConvertChar
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
'     case printState
	add	objptr, #109
	rdbyte	local02, objptr
	sub	objptr, #109
	fle	local02, #3
	jmprel	local02
LR__1330
	jmp	#LR__1340
	jmp	#LR__1331
	jmp	#LR__1332
	jmp	#LR__1346
LR__1331
'         1:
'             param0 := c
	add	objptr, #111
	wrbyte	local01, objptr
'             printState := 2
	sub	objptr, #2
	wrbyte	#2, objptr
	sub	objptr, #109
	jmp	#LR__1346
LR__1332
'         2:
'             case printMode
	add	objptr, #110
	rdbyte	local03, objptr
	sub	objptr, #110
	sub	local03, #238
	fle	local03, #6
	jmprel	local03
LR__1333
	jmp	#LR__1334
	jmp	#LR__1339
	jmp	#LR__1335
	jmp	#LR__1336
	jmp	#LR__1337
	jmp	#LR__1338
	jmp	#LR__1339
LR__1334
'                 $EE:
'                     ' return a two-byte parameter
'                     if (param0 == 0) and (c == 0)
	add	objptr, #111
	rdbyte	local03, objptr wz
	sub	objptr, #111
 if_e	cmp	local01, #0 wz
 if_ne	jmp	#LR__1339
'                         ret0 := text.GetCurrentColumns
	add	objptr, ##262796
'     cols := video.getCurrentColumns(@display, @region)
	mov	arg01, objptr
	add	arg01, #48
	mov	arg02, objptr
	call	#_p2videodrv_getCurrentColumns
	mov	local03, result1
	sub	objptr, ##262683
	wrbyte	local03, objptr
'                         ret1 := text.GetCurrentRows
	add	objptr, ##262683
'     rows := video.getCurrentRows(@display, @region)
	mov	arg01, objptr
	add	arg01, #48
	mov	arg02, objptr
	call	#_p2videodrv_getCurrentRows
	sub	objptr, ##262682
	wrbyte	result1, objptr
'                         readState := 1
	sub	objptr, #6
	wrbyte	#1, objptr
	sub	objptr, #108
	jmp	#LR__1339
LR__1335
'                 $F0:
'                     ' fill
'                     wordfill(text.GetScreenBuffer, ((color & $F) << 4) | (color & $F) | param0, text.GetCurrentRows * text.GetCurrentColumns)
	add	objptr, ##262796
'     addr := @screenbuf
	mov	local03, objptr
	add	local03, ##2040
	sub	objptr, ##262684
	rdbyte	local02, objptr
	getnib	local01, local02, #0
	shl	local01, #4
	getnib	local02, local02, #0
	or	local01, local02
	sub	objptr, #1
	rdbyte	local02, objptr
	or	local01, local02
	add	objptr, ##262685
'     rows := video.getCurrentRows(@display, @region)
	mov	arg01, objptr
	add	arg01, #48
	mov	arg02, objptr
	call	#_p2videodrv_getCurrentRows
	mov	local02, result1
'     cols := video.getCurrentColumns(@display, @region)
	mov	arg01, objptr
	add	arg01, #48
	mov	arg02, objptr
	call	#_p2videodrv_getCurrentColumns
	qmul	local02, result1
	sub	objptr, ##262796
	mov	arg01, local03
	mov	arg02, local01
	getqx	arg03
	call	#\builtin_wordfill_
	jmp	#LR__1339
LR__1336
'                 $F1:
'                     ' move cursor
'                     text.SetTextPos(c, param0)
	add	objptr, #111
	rdbyte	arg02, objptr
	mov	arg01, local01
	add	objptr, ##262685
	call	#_p2textdrv_setTextPos
	sub	objptr, ##262796
	jmp	#LR__1339
LR__1337
'                 $F2:
'                     ' set color
'                     text.SetTextColours(param0 >> 4, param0 & $F)
	add	objptr, #111
	rdbyte	arg02, objptr
	mov	arg01, arg02
	shr	arg01, #4
	getnib	arg02, arg02, #0
	add	objptr, ##262685
'     video.setTextColours(fg, bg)
	call	#_p2videodrv_setTextColours
'                     color := param0
	sub	objptr, ##262685
	rdbyte	local03, objptr
	add	objptr, #1
	wrbyte	local03, objptr
	sub	objptr, #112
	jmp	#LR__1339
LR__1338
'                 $F3:
'                     ' fill line
'                     row, col := text.GetTextPos()
	add	objptr, ##262796
'     return video.getTextPos()
	call	#_p2videodrv_getTextPos
	mov	local03, result1
'                     col := 0
'                     wordfill(text.GetScreenBuffer + 2 * (row * text.GetCurrentColumns + col), ((color & $F) << 4) | (color & $F) | param0, text.GetCurrentColumns - col)
'     addr := @screenbuf
	mov	local02, objptr
	add	local02, ##2040
'     cols := video.getCurrentColumns(@display, @region)
	mov	arg01, objptr
	add	arg01, #48
	mov	arg02, objptr
	call	#_p2videodrv_getCurrentColumns
	qmul	local03, result1
	sub	objptr, ##262684
	rdbyte	local03, objptr
	getnib	local01, local03, #0
	shl	local01, #4
	getnib	local03, local03, #0
	or	local01, local03
	sub	objptr, #1
	rdbyte	local03, objptr
	or	local01, local03
	add	objptr, ##262685
'     cols := video.getCurrentColumns(@display, @region)
	mov	arg01, objptr
	add	arg01, #48
	mov	arg02, objptr
	getqx	local03
	shl	local03, #1
	add	local02, local03
	call	#_p2videodrv_getCurrentColumns
	sub	objptr, ##262796
	mov	arg03, result1
	mov	arg01, local02
	mov	arg02, local01
	call	#\builtin_wordfill_
LR__1339
'             printState := 0
	add	objptr, #109
	wrbyte	#0, objptr
	sub	objptr, #109
	jmp	#LR__1346
LR__1340
'         0:
'             case c
	mov	local04, local01
	cmp	local04, #238 wz
 if_ne	cmps	local04, #240 wc
 if_c_and_nz	jmp	#LR__1341
 if_ne	cmps	local04, #244 wc
 if_be	jmp	#LR__1342
LR__1341
	cmp	local04, #138 wz
 if_e	jmp	#LR__1343
	cmp	local04, #254 wz
 if_ne	cmp	local04, #255 wz
 if_ne	jmp	#LR__1344
	jmp	#LR__1345
LR__1342
'                 $EE, $F0..$F3:
'                     printMode := c
	add	objptr, #110
	wrbyte	local01, objptr
'                     printState := 1
	sub	objptr, #1
	wrbyte	#1, objptr
	sub	objptr, #109
	jmp	#LR__1345
LR__1343
'                 $8A: return $B1
	mov	result1, #177
	jmp	#LR__1347
LR__1344
'                 $FE, $FF: ' ignore
'                 other: return c
	mov	result1, local01
	jmp	#LR__1347
LR__1345
LR__1346
'     return 0
	mov	result1, #0
LR__1347
	mov	ptra, fp
	call	#popregs_
_bus_ConvertChar_ret
	ret

' 
' PUB Scan2Ascii(event): r | shifted, scancode
_bus_Scan2Ascii
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
'     if event <= 0
	cmps	local01, #1 wc
'         return 0 ' No event or release event
 if_b	mov	result1, #0
 if_b	jmp	#LR__1373
'     shifted := (event.[8+1] || event.[8+5]) ^^ event.[17]
	mov	local02, #0
	mov	local03, #0
	testbn	local01, #9 wz
 if_e	mov	local04, local01
 if_e	shr	local04, #13
 if_e	test	local04, #1 wz
 if_ne	not	local03, #0
	cmp	local03, #0 wz
 if_ne	not	local02, #0
	mov	local05, #0
	testbn	local01, #17 wz
 if_ne	neg	local05, #1
	xor	local02, local05
'     scancode := event & 255
	getbyte	local06, local01, #0
'     case scancode
	mov	local07, local06
	sub	local07, #4
	fle	local07, #95
	jmprel	local07
LR__1350
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1351
	jmp	#LR__1352
	jmp	#LR__1352
	jmp	#LR__1352
	jmp	#LR__1352
	jmp	#LR__1352
	jmp	#LR__1352
	jmp	#LR__1352
	jmp	#LR__1352
	jmp	#LR__1352
	jmp	#LR__1352
	jmp	#LR__1368
	jmp	#LR__1369
	jmp	#LR__1367
	jmp	#LR__1372
	jmp	#LR__1366
	jmp	#LR__1354
	jmp	#LR__1355
	jmp	#LR__1356
	jmp	#LR__1357
	jmp	#LR__1358
	jmp	#LR__1359
	jmp	#LR__1360
	jmp	#LR__1361
	jmp	#LR__1362
	jmp	#LR__1363
	jmp	#LR__1364
	jmp	#LR__1365
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1372
	jmp	#LR__1371
	jmp	#LR__1371
	jmp	#LR__1371
	jmp	#LR__1371
	jmp	#LR__1371
	jmp	#LR__1371
	jmp	#LR__1371
	jmp	#LR__1371
	jmp	#LR__1371
	jmp	#LR__1370
	jmp	#LR__1372
LR__1351
'         usb.KEY_A..usb.KEY_Z:
'             if shifted
	cmp	local02, #0 wz
'                 return (scancode - usb.KEY_A) + "A"
 if_ne	add	local06, #61
 if_ne	mov	result1, local06
 if_ne	jmp	#LR__1373
'             else
'                 return (scancode - usb.KEY_A) + "a"
	mov	result1, local06
	add	result1, #93
	jmp	#LR__1373
LR__1352
'         usb.KEY_1..usb.KEY_0:
'             if shifted
	cmp	local02, #0 wz
 if_e	jmp	#LR__1353
'                 return lookupz(scancode-usb.KEY_1 : "!","@","#","$","%","^","&","*","(",")")
	sub	local06, #30
	mov	arg03, ptr__bus_dat__
	mov	arg01, local06
	mov	arg02, #0
	mov	arg04, #10
	call	#__system___lookup
	jmp	#LR__1373
LR__1353
'             elseif scancode == usb.KEY_0
	cmp	local06, #39 wz
'                 return "0"
 if_e	mov	result1, #48
 if_e	jmp	#LR__1373
'             else
'                 return (scancode - usb.KEY_1) + "1"
	mov	result1, local06
	add	result1, #19
	jmp	#LR__1373
LR__1354
'         usb.KEY_MINUS:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "-"
 if_e	mov	result1, #45
 if_e	jmp	#LR__1373
'             else
'                 return "_"
	mov	result1, #95
	jmp	#LR__1373
LR__1355
'         usb.KEY_EQUAL:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "="
 if_e	mov	result1, #61
 if_e	jmp	#LR__1373
'             else
'                 return "+"
	mov	result1, #43
	jmp	#LR__1373
LR__1356
'         usb.KEY_LBRACE:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "["
 if_e	mov	result1, #91
 if_e	jmp	#LR__1373
'             else
'                 return "{"
	mov	result1, #123
	jmp	#LR__1373
LR__1357
'         usb.KEY_RBRACE:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "]"
 if_e	mov	result1, #93
 if_e	jmp	#LR__1373
'             else
'                 return "}"
	mov	result1, #125
	jmp	#LR__1373
LR__1358
'         usb.KEY_BACKSLASH:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "\"
 if_e	mov	result1, #92
 if_e	jmp	#LR__1373
'             else
'                 return "|"
	mov	result1, #124
	jmp	#LR__1373
LR__1359
'         usb.KEY_HASHTILDE:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "`"
 if_e	mov	result1, #96
 if_e	jmp	#LR__1373
'             else
'                 return "~"
	mov	result1, #126
	jmp	#LR__1373
LR__1360
'         usb.KEY_SEMICOLON:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return ";"
 if_e	mov	result1, #59
 if_e	jmp	#LR__1373
'             else
'                 return ":"
	mov	result1, #58
	jmp	#LR__1373
LR__1361
'         usb.KEY_APOST:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "'"
 if_e	mov	result1, #39
 if_e	jmp	#LR__1373
'             else
'                 return 34
	mov	result1, #34
	jmp	#LR__1373
LR__1362
'         usb.KEY_GRAVE:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "`"
 if_e	mov	result1, #96
 if_e	jmp	#LR__1373
'             else
'                 return "~"
	mov	result1, #126
	jmp	#LR__1373
LR__1363
'         usb.KEY_COMMA:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return ","
 if_e	mov	result1, #44
 if_e	jmp	#LR__1373
'             else
'                 return "<"
	mov	result1, #60
	jmp	#LR__1373
LR__1364
'         usb.KEY_DOT:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "."
 if_e	mov	result1, #46
 if_e	jmp	#LR__1373
'             else
'                 return ">"
	mov	result1, #62
	jmp	#LR__1373
LR__1365
'         usb.KEY_SLASH:
'             ifnot shifted
	cmp	local02, #0 wz
'                 return "/"
 if_e	mov	result1, #47
 if_e	jmp	#LR__1373
'             else
'                 return "?"
	mov	result1, #63
	jmp	#LR__1373
LR__1366
'         usb.KEY_SPACE: return " "
	mov	result1, #32
	jmp	#LR__1373
LR__1367
'         usb.KEY_BACKSPACE: return 8
	mov	result1, #8
	jmp	#LR__1373
LR__1368
'         usb.KEY_ENTER: return 10
	mov	result1, #10
	jmp	#LR__1373
LR__1369
'         usb.KEY_ESC: return 27
	mov	result1, #27
	jmp	#LR__1373
LR__1370
'         usb.KEY_NUM0: return "0"
	mov	result1, #48
	jmp	#LR__1373
LR__1371
'         usb.KEY_NUM1..usb.KEY_NUM9: return (scancode - usb.KEY_NUM1) + "1"
	sub	local06, #40
	mov	result1, local06
	jmp	#LR__1373
LR__1372
'         other:
'             return 0
	mov	result1, #0
LR__1373
	mov	ptra, fp
	call	#popregs_
_bus_Scan2Ascii_ret
	ret

' 
' PUB Initialize
_disk_Initialize
'     image[0] := c.fopen(@"/sd/disk0.img", @"r+b")
	mov	arg01, ##@LR__2117
	mov	arg02, ##@LR__2118
	add	objptr, ##528
	call	#_libc_a_fopen
	sub	objptr, ##528
	wrlong	result1, objptr
'     image[1] := c.fopen(@"/sd/disk1.img", @"r+b")
	mov	arg01, ##@LR__2119
	mov	arg02, ##@LR__2120
	add	objptr, ##528
	call	#_libc_a_fopen
	sub	objptr, ##524
	wrlong	result1, objptr
'     image[2] := c.fopen(@"/sd/disk2.img", @"r+b")
	mov	arg01, ##@LR__2121
	mov	arg02, ##@LR__2122
	add	objptr, ##524
	call	#_libc_a_fopen
	sub	objptr, ##520
	wrlong	result1, objptr
'     image[3] := c.fopen(@"/sd/disk3.img", @"r+b")
	mov	arg01, ##@LR__2123
	mov	arg02, ##@LR__2124
	add	objptr, ##520
	call	#_libc_a_fopen
	sub	objptr, ##516
	wrlong	result1, objptr
	sub	objptr, #12
_disk_Initialize_ret
	ret

' 
' PUB Seek(id, sector)
_disk_Seek
'     c.fseek(image[id], sector * 512, c#SEEK_SET)
	shl	arg01, #2
	add	arg01, objptr
	rdlong	arg01, arg01
	shl	arg02, #9
	mov	arg03, #0
	add	objptr, ##528
	call	#_libc_a_fseek
	sub	objptr, ##528
_disk_Seek_ret
	ret

' 
' PUB Size(id)
_disk_Size
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
'     if image[id] == 0
	mov	arg03, local01
	shl	arg03, #2
	add	arg03, objptr
	rdlong	arg03, arg03 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__1380
'     c.fseek(image[id], 0, c#SEEK_END)
	mov	arg03, local01
	shl	arg03, #2
	add	arg03, objptr
	rdlong	arg01, arg03
	mov	arg02, #0
	mov	arg03, #2
	add	objptr, ##528
	call	#_libc_a_fseek
	sub	objptr, ##528
'     result := c.ftell(image[id])
	mov	arg03, local01
	shl	arg03, #2
	add	arg03, objptr
	rdlong	arg01, arg03
	add	objptr, ##528
	call	#_libc_a_ftell
	sub	objptr, ##528
	mov	local02, result1
'     c.fseek(image[id], 0, c#SEEK_SET)
	shl	local01, #2
	add	local01, objptr
	rdlong	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	add	objptr, ##528
	call	#_libc_a_fseek
	sub	objptr, ##528
	mov	result1, local02
LR__1380
	mov	ptra, fp
	call	#popregs_
_disk_Size_ret
	ret

' 
' PUB Read(id)
_disk_Read
'     c.fread(@buffer, 1, 512, image[id])
	mov	arg03, objptr
	add	arg03, #16
	shl	arg01, #2
	add	arg01, objptr
	rdlong	arg04, arg01
	mov	arg01, arg03
	mov	arg02, #1
	decod	arg03, #9
	add	objptr, ##528
	call	#_libc_a_fread
'     return @buffer
	sub	objptr, ##512
	mov	result1, objptr
	sub	objptr, #16
_disk_Read_ret
	ret

' 
' PUB Write(id)
_disk_Write
'     c.fwrite(@buffer, 1, 512, image[id])
	mov	arg03, objptr
	add	arg03, #16
	shl	arg01, #2
	add	arg01, objptr
	rdlong	arg04, arg01
	mov	arg01, arg03
	mov	arg02, #1
	decod	arg03, #9
	add	objptr, ##528
	call	#_libc_a_fwrite
	sub	objptr, ##528
_disk_Write_ret
	ret

' 
' PUB ReadByte(address)
_memory_ReadByte
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
'     if (umath.ge(address, 0) and umath.lt(address, MEMORY_RAM))
	mov	local02, #0
	mov	arg01, local01
	mov	arg02, #0
' 
' '' Return true if x => y unsigned.
' 
'   return cpr(x,y) & constant(UGT | EQ) <> 0
	mov	local03, #0
	call	#_umath_cpr
	test	result1, #6 wz
 if_ne	not	local03, #0
	cmp	local03, #0 wz
 if_ne	not	local02, #0
	mov	local04, #0
	mov	arg01, local01
	decod	arg02, #18
' 
' '' Return true if x < y unsigned.
' 
'   return cpr(x,y) & ULT <> 0
	mov	local05, #0
	call	#_umath_cpr
	test	result1, #1 wz
 if_ne	not	local05, #0
	mov	result1, local05 wz
 if_ne	not	local04, #0
	test	local02, local04 wz
'         return ram[address]
 if_ne	add	local01, objptr
 if_ne	rdbyte	result1, local01
 if_ne	jmp	#LR__1393
'     else
'         if (umath.ge(address, constant(MEMORY_ROM_START + $40000)) and umath.lt(address, constant(MEMORY_ROM_START + $40FFF)))
	mov	local02, #0
	mov	arg01, local01
	mov	arg02, ##-268173312
' 
' '' Return true if x => y unsigned.
' 
'   return cpr(x,y) & constant(UGT | EQ) <> 0
	mov	local03, #0
	call	#_umath_cpr
	test	result1, #6 wz
 if_ne	not	local03, #0
	cmp	local03, #0 wz
 if_ne	not	local02, #0
	mov	local04, #0
	mov	arg01, local01
	mov	arg02, ##-268169217
' 
' '' Return true if x < y unsigned.
' 
'   return cpr(x,y) & ULT <> 0
	mov	local05, #0
	call	#_umath_cpr
	test	result1, #1 wz
 if_ne	not	local05, #0
	cmp	local05, #0 wz
 if_ne	not	local04, #0
	test	local02, local04 wz
'             address -= constant($40000 - $3000)
 if_ne	sub	local01, ##249856
 if_ne	jmp	#LR__1392
'         elseif (umath.ge(address, constant(MEMORY_ROM_START + $45000)) and umath.lt(address, constant(MEMORY_ROM_START + $45FFF)))
	mov	local02, #0
	mov	arg01, local01
	mov	arg02, ##-268152832
' 
' '' Return true if x => y unsigned.
' 
'   return cpr(x,y) & constant(UGT | EQ) <> 0
	mov	local03, #0
	call	#_umath_cpr
	test	result1, #6 wz
 if_ne	not	local03, #0
	cmp	local03, #0 wz
 if_ne	not	local02, #0
	mov	local04, #0
	mov	arg01, local01
	mov	arg02, ##-268148737
' 
' '' Return true if x < y unsigned.
' 
'   return cpr(x,y) & ULT <> 0
	mov	local05, #0
	call	#_umath_cpr
	test	result1, #1 wz
 if_ne	not	local05, #0
	cmp	local05, #0 wz
 if_ne	not	local04, #0
	test	local02, local04 wz
'             address -= constant($45000 - $3100)
 if_ne	sub	local01, ##270080
 if_ne	jmp	#LR__1391
'         elseif (umath.ge(address, constant(MEMORY_ROM_START + $46000)) and umath.lt(address, constant(MEMORY_ROM_START + $46FFF)))
	mov	local02, #0
	mov	arg01, local01
	mov	arg02, ##-268148736
' 
' '' Return true if x => y unsigned.
' 
'   return cpr(x,y) & constant(UGT | EQ) <> 0
	mov	local03, #0
	call	#_umath_cpr
	test	result1, #6 wz
 if_ne	not	local03, #0
	cmp	local03, #0 wz
 if_ne	not	local02, #0
	mov	local04, #0
	mov	arg01, local01
	mov	arg02, ##-268144641
' 
' '' Return true if x < y unsigned.
' 
'   return cpr(x,y) & ULT <> 0
	mov	local05, #0
	call	#_umath_cpr
	test	result1, #1 wz
 if_ne	not	local05, #0
	cmp	local05, #0 wz
 if_ne	not	local04, #0
	test	local02, local04 wz
'             address -= constant($46000 - $3200)
 if_ne	sub	local01, ##273920
 if_ne	jmp	#LR__1390
'         elseif (umath.ge(address, constant(MEMORY_ROM_START + $47000)) and umath.lt(address, constant(MEMORY_ROM_START + $47FFF)))
	mov	local02, #0
	mov	arg01, local01
	mov	arg02, ##-268144640
' 
' '' Return true if x => y unsigned.
' 
'   return cpr(x,y) & constant(UGT | EQ) <> 0
	mov	local03, #0
	call	#_umath_cpr
	test	result1, #6 wz
 if_ne	not	local03, #0
	cmp	local03, #0 wz
 if_ne	not	local02, #0
	mov	local04, #0
	mov	arg01, local01
	mov	arg02, ##-268140545
' 
' '' Return true if x < y unsigned.
' 
'   return cpr(x,y) & ULT <> 0
	mov	local05, #0
	call	#_umath_cpr
	test	result1, #1 wz
 if_ne	not	local05, #0
	cmp	local05, #0 wz
 if_ne	not	local04, #0
	test	local02, local04 wz
'             address -= constant($47000 - $3300)
 if_ne	sub	local01, ##277760
LR__1390
LR__1391
LR__1392
' 
'         if (umath.ge(address, MEMORY_ROM_START) and umath.lt(address, constant(MEMORY_ROM_START + MEMORY_ROM)))
	mov	local02, #0
	mov	arg01, local01
	mov	arg02, ##-268435456
' 
' '' Return true if x => y unsigned.
' 
'   return cpr(x,y) & constant(UGT | EQ) <> 0
	mov	local03, #0
	call	#_umath_cpr
	test	result1, #6 wz
 if_ne	not	local03, #0
	cmps	local03, #0 wz
 if_ne	not	local02, #0
	mov	local04, #0
	mov	arg01, local01
	mov	arg02, ##-268419072
' 
' '' Return true if x < y unsigned.
' 
'   return cpr(x,y) & ULT <> 0
	mov	local05, #0
	call	#_umath_cpr
	test	result1, #1 wz
 if_ne	not	local05, #0
	mov	result1, local05 wz
 if_ne	not	local04, #0
	and	local02, local04 wz
'             address &= $00007FFF
 if_ne	zerox	local01, #14
'             return rom[address]
 if_ne	mov	local02, local01
 if_ne	add	local02, ptr__memory_dat__
 if_ne	rdbyte	result1, local02
'         else
'             return 0
 if_e	mov	result1, #0
LR__1393
	mov	ptra, fp
	call	#popregs_
_memory_ReadByte_ret
	ret

' 
' PUB ReadHalf(address)
_memory_ReadHalf
	mov	COUNT_, #2
	call	#pushregs_
'     result := ReadByte(address)
	mov	local01, arg01
	call	#_memory_ReadByte
	mov	local02, result1
'     result |= ReadByte(address + 1) << 8
	add	local01, #1
	mov	arg01, local01
	call	#_memory_ReadByte
	shl	result1, #8
	or	result1, local02
	mov	ptra, fp
	call	#popregs_
_memory_ReadHalf_ret
	ret

' 
' PUB ReadWord(address)
_memory_ReadWord
	mov	COUNT_, #2
	call	#pushregs_
'     result := ReadByte(address)
	mov	local01, arg01
	call	#_memory_ReadByte
	mov	local02, result1
'     result |= ReadByte(address + 1) << 8
	mov	arg01, local01
	add	arg01, #1
	call	#_memory_ReadByte
	shl	result1, #8
	or	local02, result1
'     result |= ReadByte(address + 2) << 16
	mov	arg01, local01
	add	arg01, #2
	call	#_memory_ReadByte
	shl	result1, #16
	or	local02, result1
'     result |= ReadByte(address + 3) << 24
	add	local01, #3
	mov	arg01, local01
	call	#_memory_ReadByte
	shl	result1, #24
	or	result1, local02
	mov	ptra, fp
	call	#popregs_
_memory_ReadWord_ret
	ret

' 
' PUB WriteByte(address, value)
_memory_WriteByte
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'     if (umath.lt(address, MEMORY_RAM))
	mov	arg01, local01
	decod	arg02, #18
' 
' '' Return true if x < y unsigned.
' 
'   return cpr(x,y) & ULT <> 0
	mov	local03, #0
	call	#_umath_cpr
	test	result1, #1 wz
 if_ne	not	local03, #0
	cmp	local03, #0 wz
'         ram[address] := value
 if_ne	add	local01, objptr
 if_ne	wrbyte	local02, local01
	mov	ptra, fp
	call	#popregs_
_memory_WriteByte_ret
	ret

' 
' PUB WriteHalf(address, value)
_memory_WriteHalf
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
'     WriteByte(address, value & $000000FF)
	mov	local02, arg02
	getbyte	arg02, arg02, #0
	mov	arg01, local01
	call	#_memory_WriteByte
'     WriteByte(address + 1, (value & $0000FF00) >> 8)
	add	local01, #1
	and	local02, ##65280
	shr	local02, #8
	mov	arg01, local01
	mov	arg02, local02
	call	#_memory_WriteByte
	mov	ptra, fp
	call	#popregs_
_memory_WriteHalf_ret
	ret

' 
' PUB WriteWord(address, value)
_memory_WriteWord
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
'     WriteByte(address, value & $000000FF)
	mov	local02, arg02
	getbyte	arg02, arg02, #0
	mov	arg01, local01
	call	#_memory_WriteByte
'     WriteByte(address + 1, (value & $0000FF00) >> 8)
	mov	arg01, local01
	add	arg01, #1
	mov	arg02, local02
	and	arg02, ##65280
	shr	arg02, #8
	call	#_memory_WriteByte
'     WriteByte(address + 2, (value & $00FF0000) >> 16)
	mov	arg01, local01
	add	arg01, #2
	mov	arg02, local02
	and	arg02, ##16711680
	shr	arg02, #16
	call	#_memory_WriteByte
'     WriteByte(address + 3, (value & $FF000000) >> 24)
	add	local01, #3
	and	local02, ##-16777216
	shr	local02, #24
	mov	arg01, local01
	mov	arg02, local02
	call	#_memory_WriteByte
	mov	ptra, fp
	call	#popregs_
_memory_WriteWord_ret
	ret

' 
' PRI cpr(x, y)
_umath_cpr
' 
'   if (x == y)
	cmp	arg01, arg02 wz
'     return EQ
 if_e	mov	result1, #2
 if_e	jmp	#_umath_cpr_ret
'   elseif (x ^ $8000_0000 > y ^ $8000_0000)
	bitnot	arg01, #31
	bitnot	arg02, #31
	cmps	arg01, arg02 wcz
'     return UGT
 if_a	mov	result1, #4
'   else
'     return ULT
 if_be	mov	result1, #1
_umath_cpr_ret
	ret

' 
' ' text screen and video driver initialization methods
' ' screen will be filled with default background colour and cursor hidden until enabled
' PUB initVga(cog, basePin, vsyncPin, flags, resolution) : r 
_p2textdrv_initVga
	mov	COUNT_, #2
	call	#pushregs_
'     return init(cog, basePin, vsyncPin, video.VGA, flags, video.getTiming(resolution))
	mov	local01, arg01
	mov	local02, arg04
	mov	arg01, arg05
	call	#_p2videodrv_getTiming
	mov	arg06, result1
	mov	arg01, local01
	mov	arg04, #0
	mov	arg05, local02
	call	#_p2textdrv_init
	mov	ptra, fp
	call	#popregs_
_p2textdrv_initVga_ret
	ret

' 
' PUB setTextPos(row, col)
_p2textdrv_setTextPos
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'     if (row +< getCurrentRows()) AND (col +< getCurrentColumns())
	mov	local03, #0
	mov	local04, #0
'     rows := video.getCurrentRows(@display, @region)
	mov	arg01, objptr
	add	arg01, #48
	mov	arg02, objptr
	call	#_p2videodrv_getCurrentRows
	cmp	local01, result1 wc
 if_b	not	local04, #0
	cmp	local04, #0 wz
 if_ne	not	local03, #0
	mov	local04, #0
	mov	local05, #0
'     cols := video.getCurrentColumns(@display, @region)
	mov	arg01, objptr
	add	arg01, #48
	mov	arg02, objptr
	call	#_p2videodrv_getCurrentColumns
	cmp	local02, result1 wc
 if_b	not	local05, #0
	cmp	local05, #0 wz
 if_ne	not	local04, #0
	test	local03, local04 wz
'         video.setTextPos(row, col)
 if_ne	mov	arg01, local01
 if_ne	mov	arg02, local02
 if_ne	call	#_p2videodrv_setTextPos
	mov	ptra, fp
	call	#popregs_
_p2textdrv_setTextPos_ret
	ret

' 
' ' font control methods
' 
' ' sets address and size of font. Warning: be sure to have enough screen buffer memory!
' PUB setFont(fontAddr, size) | lines
_p2textdrv_setFont
	mov	COUNT_, #2
	call	#pushregs_
	mov	arg03, arg01
	mov	local01, arg02
'     if size +> 0
	cmp	local01, #1 wc
 if_b	jmp	#LR__1400
'         lines := video.getActiveLines(@display)
	mov	arg01, objptr
'     return (long[long[display][1]][3] & $7ff)
	add	arg01, #52
	rdlong	result1, arg01
	add	result1, #12
	rdlong	local02, result1
	zerox	local02, #10
'         video.setFont(@region, fontAddr, size)
	mov	arg01, objptr
	mov	arg02, arg03
	mov	arg03, local01
'     long[region][4] := ((fontsize-1) << 24) + (fontBase & $fffff)
	sub	arg03, #1
	shl	arg03, #24
	bitl	arg02, #372
	add	arg03, arg02
	add	arg01, #16
	wrlong	arg03, arg01
'         if video.getFlags(@region) & video.DOUBLE_HIGH
	mov	arg01, objptr
'     return byte[region][5]
	add	arg01, #5
	rdbyte	result1, arg01
	test	result1, #8 wz
'             size := size * 2
 if_ne	shl	local01, #1
'         if lines // size ' truncate to keep complete rows visible
	mov	muldiva_, local02
	mov	muldivb_, local01
	call	#divide_
	cmp	muldiva_, #0 wz
'             video.setSize(@region, lines - (lines // size))
 if_ne	mov	arg01, objptr
 if_ne	sub	local02, muldiva_
'     word[region][3] := size
 if_ne	add	arg01, #6
 if_ne	wrword	local02, arg01
'         else
'             video.setSize(@region, 0) ' text region consumes all scan lines
 if_e	mov	arg01, objptr
'     word[region][3] := size
 if_e	add	arg01, #6
 if_e	wrword	#0, arg01
LR__1400
	mov	ptra, fp
	call	#popregs_
_p2textdrv_setFont_ret
	ret

' 
' ' ----------------------------------------------------------------------------
' 
' ' internal initialization method, sets up region and display information for video driver
' 
' PRI init(cog, basePin, vsyncPin, output, flags, timing) : id | displayFlags
_p2textdrv_init
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
	mov	local06, arg06
'     if output == video.DVI
	cmp	local04, #1 wz
 if_ne	jmp	#LR__1410
'         displayFlags := vsyncPin ? video.DVI_REVERSED : 0 ' flag passed in vsyncPin argument
	cmp	local03, #0 wz
 if_ne	mov	local07, #1
 if_e	mov	local07, #0
	mov	local08, local07
	jmp	#LR__1411
LR__1410
'     else ' assume VGA RGBHV for now, but other sync modes are possible
'         displayFlags := video.RGBHV
	mov	local08, #0
LR__1411
' 
'     ' load the default palette
'     longmove(@palette, @vgapalette, 16)
	mov	arg01, objptr
	add	arg01, ##98040
	mov	arg02, ptr__p2textdrv_dat__
	mov	arg03, #16
	call	#__system__longmove
' 
' ' start a VGA display output, pointing it to the first (and only) region for its display list, and auto allocate it a COG
'     id := video.initDisplay(cog,        { the cogid to use (-1 = auto-allocate)
	add	objptr, #48
	mov	local07, objptr
	add	objptr, #72
	mov	arg10, objptr
	sub	objptr, #120
	mov	arg01, objptr
	mov	arg04, local05
	add	objptr, ##98040
	mov	arg05, objptr
	mov	arg06, ptr__p2textdrv_dat__
	add	arg06, #64
	sub	objptr, ##96000
	mov	arg08, objptr
	sub	objptr, ##2040
	neg	arg02, #1
	mov	arg03, #0
	mov	arg07, #16
	mov	arg09, #0
	call	#_p2videodrv_initRegion
	mov	arg11, result1
	mov	arg01, local01
	mov	arg02, local07
	mov	arg03, local04
	mov	arg04, local02
	mov	arg05, local03
	mov	arg06, local08
	mov	arg07, arg10
	mov	arg08, ##960
	mov	arg09, local06
	mov	arg10, #0
	call	#_p2videodrv_initDisplay
	mov	local08, result1
' 
' ' force a recomputation of displayed scan lines in the region based on font size and region flags
'   setFont(@font, FONTHEIGHT)
	mov	arg01, ptr__p2textdrv_dat__
	add	arg01, #64
	mov	arg02, #16
	call	#_p2textdrv_setFont
' 
' ' setup a text output context for the text region and then use it by default when printing
'   video.initTextOutput(@context, @display, @region, FOREGROUND, BACKGROUND, 1, 1)   'also erase region
	add	objptr, #104
	mov	arg01, objptr
	sub	objptr, #56
	mov	arg02, objptr
	sub	objptr, #48
	mov	arg03, objptr
	mov	arg04, #2
	mov	arg05, #0
	mov	arg06, #1
	mov	arg07, #1
	add	objptr, ##98132
	call	#_p2videodrv_initTextOutput
	sub	objptr, ##98132
	mov	result1, local08
	mov	ptra, fp
	call	#popregs_
_p2textdrv_init_ret
	ret

' 
' '----------------------------------------------------------------------------------
' ' initialization methods
' '----------------------------------------------------------------------------------
' 
' 'initDisplay spawns driver COG returns cogid, display starts up blank until a region is attached
' 'cog - id of COG to use for driver (-1 to auto-allocate)
' 'display - indicates address of where display data is to be stored
' 'output - indicates type of output - VGA, DVI, COMPONENT_HDTV etc
' 'basePin - pin number of starting pin or group of pins
' 'syncPin - used for vertical sync output in VGA RGBHV mode
' 'flags - indicates if interlaced/progessive, PAL/NTSC, forced mono text etc
' 'lineBuf - hub address of two scanline working buffer
' 'maxLineSize - size of each scanline in the line buffer
' 'userTiming - when non-zero points to timing structure to be used to setup display
' 'mbox - pointer to start of external memort driver mailboxes
' 'firstRegion - points to first region in display list (or 0 if no regions yet)
' 
' PUB initDisplay(cog, display, output, basePin, syncPin, flags, lineBuf, maxLineSize, userTiming, mbox, firstRegion) : id | syncFlags, pin, timing, newfreq, newmode
_p2videodrv_initDisplay
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
'     pin := basePin/4 & $f ' get 4 pin group start
	abs	local04, arg04 wc
	shr	local04, #2
	negc	local04, local04
	mov	local05, local04
'     if output == VGA
	cmp	arg03, #0 wz
 if_ne	jmp	#LR__1420
'         syncFlags := %0_0_000000
	mov	local06, #0
'         if flags & 3 == RGBHV ' 5 pin VGA
	test	arg06, #3 wz
'             syncFlags |= syncPin & $3f
 if_e	mov	local06, arg05
 if_e	and	local06, #63
'         if flags & 3 == RGBS ' 4 pin VGA
	mov	local04, arg06
	and	local04, #3
	cmp	local04, #1 wz
'             syncFlags |= pin*4
 if_e	mov	local07, local05
 if_e	shl	local07, #2
 if_e	or	local06, local07
'         if flags & 3 == RGB_SOG ' 3 pin VGA
	mov	local04, arg06
	and	local04, #3
	cmp	local04, #2 wz
'             syncFlags |= pin*4 + 2 ' sync on green
 if_e	mov	local08, local05
 if_e	shl	local08, #2
 if_e	mov	local07, local08
 if_e	add	local07, #2
 if_e	or	local06, local07
'         timing := @vga_timing ' default to 640x480
	mov	local09, ptr__p2videodrv_dat__
	add	local09, ##3984
	jmp	#LR__1432
LR__1420
'     elseif output == DVI
	cmp	arg03, #1 wz
 if_ne	jmp	#LR__1421
'         syncFlags := %1_0000000
	mov	local06, #128
'         pin := basePin/8
	abs	local04, arg04 wc
	shr	local04, #3
	negc	local05, local04
'         if flags & DVI_REVERSED
	test	arg06, #1 wz
'             pin |= 8
 if_ne	or	local05, #8
'         timing := @dvi_timing ' default to 640x480
	mov	local09, ptr__p2videodrv_dat__
	add	local09, ##4012
	jmp	#LR__1431
LR__1421
'     else
'         syncFlags := %0_1_000000
	mov	local06, #64
'         if output == COMPONENT_HDTV
	cmp	arg03, #6 wz
 if_ne	jmp	#LR__1422
'             syncFlags |= %0_0_100010
	mov	local06, #98
'             if flags & INTERLACED <> 0
	test	arg06, #1 wz
'                 syncFlags |= %0_0_010000
 if_ne	mov	local06, #114
'                 timing := @hdint_timing ' 1080i60 default, TODO add 50Hz variant
 if_ne	mov	local09, ptr__p2videodrv_dat__
 if_ne	add	local09, ##4404
 if_ne	jmp	#LR__1430
'             else
'                 if flags & PAL
	test	arg06, #2 wz
'                     timing := @hd50_timing '720p50
 if_ne	mov	local09, ptr__p2videodrv_dat__
 if_ne	add	local09, ##4320
 if_ne	jmp	#LR__1430
'                 else
'                     timing := @hd60_timing '720p60
	mov	local09, ptr__p2videodrv_dat__
	add	local09, ##4292
	jmp	#LR__1430
LR__1422
'         else
'             if output == COMPONENT_SDTV
	cmp	arg03, #5 wz
'                 syncFlags |= %0_0_000111
 if_e	or	local06, #7
 if_e	jmp	#LR__1425
'             elseif output == CVBS
	cmp	arg03, #2 wz
'                 syncFlags |= basePin & 3
 if_e	mov	local07, arg04
 if_e	and	local07, #3
 if_e	or	local06, local07
 if_e	jmp	#LR__1424
'             elseif output == SVIDEO
	cmp	arg03, #3 wz
'                 syncFlags |= %0_0_000100
 if_e	or	local06, #4
 if_e	jmp	#LR__1423
'             elseif output == SVIDEO_CVBS
	cmp	arg03, #4 wz
'                 syncFlags |= %0_0_000101
 if_e	or	local06, #5
LR__1423
LR__1424
LR__1425
' 
'             if flags & INTERLACED <> 0
	test	arg06, #1 wz
 if_e	jmp	#LR__1426
'                 syncFlags |= %0_0_010000
	or	local06, #16
'                 if flags & PAL <> 0
	test	arg06, #2 wz
'                     syncFlags |= %0_0_001000
 if_ne	or	local06, #8
'                     timing := @int576_timing
 if_ne	mov	local09, ptr__p2videodrv_dat__
 if_ne	add	local09, ##3900
 if_ne	jmp	#LR__1429
'                 else
'                     timing := @int480_timing
	mov	local09, ptr__p2videodrv_dat__
	add	local09, ##3872
	jmp	#LR__1429
LR__1426
'             else ' progressive
'                 if output == COMPONENT_SDTV
	cmp	arg03, #5 wz
 if_ne	jmp	#LR__1427
'                     if flags & PAL <> 0
	test	arg06, #2 wz
'                         syncFlags |= %0_0_001000
 if_ne	or	local06, #8
'                         timing := @prog576_timing
 if_ne	mov	local09, ptr__p2videodrv_dat__
 if_ne	add	local09, ##3956
 if_ne	jmp	#LR__1428
'                     else
'                         timing := @prog480_timing
	mov	local09, ptr__p2videodrv_dat__
	add	local09, ##3928
	jmp	#LR__1428
LR__1427
'                 else ' CVBS/S-video
'                     if flags & PAL <> 0
	test	arg06, #2 wz
'                         syncFlags |= %0_0_001000
 if_ne	or	local06, #8
'                         timing := @prog288_timing
 if_ne	mov	local09, ptr__p2videodrv_dat__
 if_ne	add	local09, ##3844
'                     else
'                         timing := @prog240_timing
 if_e	mov	local09, ptr__p2videodrv_dat__
 if_e	add	local09, ##3816
LR__1428
LR__1429
LR__1430
LR__1431
LR__1432
' 
'     ' override with custom timing if specified
'     if userTiming <> 0
	cmp	arg09, #0 wz
'         timing := userTiming
 if_ne	mov	local09, arg09
' 
'     ' Optional PLL adjustment logic:
'     ' This code attempts to be flexible in that you can choose to have this driver setup the P2 PLL
'     ' for the pixel frequency setup and optional clock mode indicated in the timing structure,
'     ' or leave the clock alone and have it configured elsewhere.
'     '
'     ' Two longs are part of the timing structure: the new optional clock mode, and the new P2 frequency.
'     ' These are used to determine what to do and one of these three cases will be handled:
'     '
'     ' (a) If the new P2 frequency is 0 or equal to the current P2 clock frequency nothing will be changed.
'     '
'     ' (b) If the new P2 frequency is non-zero and the clock mode is non-zero, then that clock mode and
'     ' frequency will be used in a CLKSET operation called by this driver.
'     '
'     ' (c) If the new P2 frequency is non-zero and the clock mode is 0, an attempt is made to auto-configure
'     ' the PLL based on the specified new frequency.  The crystal or input clock frequency are required to
'     ' be specified as well as the tolerance in Hz.  The closest PLL settings are computed based on these
'     ' criteria and will be used in CLKSET.  If the tolerance is not met then no PLL timing will be changed.
'     ' Take that into consideration when setting up the tolerance and don't set values that are unachievable.
' 
'     newmode := long[timing][0] ' get new clock mode
	rdlong	local08, local09
'     newfreq := long[timing][1] ' get desired frequency
	add	local09, #4
	rdlong	local07, local09 wz
	sub	local09, #4
'     if newfreq and (clkfreq <> newfreq)
 if_ne	rdlong	local04, #20
 if_ne	cmp	local04, local07 wz
 if_e	jmp	#LR__1434
'         if newmode == 0
	cmp	local08, #0 wz
 if_ne	jmp	#LR__1433
'             newmode := computeClockMode(newfreq)
	mov	arg01, local07
	call	#_p2videodrv_computeClockMode
	mov	local08, result1
LR__1433
'         if newmode
	cmp	local08, #0 wz
'             CLKSET(newmode, newfreq)
 if_ne	mov	arg01, local08
 if_ne	mov	arg02, local07
 if_ne	call	#__system___clkset
LR__1434
' 
'     long[display][1] := (syncFlags << 24) + (pin << 20) + timing
	shl	local06, #24
	shl	local05, #20
	add	local06, local05
	add	local06, local09
	add	local02, #4
	wrlong	local06, local02
'     long[display][2] := 0 'reserved
	add	local02, #4
	wrlong	#0, local02
	sub	local02, #8
'     if mbox
	cmp	arg10, #0 wz
 if_e	jmp	#LR__1435
'         long[display][3] := (mbox & $fffff) | $0C00_0000  'external memory is supported
	bitl	arg10, #372
	bith	arg10, #58
	add	local02, #12
	wrlong	arg10, local02
	sub	local02, #12
	jmp	#LR__1436
LR__1435
'     else
'         long[display][3] := 0 ' no external memory
	add	local02, #12
	wrlong	#0, local02
	sub	local02, #12
LR__1436
'     long[display][4] := lineBuf
	add	local02, #16
	wrlong	arg07, local02
'     long[display][5] := lineBuf + maxLineSize
	add	arg07, arg08
	add	local02, #4
	wrlong	arg07, local02
'     long[display][6] := 0 'reserved
	add	local02, #4
	wrlong	#0, local02
'     long[display][7] := -1 ' global mouse offscreen
	add	local02, #4
	wrlong	##-1, local02
'     long[display][8] := 0 ' no borders
	add	local02, #4
	wrlong	#0, local02
'     long[display][9] := 0 ' border colour (black)
	add	local02, #4
	wrlong	#0, local02
'     long[display][10] := firstRegion ' first region if non-zero
	add	local02, #4
	wrlong	arg11, local02
	sub	local02, #40
'     if output == VGA
	cmp	arg03, #0 wz
 if_ne	jmp	#LR__1437
'         long[display][11] := CQ_VGA
	add	local02, #44
	wrlong	##23097, local02
'         long[display][12] := CY_VGA
	add	local02, #4
	wrlong	##1509949497, local02
'         long[display][13] := CI_VGA
	add	local02, #4
	wrlong	##5898297, local02
	sub	local02, #52
	jmp	#LR__1444
LR__1437
'     elseif output == COMPONENT_SDTV
	cmp	arg03, #5 wz
 if_ne	jmp	#LR__1438
'         long[display][11]:= CQ_COMP_SDTV
	add	local02, #44
	wrlong	##769325440, local02
'         long[display][12]:= CI_COMP_SDTV
	add	local02, #4
	wrlong	##-236835456, local02
'         long[display][13]:= CY_COMP_SDTV ' Y on green output
	add	local02, #4
	wrlong	##456460857, local02
	sub	local02, #52
	jmp	#LR__1443
LR__1438
'     elseif output == COMPONENT_HDTV
	cmp	arg03, #6 wz
 if_ne	jmp	#LR__1439
'         long[display][11]:= CQ_COMP_HDTV
	add	local02, #44
	wrlong	##-102097280, local02
'         long[display][12]:= CI_COMP_HDTV
	add	local02, #4
	wrlong	##518389376, local02
'         long[display][13]:= CY_COMP_HDTV ' Y on green output
	add	local02, #4
	wrlong	##204145744, local02
	sub	local02, #52
	jmp	#LR__1442
LR__1439
'     else ' assume SDTV
'         if flags & PAL <> 0
	test	arg06, #2 wz
 if_e	jmp	#LR__1440
'             long[display][6]:= CV_PAL_EVEN ^ CV_PAL_ODD
	add	local02, #24
	wrlong	##-52363776, local02
'             long[display][11]:= CV_PAL_EVEN
	add	local02, #20
	wrlong	##-969930368, local02
'             long[display][12]:= CY_PAL
	add	local02, #4
	wrlong	##355010617, local02
'             long[display][13]:= CU_PAL
	add	local02, #4
	wrlong	##-219862727, local02
	sub	local02, #52
	jmp	#LR__1441
LR__1440
'         else
'             long[display][11]:= CQ_CVBS_SDTV
	add	local02, #44
	wrlong	##349117824, local02
'             long[display][12]:= CY_CVBS_SDTV
	add	local02, #4
	wrlong	##355010617, local02
'             long[display][13]:= CI_CVBS_SDTV
	add	local02, #4
	wrlong	##954655289, local02
	sub	local02, #52
LR__1441
LR__1442
LR__1443
LR__1444
'     if flags & FORCE_MONO_TEXT
	testbn	arg06, #20 wz
'         display |= FORCE_MONO_TEXT
 if_ne	bith	local02, #20
'     else
'         display &= !FORCE_MONO_TEXT
 if_e	bitl	local02, #20
' 
'     if flags & WAIT_ATN_START
	testbn	arg06, #21 wz
'         display |= WAIT_ATN_START
 if_ne	bith	local02, #21
'     else
'         display &= !WAIT_ATN_START
 if_e	bitl	local02, #21
' 
'     if cog +> MAXCOGS-1
	cmp	local01, #8 wc
'         cog := 16
 if_ae	mov	local01, #16
' 
'     return coginit(cog, @videodriver, display)
	mov	arg02, ptr__p2videodrv_dat__
	add	arg02, #32
	setq	local02
	coginit	local01, arg02 wc
 if_b	neg	local01, #1
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_p2videodrv_initDisplay_ret
	ret

' 
' 
' PRI computeClockMode(desiredHz) : mode | vco, finput, f, p, div, m, error, bestError
_p2videodrv_computeClockMode
	mov	_var01, #0
'     bestError := -1
	neg	_var02, #1
'     repeat p from 0 to 30 step 2
	mov	_var03, #0
	callpa	#(@LR__1459-@LR__1450)>>2,fcache_load_ptr_
LR__1450
'         ' compute the ideal VCO frequency f at this value of P
'         if p <> 0
	cmp	_var03, #0 wz
 if_e	jmp	#LR__1451
	abs	muldivb_, _var03 wc
	qdiv	##350000000, muldivb_
'             if desiredHz > MAXVCO_HZ/p ' test it like this to not overflow
'                 quit
	getqx	muldivb_
	negc	muldivb_, muldivb_
	cmps	arg01, muldivb_ wcz
 if_a	jmp	#LR__1460
	qmul	arg01, _var03
'             f := desiredHz * p
	getqx	_var04
	jmp	#LR__1452
LR__1451
'         else
'             f := desiredHz
	mov	_var04, arg01
'             if f > MAXVCO_HZ
	cmps	_var04, ##350000001 wc
'                 quit
 if_ae	jmp	#LR__1460
LR__1452
'         ' scan through D values, and find best M, retain best case
'         repeat div from 1 to 64
	mov	_var05, #1
LR__1453
	abs	result1, _var05 wc
	qdiv	##20000000, result1
'             'compute the PLL input frequency from the crystal through the divider
'             finput := CLKIN_HZ/div
'             if finput < MINPLLIN_HZ ' input getting too low, and only gets lower so quit now
'                 quit
	getqx	result1
	negc	_var06, result1
	cmps	_var06, ##500000 wc
 if_b	jmp	#LR__1458
' 
'             ' determine M value needed for this ideal VCO frequency and input frequency
'             m := f / finput
	mov	muldiva_, _var04
	mov	muldivb_, _var06
	call	#divide_
	mov	_var07, muldivb_
' 
'             ' check for the out of divider range case
'             if m +> 1024
	cmp	_var07, ##1025 wc
'                 quit
 if_ae	jmp	#LR__1458
	cmp	_var07, #0 wz
 if_e	mov	_var08, _var07
 if_e	add	_var08, #1
 if_e	mov	_var07, _var08
	qmul	_var06, _var07
' 
'             ' zero is special and gets a second chance
'             if m == 0
'                 m++
' 
'             ' compute the actual VCO frequency at this particular M, D setting
'             vco := finput * m
'             if vco +< MINVCO_HZ
'                 quit
	getqx	_var09
	cmp	_var09, ##100000000 wc
 if_b	jmp	#LR__1458
'             if vco +> MAXVCO_HZ
	cmp	_var09, ##350000001 wc
'                 next
 if_ae	jmp	#LR__1457
' 
'             ' compute the error and check next higher M value if possible, it may be closer
'             error := abs(f - vco)
	mov	_var10, _var04
	sub	_var10, _var09
	abs	_var10, _var10
	mov	_var11, _var10
'             if m < 1024 and (vco + finput) +< MAXVCO_HZ
	cmps	_var07, ##1024 wc
 if_b	mov	_var10, _var09
 if_b	add	_var10, _var06
 if_b	cmp	_var10, ##350000000 wc
 if_ae	jmp	#LR__1455
'                 if error > abs(f - (vco + finput))
	mov	_var10, _var04
	mov	_var08, _var09
	add	_var08, _var06
	sub	_var10, _var08
	abs	_var10, _var10
	cmps	_var11, _var10 wcz
 if_be	jmp	#LR__1454
'                     error := abs(f - (vco + finput))
	mov	_var10, _var04
	add	_var09, _var06
	sub	_var10, _var09
	abs	_var11, _var10
'                     m++
	mov	_var08, _var07
	add	_var08, #1
	mov	_var07, _var08
LR__1454
LR__1455
' 
'             ' retain best allowed frequency error and divider bits found so far
'             if error +< bestError and error +< TOLERANCE_HZ+1
	cmp	_var11, _var02 wc
 if_b	cmp	_var11, ##500001 wc
 if_ae	jmp	#LR__1456
'                 bestError := error
	mov	_var02, _var11
'                 mode := ((div-1) << 18) + ((m-1) << 8) + (((p/2 - 1) & $f) << 4)
	mov	_var01, _var05
	sub	_var01, #1
	shl	_var01, #18
	mov	_var08, _var07
	sub	_var08, #1
	shl	_var08, #8
	add	_var01, _var08
	abs	_var12, _var03 wc
	shr	_var12, #1
	negc	_var12, _var12
	sub	_var12, #1
	getnib	_var12, _var12, #0
	shl	_var12, #4
	add	_var01, _var12
LR__1456
' 
'             ' quit whenever perfect match found
'             if bestError == 0
	cmp	_var02, #0 wz
'                 quit
 if_e	jmp	#LR__1458
LR__1457
	mov	_var08, _var05
	add	_var08, #1
	mov	_var05, _var08
	cmp	_var05, #65 wc
 if_b	jmp	#LR__1453
LR__1458
' 
'         if bestError == 0
	cmp	_var02, #0 wz
'             quit
 if_ne	add	_var03, #2
 if_ne	cmps	_var03, #31 wc
 if_c_and_nz	jmp	#LR__1450
LR__1459
LR__1460
' 
'     ' final clock mode format is this #%0000_000E_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS
'     if mode
	cmp	_var01, #0 wz
'         ' also set 15 or 30pF capacitor loading based on input crystal frequency
'         mode |= (1<<24) ' enable PLL
'         if (CLKSRC == CLKSRC_XTAL) ' enable oscillator and caps for crystal
'             mode |= (CLKIN_HZ < 16000000) ? %1111 : %1011
 if_ne	or	_var01, ##16777227
	mov	result1, _var01
_p2videodrv_computeClockMode_ret
	ret

' 
' 
' 
' PUB initRegion(region, gfxMode, size, regionFlags, palette, fontBase, fontSize, screenBuf, nextRegion) : r
_p2videodrv_initRegion
' ' sets up a region
' ' optionally links it to a next region if that argument is non-zero
' 
'     long[region][0]  := nextRegion
	wrlong	arg09, arg01
'     if (gfxMode > -1)
	cmps	arg02, #0 wc
'         regionFlags := regionFlags | GRAPHICS_MODE
 if_ae	or	arg04, #2
'     long[region][1]  := (size << 16) + ((regionFlags & $ff) << 8) + (gfxMode & $f)
	shl	arg03, #16
	getbyte	arg04, arg04, #0
	shl	arg04, #8
	add	arg03, arg04
	getnib	arg02, arg02, #0
	add	arg03, arg02
	add	arg01, #4
	wrlong	arg03, arg01
'     long[region][2]  := screenBuf
	add	arg01, #4
	wrlong	arg08, arg01
'     long[region][3]  := screenBuf ' no wrap set yet
	add	arg01, #4
	wrlong	arg08, arg01
'     long[region][4]  := (((fontSize-1) & $ff) << 24) + fontBase
	sub	arg07, #1
	getbyte	arg07, arg07, #0
	shl	arg07, #24
	add	arg07, arg06
	add	arg01, #4
	wrlong	arg07, arg01
'     long[region][5]  := palette
	add	arg01, #4
	wrlong	arg05, arg01
'     long[region][6]  := 0 ' cursor 1 off until enabled
	add	arg01, #4
	wrlong	#0, arg01
'     long[region][7]  := 0 ' cursor 2 off until enabled
	add	arg01, #4
	wrlong	#0, arg01
'     long[region][8]  := -1 ' region mouse offscreen
	add	arg01, #4
	wrlong	##-1, arg01
'     long[region][9]  := 0 ' mouse image
	add	arg01, #4
	wrlong	#0, arg01
'     long[region][10] := 0 ' no wrap
	add	arg01, #4
	wrlong	#0, arg01
'     long[region][11] := 0 ' no skew
	add	arg01, #4
	wrlong	#0, arg01
	sub	arg01, #44
'     return region
	mov	result1, arg01
_p2videodrv_initRegion_ret
	ret

' 
' PUB getTiming(resolution) : r
_p2videodrv_getTiming
	mov	_var01, #0
' ' returns pre-defined timings for common video resolutions
'     if (resolution == RES_640x350)
	cmp	arg01, #0 wz
'         return @ega_timing
 if_e	mov	result1, ptr__p2videodrv_dat__
 if_e	add	result1, ##4096
 if_e	jmp	#_p2videodrv_getTiming_ret
'     if (resolution == RES_800x480_DVI)
	cmp	arg01, #2 wz
'         return @wvga_dvi_timing
 if_e	mov	result1, ptr__p2videodrv_dat__
 if_e	add	result1, ##4068
 if_e	jmp	#_p2videodrv_getTiming_ret
'     if (resolution == RES_800x600)
	cmp	arg01, #3 wz
'         return @svga_timing
 if_e	mov	result1, ptr__p2videodrv_dat__
 if_e	add	result1, ##4124
 if_e	jmp	#_p2videodrv_getTiming_ret
'     if (resolution == RES_800x600_DVI)
	cmp	arg01, #4 wz
'         return @svga_dvi_timing
 if_e	mov	result1, ptr__p2videodrv_dat__
 if_e	add	result1, ##4152
 if_e	jmp	#_p2videodrv_getTiming_ret
'     if (resolution == RES_1024x768)
	cmp	arg01, #5 wz
'         return @xga_timing
 if_e	mov	result1, ptr__p2videodrv_dat__
 if_e	add	result1, ##4180
 if_e	jmp	#_p2videodrv_getTiming_ret
'     if (resolution == RES_1280x1024)
	cmp	arg01, #6 wz
'         return @sxga_timing
 if_e	mov	result1, ptr__p2videodrv_dat__
 if_e	add	result1, ##4208
 if_e	jmp	#_p2videodrv_getTiming_ret
'     if (resolution == RES_1600x1200)
	cmp	arg01, #7 wz
'         return @uxga_timing
 if_e	mov	result1, ptr__p2videodrv_dat__
 if_e	add	result1, ##4236
 if_e	jmp	#_p2videodrv_getTiming_ret
'     if (resolution == RES_1920x1080)
	cmp	arg01, #8 wz
'         return @fullhd_timing
 if_e	mov	result1, ptr__p2videodrv_dat__
 if_e	add	result1, ##4348
 if_e	jmp	#_p2videodrv_getTiming_ret
'     if (resolution == RES_1920x1200)
	cmp	arg01, #9 wz
'         return @wuxga_timing
 if_e	mov	result1, ptr__p2videodrv_dat__
 if_e	add	result1, ##4264
'     return @vga_timing ' default to VGA resolution
 if_ne	mov	result1, ptr__p2videodrv_dat__
 if_ne	add	result1, ##3984
_p2videodrv_getTiming_ret
	ret

' 
' PUB setCursorPos(region, cursid, rowpos, colpos)
_p2videodrv_setCursorPos
'     if (cursid == 0)
	cmp	arg02, #0 wz
 if_ne	jmp	#LR__1470
'         word[region][13] := ((rowpos & $ff) << 8) + (colpos & $ff)
	getbyte	arg03, arg03, #0
	shl	arg03, #8
	getbyte	arg04, arg04, #0
	add	arg03, arg04
	add	arg01, #26
	wrword	arg03, arg01
	jmp	#LR__1471
LR__1470
'     else
'         word[region][15] := ((rowpos & $ff) << 8) + (colpos & $ff)
	getbyte	arg03, arg03, #0
	shl	arg03, #8
	getbyte	arg04, arg04, #0
	add	arg03, arg04
	add	arg01, #30
	wrword	arg03, arg01
LR__1471
_p2videodrv_setCursorPos_ret
	ret

' 
' PUB getCurrentRows(display, region) : r | height
_p2videodrv_getCurrentRows
	mov	COUNT_, #2
	call	#pushregs_
'     height := byte[region][19]+1
	add	arg02, #19
	rdbyte	local01, arg02
	add	local01, #1
'     if byte[region][5] & DOUBLE_HIGH
	sub	arg02, #14
	rdbyte	muldivb_, arg02
	test	muldivb_, #8 wz
'         height *= 2
 if_ne	shl	local01, #1
'     r := word[region][3]
	add	arg02, #1
	rdword	local02, arg02 wz
	sub	arg02, #6
'     if r == 0
 if_ne	jmp	#LR__1480
'         r := findRegionSize(display, region)
	call	#_p2videodrv_findRegionSize
	mov	local02, result1
LR__1480
'     return (r + height - 1) / height ' round up
	add	local02, local01
	sub	local02, #1
	mov	muldiva_, local02
	mov	muldivb_, local01
	call	#divide_
	mov	result1, muldivb_
	mov	ptra, fp
	call	#popregs_
_p2videodrv_getCurrentRows_ret
	ret

' 
' PUB getCurrentColumns(display, region) : r | size, width
_p2videodrv_getCurrentColumns
	mov	COUNT_, #1
	call	#pushregs_
'     width := 8
	mov	local01, #8
'     if byte[region][5] & DOUBLE_WIDE
	add	arg02, #5
	rdbyte	muldivb_, arg02
	test	muldivb_, #4 wz
'         width *= 2
 if_ne	mov	local01, #16
'     return (getActivePixels(display) + width - 1) / width ' round up
'     return ((long[long[display][1]][2] & $ff) << 3)
	add	arg01, #4
	rdlong	result1, arg01
	add	result1, #8
	rdlong	result1, result1
	getbyte	muldiva_, result1, #0
	shl	muldiva_, #3
	add	muldiva_, local01
	sub	muldiva_, #1
	mov	muldivb_, local01
	call	#divide_
	mov	result1, muldivb_
	mov	ptra, fp
	call	#popregs_
_p2videodrv_getCurrentColumns_ret
	ret

' 
' '----------------------------------------------------------------------------------
' '  text printing related methods
' '----------------------------------------------------------------------------------
' 
' PUB out(char) | src, size, fontsize, rowpos, colpos, rows, columns, ctx, currpos, region, colours, cursid
_p2videodrv_out
	mov	COUNT_, #16
	call	#pushregs_
	mov	local01, arg01
'     ' get printing context for this COG and check if it's been setup already
'     if (ctx := context[cogid()]) == 0
	mov	result1, #0
	cogid	result1
	mov	muldivb_, result1
	shl	muldivb_, #2
	add	muldivb_, ptr__p2videodrv_dat__
	rdlong	local02, muldivb_ wz
	mov	local03, local02
'         return
 if_e	jmp	#LR__1502
' 
'     ' text output is supported only in text regions in hub (for now)
'     region := long[ctx][1]
	add	local03, #4
	rdlong	local04, local03
	sub	local03, #4
'     src := long[region][2]
	add	local04, #8
	rdlong	local05, local04
'     if (byte[region][5] & GRAPHICS_MODE <> 0) OR (src & $f0000000)
	sub	local04, #3
	rdbyte	muldivb_, local04
	sub	local04, #5
	test	muldivb_, #2 wz
 if_e	test	local05, ##-268435456 wz
'         return
 if_ne	jmp	#LR__1502
' 
'     ' get current text position and colours
'     currpos := word[ctx][4]  'current row, col position (read together atomically)
	add	local03, #8
	rdword	local06, local03
'     rowpos := currpos >> 8   'extract row
	mov	local07, local06
	shr	local07, #8
'     colpos := currpos & $ff  'and column
	getbyte	local08, local06, #0
'     colours := byte[ctx][10] 'extract text fg & bg colours
	add	local03, #2
	rdbyte	local09, local03
'     cursid := byte[ctx][11]  'get optional HW cursor id to manage (0=none, or HW cursor 1, 2)
	add	local03, #1
	rdbyte	local10, local03
	sub	local03, #11
' 
'     ' compute total rows and columns from region settings & active pixel width
'     fontsize := byte[region][19]+1
	add	local04, #19
	rdbyte	local11, local04
	add	local11, #1
'     if byte[region][5] & DOUBLE_HIGH
	sub	local04, #14
	rdbyte	local12, local04
	test	local12, #8 wz
'         fontsize *= 2
 if_ne	shl	local11, #1
'     ' start with number of scan lines in region
'     rows := word[region][3]
	add	local04, #1
	rdword	local13, local04 wz
	sub	local04, #6
'     if rows == 0 ' region has been auto-sized to end of screen
 if_ne	jmp	#LR__1490
'         rows := findRegionSize(long[ctx][0], region)
	rdlong	arg01, local03
	mov	arg02, local04
	call	#_p2videodrv_findRegionSize
	mov	local13, result1
LR__1490
' 
'     ' do no damage if region size was not found or height was somehow corrupted in memory
'     if rows == 0 or fontsize == 0
	cmp	local13, #0 wz
 if_ne	cmp	local11, #0 wz
'         return
 if_e	jmp	#LR__1502
' 
'     ' divide scanlines by font size and round up to compute character rows
'     rows := (rows + fontsize - 1) / fontsize
	add	local13, local11
	sub	local13, #1
	mov	muldiva_, local13
	mov	muldivb_, local11
	call	#divide_
	mov	local13, muldivb_
' 
'     ' compute columns
'     columns := (byte[region][5] & DOUBLE_WIDE) ? 16 : 8
	add	local04, #5
	rdbyte	muldivb_, local04
	sub	local04, #5
	test	muldivb_, #4 wz
 if_ne	mov	local12, #16
 if_e	mov	local12, #8
	mov	muldivb_, local12
'     columns := (word[ctx][6] + columns - 1) / columns ' round up
	add	local03, #12
	rdword	local14, local03
	sub	local03, #12
	mov	local12, local14
	add	local12, muldivb_
	sub	local12, #1
	mov	muldiva_, local12
	call	#divide_
	mov	local15, muldivb_
	mov	local16, local15
'     ' ensure we can still write to the screen if the width or height changes dynamically
'     if rowpos +>= rows
	cmp	local07, local13 wc
'         rowpos := rows-1
 if_ae	mov	local12, local13
 if_ae	sub	local12, #1
 if_ae	mov	local07, local12
'     if colpos +>= columns
	cmp	local08, local16 wc
'         colpos := columns - 1
 if_ae	mov	local12, local16
 if_ae	sub	local12, #1
 if_ae	mov	local08, local12
' 
'     ' process char
'     if char == 8  ' BACKSPACE
	cmp	local01, #8 wz
 if_ne	jmp	#LR__1491
'         if colpos
	cmp	local08, #0 wz
 if_e	jmp	#LR__1500
	qmul	local07, local16
'             colpos--
	sub	local08, #1
'             word[src][rowpos * columns + colpos] := (colours << 8) + 32
	shl	local09, #8
	add	local09, #32
	getqx	local16
	add	local16, local08
	shl	local16, #1
	add	local16, local05
	wrword	local09, local16
	jmp	#LR__1500
LR__1491
'     elseif char == 9 ' TAB
	cmp	local01, #9 wz
 if_ne	jmp	#LR__1492
'         if colpos < columns - 8
	sub	local16, #8
	cmps	local08, local16 wc
'             colpos += 8 - (colpos & 7)
 if_b	mov	local15, local08
 if_b	and	local15, #7
 if_b	mov	local14, #8
 if_b	sub	local14, local15
 if_b	add	local08, local14
	jmp	#LR__1499
LR__1492
'     elseif char == 13 ' CR
	cmp	local01, #13 wz
'         byte[ctx][15] := colpos ' save this original CR position for LF use later
 if_e	add	local03, #15
 if_e	wrbyte	local08, local03
 if_e	sub	local03, #15
'         colpos := 0
 if_e	mov	local08, #0
 if_e	jmp	#LR__1498
'     elseif char == 12 ' FF
	cmp	local01, #12 wz
 if_ne	jmp	#LR__1493
'         clear()
	call	#_p2videodrv_clear
'         return
	jmp	#LR__1502
LR__1493
'     else
'         ' update the screen if a printable character
'         if (char > 31)
	cmps	local01, #32 wc
 if_b	jmp	#LR__1494
	qmul	local07, local16
'             word[src][rowpos * columns + colpos] := (colours << 8) + (char & $ff)
	mov	local12, local09
	shl	local12, #8
	getbyte	local14, local01, #0
	add	local12, local14
'             colpos++
	getqx	local15
	add	local15, local08
	shl	local15, #1
	add	local15, local05
	wrword	local12, local15
	add	local08, #1
LR__1494
'         ' handle line wrap if required
'         if colpos == columns OR char == 10
	cmp	local08, local16 wz
 if_ne	cmp	local01, #10 wz
 if_ne	jmp	#LR__1497
'              ' if a LF before end of line is reached, also clear to end of line
'              if (colpos < columns)
	cmps	local08, local16 wc
 if_ae	jmp	#LR__1495
'                 if byte[ctx][14] == 13 ' if LF followed a CR, only clear from original CR position
	add	local03, #14
	rdbyte	local14, local03
	sub	local03, #14
	cmp	local14, #13 wz
'                     colpos := byte[ctx][15]
 if_e	add	local03, #15
 if_e	sub	local03, #15
LR__1495
'                 'wordfill(src + (rowpos * columns + colpos) * 2, (colours << 8) + 32, columns - colpos)
'                 ' RY EDIT: commented out above line
' 
'             colpos := 0
	mov	local08, #0
'             ' scroll the region if needed
'             if ++rowpos == rows
	add	local07, #1
	cmp	local07, local13 wz
 if_ne	jmp	#LR__1496
	add	local04, #44
	rdlong	local15, local04
	fges	local15, #0 wc
	mov	local14, local16
	shl	local14, #1
	add	local15, local14
	sub	local13, #1
	qmul	local15, local13
'                 rowpos-- ' back up a row
	sub	local07, #1
'                 ' determine size of a row including any skew
'                 size := long[region][11]
	sub	local04, #44
'                 if size < 0 ' negative skews are incompatible with text scrolling and will be ignored
'                     size := 0
'                 size += columns * 2
' 
'                 ' scroll up
'                 bytemove(src, src + size, size * (rows - 1))
	mov	arg02, local05
	add	arg02, local15
	mov	arg01, local05
	getqx	arg03
	call	#__system____builtin_memmove
	qmul	local07, local16
'                 ' clear bottom row
'                 wordfill(src + rowpos * columns * 2, (colours & $ff) << 8 + 32, size/2)
	getbyte	arg02, local09, #0
	shl	arg02, #8
	add	arg02, #32
	abs	local16, local15 wc
	shr	local16, #1
	negc	arg03, local16
	getqx	local16
	shl	local16, #1
	add	local05, local16
	mov	arg01, local05
	call	#\builtin_wordfill_
LR__1496
LR__1497
LR__1498
LR__1499
LR__1500
' 
'     ' if a HW cursor is applied to the text region, then also update its position
'     if cursid
	cmp	local10, #0 wz
 if_e	jmp	#LR__1501
'         setCursorPos(region, ((cursid & $f) - 1) & 1, rowpos, colpos)
	getnib	arg02, local10, #0
	sub	arg02, #1
	and	arg02, #1
	mov	arg01, local04
	mov	arg03, local07
	mov	arg04, local08
	call	#_p2videodrv_setCursorPos
LR__1501
' 
'     ' save last position and last char
'     word[ctx][4] := (rowpos << 8) + (colpos & $ff)
	shl	local07, #8
	getbyte	local08, local08, #0
	add	local07, local08
	add	local03, #8
	wrword	local07, local03
'     byte[ctx][14] := char
	add	local03, #6
	wrbyte	local01, local03
LR__1502
	mov	ptra, fp
	call	#popregs_
_p2videodrv_out_ret
	ret

' 
' 
' PUB printStr(str) : len
_p2videodrv_printStr
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
'     repeat until byte[str][len] == 0
LR__1510
	mov	arg01, local02
	add	arg01, local01
	rdbyte	arg01, arg01 wz
 if_e	jmp	#LR__1511
'         out(byte[str][len++])
	mov	arg01, local02
	add	arg01, local01
	rdbyte	arg01, arg01
	add	local02, #1
	call	#_p2videodrv_out
	jmp	#LR__1510
LR__1511
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_p2videodrv_printStr_ret
	ret

' 
' PUB initTextOutput(ctx, display, region, fg, bg, hwcursor, clearscreen)
_p2videodrv_initTextOutput
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg06 wz
	mov	local03, arg07
'     ' init the text region's context data
'     long[ctx][0] := display
	wrlong	arg02, local01
'     long[ctx][1] := region
	add	local01, #4
	wrlong	arg03, local01
'     long[ctx][2] := ((hwcursor & $ff) << 24) + ((((bg & $f) << 4) | (fg & $f)) << 16)  ' home row,col to 0,0
	getbyte	arg01, local02, #0
	shl	arg01, #24
	getnib	result1, arg05, #0
	shl	result1, #4
	getnib	arg04, arg04, #0
	or	result1, arg04
	shl	result1, #16
	add	arg01, result1
	add	local01, #4
	wrlong	arg01, local01
'     word[ctx][4] := 0
	wrword	#0, local01
'     word[ctx][6] := getActivePixels(display)
'     return ((long[long[display][1]][2] & $ff) << 3)
	add	arg02, #4
	rdlong	result1, arg02
	add	result1, #8
	rdlong	result1, result1
	getbyte	result1, result1, #0
	shl	result1, #3
	add	local01, #4
	wrword	result1, local01
'     word[ctx][7] := 0
	add	local01, #2
	wrword	#0, local01
	sub	local01, #14
'     ' init the HW cursor if enabled, and optionally clear the screen
'     if hwcursor
 if_e	jmp	#LR__1520
'         setCursorPos(region, (hwcursor - 1) & 1, 0, 0)
	sub	local02, #1
	and	local02, #1
	mov	arg01, arg03
	mov	arg02, local02
	mov	arg03, #0
	mov	arg04, #0
	call	#_p2videodrv_setCursorPos
LR__1520
'     context[cogid()] := ctx
	mov	local02, #0
	cogid	local02
	shl	local02, #2
	add	local02, ptr__p2videodrv_dat__
	wrlong	local01, local02
'     if clearscreen
	cmp	local03, #0 wz
'         clear()
 if_ne	call	#_p2videodrv_clear
	mov	ptra, fp
	call	#popregs_
_p2videodrv_initTextOutput_ret
	ret

' 
' ' clears text region
' PUB clear() | ctx, region, display, cursid
_p2videodrv_clear
	mov	COUNT_, #6
	call	#pushregs_
'     if (ctx := context[cogid()])
	mov	arg04, #0
	cogid	arg04
	shl	arg04, #2
	add	arg04, ptr__p2videodrv_dat__
	rdlong	local01, arg04 wz
 if_e	jmp	#LR__1531
'         display := long[ctx][0]
	rdlong	local02, local01
'         region  := long[ctx][1]
	add	local01, #4
	rdlong	local03, local01
'         wordfill(getSource(region), (byte[ctx][10] << 8) + 32, getCurrentRows(display, region)*getCurrentColumns(display, region))
	mov	arg01, local03
'     return long[region][2]
	add	arg01, #8
	rdlong	local04, arg01
	add	local01, #6
	rdbyte	local05, local01
	shl	local05, #8
	add	local05, #32
	mov	arg01, local02
	mov	arg02, local03
	call	#_p2videodrv_getCurrentRows
	mov	local06, result1
	mov	arg01, local02
	mov	arg02, local03
	call	#_p2videodrv_getCurrentColumns
	qmul	local06, result1
	mov	arg01, local04
	mov	arg02, local05
	getqx	arg03
	call	#\builtin_wordfill_
'         word[ctx][4] := 0 ' home the row & column to 0
	sub	local01, #2
	wrword	#0, local01
'         cursid := byte[ctx][11]
	add	local01, #3
	rdbyte	arg04, local01 wz
'         if cursid ' set HW cursor if enabled
 if_e	jmp	#LR__1530
'             setCursorPos(region, (cursid - 1) & 1, 0, 0)
	sub	arg04, #1
	and	arg04, #1
	mov	arg01, local03
	mov	arg02, arg04
	mov	arg03, #0
	mov	arg04, #0
	call	#_p2videodrv_setCursorPos
LR__1530
LR__1531
	mov	ptra, fp
	call	#popregs_
_p2videodrv_clear_ret
	ret

' 
' ' sets colours or attributes of text
' ' colour text: fgcolour, bgcolour are colour indexes 0-F for foreground and background colours
' ' mono text: attributes fgcolour bit0 = INVERSE, bgcolour bit3 = FLASH
' PUB setTextColours(fgcolour, bgcolour) | ctx
_p2videodrv_setTextColours
'     if (ctx := context[cogid()])
	mov	result1, #0
	cogid	result1
	shl	result1, #2
	add	result1, ptr__p2videodrv_dat__
	rdlong	result1, result1 wz
 if_e	jmp	#LR__1540
'         byte[ctx][10] := ((bgcolour & $f) << 4) | (fgcolour & $f)
	getnib	arg02, arg02, #0
	shl	arg02, #4
	getnib	arg01, arg01, #0
	or	arg02, arg01
	add	result1, #10
	wrbyte	arg02, result1
LR__1540
_p2videodrv_setTextColours_ret
	ret

' 
' PUB setTextPos(curs_row, curs_col) | cursid, ctx
_p2videodrv_setTextPos
	mov	COUNT_, #2
	call	#pushregs_
'     if (ctx := context[cogid()])
	mov	result1, #0
	cogid	result1
	shl	result1, #2
	add	result1, ptr__p2videodrv_dat__
	rdlong	arg04, result1 wz
 if_e	jmp	#LR__1551
'         word[ctx][4] := ((curs_row & $ff) << 8) + (curs_col & $ff)
	getbyte	arg03, arg01, #0
	shl	arg03, #8
	getbyte	result1, arg02, #0
	add	arg03, result1
	add	arg04, #8
	wrword	arg03, arg04
'         cursid := byte[ctx][11]
	add	arg04, #3
	rdbyte	local01, arg04 wz
	sub	arg04, #11
'         if cursid
 if_e	jmp	#LR__1550
'             setCursorPos(long[ctx][1], (cursid - 1) & 1, curs_row, curs_col)
	add	arg04, #4
	rdlong	local02, arg04
	sub	local01, #1
	and	local01, #1
	mov	arg03, arg01
	mov	arg04, arg02
	mov	arg01, local02
	mov	arg02, local01
	call	#_p2videodrv_setCursorPos
LR__1550
LR__1551
	mov	ptra, fp
	call	#popregs_
_p2videodrv_setTextPos_ret
	ret

' 
' PUB getTextPos() : curs_row, curs_col | ctx
_p2videodrv_getTextPos
'     if (ctx := context[cogid()]) == 0
	mov	result1, #0
	cogid	result1
	shl	result1, #2
	add	result1, ptr__p2videodrv_dat__
	rdlong	_var01, result1 wz
'         return
 if_e	mov	result2, #0
 if_e	mov	result1, #0
'     curs_col := byte[ctx][8]
 if_ne	add	_var01, #8
 if_ne	rdbyte	result2, _var01
'     curs_row := byte[ctx][9]
 if_ne	add	_var01, #1
 if_ne	rdbyte	result1, _var01
_p2videodrv_getTextPos_ret
	ret

' 
' PRI findRegionSize(display, region) : size | ptr
_p2videodrv_findRegionSize
	mov	_var01, arg01
'     ptr := long[display][10]
	add	_var01, #40
	rdlong	_var02, _var01 wz
	sub	_var01, #40
'     size := getActiveLines(display) - word[display][16]
	mov	arg01, _var01
'     return (long[long[display][1]][3] & $7ff)
	add	arg01, #4
	rdlong	result1, arg01
	add	result1, #12
	rdlong	result1, result1
	zerox	result1, #10
	mov	arg01, result1
	add	_var01, #32
	rdword	_var01, _var01
	sub	arg01, _var01
'     repeat while ptr <> 0 and ptr <> region and size > 0
 if_e	jmp	#LR__1562
	callpa	#(@LR__1561-@LR__1560)>>2,fcache_load_ptr_
LR__1560
	cmp	_var02, arg02 wz
 if_e	jmp	#LR__1562
	cmps	arg01, #1 wc
 if_b	jmp	#LR__1562
'         size -= word[ptr][3]
	add	_var02, #6
	rdword	_var01, _var02
	sub	_var02, #6
	sub	arg01, _var01
'         ptr := long[ptr][0]
	rdlong	_var02, _var02 wz
 if_ne	jmp	#LR__1560
LR__1561
LR__1562
'     if (ptr == region) and (size > 0)
	cmp	_var02, arg02 wz
 if_e	cmps	arg01, #1 wc
'         return
 if_nc_and_z	mov	result1, arg01
'     return 0
 if_c_or_nz	mov	result1, #0
_p2videodrv_findRegionSize_ret
	ret

' 
' 
' PUB hex(value, digits)
_p2videodrv_hex
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02 wz
' ' Print a hexadecimal number
'   value <<= (8 - digits) << 2
	mov	local02, arg01
	mov	local03, #8
	sub	local03, local01
	shl	local03, #2
	shl	local02, local03
'   repeat digits
 if_e	jmp	#LR__1571
LR__1570
'     value ROL= 4
	rol	local02, #4
'     tx(lookupz(value & $F : "0".."9", "A".."F"))
	getnib	arg01, local02, #0
	mov	arg03, ptr__p2videodrv_dat__
	add	arg03, ##4432
	mov	arg02, #0
	mov	arg04, #16
	call	#__system___lookup
	mov	arg01, result1
'     out(ch)
	call	#_p2videodrv_out
	djnz	local01, #LR__1570
LR__1571
	mov	ptra, fp
	call	#popregs_
_p2videodrv_hex_ret
	ret

' 
' PUB start() : r
_usbnew_0016_start
	mov	_var01, #0
'   ifnot driver_cog
	add	ptr__usbnew_0016_dat__, ##7883
	rdbyte	_var02, ptr__usbnew_0016_dat__ wz
	sub	ptr__usbnew_0016_dat__, ##7883
 if_ne	jmp	#LR__1580
'     r := coginit(COGEXEC_NEW,@usb_host_start,0)
	mov	arg02, ptr__usbnew_0016_dat__
	mov	_var01, #16
	mov	arg03, #0
	setq	arg03
	coginit	_var01, arg02 wc
 if_b	neg	_var01, #1
'     if r >= 0
	cmps	_var01, #0 wc
'       driver_cog := r+1
 if_ae	mov	_var02, _var01
 if_ae	add	_var02, #1
 if_ae	add	ptr__usbnew_0016_dat__, ##7883
 if_ae	wrbyte	_var02, ptr__usbnew_0016_dat__
 if_ae	sub	ptr__usbnew_0016_dat__, ##7883
LR__1580
	mov	result1, _var01
_usbnew_0016_start_ret
	ret

'     '' Set KEYQUEUE_SIZE to enable (recommended value: 32)
' 
' '' Return key event from buffer if there is one
' PUB get_key() : r | tail
_usbnew_0016_get_key
'   tail := keyq_tail
	add	ptr__usbnew_0016_dat__, ##5517
	rdbyte	_var01, ptr__usbnew_0016_dat__
'   if keyq_head == tail
	sub	ptr__usbnew_0016_dat__, #1
	rdbyte	_var02, ptr__usbnew_0016_dat__
	sub	ptr__usbnew_0016_dat__, ##5516
	cmp	_var02, _var01 wz
'     return 0 ' No event
 if_e	mov	result1, #0
 if_e	jmp	#_usbnew_0016_get_key_ret
'   r := keyq_data[tail]
	mov	_var02, _var01
	shl	_var02, #2
	mov	result1, ptr__usbnew_0016_dat__
	add	result1, ##5518
	add	_var02, result1
	rdlong	result1, _var02
'   if ++tail == KEYQUEUE_SIZE
	add	_var01, #1
	cmp	_var01, #32 wz
'     tail := 0
 if_e	mov	_var01, #0
'   keyq_tail := tail
	add	ptr__usbnew_0016_dat__, ##5517
	wrbyte	_var01, ptr__usbnew_0016_dat__
	sub	ptr__usbnew_0016_dat__, ##5517
_usbnew_0016_get_key_ret
	ret

' 
' PUB GetDiskFromHost | r
_hostfs_GetDiskFromHost
	mov	COUNT_, #1
	call	#pushregs_
'     ser.start(63, 62, 0, 921_600)
	mov	arg01, #63
	mov	arg02, #62
	mov	arg03, #0
	mov	arg04, ##921600
	add	objptr, ##1044
'   if txpin == -99
'      baudrate := rxpin
'      rxpin := 63
'      txpin := 62
'      
'   startx(rxpin, txpin, mode, baudrate)
	call	#_SmartSerial_startx
'     ser.printf("Updating disk0.img from host...")
	mov	arg01, ##@LR__2125
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #0
	mov	arg05, #0
	mov	arg06, #0
	mov	arg07, #0
	call	#_SmartSerial_printf
	sub	objptr, ##1044
'     r := fs.fs_init(@sendrecv)
	mov	arg01, objptr
	add	objptr, ##1084
	call	#_fs9p_cc_fs_init
	sub	objptr, ##1084
'     if r < 0
	cmps	result1, #0 wc
 if_ae	jmp	#LR__1590
'         ser.printf(" fs_init returned error %d\n", r)
	mov	arg01, ##@LR__2126
	mov	arg02, result1
	mov	arg03, #0
	mov	arg04, #0
	mov	arg05, #0
	mov	arg06, #0
	mov	arg07, #0
	add	objptr, ##1044
	call	#_SmartSerial_printf
	sub	objptr, ##1044
'         return
	jmp	#LR__1594
LR__1590
'     r := fs.fs_open(@myfd, @"disk0.img", 0)
	mov	arg02, ##@LR__2127
	mov	arg01, objptr
	mov	arg03, #0
	add	objptr, ##1084
	call	#_fs9p_cc_fs_open
	sub	objptr, ##1084
'     if r < 0
	cmps	result1, #0 wc
 if_ae	jmp	#LR__1591
'         ser.printf(" fs_open returned error %d\n", r)
	mov	arg01, ##@LR__2128
	mov	arg02, result1
	mov	arg03, #0
	mov	arg04, #0
	mov	arg05, #0
	mov	arg06, #0
	mov	arg07, #0
	add	objptr, ##1044
	call	#_SmartSerial_printf
	sub	objptr, ##1044
'         return
	jmp	#LR__1594
LR__1591
'     image := c.fopen(@"/sd/disk0.img", @"wb")
	mov	arg01, ##@LR__2129
	mov	arg02, ##@LR__2130
	add	objptr, ##1044
	call	#_libc_a_fopen
	mov	local01, result1
	sub	objptr, ##1028
	wrlong	local01, objptr
	sub	objptr, #16
'     repeat
LR__1592
'         r := fs.fs_read(@myfd, @buf, 1024)
	mov	arg01, objptr
	add	objptr, #20
	mov	arg02, objptr
	decod	arg03, #10
	add	objptr, ##1064
	call	#_fs9p_cc_fs_read
	mov	local01, result1
'         c.fwrite(@buf, 1, 1024, image)
	sub	objptr, ##1064
	mov	arg01, objptr
	sub	objptr, #4
	rdlong	arg04, objptr
	mov	arg02, #1
	decod	arg03, #10
	add	objptr, ##1028
	call	#_libc_a_fwrite
'         ser.printf(".")
	mov	arg01, ##@LR__2131
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #0
	mov	arg05, #0
	mov	arg06, #0
	mov	arg07, #0
	call	#_SmartSerial_printf
	sub	objptr, ##1044
	cmps	local01, #1 wc
 if_ae	jmp	#LR__1592
'     until r =< 0
'     fs.fs_close(@myfd)
	mov	arg01, objptr
	add	objptr, ##1084
	call	#_fs9p_cc_fs_close
'     c.fclose(image)
	sub	objptr, ##1068
	rdlong	arg01, objptr
	add	objptr, ##1028
' {
'     return _closeraw(f);
	call	#_libc_a__closeraw
'     ser.printf(" done!\n")
	mov	arg01, ##@LR__2132
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #0
	mov	arg05, #0
	mov	arg06, #0
	mov	arg07, #0
	call	#_SmartSerial_printf
	sub	objptr, ##1044
' 
'     r := fs.fs_open(@myfd, @"disk1.img", 0)
	mov	arg02, ##@LR__2133
	mov	arg01, objptr
	mov	arg03, #0
	add	objptr, ##1084
	call	#_fs9p_cc_fs_open
	sub	objptr, ##1084
	mov	local01, result1
'     if r < 0
	cmps	local01, #0 wc
'         return
 if_b	jmp	#LR__1594
'     ser.printf("Updating disk1.img from host...")
	mov	arg01, ##@LR__2134
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #0
	mov	arg05, #0
	mov	arg06, #0
	mov	arg07, #0
	add	objptr, ##1044
	call	#_SmartSerial_printf
'     image := c.fopen(@"/sd/disk1.img", @"wb")
	mov	arg01, ##@LR__2135
	mov	arg02, ##@LR__2136
	call	#_libc_a_fopen
	mov	local01, result1
	sub	objptr, ##1028
	wrlong	local01, objptr
	sub	objptr, #16
'     repeat
LR__1593
'         r := fs.fs_read(@myfd, @buf, 1024)
	mov	arg01, objptr
	add	objptr, #20
	mov	arg02, objptr
	decod	arg03, #10
	add	objptr, ##1064
	call	#_fs9p_cc_fs_read
	mov	local01, result1
'         c.fwrite(@buf, 1, 1024, image)
	sub	objptr, ##1064
	mov	arg01, objptr
	sub	objptr, #4
	rdlong	arg04, objptr
	mov	arg02, #1
	decod	arg03, #10
	add	objptr, ##1028
	call	#_libc_a_fwrite
'         ser.printf(".")
	mov	arg01, ##@LR__2137
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #0
	mov	arg05, #0
	mov	arg06, #0
	mov	arg07, #0
	call	#_SmartSerial_printf
	sub	objptr, ##1044
	cmps	local01, #1 wc
 if_ae	jmp	#LR__1593
'     until r =< 0
'     fs.fs_close(@myfd)
	mov	arg01, objptr
	add	objptr, ##1084
	call	#_fs9p_cc_fs_close
'     c.fclose(image)
	sub	objptr, ##1068
	rdlong	arg01, objptr
	add	objptr, ##1028
' {
'     return _closeraw(f);
	call	#_libc_a__closeraw
'     ser.printf(" done!\n")
	mov	arg01, ##@LR__2138
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #0
	mov	arg05, #0
	mov	arg06, #0
	mov	arg07, #0
	call	#_SmartSerial_printf
	sub	objptr, ##1044
LR__1594
	mov	ptra, fp
	call	#popregs_
_hostfs_GetDiskFromHost_ret
	ret

' 
' '' routine for transmitting and receiving 9P protocol buffers
' 
' PUB sendrecv(startbuf, endbuf, maxlen) | len, buf, i, left
_hostfs_sendrecv
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
'     len := endbuf - startbuf
	sub	arg02, local01
	mov	local02, arg02
'     buf := startbuf
	mov	local03, local01
'     long[startbuf] := len
	wrlong	local02, local01
' 
'     '' transmit magic sequence for loadp2
'     ser.tx($FF)
	mov	arg01, #255
	add	objptr, ##1044
	call	#_SmartSerial_tx
'     ser.tx($01)
	mov	arg01, #1
	call	#_SmartSerial_tx
	sub	objptr, ##1044
'     repeat while len > 0
LR__1600
	cmps	local02, #1 wc
 if_b	jmp	#LR__1601
'         ser.tx(byte[buf++])
	rdbyte	arg01, local03
	add	objptr, ##1044
	add	local03, #1
	call	#_SmartSerial_tx
	sub	objptr, ##1044
'         len--
	sub	local02, #1
	jmp	#LR__1600
LR__1601
' 
'     ' now get response
'     buf := startbuf
	mov	local03, local01
'     byte[buf++] := ser.rx
	add	objptr, ##1044
'   repeat
LR__1602
'     v := rxcheck()
	call	#_SmartSerial_rxcheck
	cmp	result1, ##-1 wz
 if_e	jmp	#LR__1602
	wrbyte	result1, local03
'     byte[buf++] := ser.rx
	add	local03, #1
'   repeat
LR__1603
'     v := rxcheck()
	call	#_SmartSerial_rxcheck
	cmp	result1, ##-1 wz
 if_e	jmp	#LR__1603
	wrbyte	result1, local03
'     byte[buf++] := ser.rx
	add	local03, #1
'   repeat
LR__1604
'     v := rxcheck()
	call	#_SmartSerial_rxcheck
	cmp	result1, ##-1 wz
 if_e	jmp	#LR__1604
	wrbyte	result1, local03
'     byte[buf++] := ser.rx
	add	local03, #1
'   repeat
LR__1605
'     v := rxcheck()
	call	#_SmartSerial_rxcheck
	cmp	result1, ##-1 wz
 if_e	jmp	#LR__1605
	sub	objptr, ##1044
	wrbyte	result1, local03
	add	local03, #1
'     len := long[startbuf]
	rdlong	local02, local01
'     left := len - 4
	mov	local01, local02
	sub	local01, #4
'     repeat while left > 0
LR__1606
	cmps	local01, #1 wc
 if_b	jmp	#LR__1608
'         byte[buf++] := ser.rx
	add	objptr, ##1044
'   repeat
LR__1607
'     v := rxcheck()
	call	#_SmartSerial_rxcheck
	cmp	result1, ##-1 wz
 if_e	jmp	#LR__1607
	sub	objptr, ##1044
	wrbyte	result1, local03
'         --left
	sub	local01, #1
	add	local03, #1
	jmp	#LR__1606
LR__1608
'     return len
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_hostfs_sendrecv_ret
	ret

' 
' pub startx(rxpin, txpin, mode, baudrate) | bitperiod, bit_mode
_SmartSerial_startx
'   bitperiod := (clkfreq / baudrate)
	rdlong	muldiva_, #20
	mov	muldivb_, arg04
	call	#divide_
' 
'   ' save parameters in the object
'   rx_pin := rxpin
	wrlong	arg01, objptr
'   tx_pin := txpin
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #4
' 
'   ' calculate smartpin mode for 8 bits per character
'   bit_mode := 7 + (bitperiod << 16)
	shl	muldivb_, #16
	mov	arg04, #7
	add	arg04, muldivb_
' 
'   ' set up the transmit pin
'   if txpin => 0
	cmps	arg02, #0 wc
'     pinf(txpin)
 if_ae	fltl	arg02
'     wrpin(txpin, _txmode)
 if_ae	wrpin	#124, arg02
'     wxpin(txpin, bit_mode)
 if_ae	wxpin	arg04, arg02
'     pinl(txpin)	' turn smartpin on by making the pin an output
 if_ae	drvl	arg02
' 
'   ' set up the receive pin
'   if rxpin => 0
	cmps	arg01, #0 wc
'     pinf(rxpin)
 if_ae	fltl	arg01
'     wrpin(rxpin, _rxmode)
 if_ae	wrpin	#62, arg01
'     wxpin(rxpin, bit_mode)
 if_ae	wxpin	arg04, arg01
'     pinl(rxpin)  ' turn smartpin on
 if_ae	drvl	arg01
_SmartSerial_startx_ret
	ret

' 
' ' transmit the 8 bit value "val"
' pub tx(val)
_SmartSerial_tx
'   if tx_pin => 0
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, #4
	cmps	arg02, #0 wc
 if_b	jmp	#LR__1612
'     wypin(tx_pin, val)
	add	objptr, #4
	rdlong	arg02, objptr
	wypin	arg01, arg02
	callpa	#(@LR__1611-@LR__1610)>>2,fcache_load_ptr_
'     txflush()
'   repeat
LR__1610
'     z := pinr(tx_pin)
	rdlong	arg01, objptr
	test	arg01, #32 wz
 if_ne	mov	result1, inb
 if_e	mov	result1, ina
	shr	result1, arg01
	shr	arg01, #6
	zerox	result1, arg01 wz
 if_e	jmp	#LR__1610
LR__1611
	sub	objptr, #4
LR__1612
_SmartSerial_tx_ret
	ret

'   while z == 0
'   
' ' check if byte received (never waits)
' ' returns -1 if no byte, otherwise byte
' 
' pub rxcheck() : rxbyte | rxpin, z
_SmartSerial_rxcheck
'   rxbyte := -1
	neg	_var01, #1
'   rxpin := rx_pin
	rdlong	_var02, objptr
'   if rxpin => 0
	cmps	_var02, #0 wc
 if_b	jmp	#LR__1620
'     z := pinr(rxpin)
	mov	arg01, _var02
	test	arg01, #32 wz
 if_ne	mov	result1, inb
 if_e	mov	result1, ina
	shr	result1, arg01
	shr	arg01, #6
	zerox	result1, arg01 wz
'     if z
'       rxbyte := rdpin(rxpin)>>24
 if_ne	rdpin	_var01, _var02
 if_ne	shr	_var01, #24
LR__1620
	mov	result1, _var01
_SmartSerial_rxcheck_ret
	ret

' 
' pub num(val, base, signflag, digitsNeeded) | i, digit, r1, q1
_SmartSerial_num
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03 wz
	mov	local04, arg04
' 
'   '' if signflag is nonzero, it indicates we should treat
'   '' val as signed; if it is > 1, it is a character we should
'   '' print for positive numbers (typically "+")
'   
'   if (signflag)
'       if (val < 0)
 if_ne	cmps	local01, #0 wc
'         signflag := "-"
 if_c_and_nz	mov	local03, #45
'         val := -val
 if_c_and_nz	neg	local01, local01
'         
'   '' make sure we will not overflow our buffer
'   if (digitsNeeded > 32)
	fles	local04, #32 wc
'     digitsNeeded := 32
' 
'   '' accumulate the digits
'   i := 0
	mov	local05, #0
	callpa	#(@LR__1635-@LR__1630)>>2,fcache_load_ptr_
'   repeat
LR__1630
'     if (val < 0)
	cmps	local01, #0 wc
 if_ae	jmp	#LR__1631
'       ' synthesize unsigned division from signed
'       ' basically shift val right by 2 to make it positive
'       ' then adjust the result afterwards by the bit we
'       ' shifted out
'       r1 := val&1  ' capture low bit
	mov	local06, local01
	and	local06, #1
'       q1 := val>>1 ' divide val by 2
	shr	local01, #1
'       digit := r1 + 2*(q1 // base)
	mov	muldiva_, local01
	mov	muldivb_, local02
	call	#divide_
	shl	muldiva_, #1
	add	local06, muldiva_
'       val := 2*(q1 / base)
	shl	muldivb_, #1
	mov	local01, muldivb_
'       if (digit => base)
	cmps	local06, local02 wc
'         val++
 if_ae	add	local01, #1
'         digit -= base
 if_ae	sub	local06, local02
	jmp	#LR__1632
LR__1631
'     else
'       digit := val // base
	mov	muldiva_, local01
	mov	muldivb_, local02
	call	#divide_
	mov	local06, muldiva_
'       val := val / base
	mov	local01, muldivb_
LR__1632
' 
'     if (digit => 0 and digit =< 9)
	cmps	local06, #0 wc
 if_b	jmp	#LR__1633
	cmps	local06, #10 wc
'        digit += "0"
 if_b	add	local06, #48
 if_b	jmp	#LR__1634
LR__1633
'     else
'        digit := (digit - 10) + "A"
	add	local06, #55
LR__1634
'     buf[i++] := digit
	mov	local07, local05
	mov	local08, objptr
	add	local08, #8
	add	local07, local08
	wrbyte	local06, local07
'     --digitsNeeded
	sub	local04, #1
	cmp	local01, #0 wz
	add	local05, #1
 if_e	cmps	local04, #1 wc
 if_c_and_z	jmp	#LR__1636
	cmps	local05, #32 wc
 if_b	jmp	#LR__1630
LR__1635
LR__1636
'   while (val <> 0 or digitsNeeded > 0) and (i < 32)
'   if (signflag > 1)
	cmps	local03, #2 wc
'     tx(signflag)
 if_ae	mov	arg01, local03
 if_ae	call	#_SmartSerial_tx
'     
'   '' now print the digits in reverse order
'   repeat while (i > 0)
LR__1637
	cmps	local05, #1 wc
 if_b	jmp	#LR__1638
'     tx(buf[--i])
	sub	local05, #1
	mov	local07, local05
	mov	local08, objptr
	add	local08, #8
	add	local07, local08
	rdbyte	arg01, local07
	call	#_SmartSerial_tx
	jmp	#LR__1637
LR__1638
	mov	ptra, fp
	call	#popregs_
_SmartSerial_num_ret
	ret

' 
' '' print a hex number with the specified number
' '' of digits; 0 means just use as many as we need
' pub hex(val, digits = 8) | mask
_SmartSerial_hex
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'   if digits > 0 and digits < 8
	cmps	local02, #1 wc
 if_b	jmp	#LR__1640
	cmps	local02, #8 wc
'     mask := (|< (4*digits)) - 1
 if_b	mov	local03, local02
 if_b	shl	local03, #2
 if_b	decod	local04, local03
 if_b	sub	local04, #1
'     val &= mask
 if_b	and	local01, local04
LR__1640
'   num(val, 16, 0, digits)
	mov	arg01, local01
	mov	arg02, #16
	mov	arg03, #0
	mov	arg04, local02
	call	#_SmartSerial_num
	mov	ptra, fp
	call	#popregs_
_SmartSerial_hex_ret
	ret

' 
' ''
' '' C like formatted print
' ''
' pub printf(fmt = string(""), an=0, bn=0, cn=0, dn=0, en=0, fn=0) | c, valptr, val
_SmartSerial_printf
	mov	COUNT_, #6
	call	#pushregs_
	add	ptra, #48
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg06, fp
	add	fp, #4
	wrlong	arg07, fp
'   valptr := @an
	sub	fp, #20
	mov	local01, fp
	add	fp, #28
	wrlong	local01, fp
	sub	fp, #32
'   repeat
LR__1650
'     c := byte[fmt++]
	rdlong	local01, fp
	mov	arg07, local01
	add	arg07, #1
	wrlong	arg07, fp
	rdbyte	local01, local01 wz
	add	fp, #28
	wrlong	local01, fp
'     if (c == 0)
	sub	fp, #28
'       quit
 if_e	jmp	#LR__1664
'     if c == "%"
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	cmp	local01, #37 wz
 if_ne	jmp	#LR__1658
'       c := byte[fmt++]
	rdlong	local01, fp
	mov	arg07, local01
	add	arg07, #1
	wrlong	arg07, fp
	rdbyte	local01, local01 wz
	add	fp, #28
	wrlong	local01, fp
'       if (c == 0)
	sub	fp, #28
'         quit
 if_e	jmp	#LR__1664
'       if (c == "%")
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	cmp	local01, #37 wz
 if_ne	jmp	#LR__1651
'         tx(c)
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #28
	call	#_SmartSerial_tx
'         next
	jmp	#LR__1650
LR__1651
'       val := long[valptr]
	add	fp, #32
	rdlong	local01, fp
	rdlong	local02, local01
	add	fp, #4
	wrlong	local02, fp
'       valptr += 4
	sub	fp, #4
	rdlong	local01, fp
	add	local01, #4
	wrlong	local01, fp
'       case c
	sub	fp, #4
	rdlong	local03, fp
	sub	fp, #28
	cmp	local03, #100 wz
 if_e	jmp	#LR__1652
	cmp	local03, #117 wz
 if_e	jmp	#LR__1653
	cmp	local03, #120 wz
 if_e	jmp	#LR__1654
	cmp	local03, #115 wz
 if_e	jmp	#LR__1655
	cmp	local03, #99 wz
 if_e	jmp	#LR__1657
	jmp	#LR__1650
LR__1652
'         "d": dec(val)
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
'   num(val, 10, 1, 0)
	mov	arg02, #10
	mov	arg03, #1
	mov	arg04, #0
	call	#_SmartSerial_num
	jmp	#LR__1650
LR__1653
'         "u": decuns(val)
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
'   num(val, 10, 0, digits)
	mov	arg04, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#_SmartSerial_num
	jmp	#LR__1650
LR__1654
'         "x": hex(val)
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	mov	arg02, #8
	call	#_SmartSerial_hex
	jmp	#LR__1650
LR__1655
'         "s": str(val)
	add	fp, #36
	rdlong	local04, fp
	sub	fp, #36
'   repeat while ((c := byte[s++]) <> 0)
LR__1656
	rdbyte	arg01, local04 wz
	add	local04, #1
 if_e	jmp	#LR__1650
'     tx(c)
	call	#_SmartSerial_tx
	jmp	#LR__1656
LR__1657
'         "c": tx(val)
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	call	#_SmartSerial_tx
	jmp	#LR__1650
LR__1658
'     elseif c == "\"
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	cmp	local01, #92 wz
 if_ne	jmp	#LR__1663
'       c := byte[fmt++]
	rdlong	local01, fp
	mov	local05, local01
	add	local05, #1
	wrlong	local05, fp
	rdbyte	local02, local01 wz
	add	fp, #28
	wrlong	local02, fp
'       if c == 0
	sub	fp, #28
'         quit
 if_e	jmp	#LR__1664
'       case c
	add	fp, #28
	rdlong	local06, fp
	sub	fp, #28
	cmp	local06, #110 wz
 if_e	jmp	#LR__1659
	cmp	local06, #114 wz
 if_e	jmp	#LR__1660
	cmp	local06, #116 wz
 if_e	jmp	#LR__1661
	jmp	#LR__1662
LR__1659
'         "n": nl
'   tx(13)
	mov	arg01, #13
	call	#_SmartSerial_tx
'   tx(10)
	mov	arg01, #10
	call	#_SmartSerial_tx
	jmp	#LR__1650
LR__1660
'         "r": tx(13)
	mov	arg01, #13
	call	#_SmartSerial_tx
	jmp	#LR__1650
LR__1661
'         "t": tx(8)
	mov	arg01, #8
	call	#_SmartSerial_tx
	jmp	#LR__1650
LR__1662
'         other: tx(c)
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #28
	call	#_SmartSerial_tx
	jmp	#LR__1650
LR__1663
'     else
'       tx(c)
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #28
	call	#_SmartSerial_tx
	jmp	#LR__1650
LR__1664
	mov	ptra, fp
	call	#popregs_
_SmartSerial_printf_ret
	ret

_fs9p_cc_strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__1670
' 		return scan2 ? -1 : 0;
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#_fs9p_cc_strncmp_ret
LR__1670
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#_fs9p_cc_strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__1672-@LR__1671)>>2,fcache_load_ptr_
' 	count = n;
' 	do {
LR__1671
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__1673
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__1671
LR__1672
LR__1673
	cmps	_var03, #0 wc
' 		return(0);
 if_b	mov	result1, #0
 if_b	jmp	#_fs9p_cc_strncmp_ret
	cmp	_var04, _var06 wz
' 		return(0);
 if_e	mov	result1, #0
 if_e	jmp	#_fs9p_cc_strncmp_ret
	cmp	_var04, #0 wz
' 		return(-1);
 if_e	neg	result1, #1
 if_e	jmp	#_fs9p_cc_strncmp_ret
	cmp	_var06, #0 wz
' 		return(1);
 if_e	mov	result1, #1
' 		return(c1 - c2);
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
_fs9p_cc_strncmp_ret
	ret

_fs9p_cc_fs_init
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	add	objptr, #8
	wrlong	local01, objptr
	sub	objptr, #8
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	mov	arg02, #0
	call	#_fs9p_cc_doPut4_0246
	wrbyte	#100, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
	bmask	arg02, #15
	getbyte	arg02, arg02, #0
	wrbyte	arg02, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
	wrbyte	#255, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
'     ptr = doPut1(ptr, x & 0xff);
'     ptr = doPut1(ptr, (x>>8) & 0xff);
'     return ptr;
	mov	arg01, result1
	mov	arg02, ##1048
	call	#_fs9p_cc_doPut4_0246
	mov	arg01, result1
	mov	arg02, ##@LR__2139
	call	#_fs9p_cc_doPutStr_0249
	mov	arg02, result1
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	mov	arg03, ##1048
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	mov	local03, ptr__fs9p_cc_dat__
	add	local03, #8
	rdbyte	local02, local03
	cmp	local02, #101 wz
'         return -1;
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__1684
'     r = b[0];
'     r |= (b[1]<<8);
'     return r;
	mov	arg01, local03
	add	arg01, #3
	call	#_fs9p_cc_FETCH4_0253
	mov	local04, result1
	mov	arg01, local03
	add	arg01, #7
	rdbyte	result1, arg01
	add	arg01, #1
	rdbyte	arg01, arg01
	shl	arg01, #8
	or	result1, arg01
'     r = b[0];
'     r |= (b[1]<<8);
'     return r;
	cmp	result1, #6 wz
 if_ne	jmp	#LR__1680
	add	local03, #9
	mov	arg02, ##@LR__2140
	mov	arg01, local03
	mov	arg03, #6
	call	#_fs9p_cc_strncmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1681
LR__1680
' 
'         return -1;
	neg	result1, #1
	jmp	#LR__1684
LR__1681
	cmp	local04, #64 wc
 if_b	jmp	#LR__1682
	cmp	local04, ##1049 wc
 if_b	jmp	#LR__1683
LR__1682
' 
'         return -1;
	neg	result1, #1
	jmp	#LR__1684
LR__1683
	wrlong	local04, ptr__fs9p_cc_dat__
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	mov	arg02, #0
	call	#_fs9p_cc_doPut4_0246
	wrbyte	#104, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
	bmask	arg02, #15
	getbyte	arg02, arg02, #0
	wrbyte	arg02, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
	wrbyte	#255, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
'     ptr = doPut1(ptr, x & 0xff);
'     ptr = doPut1(ptr, (x>>8) & 0xff);
'     return ptr;
	mov	arg01, result1
	mov	arg02, objptr
	call	#_fs9p_cc_doPut4_0246
	mov	arg01, result1
	neg	arg02, #1
	call	#_fs9p_cc_doPut4_0246
	mov	arg01, result1
	mov	arg02, ##@LR__2141
	call	#_fs9p_cc_doPutStr_0249
	mov	arg01, result1
	mov	arg02, ##@LR__2142
	call	#_fs9p_cc_doPutStr_0249
	mov	arg02, result1
	add	objptr, #8
	rdlong	local02, objptr
	mov	local04, local02
	sub	objptr, #8
	zerox	local04, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	rdlong	arg03, ptr__fs9p_cc_dat__
	mov	local03, objptr
	mov	objptr, local04
	call	local02
	mov	objptr, local03
	mov	local03, ptr__fs9p_cc_dat__
	add	local03, #8
	rdbyte	local04, local03
	cmp	local04, #105 wz
' 
'         return -1;
 if_ne	neg	result1, #1
'     }
'     return 0;
 if_e	mov	result1, #0
LR__1684
	mov	ptra, fp
	call	#popregs_
_fs9p_cc_fs_init_ret
	ret

_fs9p_cc_doPut2_0245
	mov	result1, arg02
	getbyte	arg02, arg02, #0
	wrbyte	arg02, arg01
'     *ptr++ = x;
'     return ptr;
	add	arg01, #1
	getbyte	arg02, result1, #1
	wrbyte	arg02, arg01
'     *ptr++ = x;
'     return ptr;
	add	arg01, #1
	mov	result1, arg01
'     ptr = doPut1(ptr, x & 0xff);
'     ptr = doPut1(ptr, (x>>8) & 0xff);
'     return ptr;
_fs9p_cc_doPut2_0245_ret
	ret

_fs9p_cc_doPut4_0246
	mov	result1, arg02
	getbyte	arg02, arg02, #0
	wrbyte	arg02, arg01
'     *ptr++ = x;
'     return ptr;
	add	arg01, #1
	getbyte	arg02, result1, #1
	wrbyte	arg02, arg01
'     *ptr++ = x;
'     return ptr;
	add	arg01, #1
	getbyte	arg02, result1, #2
	wrbyte	arg02, arg01
'     *ptr++ = x;
'     return ptr;
	add	arg01, #1
	getbyte	arg02, result1, #3
	wrbyte	arg02, arg01
'     *ptr++ = x;
'     return ptr;
	add	arg01, #1
	mov	result1, arg01
'     ptr = doPut1(ptr, x & 0xff);
'     ptr = doPut1(ptr, (x>>8) & 0xff);
'     ptr = doPut1(ptr, (x>>16) & 0xff);
'     ptr = doPut1(ptr, (x>>24) & 0xff);
'     return ptr;
_fs9p_cc_doPut4_0246_ret
	ret

_fs9p_cc_doPutStr_0249
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local02
	mov	local03, arg01
	callpa	#(@LR__1691-@LR__1690)>>2,fcache_load_ptr_
LR__1690
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__1690
LR__1691
	sub	local03, arg01
	mov	arg02, local03
	mov	arg01, local01
	call	#_fs9p_cc_doPut2_0245
	mov	local01, result1
'     ptr = doPut2(ptr, L);
'     for (i = 0; i < L; i++) {
	cmp	local03, #1 wc
 if_b	jmp	#LR__1696
	mov	local04, local03
	callpa	#(@LR__1694-@LR__1692)>>2,fcache_load_ptr_
LR__1692
	rep	@LR__1695, local04
LR__1693
	mov	local04, local02
	add	local04, #1
	rdbyte	local03, local02
	mov	local02, local04
	wrbyte	local03, local01
	add	local01, #1
LR__1694
LR__1695
LR__1696
'         *ptr++ = *s++;
'     }
'     return ptr;
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_fs9p_cc_doPutStr_0249_ret
	ret

_fs9p_cc_FETCH4_0253
	rdbyte	result1, arg01
	add	arg01, #1
	rdbyte	_var01, arg01
	shl	_var01, #8
	or	result1, _var01
	add	arg01, #1
	rdbyte	_var01, arg01
	shl	_var01, #16
	or	result1, _var01
	add	arg01, #1
	rdbyte	_var01, arg01
	shl	_var01, #24
	or	result1, _var01
'     r = b[0];
'     r |= (b[1]<<8);
'     r |= (b[2]<<16);
'     r |= (b[3]<<24);
'     return r;
_fs9p_cc_FETCH4_0253_ret
	ret

_fs9p_cc_do_fs_walk_0267
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, #0
' 
'     do {
LR__1700
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	mov	arg02, #0
	call	#_fs9p_cc_doPut4_0246
	wrbyte	#110, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
	mov	arg01, result1
	bmask	arg02, #15
	call	#_fs9p_cc_doPut2_0245
	mov	arg01, result1
	mov	arg02, local01
	call	#_fs9p_cc_doPut4_0246
	mov	arg01, result1
	mov	local01, local02
	mov	arg02, local01
	call	#_fs9p_cc_doPut4_0246
	mov	local06, result1
	callpa	#(@LR__1702-@LR__1701)>>2,fcache_load_ptr_
'         ptr = doPut4(txbuf, 0);
'         ptr = doPut1(ptr, t_walk);
'         ptr = doPut2(ptr,  0xffffU );
'         ptr = doPut4(ptr, curdir);
'         curdir = (uint32_t)newfile;
'         ptr = doPut4(ptr, curdir);
'         while (*path == '/') path++;
LR__1701
	rdbyte	result1, local03
	cmp	result1, #47 wz
 if_e	add	local03, #1
 if_e	jmp	#LR__1701
LR__1702
	mov	local07, local06
	mov	local08, ptr__fs9p_cc_dat__
	add	local08, #4
	sub	local07, local08
	rdbyte	arg04, local03 wz
 if_e	jmp	#LR__1707
	mov	arg01, local06
	mov	arg02, #1
	call	#_fs9p_cc_doPut2_0245
	mov	arg01, result1
	mov	local09, arg01
	mov	arg02, #0
	call	#_fs9p_cc_doPut2_0245
	mov	local06, result1
	callpa	#(@LR__1704-@LR__1703)>>2,fcache_load_ptr_
'             ptr = doPut2(ptr, 1);
'             sizeptr = ptr;
'             ptr = doPut2(ptr, 0);
'             while (*path && *path != '/' && len < maxlen) {
LR__1703
	rdbyte	arg04, local03 wz
 if_ne	mov	local08, arg04
 if_ne	cmp	local08, #47 wz
 if_e	jmp	#LR__1705
	rdlong	arg04, ptr__fs9p_cc_dat__
	cmps	local07, arg04 wc
 if_ae	jmp	#LR__1705
	mov	arg04, local03
	add	arg04, #1
	rdbyte	arg03, local03
	mov	local03, arg04
	wrbyte	arg03, local06
	add	local07, #1
	add	local06, #1
	jmp	#LR__1703
LR__1704
LR__1705
	cmp	local04, #0 wz
 if_e	jmp	#LR__1706
	rdbyte	local08, local03 wz
 if_ne	jmp	#LR__1706
	cmp	local05, #0 wz
' 		return 0;
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__1709
	mov	arg01, local09
	mov	arg02, #1
	call	#_fs9p_cc_doPut2_0245
	add	local09, #2
	wrbyte	#46, local09
'     *ptr++ = x;
'     return ptr;
	add	local09, #1
	mov	local06, local09
	jmp	#LR__1708
LR__1706
	mov	arg02, local06
	mov	local08, local09
	add	local08, #2
	sub	arg02, local08
	mov	arg01, local09
	call	#_fs9p_cc_doPut2_0245
	jmp	#LR__1708
LR__1707
	mov	arg01, local06
	mov	arg02, #0
	call	#_fs9p_cc_doPut2_0245
	mov	local06, result1
LR__1708
	add	objptr, #8
	rdlong	local09, objptr
	sub	objptr, #8
	mov	local08, local09
	zerox	local09, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	rdlong	arg03, ptr__fs9p_cc_dat__
	mov	arg02, local06
	mov	local06, objptr
	mov	objptr, local09
	call	local08
	mov	objptr, local06
	mov	local05, #1
	add	ptr__fs9p_cc_dat__, #8
	rdbyte	local09, ptr__fs9p_cc_dat__
	sub	ptr__fs9p_cc_dat__, #8
	cmp	local09, #111 wz
'             return -1;
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__1709
	rdbyte	local09, local03 wz
 if_ne	jmp	#LR__1700
'     return 0;
	mov	result1, #0
LR__1709
	mov	ptra, fp
	call	#popregs_
_fs9p_cc_do_fs_walk_0267_ret
	ret

_fs9p_cc_fs_open_relative
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg04
	mov	arg02, local01
' {
'     return do_fs_walk(dir, newfile, path, 0);
	mov	arg04, #0
	call	#_fs9p_cc_do_fs_walk_0267
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1710
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	mov	arg02, #0
	call	#_fs9p_cc_doPut4_0246
	wrbyte	#112, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
	mov	arg01, result1
	bmask	arg02, #15
	call	#_fs9p_cc_doPut2_0245
	mov	arg01, result1
	mov	arg02, local01
	call	#_fs9p_cc_doPut4_0246
	getbyte	arg02, local02, #0
	wrbyte	arg02, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
	mov	arg02, result1
	add	objptr, #8
	rdlong	local02, objptr
	mov	local03, local02
	sub	objptr, #8
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	rdlong	arg03, ptr__fs9p_cc_dat__
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
	add	ptr__fs9p_cc_dat__, #8
	rdbyte	local04, ptr__fs9p_cc_dat__
	sub	ptr__fs9p_cc_dat__, #8
	cmp	local04, #113 wz
'         return -1;
 if_ne	neg	result1, #1
 if_e	add	local01, #4
 if_e	wrlong	#0, local01
 if_e	sub	local01, #4
 if_e	wrlong	#0, local01
'     }
'     f->offlo = f->offhi = 0;
'     return 0;
 if_e	mov	result1, #0
LR__1710
	mov	ptra, fp
	call	#popregs_
_fs9p_cc_fs_open_relative_ret
	ret

_fs9p_cc_fs_open
	mov	COUNT_, #3
	call	#pushregs_
' {
'     return fs_open_relative(&rootdir, f, path, fs_mode);
	mov	local01, objptr
	mov	local02, arg01
	mov	local03, arg02
	mov	arg04, arg03
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local03
	call	#_fs9p_cc_fs_open_relative
	mov	ptra, fp
	call	#popregs_
_fs9p_cc_fs_open_ret
	ret

_fs9p_cc_fs_close
	mov	COUNT_, #3
	call	#pushregs_
	mov	arg03, arg01
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	mov	arg02, #0
	call	#_fs9p_cc_doPut4_0246
	wrbyte	#120, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
	mov	arg01, result1
	bmask	arg02, #15
	call	#_fs9p_cc_doPut2_0245
	mov	arg01, result1
	mov	arg02, arg03
	call	#_fs9p_cc_doPut4_0246
	mov	arg02, result1
	add	objptr, #8
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #8
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	rdlong	arg03, ptr__fs9p_cc_dat__
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	cmps	result1, #0 wc
 if_ae	add	ptr__fs9p_cc_dat__, #8
 if_ae	rdbyte	local03, ptr__fs9p_cc_dat__
 if_ae	sub	ptr__fs9p_cc_dat__, #8
 if_ae	cmp	local03, #121 wz
'         return -1;
 if_c_or_nz	neg	result1, #1
'     }
'     return 0;
 if_nc_and_z	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_fs9p_cc_fs_close_ret
	ret

_fs9p_cc_fs_read
	mov	COUNT_, #10
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, #0
'     uint32_t oldlo;
'     while (count > 0) {
LR__1720
	cmps	local03, #1 wc
 if_b	jmp	#LR__1723
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	mov	arg02, #0
	call	#_fs9p_cc_doPut4_0246
	wrbyte	#116, result1
'     *ptr++ = x;
'     return ptr;
	add	result1, #1
	mov	arg01, result1
	bmask	arg02, #15
	call	#_fs9p_cc_doPut2_0245
	mov	arg01, result1
	mov	arg02, local01
	call	#_fs9p_cc_doPut4_0246
	mov	arg01, result1
	rdlong	arg02, local01
	call	#_fs9p_cc_doPut4_0246
	mov	arg01, result1
	add	local01, #4
	rdlong	arg02, local01
	sub	local01, #4
	call	#_fs9p_cc_doPut4_0246
	mov	arg01, result1
	rdlong	arg03, ptr__fs9p_cc_dat__
	mov	arg02, arg01
	add	arg02, #4
	mov	local05, ptr__fs9p_cc_dat__
	add	local05, #4
	sub	arg02, local05
	sub	arg03, arg02
	cmps	local03, arg03 wc
 if_b	mov	local06, local03
 if_ae	mov	local06, arg03
	mov	arg02, local06
	call	#_fs9p_cc_doPut4_0246
	mov	arg02, result1
	add	objptr, #8
	rdlong	local07, objptr
	sub	objptr, #8
	mov	local05, local07
	zerox	local07, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg01, ptr__fs9p_cc_dat__
	add	arg01, #4
	rdlong	arg03, ptr__fs9p_cc_dat__
	mov	local08, objptr
	mov	objptr, local07
	call	local05
	mov	objptr, local08
	cmps	result1, #0 wc
 if_b	jmp	#LR__1724
	mov	local09, ptr__fs9p_cc_dat__
	add	local09, #8
	rdbyte	local08, local09
	cmp	local08, #117 wz
'             return -1;
	add	local09, #1
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__1724
	add	local09, #2
	mov	arg01, local09
	call	#_fs9p_cc_FETCH4_0253
	mov	local10, result1
	add	local09, #4
	cmps	local10, #0 wc
 if_b	jmp	#LR__1721
	cmps	local10, local06 wcz
 if_be	jmp	#LR__1722
LR__1721
'             return -1;
	neg	result1, #1
	jmp	#LR__1724
LR__1722
	cmp	local10, #0 wz
' 
'             break;
 if_e	jmp	#LR__1723
	mov	arg01, local02
	mov	arg02, local09
	mov	arg03, local10
	call	#__system____builtin_memmove
	add	local02, local10
	add	local04, local10
	sub	local03, local10
	rdlong	local09, local01
	mov	local08, local09
	add	local08, local10
	wrlong	local08, local01
	cmp	local08, local09 wc
 if_ae	jmp	#LR__1720
	add	local01, #4
	rdlong	local05, local01
	add	local05, #1
	wrlong	local05, local01
	sub	local01, #4
	jmp	#LR__1720
LR__1723
'             f->offhi++;
'         }
'     }
'     return totalread;
	mov	result1, local04
LR__1724
	mov	ptra, fp
	call	#popregs_
_fs9p_cc_fs_read_ret
	ret
hubexit
	jmp	#cogexit

__system___clkset
	mov	_var01, arg01
	and	_var01, #3 wz
 if_e	cmps	arg01, #2 wc
 if_nc_and_z	mov	_var01, #3
	rdlong	_var02, #24
	wrlong	arg02, #20
	andn	_var02, #3
	wrlong	arg01, #24
	andn	arg01, #3
	hubset	_var02
	hubset	arg01
	waitx	##200000
	or	arg01, _var01
	hubset	arg01
	abs	_var02, arg02 wc
	qdiv	_var02, ##1000
	add	ptr___system__dat__, #12
	getqx	_var02
	negc	_var02, _var02
	wrlong	_var02, ptr___system__dat__
	abs	_var02, arg02 wc
	qdiv	_var02, ##1000000
	add	ptr___system__dat__, #4
	getqx	_var02
	negc	_var02, _var02
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #16
	wrlong	#0, ptr___system__dat__
__system___clkset_ret
	ret

__system___setbaud
	rdlong	muldiva_, #20
	mov	muldivb_, arg01
	call	#divide_
	callpa	#(@LR__1731-@LR__1730)>>2,fcache_load_ptr_
LR__1730
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__1730
LR__1731
	dirl	#62
	dirl	#63
	wrlong	muldivb_, ptr___system__dat__
	shl	muldivb_, #16
	mov	arg02, #7
	add	arg02, muldivb_
	wrpin	#124, #62
	wxpin	arg02, #62
	wrpin	#62, #63
	add	arg02, #20
	wxpin	arg02, #63
	dirh	#62
	dirh	#63
__system___setbaud_ret
	ret

__system___txraw
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	callpa	#(@LR__1741-@LR__1740)>>2,fcache_load_ptr_
LR__1740
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__1740
LR__1741
	rdlong	result1, ptr___system__dat__ wz
 if_e	mov	arg01, ##921600
 if_e	call	#__system___setbaud
	drvl	#62
	wypin	local01, #62
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___txraw_ret
	ret

__system___rxraw
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, ptr___system__dat__ wz
 if_e	mov	arg01, ##921600
 if_e	call	#__system___setbaud
	cmp	local01, #0 wz
 if_e	jmp	#LR__1750
	rdlong	local03, #20
	shr	local03, #10
	qmul	local01, local03
	getct	result1
	getqx	local04
	add	result1, local04
	mov	local05, result1
	jmp	#LR__1751
LR__1750
	mov	local05, #0
LR__1751
	neg	local06, #1
	mov	local07, #63
	mov	local08, #0
	add	ptr___system__dat__, #4
	rdlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
LR__1752
	testb	local09, #8 wc
	testbn	local09, #9 andc
	shr	local09, #10
 if_b	mov	local08, #1
 if_ae	testp	#63 wz
 if_nc_and_z	mov	local08, #1
 if_nc_and_z	rdpin	local09, #63
 if_nc_and_z	shr	local09, #4
LR__1753
	mov	local02, #0
	cmp	local08, #0 wz
 if_ne	neg	local02, #1
	mov	local10, #0
	mov	local03, #0
	cmp	local01, #0 wz
 if_ne	neg	local03, #1
	mov	local04, #0
	mov	local11, #0
	mov	local12, local05
	getct	result1
	mov	local13, result1
	sub	local12, local13
	cmps	local12, #0 wc
 if_b	not	local11, #0
	cmp	local11, #0 wz
 if_ne	not	local04, #0
	test	local03, local04 wz
 if_ne	not	local10, #0
	or	local02, local10 wz
 if_e	jmp	#LR__1752
	cmp	local08, #0 wz
 if_ne	mov	local06, local09
 if_ne	getbyte	local06, local06, #0
	add	ptr___system__dat__, #4
	wrlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___rxraw_ret
	ret

__system___getus
	getct	result2 wc
	getct	_var01
	add	ptr___system__dat__, #16
	rdlong	_var02, ptr___system__dat__ wz
	sub	ptr___system__dat__, #16
 if_ne	jmp	#LR__1760
	rdlong	_var02, #20
	qdiv	_var02, ##1000000
	add	ptr___system__dat__, #16
	getqx	result1
	mov	_var02, result1
	wrlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #16
LR__1760
	qdiv	result2, _var02
	getqy	result2
	setq	result2
	qdiv	_var01, _var02
	getqx	result1
__system___getus_ret
	ret

__system____builtin_memmove
	mov	_var01, arg01
	cmps	arg01, arg02 wc
 if_b	jmp	#LR__1770
	mov	_var02, arg02
	add	_var02, arg03
	cmps	arg01, _var02 wc
 if_b	jmp	#LR__1776
LR__1770
	mov	_var03, arg03
	shr	_var03, #2 wz
 if_e	jmp	#LR__1775
	callpa	#(@LR__1773-@LR__1771)>>2,fcache_load_ptr_
LR__1771
	rep	@LR__1774, _var03
LR__1772
	rdlong	_var03, arg02
	wrlong	_var03, arg01
	add	arg01, #4
	add	arg02, #4
LR__1773
LR__1774
LR__1775
	test	arg03, #2 wz
 if_ne	rdword	_var02, arg02
 if_ne	wrword	_var02, arg01
 if_ne	add	arg01, #2
 if_ne	add	arg02, #2
	test	arg03, #1 wz
 if_ne	rdbyte	_var02, arg02
 if_ne	wrbyte	_var02, arg01
	jmp	#LR__1782
LR__1776
	add	arg01, arg03
	add	arg02, arg03
	mov	_var04, arg03 wz
 if_e	jmp	#LR__1781
	callpa	#(@LR__1779-@LR__1777)>>2,fcache_load_ptr_
LR__1777
	rep	@LR__1780, _var04
LR__1778
	sub	arg01, #1
	sub	arg02, #1
	rdbyte	_var02, arg02
	wrbyte	_var02, arg01
LR__1779
LR__1780
LR__1781
LR__1782
	mov	result1, _var01
__system____builtin_memmove_ret
	ret

__system__longmove
	mov	_var01, arg01
	cmps	arg01, arg02 wc
 if_ae	jmp	#LR__1794
	mov	_var02, arg03 wz
 if_e	jmp	#LR__1800
	callpa	#(@LR__1792-@LR__1790)>>2,fcache_load_ptr_
LR__1790
	rep	@LR__1793, _var02
LR__1791
	rdlong	_var02, arg02
	wrlong	_var02, arg01
	add	arg01, #4
	add	arg02, #4
LR__1792
LR__1793
	jmp	#LR__1800
LR__1794
	mov	_var02, arg03
	shl	_var02, #2
	add	arg01, _var02
	mov	_var03, arg03
	shl	_var03, #2
	add	arg02, _var03
	mov	_var04, arg03 wz
 if_e	jmp	#LR__1799
	callpa	#(@LR__1797-@LR__1795)>>2,fcache_load_ptr_
LR__1795
	rep	@LR__1798, _var04
LR__1796
	sub	arg01, #4
	sub	arg02, #4
	rdlong	_var04, arg02
	wrlong	_var04, arg01
LR__1797
LR__1798
LR__1799
LR__1800
	mov	result1, _var01
__system__longmove_ret
	ret

__system____builtin_strcpy
	mov	_var01, arg01
	callpa	#(@LR__1811-@LR__1810)>>2,fcache_load_ptr_
LR__1810
	rdbyte	result1, arg02 wz
	wrbyte	result1, arg01
	add	arg02, #1
	add	arg01, #1
 if_ne	jmp	#LR__1810
LR__1811
	mov	result1, _var01
__system____builtin_strcpy_ret
	ret

__system___lookup
	sub	arg01, arg02
	cmps	arg01, #0 wc
 if_b	jmp	#LR__1820
	cmps	arg01, arg04 wc
 if_b	mov	_var01, arg01
 if_b	shl	_var01, #2
 if_b	add	_var01, arg03
 if_b	rdlong	result1, _var01
 if_b	jmp	#__system___lookup_ret
LR__1820
	mov	result1, #0
__system___lookup_ret
	ret

__system____topofstack
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	add	fp, #4
	wrlong	arg01, fp
	mov	result1, fp
	sub	fp, #4
	mov	ptra, fp
	call	#popregs_
__system____topofstack_ret
	ret

__system___lockmem
	mov	result1, #0
	cogid	result1
	add	result1, #256
LR__1830
	rdlong	_var01, arg01 wz
 if_e	wrlong	result1, arg01
 if_e	rdlong	_var01, arg01
 if_e	rdlong	_var01, arg01
	cmp	_var01, result1 wz
 if_ne	jmp	#LR__1830
__system___lockmem_ret
	ret

__system___tx
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	cmp	local01, #10 wz
 if_ne	jmp	#LR__1840
	add	ptr___system__dat__, #8
	rdlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	local02, #2 wz
 if_ne	mov	arg01, #13
 if_ne	call	#__system___txraw
LR__1840
	mov	arg01, local01
	call	#__system___txraw
	mov	ptra, fp
	call	#popregs_
__system___tx_ret
	ret

__system___rx
	mov	COUNT_, #1
	call	#pushregs_
LR__1850
	mov	arg01, #0
	call	#__system___rxraw
	mov	local01, result1
	cmp	local01, ##-1 wz
 if_e	jmp	#LR__1850
	cmp	local01, #13 wz
 if_ne	jmp	#LR__1851
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	result1, #2 wz
 if_ne	mov	local01, #10
LR__1851
	add	ptr___system__dat__, #8
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	arg01, #1 wz
 if_e	jmp	#LR__1854
	cmp	local01, #127 wz
 if_ne	jmp	#LR__1852
	mov	arg01, #8
	call	#__system___tx
	jmp	#LR__1853
LR__1852
	mov	arg01, local01
	call	#__system___tx
LR__1853
LR__1854
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system___rx_ret
	ret

__system___waitms
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__1861-@LR__1860)>>2,fcache_load_ptr_
LR__1860
	cmps	_var01, ##1000 wc
 if_b	jmp	#LR__1862
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000
	jmp	#LR__1860
LR__1861
LR__1862
	cmps	_var01, #1 wc
 if_b	jmp	#LR__1863
	qmul	_var01, _var03
	mov	arg03, ##1000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	arg01
	addct1	arg01, _var02
	waitct1
LR__1863
__system___waitms_ret
	ret

__system___waitus
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__1871-@LR__1870)>>2,fcache_load_ptr_
LR__1870
	cmps	_var01, ##1000000 wc
 if_b	jmp	#LR__1872
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000000
	jmp	#LR__1870
LR__1871
LR__1872
	cmps	_var01, #1 wc
 if_b	jmp	#LR__1873
	qmul	_var01, _var03
	mov	arg03, ##1000000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	result1
	addct1	_var02, result1
	waitct1
LR__1873
__system___waitus_ret
	ret

__system___mount
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	neg	local03, #1
 if_e	neg	result1, #1
 if_e	jmp	#LR__1895
	rdbyte	result1, local01
	cmp	result1, #47 wz
 if_ne	jmp	#LR__1882
	mov	arg01, local01
	mov	local04, arg01
	callpa	#(@LR__1881-@LR__1880)>>2,fcache_load_ptr_
LR__1880
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__1880
LR__1881
	sub	local04, arg01
	mov	result1, local04
	cmps	result1, #16 wc
 if_b	jmp	#LR__1883
LR__1882
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__1895
LR__1883
	mov	local05, #0
LR__1884
	cmps	local05, #4 wc
 if_ae	jmp	#LR__1889
	mov	arg01, local05
	shl	arg01, #2
	mov	result1, ptr___system__dat__
	add	result1, #100
	add	arg01, result1
	rdlong	result1, arg01 wz
 if_e	cmps	local03, #0 wc
 if_c_and_z	mov	local03, local05
 if_c_and_z	jmp	#LR__1888
	mov	arg01, local05
	shl	arg01, #2
	mov	local04, ptr___system__dat__
	add	local04, #100
	add	arg01, local04
	rdlong	arg01, arg01
	mov	local04, arg01
	callpa	#(@LR__1886-@LR__1885)>>2,fcache_load_ptr_
LR__1885
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__1885
LR__1886
	sub	local04, arg01
	mov	result1, local04
	mov	local06, result1
	mov	arg01, local06
	add	arg01, local01
	rdbyte	local04, arg01
	cmp	local04, #47 wz
 if_ne	mov	local07, local06
 if_ne	add	local07, local01
 if_ne	rdbyte	arg01, local07 wz
 if_ne	jmp	#LR__1887
	mov	local04, local05
	shl	local04, #2
	mov	arg03, ptr___system__dat__
	add	arg03, #100
	add	local04, arg03
	rdlong	arg02, local04
	mov	arg01, local01
	mov	arg03, local06
	call	#__system__strncmp
	cmp	result1, #0 wz
 if_e	mov	local03, local05
 if_e	jmp	#LR__1889
LR__1887
LR__1888
	add	local05, #1
	jmp	#LR__1884
LR__1889
	cmp	local03, ##-1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#11, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__1895
	mov	local05, local03
	mov	local07, local05
	shl	local07, #2
	mov	local06, ptr___system__dat__
	add	local06, #116
	add	local07, local06
	rdlong	local06, local07 wz
 if_e	jmp	#LR__1890
	add	local06, #76
	rdlong	local07, local06 wz
	sub	local06, #76
 if_e	jmp	#LR__1890
	add	local06, #76
	rdlong	local07, local06
	mov	local04, local07
	zerox	local07, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	local06, local05
	shl	local06, #2
	mov	local03, ptr___system__dat__
	add	local03, #100
	add	local06, local03
	rdlong	arg01, local06
	mov	local06, objptr
	mov	objptr, local07
	call	local04
	mov	objptr, local06
LR__1890
	mov	local06, local05
	shl	local06, #2
	mov	local07, ptr___system__dat__
	add	local07, #116
	add	local06, local07
	wrlong	local02, local06
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1891
	shl	local05, #2
	mov	local07, ptr___system__dat__
	add	local07, #100
	add	local05, local07
	wrlong	#0, local05
	jmp	#LR__1894
LR__1891
	mov	local08, local05
	shl	local08, #4
	mov	local07, ptr___system__dat__
	add	local07, #36
	add	local08, local07
	mov	arg01, local08
	mov	arg02, local01
	mov	arg03, #16
	call	#__system__strncpy
	add	local02, #72
	rdlong	local07, local02 wz
	sub	local02, #72
 if_e	jmp	#LR__1893
	add	local02, #72
	rdlong	local07, local02
	mov	local09, local07
	zerox	local07, #19
	shr	local09, #20
	shl	local09, #2
	add	local09, __methods__
	rdlong	local09, local09
	mov	arg01, local08
	mov	local06, objptr
	mov	objptr, local07
	call	local09
	mov	objptr, local06
	mov	arg01, result1 wz
 if_e	jmp	#LR__1892
	mov	local08, local05
	shl	local08, #2
	add	ptr___system__dat__, #116
	add	local08, ptr___system__dat__
	wrlong	#0, local08
	shl	local05, #2
	sub	ptr___system__dat__, #16
	add	local05, ptr___system__dat__
	wrlong	#0, local05
	neg	arg01, arg01 wz
	sub	ptr___system__dat__, #68
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__1895
LR__1892
LR__1893
	shl	local05, #2
	mov	local07, ptr___system__dat__
	add	local07, #100
	add	local05, local07
	wrlong	local08, local05
LR__1894
	mov	result1, #0
LR__1895
	mov	ptra, fp
	call	#popregs_
__system___mount_ret
	ret

__system____getvfsforfile
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	callpa	#(@LR__1901-@LR__1900)>>2,fcache_load_ptr_
LR__1900
	rdbyte	result1, local02
	cmp	result1, #47 wz
 if_e	add	local02, #1
 if_e	rdbyte	local04, local02
 if_e	sub	local02, #1
 if_e	cmp	local04, #47 wz
 if_e	add	local02, #1
 if_e	jmp	#LR__1900
LR__1901
	rdbyte	local04, local02
	cmp	local04, #47 wz
 if_ne	jmp	#LR__1902
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncpy
	jmp	#LR__1904
LR__1902
	mov	arg02, ptr___system__dat__
	add	arg02, #132
	mov	arg01, local01
	mov	arg03, #256
	call	#__system__strncpy
	rdbyte	local04, local02 wz
 if_e	jmp	#LR__1903
	rdbyte	local04, local02
	cmp	local04, #46 wz
 if_e	add	local02, #1
 if_e	rdbyte	local05, local02
 if_e	sub	local02, #1
 if_e	mov	local06, local05
 if_e	zerox	local06, #7 wz
 if_e	jmp	#LR__1903
	rdbyte	local05, local01
	cmp	local05, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local04, local01
 if_e	sub	local01, #1
 if_e	cmps	local04, #0 wz
 if_ne	mov	arg02, ##@LR__2090
 if_ne	mov	arg01, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncat
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncat
LR__1903
LR__1904
	mov	arg01, local01
	call	#__system___normalizeName
	rdbyte	local04, local01 wz
 if_e	jmp	#LR__1905
	rdbyte	local04, local01
	cmp	local04, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local06, local01
 if_e	sub	local01, #1
 if_e	cmps	local06, #0 wz
 if_ne	jmp	#LR__1906
LR__1905
	mov	result1, ptr___system__dat__
	add	result1, ##644
	jmp	#LR__1920
LR__1906
	mov	local07, #0
LR__1907
	cmps	local07, #4 wc
 if_ae	jmp	#LR__1919
	mov	local06, local07
	shl	local06, #2
	mov	local04, ptr___system__dat__
	add	local04, #100
	add	local06, local04
	rdlong	local06, local06 wz
 if_e	jmp	#LR__1918
	mov	local04, local07
	shl	local04, #2
	mov	local06, ptr___system__dat__
	add	local06, #100
	add	local04, local06
	rdlong	arg01, local04
	mov	local08, arg01
	callpa	#(@LR__1909-@LR__1908)>>2,fcache_load_ptr_
LR__1908
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__1908
LR__1909
	sub	local08, arg01
	mov	local09, local08
	mov	local04, local09
	add	local04, local01
	rdbyte	local06, local04
	cmp	local06, #47 wz
 if_ne	mov	local10, local09
 if_ne	add	local10, local01
 if_ne	rdbyte	local05, local10 wz
 if_ne	jmp	#LR__1917
	mov	local04, local07
	shl	local04, #2
	mov	arg03, ptr___system__dat__
	add	arg03, #100
	add	local04, arg03
	rdlong	arg02, local04
	mov	arg03, local09
	mov	arg01, local01
	call	#__system__strncmp
	cmps	result1, #0 wz
 if_ne	jmp	#LR__1917
	mov	local11, local07
	shl	local11, #2
	mov	local04, ptr___system__dat__
	add	local04, #116
	add	local11, local04
	rdlong	local12, local11
	callpa	#(@LR__1911-@LR__1910)>>2,fcache_load_ptr_
LR__1910
	mov	local06, local09
	add	local06, #1
	add	local06, local01
	rdbyte	local11, local06
	cmp	local11, #46 wz
 if_ne	jmp	#LR__1912
	mov	local11, local09
	add	local11, #2
	add	local11, local01
	rdbyte	local10, local11
	cmp	local10, #47 wz
 if_ne	mov	local13, local09
 if_ne	add	local13, #2
 if_ne	add	local13, local01
 if_ne	rdbyte	local14, local13 wz
 if_e	add	local09, #1
 if_e	jmp	#LR__1910
LR__1911
LR__1912
	cmp	local03, #0 wz
 if_ne	mov	arg01, local03
 if_ne	mov	arg02, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncpy
	mov	arg02, local01
	add	arg02, local09
	add	arg02, #1
	mov	arg01, local01
	call	#__system____builtin_strcpy
	mov	arg01, local01
	mov	local08, arg01
	callpa	#(@LR__1914-@LR__1913)>>2,fcache_load_ptr_
LR__1913
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__1913
LR__1914
	sub	local08, arg01
	mov	local09, local08
LR__1915
	cmps	local09, #1 wc
 if_b	jmp	#LR__1916
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #47 wz
 if_e	mov	local11, local09
 if_e	add	local11, local01
 if_e	wrbyte	#0, local11
 if_e	sub	local09, #1
 if_e	jmp	#LR__1915
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #46 wz
 if_ne	jmp	#LR__1916
	cmps	local09, #2 wc
 if_b	jmp	#LR__1916
	mov	local14, local09
	sub	local14, #1
	add	local14, local01
	rdbyte	local05, local14
	cmp	local05, #47 wz
 if_ne	jmp	#LR__1916
	mov	local04, local09
	sub	local04, #1
	add	local04, local01
	wrbyte	#0, local04
	sub	local09, #2
	jmp	#LR__1915
LR__1916
	mov	result1, local12
	jmp	#LR__1920
LR__1917
LR__1918
	add	local07, #1
	jmp	#LR__1907
LR__1919
	add	ptr___system__dat__, ##724
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, ##724
LR__1920
	mov	ptra, fp
	call	#popregs_
__system____getvfsforfile_ret
	ret

__system___int64_shl
	test	arg03, #32 wz
 if_ne	mov	arg02, arg01
 if_ne	mov	arg01, #0
	test	arg03, #31 wz
 if_e	jmp	#LR__1930
	shl	arg02, arg03
	mov	result1, arg01
	neg	result2, arg03
	shr	result1, result2
	or	arg02, result1
	shl	arg01, arg03
LR__1930
	mov	result2, arg02
	mov	result1, arg01
__system___int64_shl_ret
	ret

__system___usepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #20
	test	arg01, _var01 wz
 if_e	add	ptr___system__dat__, #24
 if_e	rdlong	_var02, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #24
 if_e	test	arg02, _var02 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___usepins_ret
	add	ptr___system__dat__, #20
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg01
	wrlong	_var02, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg02
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #24
	neg	result1, #1
__system___usepins_ret
	ret

__system___freepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg01
	wrlong	_var01, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg02
	wrlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #24
__system___freepins_ret
	ret

__system___gc_ptrs
	mov	_var01, __heap_ptr
	mov	_var02, _var01
	add	_var02, ##5992
	rdlong	result2, _var01 wz
 if_ne	jmp	#LR__1940
	mov	result2, _var02
	sub	result2, _var01
	wrword	#1, _var01
	mov	result1, _var01
	add	result1, #2
	wrword	##27792, result1
	mov	result1, _var01
	add	result1, #4
	wrword	#0, result1
	mov	result1, _var01
	add	result1, #6
	wrword	#1, result1
	add	_var01, #16
	abs	result2, result2 wc
	shr	result2, #4
	negc	result2, result2
	wrword	result2, _var01
	mov	result2, _var01
	add	result2, #2
	wrword	##27791, result2
	mov	result2, _var01
	add	result2, #4
	wrword	#0, result2
	mov	result2, _var01
	add	result2, #6
	wrword	#0, result2
	sub	_var01, #16
LR__1940
	mov	result1, _var01
	mov	result2, _var02
__system___gc_ptrs_ret
	ret

__system___gc_tryalloc
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
	mov	local05, local03
	mov	local06, #0
	callpa	#(@LR__1951-@LR__1950)>>2,fcache_load_ptr_
LR__1950
	mov	local07, local05
	add	local05, #6
	rdword	arg02, local05 wz
	mov	arg01, local03
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local05, result1 wz
 if_ne	rdword	local06, local05
	cmp	local05, #0 wz
 if_ne	cmps	local05, local04 wc
 if_a	jmp	#LR__1952
 if_ne	cmps	local01, local06 wcz
 if_a	jmp	#LR__1950
LR__1951
LR__1952
	cmp	local05, #0 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__1955
	mov	result2, local05
	add	result2, #6
	rdword	local08, result2
	cmps	local01, local06 wc
 if_ae	jmp	#LR__1954
	wrword	local01, local05
	mov	arg01, local05
	mov	local08, local01
	shl	local08, #4
	add	arg01, local08
	sub	local06, local01
	wrword	local06, arg01
	mov	local08, arg01
	add	local08, #2
	wrword	##27791, local08
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, arg01
	add	local08, #4
	wrword	result1, local08
	mov	local08, local05
	add	local08, #6
	mov	arg02, arg01
	rdword	local08, local08
	add	arg02, #6
	wrword	local08, arg02
	mov	local09, arg01
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, result1
	rdword	local10, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local10, #4
 if_ne	add	arg01, local10
 if_ne	mov	result1, arg01
	mov	local11, result1 wz
 if_e	jmp	#LR__1953
	cmps	local11, local04 wc
 if_ae	jmp	#LR__1953
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local11, #4
	wrword	result1, local11
LR__1953
LR__1954
	add	local07, #6
	wrword	local08, local07
	mov	local09, ##27776
	or	local09, local02
	mov	result1, #0
	cogid	result1
	or	local09, result1
	mov	local11, local05
	add	local11, #2
	wrword	local09, local11
	mov	local09, local03
	add	local09, #8
	mov	local11, local05
	rdword	local09, local09
	add	local11, #6
	wrword	local09, local11
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local03, #8
	wrword	result1, local03
	add	local05, #8
	mov	result1, local05
LR__1955
	mov	ptra, fp
	call	#popregs_
__system___gc_tryalloc_ret
	ret

__system___gc_alloc_managed
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, #0
	call	#__system___gc_doalloc
	mov	arg02, result1 wz
 if_e	cmps	local01, #1 wc
 if_nc_and_z	mov	result1, #0
 if_c_or_nz	mov	result1, arg02
	mov	ptra, fp
	call	#popregs_
__system___gc_alloc_managed_ret
	ret

__system___gc_doalloc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, arg02
 if_e	mov	result1, #0
 if_e	jmp	#LR__1967
	add	local01, #23
	andn	local01, #15
	shr	local01, #4
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	call	#__system___lockmem
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1 wz
 if_ne	jmp	#LR__1960
	call	#__system___gc_docollect
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1
LR__1960
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	wrlong	#0, arg01
	cmp	local03, #0 wz
 if_e	jmp	#LR__1966
	shl	local01, #4
	sub	local01, #8
	abs	local04, local01 wc
	shr	local04, #2
	negc	local05, local04 wz
	mov	local06, local03
 if_e	jmp	#LR__1965
	callpa	#(@LR__1963-@LR__1961)>>2,fcache_load_ptr_
LR__1961
	rep	@LR__1964, local05
LR__1962
	wrlong	#0, local06
	add	local06, #4
LR__1963
LR__1964
LR__1965
LR__1966
	mov	result1, local03
LR__1967
	mov	ptra, fp
	call	#popregs_
__system___gc_doalloc_ret
	ret

__system___gc_isvalidptr
	bitl	arg03, #248
	sub	arg03, #8
	cmps	arg03, arg01 wc
 if_b	jmp	#LR__1970
	cmps	arg03, arg02 wc
 if_b	jmp	#LR__1971
LR__1970
	mov	result1, #0
	jmp	#__system___gc_isvalidptr_ret
LR__1971
	mov	_var01, arg03
	xor	_var01, arg01
	test	_var01, #15 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___gc_isvalidptr_ret
	mov	_var01, arg03
	add	_var01, #2
	rdword	_var01, _var01
	and	_var01, ##65472
	cmp	_var01, ##27776 wz
 if_ne	mov	result1, #0
 if_e	mov	result1, arg03
__system___gc_isvalidptr_ret
	ret

__system___gc_free
	mov	arg03, arg01
	call	#__system___gc_ptrs
	mov	arg01, result1
	mov	arg02, result2
	call	#__system___gc_isvalidptr
	mov	arg02, result1 wz
 if_e	jmp	#LR__1980
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	call	#__system___lockmem
	mov	arg01, arg02
	call	#__system___gc_dofree
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	wrlong	#0, arg01
LR__1980
__system___gc_free_ret
	ret

__system___gc_dofree
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	call	#__system___gc_ptrs
	mov	local02, result1
	mov	local03, result2
	mov	arg02, local01
	add	arg02, #2
	wrword	##27791, arg02
	mov	local04, local01
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	callpa	#(@LR__1991-@LR__1990)>>2,fcache_load_ptr_
LR__1990
	add	local04, #4
	rdword	arg02, local04 wz
	mov	arg01, local02
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_e	jmp	#LR__1992
	mov	arg01, local04
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__1990
LR__1991
LR__1992
	cmp	local04, #0 wz
 if_e	mov	local04, local02
	mov	arg02, local04
	add	arg02, #6
	mov	arg01, local01
	rdword	arg02, arg02
	add	arg01, #6
	wrword	arg02, arg01
	mov	arg02, local01 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local04
	add	arg02, #6
	wrword	result1, arg02
	cmp	local04, local02 wz
 if_e	jmp	#LR__1995
	mov	arg01, local04
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	cmp	result1, local01 wz
 if_ne	jmp	#LR__1994
	rdword	local06, local04
	rdword	arg02, local01
	add	local06, arg02
	wrword	local06, local04
	mov	local06, local01
	add	local06, #2
	wrword	#0, local06
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	cmps	local06, local03 wc
 if_ae	jmp	#LR__1993
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local06
	add	arg02, #4
	wrword	result1, arg02
LR__1993
	mov	arg02, local01
	add	arg02, #6
	mov	result2, local04
	rdword	arg02, arg02
	add	result2, #6
	wrword	arg02, result2
	add	local01, #6
	wrword	#0, local01
	mov	local01, local04
LR__1994
LR__1995
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	arg02, result1 wz
 if_e	jmp	#LR__1997
	cmps	arg02, local03 wc
 if_ae	jmp	#LR__1997
	mov	arg01, arg02
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__1997
	mov	local04, local01
	rdword	local06, local04
	mov	arg01, arg02
	rdword	local01, arg01
	add	local06, local01
	wrword	local06, local04
	mov	local06, arg01
	add	local06, #6
	mov	local01, local04
	rdword	local06, local06
	add	local01, #6
	wrword	local06, local01
	mov	local06, arg01
	add	local06, #2
	wrword	#170, local06
	mov	local06, arg01
	add	local06, #6
	wrword	#0, local06
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1 wz
 if_e	jmp	#LR__1996
	cmps	local06, local03 wc
 if_ae	jmp	#LR__1996
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local04, local06
	add	local04, #4
	wrword	result1, local04
LR__1996
LR__1997
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___gc_dofree_ret
	ret

__system___gc_docollect
	mov	COUNT_, #5
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result2
	mov	local02, result1
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
	mov	result1, #0
	cogid	result1
	mov	local05, result1
 if_e	jmp	#LR__2002
	callpa	#(@LR__2001-@LR__2000)>>2,fcache_load_ptr_
LR__2000
	cmps	local04, local01 wc
 if_ae	jmp	#LR__2002
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	andn	arg02, #32
	mov	arg01, local04
	add	arg01, #2
	wrword	arg02, arg01
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_ne	jmp	#LR__2000
LR__2001
LR__2002
	mov	local03, #0
	mov	arg01, #0
	call	#__system____topofstack
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___gc_markhub
	call	#__system___gc_markcog
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1 wz
 if_e	jmp	#LR__2006
LR__2003
	mov	local04, local02
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	test	arg02, #32 wz
 if_e	test	arg02, #16 wz
 if_ne	jmp	#LR__2005
	getnib	arg02, arg02, #0
	cmp	arg02, local05 wz
 if_ne	cmp	arg02, #14 wz
 if_ne	jmp	#LR__2004
	mov	arg01, local04
	call	#__system___gc_dofree
	mov	local02, result1
LR__2004
LR__2005
	cmp	local02, #0 wz
 if_ne	cmps	local02, local01 wc
 if_c_and_nz	jmp	#LR__2003
LR__2006
	mov	ptra, fp
	call	#popregs_
__system___gc_docollect_ret
	ret

__system___gc_markhub
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
LR__2010
	cmps	local01, local02 wc
 if_ae	jmp	#LR__2011
	rdlong	arg03, local01
	add	local01, #4
	mov	arg02, local04
	mov	arg01, local03
	call	#__system___gc_isvalidptr
	mov	arg03, result1 wz
 if_e	jmp	#LR__2010
	mov	arg01, arg03
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2010
	mov	result2, arg03
	add	result2, #2
	rdword	result2, result2
	andn	result2, #15
	or	result2, #46
	add	arg03, #2
	wrword	result2, arg03
	jmp	#LR__2010
LR__2011
	mov	ptra, fp
	call	#popregs_
__system___gc_markhub_ret
	ret

__system___gc_markcog
	mov	COUNT_, #4
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result1
	mov	local02, result2
	mov	local03, #495
LR__2020
	'.live	local03
	alts	local03, #0
	mov	local04, local03
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local04
	call	#__system___gc_isvalidptr
	cmp	result1, #0 wz
 if_e	jmp	#LR__2021
	mov	local04, result1
	add	local04, #2
	rdword	local04, local04
	or	local04, #32
	add	result1, #2
	wrword	local04, result1
LR__2021
	sub	local03, #1
	cmps	local03, #0 wc
 if_ae	jmp	#LR__2020
	mov	ptra, fp
	call	#popregs_
__system___gc_markcog_ret
	ret

__system__strncpy
	mov	_var01, arg01
LR__2030
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_b	jmp	#LR__2031
	mov	result1, arg02
	add	result1, #1
	rdbyte	_var02, arg02
	mov	arg02, result1
	wrbyte	_var02, _var01
	getbyte	_var02, _var02, #0
	zerox	_var02, #7 wz
	add	_var01, #1
 if_ne	jmp	#LR__2030
LR__2031
	callpa	#(@LR__2033-@LR__2032)>>2,fcache_load_ptr_
LR__2032
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_ae	mov	_var03, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	#0, _var03
 if_ae	jmp	#LR__2032
LR__2033
	mov	result1, arg01
__system__strncpy_ret
	ret

__system__strncat
	cmps	arg02, #0 wz
 if_e	jmp	#LR__2045
	cmp	arg03, #1 wc
 if_b	jmp	#LR__2045
	mov	_var01, arg01
	callpa	#(@LR__2041-@LR__2040)>>2,fcache_load_ptr_
LR__2040
	rdbyte	result1, _var01 wz
 if_ne	add	_var01, #1
 if_ne	jmp	#LR__2040
LR__2041
	mov	_var02, arg03
	callpa	#(@LR__2043-@LR__2042)>>2,fcache_load_ptr_
LR__2042
	rdbyte	_var03, arg02
	mov	_var04, _var03
	zerox	_var04, #7 wz
	add	arg02, #1
 if_e	jmp	#LR__2044
	sub	_var02, #1
	cmps	_var02, #0 wc
 if_ae	mov	_var04, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	_var03, _var04
 if_ae	jmp	#LR__2042
LR__2043
LR__2044
	wrbyte	#0, _var01
LR__2045
	mov	result1, arg01
__system__strncat_ret
	ret

__system__strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__2050
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#__system__strncmp_ret
LR__2050
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#__system__strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__2052-@LR__2051)>>2,fcache_load_ptr_
LR__2051
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__2053
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__2051
LR__2052
LR__2053
	cmps	_var03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#__system__strncmp_ret
	cmp	_var04, _var06 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system__strncmp_ret
	cmp	_var04, #0 wz
 if_e	neg	result1, #1
 if_e	jmp	#__system__strncmp_ret
	cmp	_var06, #0 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
__system__strncmp_ret
	ret

__system____root_opendir
	mov	result1, ptr___system__dat__
	add	result1, #100
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, #0
__system____root_opendir_ret
	ret

__system____root_readdir
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	add	local01, #4
	rdlong	local03, local01
	sub	local01, #4
LR__2060
	mov	arg03, ptr___system__dat__
	add	arg03, #116
	cmp	local03, arg03 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__2061
	rdlong	arg03, local03 wz
 if_e	add	local03, #4
 if_e	jmp	#LR__2060
	rdlong	arg02, local03
	add	arg02, #1
	mov	arg01, local02
	mov	arg03, #64
	call	#__system__strncpy
	add	local02, #80
	wrbyte	#1, local02
	sub	local02, #8
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local03, #4
	add	local01, #4
	wrlong	local03, local01
	mov	result1, #0
LR__2061
	mov	ptra, fp
	call	#popregs_
__system____root_readdir_ret
	ret

__system____root_closedir
	mov	result1, #0
__system____root_closedir_ret
	ret

__system____root_stat
	mov	_var01, arg02
	mov	arg01, _var01
	mov	arg02, #0
	mov	arg03, #48
	call	#\builtin_bytefill_
	add	_var01, #8
	wrlong	##4607, _var01
	mov	result1, #0
__system____root_stat_ret
	ret

__system___normalizeName
	mov	_var01, #0
	mov	_var02, arg01
	mov	_var03, _var02
LR__2070
	rdbyte	_var04, _var02 wz
 if_e	jmp	#LR__2089
	cmp	_var01, #0 wz
 if_ne	mov	_var04, _var03
 if_ne	add	_var03, #1
 if_ne	wrbyte	#47, _var04
 if_ne	mov	_var01, #0
	rdbyte	_var04, _var02
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__2082
	add	_var02, #1
	rdbyte	_var04, _var02
	sub	_var02, #1
	cmp	_var04, #47 wz
 if_e	jmp	#LR__2071
	add	_var02, #1
	rdbyte	_var05, _var02
	sub	_var02, #1
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__2072
LR__2071
	mov	_var07, _var02
	add	_var07, #1
	mov	_var02, _var07
	jmp	#LR__2086
LR__2072
	add	_var02, #1
	rdbyte	_var07, _var02
	sub	_var02, #1
	getbyte	_var04, _var07, #0
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__2081
	add	_var02, #2
	rdbyte	_var07, _var02
	sub	_var02, #2
	getbyte	_var04, _var07, #0
	cmp	_var04, #47 wz
 if_e	jmp	#LR__2073
	add	_var02, #2
	rdbyte	_var05, _var02
	sub	_var02, #2
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__2080
LR__2073
	add	_var02, #2
	cmps	_var03, arg01 wcz
 if_be	jmp	#LR__2079
	mov	_var08, _var03
	sub	_var08, #1
LR__2074
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__2075
	cmps	_var08, arg01 wcz
 if_a	sub	_var08, #1
 if_a	jmp	#LR__2074
LR__2075
	callpa	#(@LR__2077-@LR__2076)>>2,fcache_load_ptr_
LR__2076
	cmps	_var08, arg01 wcz
 if_be	jmp	#LR__2078
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	sub	_var08, #1
 if_ne	jmp	#LR__2076
LR__2077
LR__2078
	mov	_var03, _var08
LR__2079
	mov	_var01, #1
	jmp	#LR__2086
LR__2080
LR__2081
LR__2082
	callpa	#(@LR__2084-@LR__2083)>>2,fcache_load_ptr_
LR__2083
	rdbyte	_var04, _var02 wz
 if_ne	mov	_var07, _var04
 if_ne	cmp	_var07, #47 wz
 if_e	jmp	#LR__2085
	mov	_var06, _var02
	mov	_var05, _var02
	add	_var05, #1
	rdbyte	_var09, _var06
	mov	_var02, _var05
	wrbyte	_var09, _var03
	add	_var03, #1
	jmp	#LR__2083
LR__2084
LR__2085
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__2070
	mov	_var01, #1
LR__2086
	callpa	#(@LR__2088-@LR__2087)>>2,fcache_load_ptr_
LR__2087
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_e	mov	_var07, _var02
 if_e	add	_var07, #1
 if_e	mov	_var02, _var07
 if_e	jmp	#LR__2087
LR__2088
	jmp	#LR__2070
LR__2089
	wrbyte	#0, _var03
__system___normalizeName_ret
	ret

LR__2090
	byte	"/"
	byte	0
LR__2091
	byte	" !!! corrupted heap??? !!! "
	byte	0
LR__2092
	byte	" !!! out of heap memory !!! "
	byte	0
LR__2093
	byte	" !!! corrupted heap !!! "
	byte	0
LR__2094
	byte	"/sd"
	byte	0
LR__2095
	byte	0
	byte	0
LR__2096
	byte	"*+,:;<=>[]|",34,"?",127
	byte	0
LR__2097
	byte	"FAT32   "
	byte	0
LR__2098
	byte	"TZ"
	byte	0
LR__2099
	byte	0
	byte	0
LR__2100
	byte	"bad opcode"
	byte	0
LR__2101
	byte	"vm panic: "
	byte	0
LR__2102
	byte	" "
	byte	0
LR__2103
	byte	"stack pointer has high bit set???"
	byte	0
LR__2104
	byte	"bad size"
	byte	0
LR__2105
	byte	"bad size"
	byte	0
LR__2106
	byte	"stack pointer has high bit set"
	byte	0
LR__2107
	byte	"bad register"
	byte	0
LR__2108
	byte	"bad register"
	byte	0
LR__2109
	byte	"bad source"
	byte	0
LR__2110
	byte	"bad target"
	byte	0
LR__2111
	byte	"bad size"
	byte	0
LR__2112
	byte	"bad size"
	byte	0
LR__2113
	byte	"bad size"
	byte	0
LR__2114
	byte	"bad target"
	byte	0
LR__2115
	byte	"bad size"
	byte	0
LR__2116
	byte	"bad size"
	byte	0
LR__2117
	byte	"/sd/disk0.img"
	byte	0
LR__2118
	byte	"r+b"
	byte	0
LR__2119
	byte	"/sd/disk1.img"
	byte	0
LR__2120
	byte	"r+b"
	byte	0
LR__2121
	byte	"/sd/disk2.img"
	byte	0
LR__2122
	byte	"r+b"
	byte	0
LR__2123
	byte	"/sd/disk3.img"
	byte	0
LR__2124
	byte	"r+b"
	byte	0
LR__2125
	byte	"Updating disk0.img from host..."
	byte	0
LR__2126
	byte	" fs_init returned error %d\n"
	byte	0
LR__2127
	byte	"disk0.img"
	byte	0
LR__2128
	byte	" fs_open returned error %d\n"
	byte	0
LR__2129
	byte	"/sd/disk0.img"
	byte	0
LR__2130
	byte	"wb"
	byte	0
LR__2131
	byte	"."
	byte	0
LR__2132
	byte	" done!\n"
	byte	0
LR__2133
	byte	"disk1.img"
	byte	0
LR__2134
	byte	"Updating disk1.img from host..."
	byte	0
LR__2135
	byte	"/sd/disk1.img"
	byte	0
LR__2136
	byte	"wb"
	byte	0
LR__2137
	byte	"."
	byte	0
LR__2138
	byte	" done!\n"
	byte	0
LR__2139
	byte	"9P2000"
	byte	0
LR__2140
	byte	"9P2000"
	byte	0
LR__2141
	byte	"user"
	byte	0
LR__2142
	byte	0
	byte	0
	alignl
_libc_a_dat_
	byte	$00[12]
	byte	$05, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
	long	(26 {__system___tx})<<20
	long	(27 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(28 {_libc_a__rxtxioctl_0726})<<20
	long	(29 {_libc_a___dummy_flush_0727})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(26 {__system___tx})<<20
	long	(27 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(28 {_libc_a__rxtxioctl_0726})<<20
	long	(29 {_libc_a___dummy_flush_0727})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(26 {__system___tx})<<20
	long	(27 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(28 {_libc_a__rxtxioctl_0726})<<20
	long	(29 {_libc_a___dummy_flush_0727})<<20
	byte	$00[368]
	alignl
_fatfs_cc_dat_
	byte	$43, $55, $45, $41, $41, $41, $41, $43, $45, $45, $45, $49, $49, $49, $41, $41
	byte	$45, $92, $92, $4f, $4f, $4f, $55, $55, $59, $4f, $55, $4f, $9c, $4f, $9e, $9f
	byte	$41, $49, $4f, $55, $a5, $a5, $a6, $a7, $a8, $a9, $aa, $ab, $ac, $ad, $ae, $af
	byte	$b0, $b1, $b2, $b3, $b4, $41, $41, $41, $b8, $b9, $ba, $bb, $bc, $bd, $be, $bf
	byte	$c0, $c1, $c2, $c3, $c4, $c5, $41, $41, $c8, $c9, $ca, $cb, $cc, $cd, $ce, $cf
	byte	$d1, $d1, $45, $45, $45, $49, $49, $49, $49, $d9, $da, $db, $dc, $dd, $49, $df
	byte	$4f, $e1, $4f, $4f, $4f, $4f, $e6, $e8, $e8, $55, $55, $55, $59, $59, $ee, $ef
	byte	$f0, $f1, $f2, $f3, $f4, $f5, $f6, $f7, $f8, $f9, $fa, $fb, $fc, $fd, $fe, $ff
	byte	$00[8]
	byte	$ff, $ff, $ff, $ff, $1f, $00, $00, $00, $1c, $00, $00, $00, $1f, $00, $00, $00
	byte	$1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00
	byte	$1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00
	byte	$1f, $00, $00, $00, $00, $00, $00, $00, $1f, $00, $00, $00, $3b, $00, $00, $00
	byte	$5a, $00, $00, $00, $78, $00, $00, $00, $97, $00, $00, $00, $b5, $00, $00, $00
	byte	$d4, $00, $00, $00, $f3, $00, $00, $00, $11, $01, $00, $00, $30, $01, $00, $00
	byte	$4e, $01, $00, $00, $6d, $01, $00, $00, $ff, $ff, $ff, $ff, $00, $00, $00, $00
	byte	$00[32]
	long	@@@_fatfs_cc_dat_ + 310
	long	@@@_fatfs_cc_dat_ + 314
	byte	$00[18]
	byte	$3f, $3f, $3f, $00, $55, $43, $54, $00, $55, $43, $54, $00, $00, $00, $00, $00
	byte	$00[7]
	byte	$ca, $9a, $3b, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$91, $11, $11, $11, $11, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$01[7]
	byte	$90, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
	byte	$42[10]
	byte	$20[7]
	byte	$44[6]
	byte	$04[20]
	byte	$20[6]
	byte	$48[6]
	byte	$08[20]
	byte	$20, $20, $20, $20, $01, $00, $00, $00, $00
	alignl
_bus_dat_
	byte	$21, $00, $00, $00, $40, $00, $00, $00, $23, $00, $00, $00, $24, $00, $00, $00
	byte	$25, $00, $00, $00, $5e, $00, $00, $00, $26, $00, $00, $00, $2a, $00, $00, $00
	byte	$28, $00, $00, $00, $29, $00, $00, $00
	alignl
_memory_dat_
'-' rom file "../smolrom.bin"
	byte	$00, $9d, $02, $97, $ff, $ff, $00, $00, $20, $0e, $97, $00, $00, $00, $00, $fa
	byte	$fb, $03, $00, $0e, $97, $00, $00, $00, $00, $00, $00, $00, $00, $0e, $57, $00
	byte	$aa, $04, $00, $00, $00, $00, $8c, $02, $97, $89, $00, $00, $f0, $00, $02, $98
	byte	$de, $01, $00, $f0, $02, $98, $5d, $02, $00, $f0, $02, $8b, $00, $10, $00, $80
	byte	$00, $02, $87, $00, $00, $00, $00, $00, $22, $98, $92, $00, $00, $f0, $02, $88
	byte	$34, $00, $00, $f0, $02, $97, $00, $00, $00, $00, $00, $02, $97, $08, $00, $00
	byte	$00, $01, $02, $97, $00, $00, $00, $00, $02, $00, $aa, $02, $97, $02, $00, $00
	byte	$00, $00, $00, $aa, $02, $97, $00, $00, $01, $80, $00, $02, $27, $00, $01, $00
	byte	$9b, $01, $00, $02, $88, $83, $00, $00, $f0, $73, $6d, $6f, $6c, $72, $6f, $6d
	byte	$0a, $00, $02, $97, $f0, $00, $00, $f0, $00, $02, $98, $de, $01, $00, $f0, $02
	byte	$27, $00, $00, $02, $27, $00, $01, $02, $67, $00, $08, $02, $02, $98, $01, $02
	byte	$00, $f0, $0e, $87, $4c, $33, $3c, $52, $fc, $09, $00, $00, $20, $aa, $02, $97
	byte	$04, $01, $00, $f0, $00, $02, $98, $de, $01, $00, $f0, $02, $98, $5c, $01, $00
	byte	$f0, $02, $97, $ff, $ff, $00, $00, $20, $02, $27, $00, $00, $02, $97, $00, $00
	byte	$04, $00, $01, $02, $97, $f0, $fb, $03, $00, $02, $02, $88, $00, $08, $00, $00
	byte	$72, $65, $61, $64, $20, $2d, $3e, $20, $30, $78, $30, $30, $30, $30, $30, $38
	byte	$30, $30, $0a, $00, $6a, $75, $6d, $70, $20, $2d, $3e, $20, $30, $78, $30, $30
	byte	$30, $30, $30, $38, $30, $30, $0a, $00, $02, $27, $00, $00, $02, $27, $04, $01
	byte	$02, $67, $00, $08, $02, $02, $98, $01, $02, $00, $f0, $0e, $87, $4c, $33, $3c
	byte	$52, $fc, $09, $00, $00, $20, $aa, $02, $98, $5c, $01, $00, $f0, $02, $97, $ff
	byte	$ff, $00, $00, $20, $02, $27, $04, $00, $02, $97, $00, $00, $04, $00, $01, $02
	byte	$97, $f0, $fb, $03, $00, $02, $02, $88, $00, $08, $00, $00, $02, $27, $00, $00
	byte	$02, $27, $00, $01, $02, $27, $00, $02, $02, $27, $00, $03, $02, $27, $00, $04
	byte	$02, $27, $00, $05, $02, $27, $00, $06, $02, $27, $00, $07, $02, $27, $00, $08
	byte	$02, $27, $00, $09, $02, $27, $00, $0a, $02, $27, $00, $0b, $02, $27, $00, $0c
	byte	$02, $27, $00, $0d, $02, $27, $00, $0e, $02, $27, $00, $0f, $02, $27, $00, $10
	byte	$02, $27, $00, $11, $02, $27, $00, $12, $02, $27, $00, $13, $02, $27, $00, $14
	byte	$02, $27, $00, $15, $02, $27, $00, $16, $02, $27, $00, $17, $02, $27, $00, $18
	byte	$02, $27, $00, $19, $02, $27, $00, $1a, $02, $27, $00, $1b, $02, $27, $00, $1c
	byte	$02, $27, $00, $1d, $02, $27, $00, $1e, $02, $27, $00, $1f, $00, $aa, $00, $8a
	byte	$00, $00, $8a, $01, $02, $27, $00, $01, $01, $9b, $00, $01, $00, $91, $00, $06
	byte	$07, $00, $00, $22, $88, $e4, $01, $00, $f0, $00, $9a, $01, $00, $9a, $00, $00
	byte	$aa, $00, $8a, $03, $00, $8a, $04, $02, $97, $00, $20, $00, $80, $03, $02, $97
	byte	$00, $30, $00, $80, $04, $00, $13, $01, $04, $00, $9b, $02, $03, $00, $9b, $00
	byte	$04, $00, $9a, $04, $00, $9a, $03, $00, $aa, $00, $8a, $03, $00, $8a, $04, $02
	byte	$97, $00, $20, $00, $80, $03, $02, $97, $00, $40, $00, $80, $04, $00, $13, $01
	byte	$04, $00, $9b, $02, $03, $00, $9b, $00, $04, $00, $9a, $04, $00, $9a, $03, $00
	byte	$aa, $02, $88, $63, $02, $00, $f0, $02, $88, $18, $03, $00, $f0, $02, $88, $83
	byte	$02, $00, $f0, $02, $98, $3a, $03, $00, $f0, $00, $8c, $00, $90, $0e, $87, $fe
	byte	$fb, $03, $00, $fa, $fb, $03, $00, $12, $88, $69, $02, $00, $f0, $02, $88, $99
	byte	$02, $00, $f0, $02, $98, $3a, $03, $00, $f0, $0e, $87, $fe, $fb, $03, $00, $fa
	byte	$fb, $03, $00, $12, $88, $50, $03, $00, $f0, $00, $9c, $00, $8a, $08, $00, $8a
	byte	$09, $02, $97, $fe, $fb, $03, $00, $08, $02, $98, $75, $03, $00, $f0, $02, $97
	byte	$df, $ff, $03, $00, $08, $02, $98, $af, $03, $00, $f0, $02, $97, $fe, $fb, $03
	byte	$00, $09, $02, $81, $20, $00, $00, $00, $09, $0c, $87, $09, $fa, $fb, $03, $00
	byte	$12, $88, $f7, $02, $00, $f0, $00, $97, $09, $08, $02, $98, $75, $03, $00, $f0
	byte	$00, $97, $09, $08, $02, $a1, $20, $00, $00, $00, $08, $02, $98, $af, $03, $00
	byte	$f0, $02, $88, $c2, $02, $00, $f0, $02, $97, $df, $ff, $03, $00, $08, $02, $98
	byte	$75, $03, $00, $f0, $0e, $a1, $20, $00, $00, $00, $fa, $fb, $03, $00, $00, $9a
	byte	$09, $00, $9a, $08, $00, $8c, $00, $aa, $02, $98, $3a, $03, $00, $f0, $00, $8a
	byte	$08, $03, $97, $fa, $fb, $03, $00, $08, $02, $98, $af, $03, $00, $f0, $0c, $97
	byte	$08, $fa, $fb, $03, $00, $00, $9a, $08, $00, $aa, $0e, $87, $00, $00, $00, $00
	byte	$fa, $fb, $03, $00, $1e, $97, $fe, $fb, $03, $00, $fa, $fb, $03, $00, $00, $aa
	byte	$02, $97, $ff, $ff, $ff, $ff, $00, $02, $27, $00, $01, $02, $27, $00, $02, $02
	byte	$27, $00, $03, $02, $27, $00, $04, $02, $27, $00, $05, $02, $27, $00, $06, $02
	byte	$27, $00, $07, $00, $aa, $01, $97, $08, $00, $08, $91, $08, $01, $97, $08, $01
	byte	$08, $91, $08, $01, $97, $08, $02, $08, $91, $08, $01, $97, $08, $03, $08, $91
	byte	$08, $01, $97, $08, $04, $08, $91, $08, $01, $97, $08, $05, $08, $91, $08, $01
	byte	$97, $08, $06, $08, $91, $08, $01, $97, $08, $07, $08, $91, $08, $00, $aa, $04
	byte	$97, $00, $08, $08, $91, $08, $04, $97, $01, $08, $08, $91, $08, $04, $97, $02
	byte	$08, $08, $91, $08, $04, $97, $03, $08, $08, $91, $08, $04, $97, $04, $08, $08
	byte	$91, $08, $04, $97, $05, $08, $08, $91, $08, $04, $97, $06, $08, $08, $91, $08
	byte	$04, $97, $07, $08, $08, $91, $08, $00, $aa, $00, $8a, $00, $02, $97, $02, $04
	byte	$00, $f0, $00, $02, $98, $de, $01, $00, $f0, $00, $9a, $00, $02, $88, $79, $04
	byte	$00, $f0, $44, $69, $76, $69, $64, $65, $20, $62, $79, $20, $7a, $65, $72, $6f
	byte	$0a, $00, $00, $8a, $00, $02, $97, $2b, $04, $00, $f0, $00, $02, $98, $de, $01
	byte	$00, $f0, $00, $9a, $00, $02, $88, $79, $04, $00, $f0, $49, $6e, $76, $61, $6c
	byte	$69, $64, $20, $6f, $70, $63, $6f, $64, $65, $0a, $00, $00, $8a, $00, $02, $97
	byte	$57, $04, $00, $f0, $00, $02, $98, $de, $01, $00, $f0, $00, $9a, $00, $00, $9a
	byte	$01, $02, $88, $79, $04, $00, $f0, $50, $61, $67, $65, $20, $66, $61, $75, $6c
	byte	$74, $20, $61, $74, $20, $76, $69, $72, $74, $75, $61, $6c, $20, $61, $64, $64
	byte	$72, $65, $73, $73, $20, $72, $31, $0a, $00, $08, $91, $20, $00, $8a, $22, $00
	byte	$8a, $21, $00, $8a, $20, $00, $8a, $1f, $00, $8a, $1e, $00, $8a, $1d, $00, $8a
	byte	$1c, $00, $8a, $1b, $00, $8a, $1a, $00, $8a, $19, $00, $8a, $18, $00, $8a, $17
	byte	$00, $8a, $16, $00, $8a, $15, $00, $8a, $14, $00, $8a, $13, $00, $8a, $12, $00
	byte	$8a, $11, $00, $8a, $10, $00, $8a, $0f, $00, $8a, $0e, $00, $8a, $0d, $00, $8a
	byte	$0c, $00, $8a, $0b, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $07
	byte	$00, $8a, $06, $00, $8a, $05, $00, $8a, $04, $00, $8a, $03, $00, $8a, $02, $00
	byte	$8a, $01, $00, $8a, $00, $86, $81, $0d, $00, $00, $00, $20, $80, $02, $97, $62
	byte	$05, $00, $f0, $00, $02, $98, $de, $01, $00, $f0, $00, $9a, $00, $00, $9a, $01
	byte	$00, $9a, $02, $00, $9a, $03, $00, $9a, $04, $00, $9a, $05, $00, $9a, $06, $00
	byte	$9a, $07, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $0b, $00, $9a
	byte	$0c, $00, $9a, $0d, $00, $9a, $0e, $00, $9a, $0f, $00, $9a, $10, $00, $9a, $11
	byte	$00, $9a, $12, $00, $9a, $13, $00, $9a, $14, $00, $9a, $15, $00, $9a, $16, $00
	byte	$9a, $17, $00, $9a, $18, $00, $9a, $19, $00, $9a, $1a, $00, $9a, $1b, $00, $9a
	byte	$1c, $00, $9a, $1d, $00, $9a, $1e, $00, $9a, $1f, $0c, $91, $20, $00, $9a, $22
	byte	$00, $ba, $42, $72, $65, $61, $6b, $70, $6f, $69, $6e, $74, $20, $72, $65, $61
	byte	$63, $68, $65, $64, $21, $0a, $00, $00, $8a, $02, $00, $8a, $03, $02, $27, $00
	byte	$03, $01, $27, $00, $02, $00, $91, $00, $02, $87, $00, $00, $00, $00, $02, $12
	byte	$88, $12, $06, $00, $f0, $02, $87, $30, $00, $00, $00, $02, $32, $88, $bc, $05
	byte	$00, $f0, $02, $87, $39, $00, $00, $00, $02, $52, $88, $bc, $05, $00, $f0, $02
	byte	$a1, $30, $00, $00, $00, $02, $02, $88, $04, $06, $00, $f0, $02, $87, $41, $00
	byte	$00, $00, $02, $32, $88, $e3, $05, $00, $f0, $02, $87, $5a, $00, $00, $00, $02
	byte	$52, $88, $e3, $05, $00, $f0, $02, $a1, $37, $00, $00, $00, $02, $02, $88, $04
	byte	$06, $00, $f0, $02, $87, $61, $00, $00, $00, $02, $32, $88, $81, $05, $00, $f0
	byte	$02, $87, $7a, $00, $00, $00, $02, $52, $88, $81, $05, $00, $f0, $02, $a1, $57
	byte	$00, $00, $00, $02, $00, $82, $01, $03, $00, $81, $02, $03, $02, $88, $81, $05
	byte	$00, $f0, $00, $97, $03, $00, $00, $9a, $03, $00, $9a, $02, $00, $aa, $00, $8a
	byte	$00, $00, $8a, $01, $00, $8a, $1f, $00, $97, $02, $1f, $05, $17, $00, $01, $00
	byte	$91, $00, $00, $91, $01, $02, $a8, $2b, $06, $00, $f0, $00, $9a, $1f, $00, $9a
	byte	$01, $00, $9a, $00, $00, $aa, $00, $8a, $00, $00, $8a, $01, $00, $8a, $1f, $00
	byte	$97, $02, $1f, $05, $97, $00, $01, $08, $91, $00, $08, $91, $01, $02, $a8, $53
	byte	$06, $00, $f0, $00, $9a, $1f, $00, $9a, $01, $00, $9a, $00, $00, $aa, $00, $8a
	byte	$00, $00, $8a, $01, $00, $8a, $1f, $00, $97, $02, $1f, $05, $07, $00, $01, $22
	byte	$88, $9c, $06, $00, $f0, $00, $91, $00, $00, $91, $01, $02, $a8, $7b, $06, $00
	byte	$f0, $02, $27, $00, $00, $02, $87, $00, $00, $00, $00, $00, $00, $9a, $1f, $00
	byte	$9a, $01, $00, $9a, $00, $00, $aa, $00, $8a, $00, $00, $8a, $01, $00, $8a, $1f
	byte	$00, $97, $02, $1f, $05, $87, $00, $01, $22, $88, $d5, $06, $00, $f0, $08, $91
	byte	$00, $08, $91, $01, $02, $a8, $b4, $06, $00, $f0, $02, $27, $00, $00, $02, $87
	byte	$00[6]
	byte	$9a, $1f, $00, $9a, $01, $00, $9a, $00, $00, $aa, $00, $8a, $01, $03, $97, $8e
	byte	$21, $28, $02, $00, $00, $97, $00, $01, $02, $84, $0d, $01, $00, $a3, $01, $00
	byte	$00, $97, $00, $01, $02, $95, $11, $01, $00, $a3, $01, $00, $00, $97, $00, $01
	byte	$02, $84, $05, $01, $00, $a3, $01, $00, $0c, $97, $00, $8e, $21, $28, $02, $00
	byte	$9a, $01, $00, $aa, $02, $98, $e0, $06, $00, $f0, $00, $a1, $01, $02, $00, $b2
	byte	$02, $00, $00, $81, $01, $00, $00, $aa, $00, $8a, $00, $00, $8a, $01, $00, $8a
	byte	$02, $01, $17, $00, $02, $04, $17, $02, $01, $00, $91, $00, $00, $91, $01, $02
	byte	$07, $00, $02, $22, $88, $37, $07, $00, $f0, $00, $9a, $02, $00, $9a, $01, $00
	byte	$9a, $00, $00, $aa, $00, $8a, $00, $00, $8a, $01, $05, $07, $01, $00, $22, $88
	byte	$80, $07, $00, $f0, $06, $07, $00, $00, $12, $88, $88, $07, $00, $f0, $00, $91
	byte	$00, $00, $91, $01, $02, $88, $60, $07, $00, $f0, $00, $9a, $01, $00, $9a, $00
	byte	$00, $aa, $02, $27, $00, $00, $02, $87, $00, $00, $00, $00, $00, $00, $9a, $01
	byte	$00, $9a, $00, $00, $aa, $00, $8a, $01, $02, $27, $00, $01, $06, $07, $00, $00
	byte	$12, $88, $b8, $07, $00, $f0, $00, $91, $00, $00, $91, $01, $02, $88, $a2, $07
	byte	$00, $f0, $00, $97, $01, $00, $00, $9a, $01, $00, $aa, $02, $93, $00, $10, $00
	byte	$80, $00, $00, $8b, $00, $00, $02, $87, $00, $00, $00, $00, $00, $12, $88, $df
	byte	$07, $00, $f0, $02, $27, $01, $00, $00, $aa, $02, $27, $00, $00, $00, $aa, $02
	byte	$98, $6e, $06, $00, $f0, $12, $27, $01, $00, $22, $27, $00, $00, $00, $aa, $00
	byte	$a0, $00, $aa, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $0c, $b1, $20, $00
	byte	$8a, $02, $00, $8a, $01, $00, $8a, $00, $00, $97, $20, $22, $08, $b1, $22, $81
	byte	$97, $22, $08, $00, $02, $98, $c1, $07, $00, $f0, $00, $97, $00, $08, $02, $87
	byte	$00, $00, $00, $00, $08, $12, $27, $01, $08, $22, $27, $00, $08, $02, $87, $00
	byte	$00, $00, $00, $08, $22, $88, $46, $08, $00, $f0, $02, $88, $56, $08, $00, $f0
	byte	$02, $27, $00, $00, $02, $88, $60, $09, $00, $f0, $02, $88, $56, $08, $00, $f0
	byte	$81, $97, $22, $08, $08, $81, $97, $22, $0c, $09, $02, $81, $00, $00, $00, $00
	byte	$09, $04, $17, $08, $09, $02, $27, $00, $08, $81, $97, $22, $0c, $09, $02, $81
	byte	$03, $00, $00, $00, $09, $04, $97, $08, $09, $02, $27, $00, $08, $81, $97, $22
	byte	$0c, $09, $02, $81, $07, $00, $00, $00, $09, $04, $17, $08, $09, $02, $27, $01
	byte	$00, $81, $97, $22, $08, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01
	byte	$02, $00, $f0, $02, $97, $00, $06, $00, $00, $08, $02, $81, $14, $00, $00, $00
	byte	$08, $84, $97, $08, $22, $14, $02, $27, $1f, $08, $84, $97, $08, $22, $10, $81
	byte	$97, $22, $10, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $56, $09, $00
	byte	$f0, $81, $97, $22, $04, $00, $81, $97, $22, $14, $01, $02, $27, $0b, $02, $02
	byte	$98, $e5, $07, $00, $f0, $00, $97, $00, $08, $02, $87, $00, $00, $00, $00, $08
	byte	$22, $88, $02, $09, $00, $f0, $02, $88, $32, $09, $00, $f0, $81, $97, $22, $14
	byte	$09, $08, $b1, $09, $01, $67, $09, $08, $81, $97, $22, $0c, $09, $00, $91, $09
	byte	$04, $57, $08, $09, $81, $97, $22, $0c, $00, $00, $91, $00, $01, $67, $00, $00
	byte	$02, $88, $60, $09, $00, $f0, $02, $88, $32, $09, $00, $f0, $81, $97, $22, $14
	byte	$08, $02, $81, $10, $00, $00, $00, $08, $84, $97, $08, $22, $14, $81, $97, $22
	byte	$10, $08, $00, $b1, $08, $84, $97, $08, $22, $10, $02, $88, $c5, $08, $00, $f0
	byte	$02, $27, $00, $00, $02, $88, $60, $09, $00, $f0, $08, $91, $20, $00, $9a, $01
	byte	$00, $9a, $02, $0c, $91, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00
	byte	$aa, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $02, $a1, $18
	byte	$00, $00, $00, $20, $00, $8a, $03, $00, $8a, $02, $00, $8a, $01, $00, $8a, $00
	byte	$00, $97, $20, $22, $08, $b1, $22, $81, $97, $22, $04, $00, $81, $97, $22, $08
	byte	$01, $81, $97, $22, $0c, $02, $02, $98, $f9, $07, $00, $f0, $00, $97, $00, $08
	byte	$84, $97, $08, $22, $28, $81, $97, $22, $28, $08, $02, $87, $00, $00, $00, $00
	byte	$08, $22, $27, $01, $08, $12, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08
	byte	$22, $88, $e2, $09, $00, $f0, $02, $88, $f3, $09, $00, $f0, $81, $97, $22, $0c
	byte	$00, $02, $98, $04, $0d, $00, $f0, $02, $88, $f3, $09, $00, $f0, $81, $97, $22
	byte	$08, $00, $02, $98, $0f, $23, $00, $f0, $00, $97, $00, $08, $84, $97, $08, $22
	byte	$14, $81, $97, $22, $08, $00, $02, $98, $86, $21, $00, $f0, $00, $97, $00, $08
	byte	$84, $97, $08, $22, $18, $81, $97, $22, $14, $08, $02, $87, $00, $00, $00, $00
	byte	$08, $12, $27, $01, $08, $22, $27, $00, $08, $81, $97, $22, $18, $09, $02, $87
	byte	$00, $00, $00, $00, $09, $12, $27, $01, $09, $22, $27, $00, $09, $00, $93, $09
	byte	$08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $5a, $0a, $00, $f0, $02, $88
	byte	$6a, $0a, $00, $f0, $02, $27, $00, $00, $02, $88, $e3, $0c, $00, $f0, $02, $88
	byte	$6a, $0a, $00, $f0, $02, $27, $01, $00, $81, $97, $22, $08, $01, $02, $97, $00
	byte	$06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00, $00
	byte	$09, $81, $97, $22, $14, $0a, $00, $81, $0a, $09, $81, $97, $22, $18, $08, $04
	byte	$57, $08, $09, $81, $97, $22, $10, $00, $02, $67, $fa, $01, $01, $02, $98, $ba
	byte	$20, $00, $f0, $00, $97, $00, $08, $02, $a2, $fa, $01, $00, $00, $08, $84, $97
	byte	$08, $22, $1c, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $14, $0a, $00
	byte	$81, $0a, $09, $04, $91, $09, $81, $97, $22, $1c, $08, $04, $57, $08, $09, $81
	byte	$97, $22, $04, $00, $02, $97, $00, $06, $00, $00, $01, $81, $97, $22, $14, $08
	byte	$00, $81, $08, $01, $08, $91, $01, $02, $27, $0b, $02, $02, $98, $1e, $06, $00
	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $14, $0a, $00, $81, $0a
	byte	$09, $08, $91, $09, $02, $81, $0b, $00, $00, $00, $09, $02, $27, $00, $08, $04
	byte	$17, $08, $09, $02, $27, $01, $00, $81, $97, $22, $08, $01, $02, $97, $00, $06
	byte	$00, $00, $02, $02, $98, $29, $02, $00, $f0, $02, $27, $00, $08, $84, $97, $08
	byte	$22, $20, $81, $97, $22, $20, $08, $81, $97, $22, $1c, $09, $00, $87, $09, $08
	byte	$32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12
	byte	$88, $c4, $0c, $00, $f0, $81, $97, $22, $08, $00, $02, $98, $86, $21, $00, $f0
	byte	$00, $97, $00, $08, $84, $97, $08, $22, $24, $81, $97, $22, $24, $00, $02, $98
	byte	$b9, $24, $00, $f0, $81, $97, $22, $24, $00, $81, $97, $22, $08, $01, $02, $97
	byte	$00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00
	byte	$00, $09, $02, $27, $ff, $08, $04, $17, $08, $09, $02, $97, $00, $06, $00, $00
	byte	$09, $00, $91, $09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $20
	byte	$08, $81, $97, $22, $1c, $09, $00, $b1, $09, $00, $87, $09, $08, $22, $27, $01
	byte	$08, $12, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $de, $0b
	byte	$00, $f0, $02, $88, $13, $0c, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $04
	byte	$91, $09, $81, $97, $22, $08, $00, $02, $98, $86, $21, $00, $f0, $00, $97, $00
	byte	$08, $04, $57, $08, $09, $02, $97, $00, $06, $00, $00, $09, $08, $91, $09, $02
	byte	$27, $00, $08, $04, $57, $08, $09, $02, $88, $45, $0c, $00, $f0, $02, $97, $00
	byte	$06, $00, $00, $09, $04, $91, $09, $02, $27, $00, $08, $04, $57, $08, $09, $02
	byte	$97, $00, $06, $00, $00, $09, $08, $91, $09, $81, $97, $22, $10, $08, $02, $b5
	byte	$fa, $01, $00, $00, $08, $04, $57, $08, $09, $02, $88, $45, $0c, $00, $f0, $02
	byte	$27, $06, $08, $84, $97, $08, $22, $28, $81, $97, $22, $28, $08, $02, $87, $00
	byte	$02, $00, $00, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00
	byte	$00, $00, $08, $12, $88, $9a, $0c, $00, $f0, $02, $97, $00, $06, $00, $00, $09
	byte	$81, $97, $22, $28, $0a, $00, $81, $0a, $09, $02, $27, $00, $08, $04, $17, $08
	byte	$09, $81, $97, $22, $28, $08, $00, $91, $08, $84, $97, $08, $22, $28, $02, $88
	byte	$4e, $0c, $00, $f0, $81, $97, $22, $24, $00, $81, $97, $22, $08, $01, $02, $97
	byte	$00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $81, $97, $22, $20, $08
	byte	$00, $91, $08, $84, $97, $08, $22, $20, $02, $88, $38, $0b, $00, $f0, $81, $97
	byte	$22, $04, $00, $81, $97, $22, $08, $01, $81, $97, $22, $0c, $02, $02, $98, $f9
	byte	$07, $00, $f0, $00, $97, $00, $00, $02, $88, $e3, $0c, $00, $f0, $08, $91, $20
	byte	$00, $9a, $01, $00, $9a, $02, $00, $9a, $03, $02, $81, $18, $00, $00, $00, $20
	byte	$00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $aa, $00, $8a
	byte	$02, $00, $8a, $01, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22
	byte	$02, $a1, $14, $00, $00, $00, $20, $00, $8a, $00, $00, $97, $20, $22, $08, $b1
	byte	$22, $02, $27, $01, $00, $81, $97, $22, $04, $01, $02, $81, $00, $00, $00, $00
	byte	$01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02
	byte	$00, $f0, $02, $27, $01, $08, $84, $97, $08, $22, $08, $81, $97, $22, $08, $08
	byte	$02, $87, $20, $00, $00, $00, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02
	byte	$87, $00, $00, $00, $00, $08, $12, $88, $1a, $0e, $00, $f0, $02, $97, $00, $06
	byte	$00, $00, $09, $81, $97, $22, $08, $0a, $02, $94, $10, $00, $00, $00, $0a, $00
	byte	$81, $0a, $09, $01, $67, $09, $08, $81, $97, $22, $04, $09, $00, $91, $09, $01
	byte	$67, $09, $09, $00, $87, $09, $08, $12, $27, $01, $08, $22, $27, $00, $08, $02
	byte	$87, $00, $00, $00, $00, $08, $22, $88, $b8, $0d, $00, $f0, $02, $88, $07, $0e
	byte	$00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $08, $0a, $02, $94
	byte	$10, $00, $00, $00, $0a, $00, $81, $0a, $09, $01, $67, $09, $08, $84, $57, $08
	byte	$22, $10, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $08, $0a, $02, $94
	byte	$10, $00, $00, $00, $0a, $00, $81, $0a, $09, $04, $91, $09, $01, $67, $09, $08
	byte	$84, $57, $08, $22, $18, $02, $88, $1a, $0e, $00, $f0, $02, $88, $07, $0e, $00
	byte	$f0, $81, $97, $22, $08, $08, $00, $91, $08, $84, $97, $08, $22, $08, $02, $88
	byte	$51, $0d, $00, $f0, $81, $97, $22, $08, $08, $02, $87, $20, $00, $00, $00, $08
	byte	$12, $27, $01, $08, $22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22
	byte	$88, $41, $0e, $00, $f0, $02, $88, $4d, $0e, $00, $f0, $02, $88, $d3, $0f, $00
	byte	$f0, $02, $88, $4d, $0e, $00, $f0, $02, $27, $00, $08, $84, $97, $08, $22, $0c
	byte	$81, $97, $22, $0c, $08, $02, $87, $10, $00, $00, $00, $08, $32, $27, $01, $08
	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $b2, $0e, $00
	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $08, $0a, $02, $94, $10
	byte	$00, $00, $00, $0a, $00, $81, $0a, $09, $81, $97, $22, $0c, $0a, $00, $81, $0a
	byte	$09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $08, $00, $91
	byte	$08, $84, $97, $08, $22, $0c, $02, $88, $56, $0e, $00, $f0, $02, $27, $01, $00
	byte	$81, $97, $22, $04, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01
	byte	$02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $02, $27, $00
	byte	$08, $84, $97, $08, $22, $08, $81, $97, $22, $08, $08, $81, $67, $22, $18, $09
	byte	$00, $87, $09, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00
	byte	$00, $00, $08, $12, $88, $d3, $0f, $00, $f0, $81, $67, $22, $10, $00, $81, $97
	byte	$22, $04, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97
	byte	$00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00
	byte	$00, $09, $04, $91, $09, $01, $67, $09, $08, $84, $57, $08, $22, $14, $81, $67
	byte	$22, $10, $00, $02, $98, $d2, $25, $00, $f0, $02, $27, $00, $08, $84, $97, $08
	byte	$22, $0c, $81, $97, $22, $0c, $08, $02, $87, $00, $02, $00, $00, $08, $32, $27
	byte	$01, $08, $42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $94
	byte	$0f, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $0c, $0a, $00
	byte	$81, $0a, $09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $08
	byte	$00, $91, $08, $84, $97, $08, $22, $0c, $02, $88, $48, $0f, $00, $f0, $81, $67
	byte	$22, $10, $00, $81, $97, $22, $04, $01, $02, $81, $00, $00, $00, $00, $01, $01
	byte	$27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0
	byte	$81, $67, $22, $14, $08, $84, $57, $08, $22, $10, $81, $97, $22, $08, $08, $00
	byte	$91, $08, $84, $97, $08, $22, $08, $02, $88, $dc, $0e, $00, $f0, $02, $81, $18
	byte	$00, $00, $00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a
	byte	$00, $9a, $01, $00, $9a, $02, $00, $aa, $00, $8a, $02, $00, $8a, $0a, $00, $8a
	byte	$09, $00, $8a, $08, $00, $8a, $22, $0c, $b1, $20, $00, $8a, $01, $00, $8a, $00
	byte	$00, $97, $20, $22, $08, $b1, $22, $02, $27, $00, $08, $84, $97, $08, $22, $0c
	byte	$81, $97, $22, $0c, $08, $02, $87, $00, $02, $00, $00, $08, $32, $27, $01, $08
	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $62, $10, $00
	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $0c, $0a, $00, $81, $0a
	byte	$09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $08, $00, $91
	byte	$08, $84, $97, $08, $22, $0c, $02, $88, $16, $10, $00, $f0, $81, $97, $22, $08
	byte	$00, $02, $67, $00, $10, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00, $08
	byte	$02, $95, $0c, $08, $84, $17, $08, $22, $10, $02, $97, $00, $06, $00, $00, $09
	byte	$81, $27, $22, $10, $08, $04, $17, $08, $09, $02, $97, $00, $06, $00, $00, $09
	byte	$00, $91, $09, $02, $27, $01, $08, $04, $17, $08, $09, $02, $97, $00, $06, $00
	byte	$00, $09, $04, $91, $09, $02, $27, $52, $08, $04, $17, $08, $09, $02, $97, $00
	byte	$06, $00, $00, $09, $02, $81, $03, $00, $00, $00, $09, $02, $27, $59, $08, $04
	byte	$17, $08, $09, $02, $97, $00, $06, $00, $00, $09, $08, $91, $09, $81, $97, $22
	byte	$08, $08, $04, $57, $08, $09, $02, $97, $ee, $26, $00, $f0, $00, $02, $97, $00
	byte	$06, $00, $00, $01, $02, $81, $06, $00, $00, $00, $01, $02, $98, $2e, $07, $00
	byte	$f0, $02, $27, $01, $00, $81, $97, $22, $04, $01, $02, $97, $00, $06, $00, $00
	byte	$02, $02, $98, $29, $02, $00, $f0, $02, $27, $00, $08, $84, $97, $08, $22, $0c
	byte	$81, $97, $22, $0c, $08, $02, $87, $00, $02, $00, $00, $08, $32, $27, $01, $08
	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $62, $11, $00
	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $0c, $0a, $00, $81, $0a
	byte	$09, $02, $27, $00, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $08, $00, $91
	byte	$08, $84, $97, $08, $22, $0c, $02, $88, $16, $11, $00, $f0, $02, $27, $00, $08
	byte	$84, $97, $08, $22, $0c, $81, $97, $22, $0c, $08, $81, $27, $22, $10, $09, $00
	byte	$87, $09, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00, $00
	byte	$00, $08, $12, $88, $bb, $11, $00, $f0, $81, $97, $22, $0c, $00, $04, $91, $00
	byte	$81, $97, $22, $04, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02
	byte	$00, $f0, $81, $97, $22, $0c, $08, $00, $91, $08, $84, $97, $08, $22, $0c, $02
	byte	$88, $6b, $11, $00, $f0, $02, $27, $00, $00, $81, $97, $22, $04, $01, $02, $98
	byte	$b9, $24, $00, $f0, $02, $27, $01, $00, $81, $97, $22, $04, $01, $02, $98, $b9
	byte	$24, $00, $f0, $02, $27, $00, $08, $84, $97, $08, $22, $0c, $81, $97, $22, $0c
	byte	$08, $81, $27, $22, $10, $09, $00, $87, $09, $08, $32, $27, $01, $08, $42, $27
	byte	$00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $2b, $12, $00, $f0, $81
	byte	$97, $22, $0c, $00, $04, $91, $00, $81, $97, $22, $04, $01, $02, $98, $b9, $24
	byte	$00, $f0, $81, $97, $22, $0c, $08, $00, $91, $08, $84, $97, $08, $22, $0c, $02
	byte	$88, $e2, $11, $00, $f0, $08, $91, $20, $00, $9a, $01, $0c, $91, $20, $00, $9a
	byte	$22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $02, $00, $aa, $00
	byte	$8a, $09, $00, $8a, $08, $00, $8a, $22, $00, $8a, $01, $00, $8a, $00, $00, $97
	byte	$20, $22, $08, $b1, $22, $81, $97, $22, $04, $08, $81, $97, $22, $08, $09, $02
	byte	$81, $03, $00, $00, $00, $09, $04, $97, $08, $09, $08, $91, $20, $00, $9a, $01
	byte	$00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $aa, $00, $8a, $22, $00, $8a
	byte	$00, $00, $97, $20, $22, $08, $b1, $22, $81, $97, $22, $04, $00, $02, $81, $03
	byte	$00, $00, $00, $00, $01, $97, $00, $00, $02, $88, $a4, $12, $00, $f0, $08, $91
	byte	$20, $00, $9a, $22, $00, $aa, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $02
	byte	$a1, $1c, $00, $00, $00, $20, $00, $8a, $02, $00, $8a, $01, $00, $8a, $00, $00
	byte	$97, $20, $22, $08, $b1, $22, $81, $97, $22, $04, $08, $84, $97, $08, $22, $10
	byte	$81, $97, $22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08, $08
	byte	$02, $b5, $fa, $01, $00, $00, $08, $81, $97, $22, $04, $09, $00, $81, $09, $08
	byte	$02, $81, $f9, $01, $00, $00, $08, $02, $a2, $fa, $01, $00, $00, $08, $84, $97
	byte	$08, $22, $14, $81, $97, $22, $08, $00, $02, $81, $03, $00, $00, $00, $00, $01
	byte	$97, $00, $00, $02, $67, $fa, $01, $01, $02, $98, $ba, $20, $00, $f0, $00, $97
	byte	$00, $08, $02, $b4, $fa, $01, $00, $00, $08, $84, $97, $08, $22, $18, $81, $97
	byte	$22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08, $08, $02, $87
	byte	$00, $00, $00, $00, $08, $52, $27, $01, $08, $62, $27, $00, $08, $81, $97, $22
	byte	$08, $09, $02, $81, $03, $00, $00, $00, $09, $01, $97, $09, $09, $02, $b5, $fa
	byte	$01, $00, $00, $09, $02, $87, $00, $00, $00, $00, $09, $12, $27, $01, $09, $22
	byte	$27, $00, $09, $00, $83, $09, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88
	byte	$90, $13, $00, $f0, $02, $88, $a3, $13, $00, $f0, $81, $97, $22, $18, $08, $00
	byte	$91, $08, $84, $97, $08, $22, $18, $02, $88, $a3, $13, $00, $f0, $81, $97, $22
	byte	$08, $08, $00, $91, $08, $01, $67, $08, $08, $84, $57, $08, $22, $20, $81, $97
	byte	$22, $18, $08, $02, $87, $00, $00, $00, $00, $08, $12, $27, $01, $08, $22, $27
	byte	$00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $db, $13, $00, $f0, $02
	byte	$88, $eb, $13, $00, $f0, $81, $67, $22, $20, $08, $84, $57, $08, $22, $1c, $02
	byte	$88, $55, $14, $00, $f0, $81, $97, $22, $18, $08, $02, $87, $00, $00, $00, $00
	byte	$08, $12, $88, $4f, $14, $00, $f0, $81, $67, $22, $20, $00, $81, $97, $22, $08
	byte	$01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06
	byte	$00, $00, $02, $02, $98, $01, $02, $00, $f0, $81, $67, $22, $20, $08, $84, $57
	byte	$08, $22, $1c, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $01, $67, $09
	byte	$08, $84, $57, $08, $22, $20, $81, $97, $22, $18, $08, $00, $b1, $08, $84, $97
	byte	$08, $22, $18, $02, $88, $eb, $13, $00, $f0, $02, $88, $55, $14, $00, $f0, $81
	byte	$67, $22, $1c, $08, $84, $57, $08, $22, $20, $81, $97, $22, $08, $08, $02, $81
	byte	$03, $00, $00, $00, $08, $01, $97, $08, $08, $02, $b5, $fa, $01, $00, $00, $08
	byte	$84, $97, $08, $22, $28, $81, $97, $22, $14, $08, $02, $87, $00, $00, $00, $00
	byte	$08, $12, $88, $77, $15, $00, $f0, $81, $67, $22, $20, $00, $81, $97, $22, $08
	byte	$01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06
	byte	$00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $67, $fa, $01, $08, $81, $97
	byte	$22, $28, $09, $00, $a1, $09, $08, $84, $97, $08, $22, $24, $81, $97, $22, $24
	byte	$08, $81, $97, $22, $04, $09, $00, $87, $09, $08, $42, $27, $01, $08, $32, $27
	byte	$00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $eb, $14, $00, $f0, $02
	byte	$88, $fb, $14, $00, $f0, $81, $97, $22, $04, $08, $84, $97, $08, $22, $24, $02
	byte	$88, $fb, $14, $00, $f0, $02, $97, $00, $06, $00, $00, $00, $02, $81, $06, $00
	byte	$00, $00, $00, $81, $97, $22, $28, $08, $00, $81, $08, $00, $81, $97, $22, $0c
	byte	$01, $81, $97, $22, $24, $02, $02, $98, $1e, $06, $00, $f0, $02, $97, $00, $06
	byte	$00, $00, $09, $04, $91, $09, $01, $67, $09, $08, $84, $57, $08, $22, $20, $81
	byte	$97, $22, $0c, $08, $81, $97, $22, $24, $09, $00, $81, $09, $08, $84, $97, $08
	byte	$22, $0c, $81, $97, $22, $04, $08, $81, $97, $22, $24, $09, $00, $a1, $09, $08
	byte	$84, $97, $08, $22, $04, $81, $97, $22, $14, $08, $00, $b1, $08, $84, $97, $08
	byte	$22, $14, $02, $27, $00, $08, $84, $97, $08, $22, $28, $02, $88, $7b, $14, $00
	byte	$f0, $81, $97, $22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08
	byte	$08, $81, $97, $22, $10, $09, $00, $81, $09, $08, $81, $97, $22, $08, $09, $02
	byte	$81, $03, $00, $00, $00, $09, $04, $97, $08, $09, $08, $91, $20, $00, $9a, $01
	byte	$00, $9a, $02, $02, $81, $1c, $00, $00, $00, $20, $00, $9a, $22, $00, $9a, $08
	byte	$00, $9a, $09, $00, $aa, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $02, $a1
	byte	$1c, $00, $00, $00, $20, $00, $8a, $02, $00, $8a, $01, $00, $8a, $00, $00, $97
	byte	$20, $22, $08, $b1, $22, $81, $97, $22, $08, $08, $02, $81, $03, $00, $00, $00
	byte	$08, $01, $97, $08, $08, $02, $b5, $fa, $01, $00, $00, $08, $81, $97, $22, $04
	byte	$09, $00, $81, $09, $08, $02, $81, $f9, $01, $00, $00, $08, $02, $a2, $fa, $01
	byte	$00, $00, $08, $84, $97, $08, $22, $10, $81, $97, $22, $08, $00, $02, $81, $03
	byte	$00, $00, $00, $00, $01, $97, $00, $00, $02, $67, $fa, $01, $01, $02, $98, $ba
	byte	$20, $00, $f0, $00, $97, $00, $08, $02, $b4, $fa, $01, $00, $00, $08, $84, $97
	byte	$08, $22, $14, $81, $97, $22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01
	byte	$97, $08, $08, $02, $87, $00, $00, $00, $00, $08, $52, $27, $01, $08, $62, $27
	byte	$00, $08, $81, $97, $22, $08, $09, $02, $81, $03, $00, $00, $00, $09, $01, $97
	byte	$09, $09, $02, $b5, $fa, $01, $00, $00, $09, $02, $87, $00, $00, $00, $00, $09
	byte	$12, $27, $01, $09, $22, $27, $00, $09, $00, $83, $09, $08, $02, $87, $00, $00
	byte	$00, $00, $08, $22, $88, $95, $16, $00, $f0, $02, $88, $a8, $16, $00, $f0, $81
	byte	$97, $22, $14, $08, $00, $91, $08, $84, $97, $08, $22, $14, $02, $88, $a8, $16
	byte	$00, $f0, $81, $97, $22, $08, $08, $00, $91, $08, $01, $67, $08, $08, $84, $57
	byte	$08, $22, $1c, $81, $97, $22, $14, $08, $02, $87, $00, $00, $00, $00, $08, $12
	byte	$27, $01, $08, $22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88
	byte	$e0, $16, $00, $f0, $02, $88, $f0, $16, $00, $f0, $81, $67, $22, $1c, $08, $84
	byte	$57, $08, $22, $18, $02, $88, $5a, $17, $00, $f0, $81, $97, $22, $14, $08, $02
	byte	$87, $00, $00, $00, $00, $08, $12, $88, $54, $17, $00, $f0, $81, $67, $22, $1c
	byte	$00, $81, $97, $22, $08, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01
	byte	$01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $81, $67
	byte	$22, $1c, $08, $84, $57, $08, $22, $18, $02, $97, $00, $06, $00, $00, $09, $04
	byte	$91, $09, $01, $67, $09, $08, $84, $57, $08, $22, $1c, $81, $97, $22, $14, $08
	byte	$00, $b1, $08, $84, $97, $08, $22, $14, $02, $88, $f0, $16, $00, $f0, $02, $88
	byte	$5a, $17, $00, $f0, $81, $67, $22, $18, $08, $84, $57, $08, $22, $1c, $81, $97
	byte	$22, $08, $08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08, $08, $02, $b5
	byte	$fa, $01, $00, $00, $08, $84, $97, $08, $22, $28, $81, $97, $22, $10, $08, $02
	byte	$87, $00, $00, $00, $00, $08, $12, $88, $54, $19, $00, $f0, $02, $67, $fa, $01
	byte	$08, $81, $97, $22, $28, $09, $00, $a1, $09, $08, $84, $97, $08, $22, $20, $81
	byte	$97, $22, $20, $08, $81, $97, $22, $04, $09, $00, $87, $09, $08, $42, $27, $01
	byte	$08, $32, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $ce, $17
	byte	$00, $f0, $02, $88, $de, $17, $00, $f0, $81, $97, $22, $04, $08, $84, $97, $08
	byte	$22, $20, $02, $88, $de, $17, $00, $f0, $81, $97, $22, $08, $00, $02, $98, $af
	byte	$19, $00, $f0, $00, $97, $00, $08, $84, $97, $08, $22, $24, $81, $97, $22, $08
	byte	$08, $02, $81, $03, $00, $00, $00, $08, $01, $97, $08, $08, $81, $97, $22, $20
	byte	$09, $00, $81, $09, $08, $81, $97, $22, $24, $09, $00, $87, $09, $08, $52, $27
	byte	$01, $08, $62, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $2f
	byte	$18, $00, $f0, $02, $88, $6b, $18, $00, $f0, $81, $97, $22, $08, $00, $02, $81
	byte	$03, $00, $00, $00, $00, $01, $97, $00, $00, $81, $97, $22, $24, $09, $00, $a1
	byte	$09, $00, $81, $97, $22, $20, $09, $00, $81, $09, $00, $81, $97, $22, $08, $01
	byte	$02, $98, $e9, $1b, $00, $f0, $00, $97, $00, $08, $84, $57, $08, $22, $1c, $02
	byte	$88, $6b, $18, $00, $f0, $81, $67, $22, $1c, $00, $81, $97, $22, $08, $01, $02
	byte	$81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00
	byte	$02, $02, $98, $01, $02, $00, $f0, $81, $97, $22, $0c, $00, $02, $97, $00, $06
	byte	$00, $00, $01, $02, $81, $06, $00, $00, $00, $01, $81, $97, $22, $28, $08, $00
	byte	$81, $08, $01, $81, $97, $22, $20, $02, $02, $98, $1e, $06, $00, $f0, $81, $67
	byte	$22, $1c, $00, $81, $97, $22, $08, $01, $02, $81, $00, $00, $00, $00, $01, $01
	byte	$27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0
	byte	$02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $01, $67, $09, $08, $84, $57
	byte	$08, $22, $1c, $81, $97, $22, $0c, $08, $81, $97, $22, $20, $09, $00, $81, $09
	byte	$08, $84, $97, $08, $22, $0c, $81, $97, $22, $04, $08, $81, $97, $22, $20, $09
	byte	$00, $a1, $09, $08, $84, $97, $08, $22, $04, $81, $97, $22, $10, $08, $00, $b1
	byte	$08, $84, $97, $08, $22, $10, $81, $97, $22, $08, $08, $02, $81, $03, $00, $00
	byte	$00, $08, $01, $97, $08, $08, $81, $97, $22, $20, $09, $00, $81, $09, $08, $81
	byte	$97, $22, $08, $09, $02, $81, $03, $00, $00, $00, $09, $04, $97, $08, $09, $02
	byte	$27, $00, $08, $84, $97, $08, $22, $28, $02, $88, $80, $17, $00, $f0, $08, $91
	byte	$20, $00, $9a, $01, $00, $9a, $02, $02, $81, $1c, $00, $00, $00, $20, $00, $9a
	byte	$22, $00, $9a, $08, $00, $9a, $09, $00, $aa, $00, $8a, $02, $00, $8a, $22, $00
	byte	$8a, $01, $00, $8a, $00, $00, $97, $20, $22, $08, $b1, $22, $81, $97, $22, $04
	byte	$00, $02, $98, $af, $19, $00, $f0, $00, $97, $00, $00, $81, $97, $22, $04, $01
	byte	$81, $97, $22, $08, $02, $02, $98, $ac, $12, $00, $f0, $08, $91, $20, $00, $9a
	byte	$01, $00, $9a, $22, $00, $9a, $02, $00, $aa, $00, $8a, $02, $00, $8a, $01, $00
	byte	$8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $0c, $b1, $20, $00, $8a
	byte	$00, $00, $97, $20, $22, $08, $b1, $22, $02, $27, $00, $08, $84, $97, $08, $22
	byte	$08, $81, $97, $22, $04, $08, $00, $91, $08, $01, $67, $08, $08, $84, $57, $08
	byte	$22, $0c, $02, $27, $01, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $90
	byte	$1a, $00, $f0, $81, $67, $22, $0c, $00, $81, $97, $22, $04, $01, $02, $81, $00
	byte	$00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02
	byte	$98, $01, $02, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $01
	byte	$67, $09, $08, $84, $57, $08, $22, $0c, $81, $67, $22, $0c, $08, $02, $87, $00
	byte	$00, $00, $00, $08, $22, $88, $46, $1a, $00, $f0, $02, $88, $5d, $1a, $00, $f0
	byte	$81, $97, $22, $08, $08, $02, $81, $fa, $01, $00, $00, $08, $84, $97, $08, $22
	byte	$08, $02, $88, $8a, $1a, $00, $f0, $81, $97, $22, $08, $08, $02, $97, $00, $06
	byte	$00, $00, $0a, $08, $91, $0a, $01, $67, $0a, $09, $00, $81, $09, $08, $84, $97
	byte	$08, $22, $08, $81, $97, $22, $08, $00, $02, $88, $90, $1a, $00, $f0, $02, $88
	byte	$8a, $1a, $00, $f0, $02, $88, $e8, $19, $00, $f0, $02, $81, $0c, $00, $00, $00
	byte	$20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $01
	byte	$00, $9a, $02, $00, $aa, $00, $8a, $02, $00, $8a, $0a, $00, $8a, $09, $00, $8a
	byte	$08, $00, $8a, $22, $02, $a1, $10, $00, $00, $00, $20, $00, $8a, $01, $00, $8a
	byte	$00, $00, $97, $20, $22, $08, $b1, $22, $02, $27, $01, $00, $81, $97, $22, $08
	byte	$01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $27
	byte	$1f, $08, $84, $97, $08, $22, $0c, $02, $27, $00, $08, $84, $97, $08, $22, $10
	byte	$02, $27, $14, $08, $84, $97, $08, $22, $14, $02, $27, $00, $08, $84, $97, $08
	byte	$22, $18, $81, $97, $22, $0c, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88
	byte	$c0, $1b, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $14, $0a
	byte	$00, $81, $0a, $09, $01, $27, $09, $08, $02, $87, $00, $00, $00, $00, $08, $22
	byte	$27, $01, $08, $12, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88
	byte	$50, $1b, $00, $f0, $02, $88, $9c, $1b, $00, $f0, $02, $97, $00, $06, $00, $00
	byte	$00, $81, $97, $22, $14, $08, $00, $81, $08, $00, $81, $97, $22, $04, $01, $81
	byte	$97, $22, $10, $08, $00, $81, $08, $01, $02, $27, $0b, $02, $02, $98, $1e, $06
	byte	$00, $f0, $81, $97, $22, $18, $08, $00, $91, $08, $84, $97, $08, $22, $18, $81
	byte	$97, $22, $10, $08, $02, $81, $0b, $00, $00, $00, $08, $84, $97, $08, $22, $10
	byte	$02, $88, $9c, $1b, $00, $f0, $81, $97, $22, $14, $08, $02, $81, $10, $00, $00
	byte	$00, $08, $84, $97, $08, $22, $14, $81, $97, $22, $0c, $08, $00, $b1, $08, $84
	byte	$97, $08, $22, $0c, $02, $88, $08, $1b, $00, $f0, $81, $97, $22, $18, $00, $02
	byte	$88, $cb, $1b, $00, $f0, $08, $91, $20, $00, $9a, $01, $02, $81, $10, $00, $00
	byte	$00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a
	byte	$02, $00, $aa, $00, $8a, $02, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00
	byte	$8a, $22, $02, $a1, $24, $00, $00, $00, $20, $00, $8a, $01, $00, $8a, $00, $00
	byte	$97, $20, $22, $08, $b1, $22, $81, $97, $22, $08, $00, $02, $98, $af, $19, $00
	byte	$f0, $00, $97, $00, $08, $84, $97, $08, $22, $14, $81, $97, $22, $14, $08, $81
	byte	$97, $22, $04, $09, $00, $81, $09, $08, $84, $97, $08, $22, $18, $81, $97, $22
	byte	$14, $00, $02, $67, $fa, $01, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00
	byte	$08, $02, $a2, $fa, $01, $00, $00, $08, $84, $97, $08, $22, $0c, $81, $97, $22
	byte	$18, $00, $02, $67, $fa, $01, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00
	byte	$08, $02, $a2, $fa, $01, $00, $00, $08, $84, $97, $08, $22, $10, $81, $97, $22
	byte	$10, $08, $81, $97, $22, $0c, $09, $00, $87, $09, $08, $22, $27, $01, $08, $12
	byte	$27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $9c, $1c, $00, $f0
	byte	$02, $88, $b6, $1d, $00, $f0, $02, $27, $01, $00, $81, $97, $22, $08, $01, $02
	byte	$81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00
	byte	$02, $02, $98, $01, $02, $00, $f0, $02, $27, $01, $08, $84, $97, $08, $22, $28
	byte	$81, $97, $22, $28, $08, $02, $87, $20, $00, $00, $00, $08, $32, $27, $01, $08
	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $8f, $1d, $00
	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $28, $0a, $02, $94, $10
	byte	$00, $00, $00, $0a, $00, $81, $0a, $09, $01, $67, $09, $08, $81, $97, $22, $08
	byte	$09, $00, $91, $09, $01, $67, $09, $09, $00, $87, $09, $08, $12, $27, $01, $08
	byte	$22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $2d, $1d, $00
	byte	$f0, $02, $88, $7c, $1d, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97
	byte	$22, $28, $0a, $02, $94, $10, $00, $00, $00, $0a, $00, $81, $0a, $09, $04, $91
	byte	$09, $01, $67, $09, $08, $84, $97, $08, $22, $2c, $02, $97, $00, $06, $00, $00
	byte	$09, $81, $97, $22, $28, $0a, $02, $94, $10, $00, $00, $00, $0a, $00, $81, $0a
	byte	$09, $04, $91, $09, $81, $97, $22, $2c, $08, $00, $91, $08, $04, $57, $08, $09
	byte	$02, $88, $7c, $1d, $00, $f0, $81, $97, $22, $28, $08, $00, $91, $08, $84, $97
	byte	$08, $22, $28, $02, $88, $c6, $1c, $00, $f0, $02, $27, $01, $00, $81, $97, $22
	byte	$08, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00
	byte	$06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $02, $88, $b6, $1d, $00, $f0
	byte	$81, $97, $22, $0c, $08, $84, $97, $08, $22, $1c, $81, $97, $22, $08, $08, $02
	byte	$81, $03, $00, $00, $00, $08, $01, $97, $08, $08, $02, $87, $00, $00, $00, $00
	byte	$08, $52, $27, $01, $08, $62, $27, $00, $08, $81, $97, $22, $08, $09, $02, $81
	byte	$03, $00, $00, $00, $09, $01, $97, $09, $09, $02, $b5, $fa, $01, $00, $00, $09
	byte	$02, $87, $00, $00, $00, $00, $09, $12, $27, $01, $09, $22, $27, $00, $09, $00
	byte	$83, $09, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $1c, $1e, $00, $f0
	byte	$02, $88, $2f, $1e, $00, $f0, $81, $97, $22, $1c, $08, $00, $91, $08, $84, $97
	byte	$08, $22, $1c, $02, $88, $2f, $1e, $00, $f0, $81, $97, $22, $08, $08, $00, $91
	byte	$08, $01, $67, $08, $08, $84, $97, $08, $22, $20, $81, $97, $22, $20, $08, $84
	byte	$97, $08, $22, $24, $81, $97, $22, $1c, $08, $02, $87, $00, $00, $00, $00, $08
	byte	$12, $88, $ae, $1e, $00, $f0, $81, $97, $22, $20, $00, $81, $97, $22, $08, $01
	byte	$02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00
	byte	$00, $02, $02, $98, $01, $02, $00, $f0, $81, $97, $22, $20, $08, $84, $97, $08
	byte	$22, $24, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $01, $67, $09, $08
	byte	$84, $97, $08, $22, $20, $81, $97, $22, $1c, $08, $00, $b1, $08, $84, $97, $08
	byte	$22, $1c, $02, $88, $4a, $1e, $00, $f0, $81, $97, $22, $10, $08, $81, $97, $22
	byte	$0c, $09, $00, $87, $09, $08, $22, $27, $01, $08, $12, $27, $00, $08, $02, $87
	byte	$00, $00, $00, $00, $08, $22, $88, $d7, $1e, $00, $f0, $02, $88, $4f, $20, $00
	byte	$f0, $81, $97, $22, $08, $00, $02, $81, $00, $00, $00, $00, $00, $01, $27, $00
	byte	$00, $02, $98, $86, $21, $00, $f0, $00, $97, $00, $08, $84, $97, $08, $22, $2c
	byte	$81, $97, $22, $24, $00, $81, $97, $22, $08, $01, $02, $81, $00, $00, $00, $00
	byte	$01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02
	byte	$00, $f0, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $81, $97, $22, $2c
	byte	$08, $04, $57, $08, $09, $02, $97, $00, $06, $00, $00, $09, $08, $91, $09, $02
	byte	$27, $00, $08, $04, $57, $08, $09, $81, $97, $22, $24, $00, $81, $97, $22, $08
	byte	$01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06
	byte	$00, $00, $02, $02, $98, $29, $02, $00, $f0, $81, $97, $22, $2c, $00, $81, $97
	byte	$22, $08, $01, $02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $98
	byte	$b9, $24, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $02, $27, $ff, $08, $04
	byte	$17, $08, $09, $02, $97, $00, $06, $00, $00, $09, $00, $91, $09, $02, $27, $00
	byte	$08, $04, $17, $08, $09, $02, $97, $00, $06, $00, $00, $09, $04, $91, $09, $02
	byte	$27, $00, $08, $04, $57, $08, $09, $02, $97, $00, $06, $00, $00, $09, $08, $91
	byte	$09, $81, $97, $22, $18, $08, $02, $b5, $fa, $01, $00, $00, $08, $04, $57, $08
	byte	$09, $02, $27, $06, $08, $84, $97, $08, $22, $28, $81, $97, $22, $28, $08, $02
	byte	$87, $00, $02, $00, $00, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87
	byte	$00, $00, $00, $00, $08, $12, $88, $1c, $20, $00, $f0, $02, $97, $00, $06, $00
	byte	$00, $09, $81, $97, $22, $28, $0a, $00, $81, $0a, $09, $02, $27, $00, $08, $04
	byte	$17, $08, $09, $81, $97, $22, $28, $08, $00, $91, $08, $84, $97, $08, $22, $28
	byte	$02, $88, $d0, $1f, $00, $f0, $81, $97, $22, $2c, $00, $81, $97, $22, $08, $01
	byte	$02, $81, $00, $00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00
	byte	$00, $02, $02, $98, $29, $02, $00, $f0, $81, $97, $22, $2c, $00, $02, $88, $9c
	byte	$20, $00, $f0, $02, $88, $9c, $20, $00, $f0, $02, $97, $00, $06, $00, $00, $09
	byte	$08, $91, $09, $81, $97, $22, $18, $08, $02, $b5, $fa, $01, $00, $00, $08, $04
	byte	$57, $08, $09, $81, $97, $22, $24, $00, $81, $97, $22, $08, $01, $02, $81, $00
	byte	$00, $00, $00, $01, $01, $27, $01, $01, $02, $97, $00, $06, $00, $00, $02, $02
	byte	$98, $29, $02, $00, $f0, $81, $97, $22, $24, $00, $02, $88, $9c, $20, $00, $f0
	byte	$02, $88, $9c, $20, $00, $f0, $08, $91, $20, $00, $9a, $01, $02, $81, $24, $00
	byte	$00, $00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00
	byte	$9a, $02, $00, $aa, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $08, $b1, $20
	byte	$00, $8a, $01, $00, $8a, $00, $00, $97, $20, $22, $08, $b1, $22, $81, $97, $22
	byte	$04, $08, $02, $87, $00, $00, $00, $00, $08, $12, $27, $01, $08, $22, $27, $00
	byte	$08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $fa, $20, $00, $f0, $02, $88
	byte	$0a, $21, $00, $f0, $02, $27, $00, $00, $02, $88, $72, $21, $00, $f0, $02, $88
	byte	$0a, $21, $00, $f0, $81, $97, $22, $04, $08, $81, $97, $22, $08, $09, $00, $b5
	byte	$09, $08, $84, $97, $08, $22, $0c, $81, $97, $22, $0c, $08, $02, $87, $00, $00
	byte	$00, $00, $08, $12, $27, $01, $08, $22, $27, $00, $08, $02, $87, $00, $00, $00
	byte	$00, $08, $22, $88, $44, $21, $00, $f0, $02, $88, $55, $21, $00, $f0, $81, $97
	byte	$22, $04, $00, $02, $88, $72, $21, $00, $f0, $02, $88, $55, $21, $00, $f0, $81
	byte	$97, $22, $04, $00, $81, $97, $22, $08, $08, $00, $81, $08, $00, $81, $97, $22
	byte	$0c, $08, $00, $a1, $08, $00, $02, $88, $72, $21, $00, $f0, $08, $91, $20, $00
	byte	$9a, $01, $08, $91, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $aa
	byte	$00, $8a, $02, $00, $8a, $01, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00
	byte	$8a, $22, $02, $a1, $14, $00, $00, $00, $20, $00, $8a, $00, $00, $97, $20, $22
	byte	$08, $b1, $22, $02, $27, $01, $00, $81, $97, $22, $04, $01, $02, $97, $00, $06
	byte	$00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00, $00, $09
	byte	$01, $27, $09, $08, $84, $17, $08, $22, $10, $02, $27, $00, $08, $84, $97, $08
	byte	$22, $08, $81, $97, $22, $08, $08, $81, $27, $22, $10, $09, $00, $87, $09, $08
	byte	$32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12
	byte	$88, $ea, $22, $00, $f0, $02, $27, $00, $08, $84, $97, $08, $22, $0c, $81, $97
	byte	$22, $08, $00, $04, $91, $00, $81, $97, $22, $04, $01, $02, $97, $00, $06, $00
	byte	$00, $02, $02, $98, $01, $02, $00, $f0, $81, $97, $22, $0c, $08, $02, $87, $00
	byte	$02, $00, $00, $08, $32, $27, $01, $08, $42, $27, $00, $08, $02, $87, $00, $00
	byte	$00, $00, $08, $12, $88, $d7, $22, $00, $f0, $02, $97, $00, $06, $00, $00, $09
	byte	$81, $97, $22, $0c, $0a, $00, $81, $0a, $09, $01, $27, $09, $00, $02, $98, $07
	byte	$24, $00, $f0, $00, $97, $00, $08, $84, $17, $08, $22, $14, $81, $27, $22, $14
	byte	$08, $02, $87, $ff, $00, $00, $00, $08, $22, $27, $01, $08, $12, $27, $00, $08
	byte	$02, $87, $00, $00, $00, $00, $08, $22, $88, $89, $22, $00, $f0, $02, $88, $c4
	byte	$22, $00, $f0, $81, $97, $22, $08, $08, $02, $94, $00, $10, $00, $00, $08, $81
	byte	$97, $22, $0c, $09, $02, $94, $08, $00, $00, $00, $09, $00, $81, $09, $08, $81
	byte	$27, $22, $14, $09, $00, $81, $09, $08, $84, $97, $08, $22, $18, $81, $97, $22
	byte	$18, $00, $02, $88, $f4, $22, $00, $f0, $02, $88, $c4, $22, $00, $f0, $81, $97
	byte	$22, $0c, $08, $00, $91, $08, $84, $97, $08, $22, $0c, $02, $88, $1e, $22, $00
	byte	$f0, $81, $97, $22, $08, $08, $00, $91, $08, $84, $97, $08, $22, $08, $02, $88
	byte	$d8, $21, $00, $f0, $02, $27, $00, $00, $02, $88, $f4, $22, $00, $f0, $02, $81
	byte	$18, $00, $00, $00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09, $00, $9a
	byte	$0a, $00, $9a, $01, $00, $9a, $02, $00, $aa, $00, $8a, $02, $00, $8a, $01, $00
	byte	$8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $0c, $b1, $20, $00, $8a
	byte	$00, $00, $97, $20, $22, $08, $b1, $22, $02, $27, $01, $00, $81, $97, $22, $04
	byte	$01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $27
	byte	$00, $08, $84, $97, $08, $22, $08, $02, $27, $10, $08, $84, $97, $08, $22, $0c
	byte	$81, $97, $22, $08, $08, $02, $87, $1e, $00, $00, $00, $08, $32, $27, $01, $08
	byte	$42, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $12, $88, $e2, $23, $00
	byte	$f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $0c, $0a, $00, $81, $0a
	byte	$09, $01, $67, $09, $08, $02, $87, $00, $00, $00, $00, $08, $12, $27, $01, $08
	byte	$22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22, $88, $ad, $23, $00
	byte	$f0, $02, $88, $be, $23, $00, $f0, $81, $97, $22, $0c, $00, $02, $88, $ec, $23
	byte	$00, $f0, $02, $88, $be, $23, $00, $f0, $81, $97, $22, $0c, $08, $02, $81, $10
	byte	$00, $00, $00, $08, $84, $97, $08, $22, $0c, $81, $97, $22, $08, $08, $00, $91
	byte	$08, $84, $97, $08, $22, $08, $02, $88, $56, $23, $00, $f0, $02, $27, $00, $00
	byte	$02, $88, $ec, $23, $00, $f0, $02, $81, $0c, $00, $00, $00, $20, $00, $9a, $22
	byte	$00, $9a, $08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $01, $00, $9a, $02, $00
	byte	$aa, $00, $8a, $08, $00, $8a, $22, $08, $b1, $20, $00, $8a, $00, $00, $97, $20
	byte	$22, $08, $b1, $22, $81, $27, $22, $04, $08, $02, $87, $ff, $00, $00, $00, $08
	byte	$12, $27, $01, $08, $22, $27, $00, $08, $02, $87, $00, $00, $00, $00, $08, $22
	byte	$88, $41, $24, $00, $f0, $02, $88, $51, $24, $00, $f0, $02, $27, $ff, $00, $02
	byte	$88, $ae, $24, $00, $f0, $02, $88, $51, $24, $00, $f0, $02, $27, $00, $08, $84
	byte	$17, $08, $22, $08, $81, $27, $22, $04, $08, $02, $b5, $02, $00, $00, $00, $08
	byte	$02, $87, $01, $00, $00, $00, $08, $12, $27, $01, $08, $22, $27, $00, $08, $02
	byte	$87, $00, $00, $00, $00, $08, $12, $88, $a3, $24, $00, $f0, $81, $27, $22, $08
	byte	$08, $00, $91, $08, $84, $17, $08, $22, $08, $81, $27, $22, $04, $08, $02, $95
	byte	$01, $08, $84, $17, $08, $22, $04, $02, $88, $5a, $24, $00, $f0, $81, $27, $22
	byte	$08, $00, $02, $88, $ae, $24, $00, $f0, $0c, $91, $20, $00, $9a, $22, $00, $9a
	byte	$08, $00, $aa, $00, $8a, $02, $00, $8a, $0a, $00, $8a, $09, $00, $8a, $08, $00
	byte	$8a, $22, $02, $a1, $10, $00, $00, $00, $20, $00, $8a, $01, $00, $8a, $00, $00
	byte	$97, $20, $22, $08, $b1, $22, $81, $97, $22, $04, $00, $00, $91, $00, $02, $67
	byte	$00, $10, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00, $08, $02, $95, $0c
	byte	$08, $00, $91, $08, $84, $97, $08, $22, $0c, $81, $97, $22, $04, $00, $00, $91
	byte	$00, $02, $27, $08, $01, $02, $98, $ba, $20, $00, $f0, $00, $97, $00, $08, $02
	byte	$95, $03, $08, $00, $b1, $08, $02, $b5, $00, $02, $00, $00, $08, $84, $97, $08
	byte	$22, $10, $81, $97, $22, $04, $08, $02, $b5, $08, $00, $00, $00, $08, $84, $17
	byte	$08, $22, $14, $81, $97, $22, $0c, $00, $81, $97, $22, $08, $01, $02, $97, $00
	byte	$06, $00, $00, $02, $02, $98, $01, $02, $00, $f0, $02, $97, $00, $06, $00, $00
	byte	$09, $81, $97, $22, $10, $0a, $00, $81, $0a, $09, $01, $27, $09, $08, $84, $17
	byte	$08, $22, $18, $81, $27, $22, $18, $08, $02, $27, $01, $09, $81, $27, $22, $14
	byte	$0a, $00, $84, $0a, $09, $00, $93, $09, $08, $84, $17, $08, $22, $18, $02, $97
	byte	$00, $06, $00, $00, $09, $81, $97, $22, $10, $0a, $00, $81, $0a, $09, $81, $27
	byte	$22, $18, $08, $04, $17, $08, $09, $81, $97, $22, $0c, $00, $81, $97, $22, $08
	byte	$01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $08, $91
	byte	$20, $00, $9a, $01, $02, $81, $10, $00, $00, $00, $20, $00, $9a, $22, $00, $9a
	byte	$08, $00, $9a, $09, $00, $9a, $0a, $00, $9a, $02, $00, $aa, $00, $8a, $02, $00
	byte	$8a, $0a, $00, $8a, $09, $00, $8a, $08, $00, $8a, $22, $02, $a1, $10, $00, $00
	byte	$00, $20, $00, $8a, $01, $00, $8a, $00, $00, $97, $20, $22, $08, $b1, $22, $81
	byte	$97, $22, $04, $00, $00, $91, $00, $02, $67, $00, $10, $01, $02, $98, $ba, $20
	byte	$00, $f0, $00, $97, $00, $08, $02, $95, $0c, $08, $00, $91, $08, $84, $97, $08
	byte	$22, $0c, $81, $97, $22, $04, $00, $00, $91, $00, $02, $27, $08, $01, $02, $98
	byte	$ba, $20, $00, $f0, $00, $97, $00, $08, $02, $95, $03, $08, $00, $b1, $08, $02
	byte	$b5, $00, $02, $00, $00, $08, $84, $97, $08, $22, $10, $81, $97, $22, $04, $08
	byte	$02, $b5, $08, $00, $00, $00, $08, $84, $17, $08, $22, $14, $81, $97, $22, $0c
	byte	$00, $81, $97, $22, $08, $01, $02, $97, $00, $06, $00, $00, $02, $02, $98, $01
	byte	$02, $00, $f0, $02, $97, $00, $06, $00, $00, $09, $81, $97, $22, $10, $0a, $00
	byte	$81, $0a, $09, $01, $27, $09, $08, $84, $17, $08, $22, $18, $81, $27, $22, $18
	byte	$08, $02, $27, $01, $09, $81, $27, $22, $14, $0a, $00, $84, $0a, $09, $00, $b3
	byte	$09, $00, $83, $09, $08, $84, $17, $08, $22, $18, $02, $97, $00, $06, $00, $00
	byte	$09, $81, $97, $22, $10, $0a, $00, $81, $0a, $09, $81, $27, $22, $18, $08, $04
	byte	$17, $08, $09, $81, $97, $22, $0c, $00, $81, $97, $22, $08, $01, $02, $97, $00
	byte	$06, $00, $00, $02, $02, $98, $29, $02, $00, $f0, $08, $91, $20, $00, $9a, $01
	byte	$02, $81, $10, $00, $00, $00, $20, $00, $9a, $22, $00, $9a, $08, $00, $9a, $09
	byte	$00, $9a, $0a, $00, $9a, $02, $00, $aa, $72, $61, $6d, $64, $69, $73, $6b, $00
	byte	$00[2314]
	byte	$54, $00, $00, $f0, $00, $00, $00, $00, $00, $00, $00, $00, $57, $02, $00, $f0
	byte	$51, $02, $00, $f0, $5d, $02, $00, $f0, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$74, $00, $00, $f0, $6b, $00, $00, $f0, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[192]
	byte	$01, $02, $00, $f0, $29, $02, $00, $f0, $f9, $07, $00, $f0, $45, $12, $00, $f0
	byte	$ac, $12, $00, $f0, $6f, $19, $00, $f0, $af, $19, $00, $f0, $ab, $1a, $00, $f0
	byte	$81, $12, $00, $f0, $bb, $15, $00, $f0, $00, $00, $00, $00, $77, $09, $00, $f0
	byte	$04, $0d, $00, $f0, $ee, $0f, $00, $f0, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[192]
	byte	$1e, $06, $00, $f0, $46, $06, $00, $f0, $2e, $07, $00, $f0, $6e, $06, $00, $f0
	byte	$a7, $06, $00, $f0, $5a, $07, $00, $f0, $9b, $07, $00, $f0, $00, $00, $00, $00
	byte	$00[224]
	byte	$77, $05, $00, $f0
	alignl
_p2textdrv_dat_
'-'         orgh
'-' ' a default VGA palette
'-' vgapalette
'-'             long    $00_00_00_00   ' 0 = black
	byte	$00, $00, $00, $00
'-'             long    $00_00_AA_00   ' 1 = dark blue
	byte	$00, $aa, $00, $00
'-'             long    $00_AA_00_00   ' 2 = dark green
	byte	$00, $00, $aa, $00
'-'             long    $00_AA_AA_00   ' 3 = dark cyan
	byte	$00, $aa, $aa, $00
'-'             long    $AA_00_00_00   ' 4 = dark red
	byte	$00, $00, $00, $aa
'-'             long    $AA_00_AA_00   ' 5 = dark magenta
	byte	$00, $aa, $00, $aa
'-'             long    $AA_55_00_00   ' 6 = brown
	byte	$00, $00, $55, $aa
'-'             long    $AA_AA_AA_00   ' 7 = light grey
	byte	$00, $aa, $aa, $aa
'-'             long    $55_55_55_00   ' 8 = dark grey
	byte	$00, $55, $55, $55
'-'             long    $55_55_FF_00   ' 9 = light blue
	byte	$00, $ff, $55, $55
'-'             long    $55_FF_55_00   '10 = light green
	byte	$00, $55, $ff, $55
'-'             long    $55_FF_FF_00   '11 = light cyan
	byte	$00, $ff, $ff, $55
'-'             long    $FF_55_55_00   '12 = light red
	byte	$00, $55, $55, $ff
'-'             long    $FF_55_FF_00   '13 = light magenta
	byte	$00, $ff, $55, $ff
'-'             long    $FF_FF_55_00   '14 = yellow
	byte	$00, $55, $ff, $ff
'-'             long    $FF_FF_FF_00   '15 = white
	byte	$00, $ff, $ff, $ff
'-' 
'-' ' a default 16 scan line font for the P2
'-' font        file    "p2font16"
	byte	$00[8]
	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[12]
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[42]
	byte	$08, $00, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[33]
	byte	$1c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $88, $aa, $bb, $18, $18
	byte	$18, $6c, $00, $00, $6c, $6c, $00, $6c, $6c, $18, $00, $18, $18, $00, $18, $00
	byte	$18, $18, $6c, $6c, $00, $6c, $00, $6c, $00, $6c, $18, $6c, $00, $00, $6c, $18
	byte	$00, $00, $6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $ff, $00, $ff, $00, $00, $00, $00, $00, $01, $40, $00, $00, $00
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $00, $18
	byte	$00, $00, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[41]
	byte	$1c, $00, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[20]
	byte	$30, $08, $00, $06, $1c, $00, $08, $00, $06, $00, $18, $06, $63, $36, $0c, $00
	byte	$00, $08, $00, $06, $0c, $06, $00, $63, $63, $18, $1c, $00, $1f, $70, $18, $30
	byte	$18, $18, $00, $3b, $3c, $1c, $00, $00, $00, $03, $03, $00, $00, $00, $22, $55
	byte	$ee, $18, $18, $18, $6c, $00, $00, $6c, $6c, $00, $6c, $6c, $18, $00, $18, $18
	byte	$00, $18, $00, $18, $18, $6c, $6c, $00, $6c, $00, $6c, $00, $6c, $18, $6c, $00
	byte	$00, $6c, $18, $00, $00, $6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $00, $00
	byte	$00[19]
	byte	$18, $00, $00, $1c, $00, $00, $f0, $1b, $0e, $00, $00, $00, $7e, $7e, $00, $00
	byte	$00, $00, $00, $ff, $00, $ff, $78, $3c, $fc, $fe, $00, $03, $60, $18, $66, $fe
	byte	$63, $00, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $66, $00, $3e
	byte	$00, $1c, $0c, $30, $0c, $00, $00, $00, $00, $00, $00, $1c, $18, $3e, $3e, $30
	byte	$7f, $1c, $7f, $3e, $3e, $00, $00, $00, $00, $00, $3e, $00, $08, $3f, $3c, $1f
	byte	$7f, $7f, $3c, $63, $3c, $78, $67, $0f, $63, $63, $3e, $3f, $3e, $3f, $3e, $7e
	byte	$63, $63, $63, $63, $66, $7f, $3c, $00, $3c, $36, $00, $18, $00, $07, $00, $38
	byte	$00, $1c, $00, $07, $18, $60, $07, $1c, $00, $00, $00, $00, $00, $00, $00, $08
	byte	$00[6]
	byte	$70, $18, $0e, $6e, $00, $3c, $33, $18, $1c, $33, $0c, $36, $00, $1c, $63, $0c
	byte	$66, $3c, $0c, $00, $1c, $06, $00, $7c, $1c, $63, $0c, $1e, $0c, $63, $00, $00
	byte	$18, $36, $66, $33, $d8, $0c, $18, $0c, $0c, $6e, $00, $36, $36, $0c, $00, $00
	byte	$03, $03, $18, $00, $00, $88, $aa, $bb, $18, $18, $18, $6c, $00, $00, $6c, $6c
	byte	$00, $6c, $6c, $18, $00, $18, $18, $00, $18, $00, $18, $18, $6c, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $18, $6c, $00, $00, $6c, $18, $00, $00, $6c, $18, $18, $00
	byte	$ff, $00, $0f, $f0, $ff, $00, $1e, $7f, $00, $00, $00, $00, $00, $00, $00, $1c
	byte	$78, $00, $00, $38, $00, $00, $00, $00, $00, $70, $18, $00, $00, $36, $00, $00
	byte	$30, $36, $1b, $00, $00, $00, $81, $ff, $00, $00, $18, $18, $00, $ff, $00, $ff
	byte	$70, $66, $cc, $c6, $18, $07, $70, $3c, $66, $db, $06, $00, $3c, $3c, $18, $00
	byte	$00[6]
	byte	$3c, $66, $36, $63, $00, $36, $0c, $18, $18, $00, $00, $00, $00, $00, $00, $36
	byte	$1c, $63, $63, $38, $03, $06, $63, $63, $63, $00, $00, $60, $00, $06, $63, $3e
	byte	$1c, $66, $66, $36, $66, $66, $66, $63, $18, $30, $66, $06, $77, $67, $63, $66
	byte	$63, $66, $63, $7e, $63, $63, $63, $63, $66, $63, $0c, $01, $30, $63, $00, $00
	byte	$00, $06, $00, $30, $00, $36, $00, $06, $18, $60, $06, $18, $00, $00, $00, $00
	byte	$00, $00, $00, $0c, $00, $00, $00, $00, $00, $00, $18, $18, $18, $3b, $00, $66
	byte	$00, $0c, $36, $00, $18, $1c, $00, $36, $00, $18, $00, $66, $18, $08, $00, $00
	byte	$00, $36, $36, $00, $18, $33, $18, $00, $3e, $63, $3c, $26, $66, $33, $18, $06
	byte	$0c, $06, $06, $3b, $63, $36, $36, $0c, $00, $00, $43, $43, $18, $00, $00, $22
	byte	$55, $ee, $18, $18, $18, $6c, $00, $00, $6c, $6c, $00, $6c, $6c, $18, $00, $18
	byte	$18, $00, $18, $00, $18, $18, $6c, $6c, $00, $6c, $00, $6c, $00, $6c, $18, $6c
	byte	$00, $00, $6c, $18, $00, $00, $6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $00
	byte	$33, $63, $00, $7f, $00, $00, $00, $7e, $1c, $36, $0c, $00, $c0, $0c, $3e, $00
	byte	$00, $0c, $30, $d8, $18, $00, $00, $36, $00, $00, $30, $36, $0c, $00, $00, $00
	byte	$a5, $db, $36, $08, $3c, $3c, $00, $ff, $00, $ff, $58, $66, $fc, $fe, $18, $0f
	byte	$78, $7e, $66, $db, $1c, $00, $7e, $7e, $18, $00, $00, $00, $00, $08, $7f, $00
	byte	$3c, $24, $36, $43, $43, $36, $06, $0c, $30, $00, $00, $00, $00, $00, $40, $63
	byte	$1e, $60, $60, $3c, $03, $03, $60, $63, $63, $18, $18, $30, $00, $0c, $63, $63
	byte	$36, $66, $43, $66, $46, $46, $43, $63, $18, $30, $66, $06, $7f, $6f, $63, $66
	byte	$63, $66, $63, $5a, $63, $63, $63, $36, $66, $61, $0c, $03, $30, $00, $00, $00
	byte	$00, $06, $00, $30, $00, $26, $00, $06, $00, $00, $06, $18, $00, $00, $00, $00
	byte	$00, $00, $00, $0c, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $08, $43
	byte	$00[6]
	byte	$3c, $00, $00, $00, $00, $00, $00, $1c, $1c, $7f, $00, $33, $00, $00, $00, $00
	byte	$00, $00, $63, $63, $66, $06, $3c, $1f, $18, $00, $00, $00, $00, $00, $67, $7c
	byte	$1c, $00, $00, $00, $63, $63, $00, $00, $00, $88, $aa, $bb, $18, $18, $18, $6c
	byte	$00, $00, $6c, $6c, $00, $6c, $6c, $18, $00, $18, $18, $00, $18, $00, $18, $18
	byte	$6c, $6c, $00, $6c, $00, $6c, $00, $6c, $18, $6c, $00, $00, $6c, $18, $00, $00
	byte	$6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $00, $33, $63, $7f, $63, $00, $66
	byte	$6e, $18, $36, $63, $18, $00, $60, $06, $63, $7f, $18, $18, $18, $d8, $18, $18
	byte	$00, $1c, $00, $00, $30, $36, $06, $3e, $00, $00, $81, $ff, $7f, $1c, $3c, $7e
	byte	$00, $ff, $3c, $c3, $4c, $66, $0c, $c6, $db, $1f, $7c, $18, $66, $db, $36, $00
	byte	$18, $18, $18, $18, $0c, $00, $14, $1c, $7f, $00, $3c, $00, $7f, $03, $63, $1c
	byte	$00, $0c, $30, $66, $18, $00, $00, $00, $60, $63, $18, $30, $60, $36, $03, $03
	byte	$60, $63, $63, $18, $18, $18, $7e, $18, $30, $63, $63, $66, $03, $66, $16, $16
	byte	$03, $63, $18, $30, $36, $06, $7f, $7f, $63, $66, $63, $66, $06, $18, $63, $63
	byte	$63, $3e, $66, $30, $0c, $07, $30, $00, $00, $00, $1e, $1e, $3e, $3c, $3e, $06
	byte	$6e, $36, $1c, $70, $66, $18, $37, $3b, $3e, $3b, $6e, $3b, $3e, $3f, $33, $66
	byte	$63, $63, $63, $7f, $18, $18, $18, $00, $1c, $03, $33, $3e, $1e, $1e, $1e, $1e
	byte	$66, $3e, $3e, $3e, $1c, $1c, $1c, $36, $36, $66, $33, $33, $3e, $3e, $3e, $33
	byte	$33, $63, $63, $63, $06, $0f, $18, $23, $18, $1e, $1c, $3e, $33, $3b, $6f, $00
	byte	$00, $0c, $00, $00, $33, $33, $18, $6c, $1b, $22, $55, $ee, $18, $18, $1f, $6c
	byte	$00, $1f, $6f, $6c, $7f, $6f, $6c, $1f, $00, $18, $18, $00, $18, $00, $18, $f8
	byte	$6c, $ec, $fc, $ef, $ff, $ec, $ff, $ef, $ff, $6c, $ff, $00, $6c, $f8, $f8, $00
	byte	$6c, $ff, $18, $00, $ff, $00, $0f, $f0, $ff, $6e, $33, $03, $36, $06, $7e, $66
	byte	$3b, $3c, $63, $63, $30, $7e, $7e, $06, $63, $00, $18, $30, $0c, $18, $18, $18
	byte	$6e, $00, $00, $00, $30, $36, $13, $3e, $00, $00, $81, $ff, $7f, $3e, $e7, $ff
	byte	$18, $e7, $66, $99, $1e, $66, $0c, $c6, $3c, $7f, $7f, $18, $66, $de, $63, $00
	byte	$18, $18, $18, $30, $06, $03, $36, $1c, $3e, $00, $18, $00, $36, $3e, $30, $6e
	byte	$00, $0c, $30, $3c, $18, $00, $00, $00, $30, $6b, $18, $18, $3c, $33, $3f, $3f
	byte	$30, $3e, $7e, $00, $00, $0c, $00, $30, $18, $7b, $63, $3e, $03, $66, $1e, $1e
	byte	$03, $7f, $18, $30, $1e, $06, $6b, $7b, $63, $3e, $63, $3e, $1c, $18, $63, $63
	byte	$6b, $1c, $3c, $18, $0c, $0e, $30, $00, $00, $00, $30, $36, $63, $36, $63, $0f
	byte	$33, $6e, $18, $60, $36, $18, $7f, $66, $63, $66, $33, $6e, $63, $0c, $33, $66
	byte	$63, $36, $63, $33, $0e, $00, $70, $00, $36, $03, $33, $63, $30, $30, $30, $30
	byte	$06, $63, $63, $63, $18, $18, $18, $63, $63, $06, $6e, $7f, $63, $63, $63, $33
	byte	$33, $63, $63, $63, $06, $06, $7e, $33, $7e, $30, $18, $63, $33, $66, $7f, $7e
	byte	$3e, $0c, $7f, $7f, $18, $18, $18, $36, $36, $88, $aa, $bb, $18, $18, $18, $6c
	byte	$00, $18, $60, $6c, $60, $60, $6c, $18, $00, $18, $18, $00, $18, $00, $18, $18
	byte	$6c, $0c, $0c, $00, $00, $0c, $00, $00, $00, $6c, $00, $00, $6c, $18, $18, $00
	byte	$6c, $18, $18, $00, $ff, $00, $0f, $f0, $ff, $3b, $1b, $03, $36, $0c, $1b, $66
	byte	$18, $66, $63, $63, $7c, $db, $db, $3e, $63, $00, $7e, $60, $06, $18, $18, $00
	byte	$3b, $00, $00, $00, $30, $36, $1f, $3e, $00, $00, $bd, $c3, $7f, $7f, $e7, $ff
	byte	$3c, $c3, $42, $bd, $33, $3c, $0c, $c6, $e7, $1f, $7c, $18, $66, $d8, $63, $00
	byte	$18, $18, $18, $7f, $7f, $03, $7f, $3e, $3e, $00, $18, $00, $36, $60, $18, $3b
	byte	$00, $0c, $30, $ff, $7e, $00, $7f, $00, $18, $6b, $18, $0c, $60, $7f, $60, $63
	byte	$18, $63, $60, $00, $00, $06, $00, $60, $18, $7b, $7f, $66, $03, $66, $16, $16
	byte	$7b, $63, $18, $30, $1e, $06, $63, $73, $63, $06, $63, $36, $30, $18, $63, $63
	byte	$6b, $1c, $18, $0c, $0c, $1c, $30, $00, $00, $00, $3e, $66, $03, $33, $7f, $06
	byte	$33, $66, $18, $60, $1e, $18, $6b, $66, $63, $66, $33, $66, $06, $0c, $33, $66
	byte	$6b, $1c, $63, $18, $18, $18, $18, $00, $63, $03, $33, $7f, $3e, $3e, $3e, $3e
	byte	$06, $7f, $7f, $7f, $18, $18, $18, $63, $63, $3e, $6c, $33, $63, $63, $63, $33
	byte	$33, $63, $63, $63, $06, $06, $18, $7b, $18, $3e, $18, $63, $33, $66, $7b, $00
	byte	$00, $06, $03, $60, $0c, $0c, $18, $1b, $6c, $22, $55, $ee, $18, $1f, $1f, $6f
	byte	$7f, $1f, $6f, $6c, $6f, $7f, $7f, $1f, $1f, $f8, $ff, $ff, $f8, $ff, $ff, $f8
	byte	$ec, $fc, $ec, $ff, $ef, $ec, $ff, $ef, $ff, $ff, $ff, $ff, $fc, $f8, $f8, $fc
	byte	$ff, $ff, $1f, $f8, $ff, $ff, $0f, $f0, $00, $1b, $33, $03, $36, $18, $1b, $66
	byte	$18, $66, $7f, $36, $66, $db, $db, $06, $63, $7f, $18, $30, $0c, $18, $18, $7e
	byte	$00, $00, $18, $00, $37, $00, $00, $3e, $00, $00, $99, $e7, $7f, $3e, $e7, $7e
	byte	$3c, $c3, $42, $bd, $33, $18, $0c, $c6, $3c, $0f, $78, $7e, $66, $d8, $36, $7f
	byte	$7e, $18, $18, $30, $06, $03, $36, $3e, $1c, $00, $18, $00, $36, $60, $0c, $33
	byte	$00, $0c, $30, $3c, $18, $00, $00, $00, $0c, $63, $18, $06, $60, $30, $60, $63
	byte	$0c, $63, $60, $00, $00, $0c, $7e, $30, $18, $7b, $63, $66, $03, $66, $06, $06
	byte	$63, $63, $18, $33, $36, $06, $63, $63, $63, $06, $63, $66, $60, $18, $63, $63
	byte	$6b, $3e, $18, $06, $0c, $38, $30, $00, $00, $00, $33, $66, $03, $33, $03, $06
	byte	$33, $66, $18, $60, $1e, $18, $6b, $66, $63, $66, $33, $06, $1c, $0c, $33, $66
	byte	$6b, $1c, $63, $0c, $18, $18, $18, $00, $63, $43, $33, $03, $33, $33, $33, $33
	byte	$66, $03, $03, $03, $18, $18, $18, $7f, $7f, $06, $7e, $33, $63, $63, $63, $33
	byte	$33, $63, $63, $63, $66, $06, $7e, $33, $18, $33, $18, $63, $33, $66, $73, $00
	byte	$00, $03, $03, $60, $06, $66, $3c, $36, $36, $88, $aa, $bb, $18, $18, $18, $6c
	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $1b, $63, $03, $36, $0c, $1b, $66
	byte	$18, $66, $63, $36, $66, $db, $cf, $06, $63, $00, $18, $18, $18, $18, $1b, $00
	byte	$6e, $00, $18, $18, $36, $00, $00, $3e, $00, $00, $81, $ff, $3e, $1c, $18, $18
	byte	$18, $e7, $66, $99, $33, $7e, $0e, $e6, $db, $07, $70, $3c, $00, $d8, $1c, $7f
	byte	$3c, $18, $7e, $18, $0c, $7f, $14, $7f, $1c, $00, $00, $00, $7f, $61, $06, $33
	byte	$00, $0c, $30, $66, $18, $18, $00, $00, $06, $63, $18, $03, $60, $30, $60, $63
	byte	$0c, $63, $60, $18, $18, $18, $00, $18, $00, $3b, $63, $66, $43, $66, $46, $06
	byte	$63, $63, $18, $33, $66, $46, $63, $63, $63, $06, $6b, $66, $63, $18, $63, $36
	byte	$7f, $36, $18, $43, $0c, $70, $30, $00, $00, $00, $33, $66, $03, $33, $03, $06
	byte	$33, $66, $18, $60, $36, $18, $6b, $66, $63, $66, $33, $06, $30, $0c, $33, $66
	byte	$6b, $1c, $63, $06, $18, $18, $18, $00, $63, $66, $33, $03, $33, $33, $33, $33
	byte	$3c, $03, $03, $03, $18, $18, $18, $63, $63, $06, $1b, $33, $63, $63, $63, $33
	byte	$33, $63, $63, $63, $3c, $06, $18, $33, $18, $33, $18, $63, $33, $66, $63, $00
	byte	$00, $63, $03, $60, $3b, $73, $3c, $6c, $1b, $22, $55, $ee, $18, $18, $18, $6c
	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $1b, $63, $03, $36, $06, $1b, $3e
	byte	$18, $3c, $63, $36, $66, $7e, $7e, $06, $63, $00, $00, $0c, $30, $18, $1b, $18
	byte	$3b, $00, $00, $00, $36, $00, $00, $3e, $00, $00, $81, $ff, $1c, $08, $18, $18
	byte	$00, $ff, $3c, $c3, $33, $18, $0f, $e7, $18, $03, $60, $18, $66, $d8, $30, $7f
	byte	$18, $18, $3c, $00, $00, $00, $00, $7f, $08, $00, $18, $00, $36, $63, $63, $33
	byte	$00, $18, $18, $00, $00, $18, $00, $18, $03, $36, $18, $63, $63, $30, $63, $63
	byte	$0c, $63, $30, $18, $18, $30, $00, $0c, $18, $03, $63, $66, $66, $36, $66, $06
	byte	$66, $63, $18, $33, $66, $66, $63, $63, $63, $06, $7b, $66, $63, $18, $63, $1c
	byte	$77, $63, $18, $63, $0c, $60, $30, $00, $00, $00, $33, $66, $63, $33, $63, $06
	byte	$33, $66, $18, $60, $66, $18, $6b, $66, $63, $66, $33, $06, $63, $6c, $33, $3c
	byte	$7f, $36, $63, $63, $18, $18, $18, $00, $7f, $3c, $33, $63, $33, $33, $33, $33
	byte	$30, $63, $63, $63, $18, $18, $18, $63, $63, $66, $1b, $33, $63, $63, $63, $33
	byte	$33, $63, $63, $63, $18, $67, $18, $33, $18, $33, $18, $63, $33, $66, $63, $00
	byte	$00, $63, $03, $60, $61, $79, $3c, $00, $00, $88, $aa, $bb, $18, $18, $18, $6c
	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $3b, $63, $03, $36, $63, $1b, $06
	byte	$18, $18, $36, $36, $66, $00, $06, $0c, $63, $7f, $00, $00, $00, $18, $1b, $18
	byte	$00, $00, $00, $00, $3c, $00, $00, $3e, $00, $00, $7e, $7e, $08, $00, $3c, $3c
	byte	$00, $ff, $00, $ff, $1e, $18, $07, $67, $18, $01, $40, $00, $66, $d8, $63, $7f
	byte	$7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $00, $36, $3e, $61, $6e
	byte	$00, $30, $0c, $00, $00, $18, $00, $18, $01, $1c, $7e, $7f, $3e, $78, $3e, $3e
	byte	$0c, $3e, $1e, $00, $0c, $60, $00, $06, $18, $3e, $63, $3f, $3c, $1f, $7f, $0f
	byte	$5c, $63, $3c, $1e, $67, $7f, $63, $63, $3e, $0f, $3e, $67, $3e, $3c, $3e, $08
	byte	$36, $63, $3c, $7f, $3c, $40, $3c, $00, $00, $00, $6e, $3e, $3e, $6e, $3e, $0f
	byte	$3e, $67, $3c, $60, $67, $3c, $63, $66, $3e, $3e, $3e, $0f, $3e, $38, $6e, $18
	byte	$36, $63, $7e, $7f, $70, $18, $0e, $00, $00, $30, $6e, $3e, $6e, $6e, $6e, $6e
	byte	$60, $3e, $3e, $3e, $3c, $3c, $3c, $63, $63, $7f, $76, $73, $3e, $3e, $3e, $6e
	byte	$6e, $7e, $3e, $3e, $18, $3f, $18, $63, $18, $6e, $3c, $3e, $6e, $66, $63, $00
	byte	$00, $3e, $00, $00, $30, $7c, $18, $00, $00, $22, $55, $ee, $18, $18, $18, $6c
	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $6e, $33, $03, $36, $7f, $0e, $06
	byte	$18, $7e, $1c, $77, $3c, $00, $03, $38, $63, $00, $ff, $7e, $7e, $18, $0e, $00
	byte	$00, $00, $00, $00, $38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $ff, $00, $ff, $00, $00, $00, $03, $00, $00, $00, $00, $00, $00, $3e, $00
	byte	$00[13]
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $0c, $00, $00, $00, $00, $00, $00, $00
	byte	$00[29]
	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$30, $00, $00, $66, $00, $00, $00, $00, $00, $06, $30, $00, $00, $00, $00, $00
	byte	$00, $00, $60, $00, $00, $00, $00, $00, $00, $60, $00, $00, $00, $00, $00, $00
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $60, $00, $00, $00, $00, $00, $00, $1b, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $18, $60, $00, $00, $00, $88, $aa, $bb, $18, $18, $18, $6c
	byte	$6c, $18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18
	byte	$6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c
	byte	$6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00, $00, $00, $00, $00, $00, $00, $03
	byte	$00[13]
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[29]
	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $00
	byte	$00[6]
	byte	$33, $00, $00, $66, $00, $00, $00, $00, $00, $06, $30, $00, $00, $00, $00, $00
	byte	$00, $00, $30, $00, $00, $00, $00, $00, $00, $3e, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$30, $00, $00, $00, $00, $00, $00, $0e, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7c, $60, $00, $00, $00, $22, $55, $ee, $18, $18, $18, $6c, $6c
	byte	$18, $6c, $6c, $6c, $00, $00, $00, $18, $00, $00, $18, $18, $00, $18, $18, $6c
	byte	$00, $6c, $00, $6c, $6c, $00, $6c, $00, $00, $18, $6c, $00, $00, $18, $6c, $6c
	byte	$18, $00, $18, $ff, $ff, $0f, $f0, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[12]
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[83]
	byte	$1e, $00, $00, $3c, $00, $00, $00, $00, $00, $0f, $78, $00, $00, $00, $00, $00
	byte	$00, $00, $1f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$88, $aa, $bb, $18, $18, $18, $6c, $6c, $18, $6c, $6c, $6c, $00, $00, $00, $18
	byte	$00, $00, $18, $18, $00, $18, $18, $6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00
	byte	$00, $18, $6c, $00, $00, $18, $6c, $6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00
	byte	$00[20]
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[156]
	byte	$22, $55, $ee, $18, $18, $18, $6c, $6c, $18, $6c, $6c, $6c, $00, $00, $00, $18
	byte	$00, $00, $18, $18, $00, $18, $18, $6c, $00, $6c, $00, $6c, $6c, $00, $6c, $00
	byte	$00, $18, $6c, $00, $00, $18, $6c, $6c, $18, $00, $18, $ff, $ff, $0f, $f0, $00
	byte	$00[20]
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	alignl
_p2videodrv_dat_
'-'     context long  0[MAXCOGS] ' the printing context pointer per COG
	byte	$00[32]
'-'             orgh
'-' 
'-' videodriver
'-'             org 0
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-' '
'-' ' Initial driver entry code, this is also reused later for variable storage
'-' '
'-' '--------------------------------------------------------------------------------------------------
'-' statusaddr                  mov     statusaddr, ptra        'save ptra as the status address
	byte	$f8, $01, $00, $f6
'-' mailbox                     rdlong  mailbox, ptra[3]        'read mailbox address information
	byte	$03, $03, $04, $fb
'-' linebuf1                    rdlong  linebuf1, ptra[4]       'extract scan line buffer address
	byte	$04, $05, $04, $fb
'-' linebuf2                    rdlong  linebuf2, ptra[5]       'extract scan line buffer address
	byte	$05, $07, $04, $fb
'-' linebufsize                 add     ptra, #24               'skip past the init parameters
	byte	$18, $f0, $07, $f1
'-' paramaddr                   mov     paramaddr, ptra         'save pointer to first region data
	byte	$f8, $0b, $00, $f6
'-' regn                        cogid   c                       'get our cog id
	byte	$01, $e8, $63, $fd
'-' modedata                    getbyte b, mailbox, #3          'get per COG mailbox spacing in bytes
	byte	$01, $e6, $fb, $f8
'-' screenaddr1                 mov     a, b                    'duplicate for later
	byte	$f3, $e5, $03, $f6
'-' screenaddr2                 mul     b, #MAXCOGS wz          'multiply by total number of COGs
	byte	$08, $e6, $0f, $fa
'-' fontaddr                    sub     mailbox, b              'subtract so instances start from 1
	byte	$f3, $03, $80, $f1
'-' paletteaddr                 mul     a, c                    'compute offset for this COG ID
	byte	$f4, $e5, $03, $fa
'-' cursor1                     add     a, #4                   'add offset for 2nd mailbox entry
	byte	$04, $e4, $07, $f1
'-' cursor2                     add     mailbox, a              'include offset in mailbox address
	byte	$f2, $03, $00, $f1
'-' mouse_xy                    sets    extm_test, b            'forces external mem off if no mbox
	byte	$f3, $53, $ba, $f9
'-' mouseptr                    add     ptrb, lutoffset         'determine hub address of LUT code
	byte	$a0, $f3, $03, $f1
'-' wrap                        setq2   #511                    'read up to 512 instructions
	byte	$29, $fe, $67, $fd
'-' skew                        rdlong  $000, ptrb              '...and load into LUT RAM
	byte	$80, $01, $04, $fb
'-' status                      jmp     #$200                   'continue initialization in LUT RAM
	byte	$b4, $07, $90, $fd
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-' ' Main field/frame generation loop
'-' '--------------------------------------------------------------------------------------------------
'-' 
'-' fieldloop
'-'                             setq    #8-1                    'read 8 longs from hub
	byte	$28, $0e, $64, $fd
'-'                             rdlong  fieldparams, paramaddr  'reload field parameters to COGRAM
	byte	$05, $48, $03, $fb
'-'                             setcy   cy                      'setup the colour space converter
	byte	$38, $54, $63, $fd
'-'                             setci   ci                      'cq is done per scan line (for PAL)
	byte	$39, $56, $63, $fd
'-'                             mov     regn, regionsize        'setup first region and limit
	byte	$a8, $0d, $00, $f6
'-'                             getword regionsize, borders, #0 'extract top border size
	byte	$a6, $51, $33, $f9
'-'                             shr     borders, #16            'extract bottom border size
	byte	$10, $4c, $47, $f0
'-'                             getbyte a, brdrcolour, #0       'extract side border size
	byte	$a7, $e5, $e3, $f8
'-'                             setword m_brdr, a, #0           'setup number of side border pixels
	byte	$f2, $33, $23, $f9
'-'                             setword m_rf, vis_pixels, #0    'start with default scanline width
	byte	$9d, $31, $23, $f9
'-'                             sub     m_rf, a                 'adjust for left side border
	byte	$f2, $31, $83, $f1
'-'                             sub     m_rf, a                 'adjust for right side border
	byte	$f2, $31, $83, $f1
'-'                             mov     d, #0 wcz               'setup d+c,z flags for mouse+region
	byte	$00, $ea, $1f, $f6
'-'                             setbyte brdrcolour, d, #0       'clear out LSB of border colour
	byte	$f5, $4f, $c3, $f8
'-'                             call    #borderregion           'setup region defaults for border
	byte	$f0, $00, $b0, $fd
'-' 
'-' writestat1                  setbyte status, #$20, #3        'update status - doing back porch
	byte	$20, $24, $dc, $f8
'-' patchvbp                    callpa  #V_BP-0, #blank-0       'send vertical back porch lines
	byte	$36, $42, $4c, $fb
'-' 
'-'                             mov     ptrb, linebuf1          'restart line buffer
	byte	$02, $f2, $03, $f6
'-'                             test    regionsize  wz          'check if a top border is present
	byte	$a8, $51, $cb, $f7
'-'             if_z            call    #newregion              'if not, start a new region
	byte	$d8, $00, $b0, $ad
'-'                             mov     pa, vis_lines           'set number of visible lines
	byte	$9e, $ed, $03, $f6
'-'                             call    videomode               'begin video after last border line
	byte	$2d, $42, $63, $fd
'-' 
'-' lineloop
'-'                             call    #hsync                  'do horizontal sync
	byte	$a0, $00, $b0, $fd
'-' 
'-'                             setq2   #15                     'read small palettes at this time
	byte	$29, $1e, $64, $fd
'-'                             rdlong  $100, paletteaddr       'read from hub RAM
	byte	$0b, $00, $02, $fb
'-'             'if_c_and_z      callpb  save, #do_mouse         'c=1, render the mouse after hsync
'-'                             rdfast  #0, save                'setup the streamer read address
	byte	$f1, $01, $78, $fc
'-'                             add     status, #1
	byte	$01, $24, $04, $f1
'-' 
'-'                             cmp     pa, borders wz          'check if reached bottom border
	byte	$a6, $ed, $0b, $f2
'-'             if_z            mov     regionsize, #0          'if yes stop further region updates
	byte	$00, $50, $07, $a6
'-'             if_z            call    #borderregion           'and go back to border generation
	byte	$b4, $00, $b0, $ad
'-'                             test    m_brdr, #255 wz         'check if we have a side border
	byte	$ff, $32, $cf, $f7
'-'             if_nz           xcont   m_brdr, brdrcolour      'create left border pixels
	byte	$a7, $33, $c3, $5c
'-'                             xcont   m_rf, palselect         'generate the visible line
	byte	$ed, $31, $c3, $fc
'-'             if_nz           xcont   m_brdr, brdrcolour      'create right border pixels
	byte	$a7, $33, $c3, $5c
'-' 
'-'                             sub     regionsize, #1 wz       'decrement the region's size count
	byte	$01, $50, $8f, $f1
'-'             if_z            call    #newregion              'when 0, reload another region
	byte	$98, $00, $b0, $ad
'-' 
'-'                             call    videomode               'create the next video scan line
	byte	$2d, $42, $63, $fd
'-'                             xcont   m_bs, hsync0            'generate horizontal FP blanking
	byte	$a2, $25, $c3, $fc
'-'                             djnz    pa, #lineloop           'continue for all active lines
	byte	$ef, $ed, $6f, $fb
'-' 
'-' writestat2                  setbyte status, #$40, #3        'update status - doing front porch
	byte	$40, $24, $dc, $f8
'-' patchvfp                    callpa  #V_FP-0, #blank         'send vertical front porch lines
	byte	$1e, $14, $4c, $fb
'-' 
'-'                             add     fieldcount, #1          'increase the field counter
	byte	$01, $3e, $07, $f1
'-'                             test    fieldcount, #15 wz      'check for 16 fields elapsed
	byte	$0f, $3e, $cf, $f7
'-' flasher     if_z            xor     flash, #$ff             'flash text ~2Hz
	byte	$ff, $e0, $65, $a5
'-' 
'-' syncspace                                                   '!! These 18 instructions must be
'-'                                                             '...maintained for patching into!
'-'                             sub     m_vi, m_slim            'reduces blank line width
	byte	$9b, $2f, $83, $f1
'-' proghd0                     add     m_sn, m_slim            'widens sync (SD)
	byte	$9b, $27, $03, $f1
'-' proghd1                     setnib  flipref, #%1111, #7     '...changes back porch (HD)
	byte	$0f, $ae, $3c, $f8
'-' vsyncon                     drvnot  #0-0                    '(patched) vsync pin on
	byte	$5f, $00, $64, $fd
'-'                             setcmod cmodval
	byte	$3c, $40, $63, $fd
'-'                             mov     hsync0, sync_001        'vsync on, hsync off
	byte	$8f, $45, $03, $f6
'-'                             decod   status, #31             'update status - in vertical sync
	byte	$1f, $24, $c4, $f9
'-'                             setbyte status, fieldcount, #2
	byte	$9f, $25, $d0, $f8
'-'                             mov     hsync1, sync_000        'vsync on, hsync on
	byte	$8e, $47, $03, $f6
'-' 
'-' patchvsync                  callpa  #V_SYNC-0, #blank       'send vertical sync blanks
	byte	$11, $04, $4c, $fb
'-' vsyncoff                    xor     cmodval, #1             'vsync pin off
	byte	$01, $40, $67, $f5
'-'                             setcmod cmodval
	byte	$3c, $40, $63, $fd
'-'                             mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
	byte	$91, $45, $03, $f6
'-'                             mov     hsync1, sync_002        'vsync off, hsync on
	byte	$90, $47, $03, $f6
'-'                             add     m_vi, m_slim            'restores blank line width
	byte	$9b, $2f, $03, $f1
'-' proghd2                     sub     m_sn, m_slim            'restores sync width (SD)
	byte	$9b, $27, $83, $f1
'-' proghd3                     setnib  flipref, #0, #7         '...or restores back porch (HD)
	byte	$00, $ae, $3c, $f8
'-'                             nop                             'must keep room for 18 instructions!
	byte	$00, $00, $00, $00
'-' 
'-'                             jmp     #fieldloop              'continue on to a new field/frame
	byte	$04, $ff, $9f, $fd
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-' ' Subroutines
'-' '--------------------------------------------------------------------------------------------------
'-' 
'-' hsync                       xzero   m_sn, hsync1            'generate the sync pulse
	byte	$a3, $27, $b3, $fc
'-'                             wrlong  status, statusaddr      'update the sync status per line
	byte	$00, $24, $60, $fc
'-' dobreeze                    xcont   m_br, hsync0            'do breezeway before colour burst
	byte	$a2, $29, $c3, $fc
'-'                             setcq   cq                      'reapply CQ for PAL colour changes
	byte	$3a, $52, $63, $fd
'-' doburst                     xcont   m_cb, colourburst       'do the PAL/NTSC colour burst
	byte	$9c, $2b, $c3, $fc
'-' flipref                     xor     cq, palflipcq           'toggle PAL colour output per scanline
	byte	$a4, $53, $63, $f5
'-' bp          _ret_           xcont   m_bv, hsync0            'generate the back porch
	byte	$a2, $2d, $c3, $0c
'-' 
'-' '..................................................................................................
'-' blank_pal                   xor     cq, palflipcq           'NEEDS TO BE EVEN DIST. FROM patchvbp!
	byte	$a4, $53, $63, $f5
'-' blank                       call    #hsync                  'do hsync at the start of the line
	byte	$dc, $ff, $bf, $fd
'-'                             xcont   m_vi, hsync0            'generate blank line pixels
	byte	$a2, $2f, $c3, $fc
'-'             _ret_           djnz    pa, #blank              'repeat to generate multiple lines
	byte	$fd, $ed, $6f, $0b
'-' 
'-' '..................................................................................................
'-' ' Code to reload and setup all configurable parameters per display region
'-' 
'-' newregion                   zerox   regn, #19 wz            'check for any more regions?
	byte	$13, $0c, $4c, $f7
'-' borderregion
'-'             if_z            setnib  m_rf, #1, #4            'setup streamer for immediate data
	byte	$01, $30, $27, $a8
'-'             if_z            setnib  m_rf, #7, #7            'setup streamer for immediate data
	byte	$07, $30, $3f, $a8
'-'             if_z            mov     videomode, #nullmode
	byte	$59, $43, $07, $a6
'-'                             mov     palselect, brdrcolour   'set default border colour
	byte	$a7, $db, $03, $f6
'-'             if_z            ret     wcz                     'and exit if no more regions
	byte	$2d, $00, $7c, $ad
'-' 
'-'                             setq    #12-1                   'read region parameters from hub
	byte	$28, $16, $64, $fd
'-'                             rdlong  regn, regn              'update region data
	byte	$06, $0c, $00, $fb
'-'                             getword regionsize, modedata, #1 'extract region size
	byte	$07, $50, $3b, $f9
'-' 
'-'                             testb   modedata, #9 wc         'determine mode type 1=gfx, 0=text
	byte	$09, $0e, $14, $f4
'-'                             testb   modedata, #12 wz        'check if interlaced source
	byte	$0c, $0e, $0c, $f4
'-'                             testb   fieldcount, #0 andz     'and with LSB to get field
	byte	$00, $3e, $4f, $f4
'-'             if_z_and_c      mov     screenaddr1, cursor1    'select source for interlaced gfx
	byte	$0c, $10, $00, $86
'-'             if_z_and_c      mov     screenaddr2, cursor2    '...same for wrapped portion
	byte	$0d, $12, $00, $86
'-'                             bitz    setrowscan, #0          'clear text row scan index
	byte	$00, $9e, $86, $f4
'-'                             mov     palselect, #8           'clear default
	byte	$08, $da, $07, $f6
'-'                             getbyte rowheight, fontaddr, #3 'extract font height
	byte	$0a, $d6, $fb, $f8
'-'                             getword rowscan, wrap, #1       'get initial font scanline
	byte	$10, $de, $3b, $f9
'-' 
'-'             if_z_and_nc     incmod  rowscan, rowheight wz   'wrap rowscan at row height
	byte	$eb, $df, $0b, $27
'-'                             wrz     row                     '..and increase row if required
	byte	$6e, $d8, $63, $fd
'-' 
'-'                             getword wrap, wrap, #0          'clear unwanted top 16 bits now
	byte	$10, $20, $30, $f9
'-'                             neg     scanline, #1
	byte	$01, $dc, $67, $f6
'-'             if_c            mov     videomode, #gen_gfx     'setup function pointers
	byte	$26, $43, $07, $c6
'-'             if_nc           mov     videomode, #gen_text    '..for the appropriate mode
	byte	$d2, $42, $07, $36
'-'                             testb   modedata, #3 wz         'if gfx, 1=LUMA8, 0=non LUMA8
	byte	$03, $0e, $0c, $f4
'-'             if_c_and_z      setnib  palselect, modedata, #0
	byte	$07, $da, $03, $88
'-'                             getnib  a, modedata, #0         'colour mode 0 is special below
	byte	$07, $e4, $43, $f8
'-'                             cmp     a, #3 wz                'check for the 8 bit LUTRAM mode
	byte	$03, $e4, $0f, $f2
'-'             if_c_and_z      mov     palselect, #0           'use low LUTRAM for 8 bit palettes
	byte	$00, $da, $07, $86
'-'             if_c_and_z      setq2   #255                    'read in a 256 colour palette from
	byte	$29, $fe, $65, $8d
'-'             if_c_and_z      rdlong  0, paletteaddr          '...HUB to LUT RAM
	byte	$0b, $00, $00, $8b
'-'                             fle     a, #8 wz                'collapse LUMA8 modes, test for 0
	byte	$08, $e4, $2f, $f3
'-' 
'-' 
'-' p7          if_nc           mov     a, #2                   'override index if text mode
	byte	$02, $e4, $07, $36
'-'                             alts    a, #modetable           'setup mode table indexing
	byte	$85, $e5, $97, $f9
'-'                             mov     a, 0-0                  'get mode information
	byte	$00, $e4, $03, $f6
'-'             if_c            getbyte transfers, a, #1        'setup transfer count in gfx modes
	byte	$f2, $d9, $eb, $c8
'-'                             getbyte b, a, #2                'get burst size
	byte	$f2, $e7, $f3, $f8
'-'                             getnib  bppidx, a, #6           'get bit depth in bpp
	byte	$f2, $d5, $73, $f8
'-'                             setnib  m_rf, a, #4             'set streamer nibble 4
	byte	$f2, $31, $23, $f8
'-'                             shr     a, #4                   'prepare next nibble
	byte	$04, $e4, $47, $f0
'-'                             setnib  m_rf, a, #7             'set streamer nibble 7
	byte	$f2, $31, $3b, $f8
'-' 
'-' p0                          mov     linebufsize, #COLS      'compute scan line size in bytes
	byte	$50, $08, $04, $f6
'-'                             shl     linebufsize, bppidx     '...for the bit depth
	byte	$ea, $09, $60, $f0
'-' 
'-'                             setd    burst, b
	byte	$f3, $81, $b2, $f9
'-'                             testb   modedata, #10 wz        'test for pixel doubling
	byte	$0a, $0e, $0c, $f4
'-'             if_z            shr     b, #1                   'halve the transfer size if doubled
	byte	$01, $e6, $47, $a0
'-'                             setd    transferloop, b         'value patched is actually size-1
	byte	$f3, $7b, $b2, $f9
'-'                             add     b, #1                   '...so increment to get real size
	byte	$01, $e6, $07, $f1
'-'                             setd    double, b
	byte	$f3, $7f, $b2, $f9
'-'                             alts    bppidx, #doublebits
	byte	$78, $d5, $97, $f9
'-'             if_c            mov     pattern, 0-0
	byte	$00, $d6, $03, $c6
'-'                             setd    doubleloop, pattern
	byte	$eb, $bd, $b2, $f9
'-'             if_c            shr     pattern, #9
	byte	$09, $d6, $47, $c0
'-'             _ret_           mov     ptra, screenaddr1       'restart screen buffer at start
	byte	$08, $f0, $03, $06
'-' 
'-' '..................................................................................................
'-' ' Code to generate a mouse sprite in all the different colour depths
'-' 
'-' do_mouse
'-'                             push    ptra
	byte	$2a, $f0, $63, $fd
'-'                             push    ptrb
	byte	$2a, $f2, $63, $fd
'-' 
'-'                             testb   modedata, #14 wz
	byte	$0e, $0e, $0c, $f4
'-'             if_nz           mov     mouse_xy, globalmouse   'use global screen co-ordinates
	byte	$a5, $1d, $00, $56
'-'             if_z            mov     d, scanline             'use local region co-ordinates
	byte	$ee, $eb, $03, $a6
'-' 
'-'                             getword a, mouse_xy, #1         'get mouse y screen co-ordinate
	byte	$0e, $e4, $3b, $f9
'-'                             getnib  b, mouseptr, #7         'get y hotspot of mouse image
	byte	$0f, $e6, $7b, $f8
'-'                             sub     a, b                    'compensate for the y hotspot
	byte	$f3, $e5, $83, $f1
'-'                             subr    a, d                    'compute sprite row offset
	byte	$f5, $e5, $c3, $f2
'-'                             cmpr    a, #15 wc               'check if sprite covers scanline
	byte	$0f, $e4, $97, $f2
'-' 
'-'                             alts    bppidx, #bpptable       'bppidx is an index from 0-5
	byte	$7f, $d5, $97, $f9
'-'                             mov     bitmask, 0-0            'get table entry using bpp index
	byte	$00, $5a, $03, $f6
'-'                             mul     a, bitmask              'multiply mouse row by its length
	byte	$ad, $e5, $03, $fa
'-'                             shr     bitmask, #16 wz         'extract mask portion
	byte	$10, $5a, $4f, $f0
'-'             if_z            not     bitmask                 'fix up the 32 bpp case
	byte	$ad, $5b, $23, $a6
'-'                             mov     bpp, bitmask
	byte	$ad, $63, $03, $f6
'-'                             ones    bpp                     'convert into real bpp
	byte	$b1, $63, $a3, $f7
'-' 
'-'                             add     a, mouseptr             'add offset to base mouse address
	byte	$0f, $e4, $03, $f1
'-'                             setq2   #17-1                   'get 17 longs max, mouse mask+image
	byte	$29, $20, $64, $fd
'-'                             rdlong  $120, a                 'read mouse data and store in LUT
	byte	$f2, $41, $02, $fb
'-' 
'-'                             getword offset, mouse_xy, #0    'get mouse x screen co-ordinate
	byte	$0e, $5e, $33, $f9
'-'                             getnib  b, mouseptr, #6         'get x hotspot of mouse image
	byte	$0f, $e6, $73, $f8
'-' 
'-'                             mov     pixels, offset
	byte	$af, $e1, $03, $f6
'-'                             sub     offset, b               'compensate for the x hotspot
	byte	$f3, $5f, $83, $f1
'-'             if_nc           subr    pixels, vis_pixels wcz  'compute pixels until end of line
	byte	$9d, $e1, $db, $32
'-'                             add     pixels, b               'increase by the x hotspot amount
	byte	$f3, $e1, $03, $f1
'-'                             fle     pixels, #16             'limit drawn pixels to 16
	byte	$10, $e0, $27, $f3
'-' 
'-'             if_c_or_z       jmp     #exitmouse              'exit if sprite is out of x/y range
	byte	$80, $00, $90, $ed
'-' 
'-'                             mov     ptrb, #$120             'ptrb is used for mouse image data
	byte	$20, $f3, $07, $f6
'-'                             rdlut   c, ptrb++               'read in the mouse mask first
	byte	$e1, $e9, $a7, $fa
'-' 
'-'                             abs     a, offset               'retain offset (and make positive)
	byte	$af, $e5, $43, $f6
'-'                             muls    offset, bpp             'convert number of pixels into bits
	byte	$b1, $5f, $13, $fa
'-'                             abs     b, offset wc            'test for negative value (clipped)
	byte	$af, $e7, $53, $f6
'-'                             mov     muxmask, bitmask        'setup mask for pixel's data size
	byte	$ad, $5d, $03, $f6
'-'             if_nc           rol     muxmask, b              'align mask for first data pixel
	byte	$f3, $5d, $23, $30
'-'             if_c            rol     bitmask, b              'align mask for first mouse pixel
	byte	$f3, $5b, $23, $c0
'-'             if_c            shr     c, a                    'eliminate mouse pixels if clipped
	byte	$f2, $e9, $43, $c0
'-'                             shr     b, #5                   'convert bits to longs
	byte	$05, $e6, $47, $f0
'-'             if_c            add     ptrb, b                 'advance mouse data to skip pixels
	byte	$f3, $f3, $03, $c1
'-' 
'-'                             shl     b, #2                   'convert longs to bytes
	byte	$02, $e6, $67, $f0
'-'             if_nc           add     pb, b                   'adjust scanline buffer position
	byte	$f3, $ef, $03, $31
'-'                             setq2   #16-1                   'read 16 scanline longs into LUT
	byte	$29, $1e, $64, $fd
'-'                             rdlong  $110, pb                'using adjusted hub read position
	byte	$f7, $21, $02, $fb
'-' 
'-'                             mov     ptra, #$110             'ptra used for source image data
	byte	$10, $f1, $07, $f6
'-'                             rdlut   a, ptra                 'get original scanline pixel data
	byte	$00, $e5, $a7, $fa
'-'                             test    $, #1 wc                'c=1 will trigger initial read
	byte	$01, $80, $d5, $f7
'-' 
'-'                             rep     @endmouse, pixels       'repeat loop for up to 16 pixels
	byte	$f0, $13, $d8, $fc
'-'             if_c            rdlut   b, ptrb++               'get next mouse sprite pixel(s)
	byte	$e1, $e7, $a7, $ca
'-'             if_c            rol     b, offset               'align with the source input data
	byte	$af, $e7, $23, $c0
'-'                             shr     c, #1 wc                'get mask bit 1=set, 0=transparent
	byte	$01, $e8, $57, $f0
'-'             if_c            setq    muxmask                 'configure the muxq mask
	byte	$28, $5c, $63, $cd
'-'             if_c            muxq    a, b                    'select original or mouse pixel
	byte	$f3, $e5, $f3, $c9
'-'             if_c            wrlut   a, ptra                 'write back updated data if altered
	byte	$00, $e5, $37, $cc
'-'                             rol     muxmask, bpp wc         'advance mask by 1,2,4,8,16,32 bits
	byte	$b1, $5d, $33, $f0
'-'             if_c            rdlut   a, ++ptra               '...and read next source pixel(s)
	byte	$41, $e5, $a7, $ca
'-'                             rol     bitmask, bpp wc         'rotate mask for mouse data reload
	byte	$b1, $5b, $33, $f0
'-' endmouse
'-'                             fle     ptra, #$11f             'any way to eliminate this instrn?
	byte	$1f, $f1, $27, $f3
'-'                             sub     ptra, #$110
	byte	$10, $f1, $87, $f1
'-'                             setq2   ptra
	byte	$29, $f0, $63, $fd
'-'                             wrlong  $110, pb                'write LUT image data back to hub
	byte	$f7, $21, $62, $fc
'-' exitmouse                   pop     ptrb
	byte	$2b, $f2, $63, $fd
'-'                             pop     ptra
	byte	$2b, $f0, $63, $fd
'-'                             ret     wcz
	byte	$2d, $00, $7c, $fd
'-' 
'-' '..................................................................................................
'-' ' Code to generate the next text scan line and cursor(s)
'-' 
'-' gen_text
'-'                             mov     b, rowscan              'build font table base address
	byte	$ef, $e7, $03, $f6
'-'                             shl     b, #8                   'for this font and row's scanline
	byte	$08, $e6, $67, $f0
'-'                             add     b, fontaddr
	byte	$0a, $e6, $03, $f1
'-'                             setq    #64-1                   '64 longs holds 256 bytes of font
	byte	$28, $7e, $64, $fd
'-'                             rdlong  font, b                 'read in font data for scanline
	byte	$f3, $55, $03, $fb
'-' 
'-'                             testb   modedata, #8 wz         'flashing / full colour background?
	byte	$08, $0e, $0c, $f4
'-' p12         if_z            setr    testflash, #$83         'use text flashing code test
	byte	$83, $de, $ad, $a9
'-' p13         if_nz           setr    testflash, #$EA         'change into helpful zerox c,#15 wc
	byte	$ea, $de, $ad, $59
'-' 
'-'                             testb   modedata, #10 wz        'pixel double test
	byte	$0a, $0e, $0c, $f4
'-' readrow                     setq2   #COLS/2-1               'read maximum of 120 longs from HUB
	byte	$29, $4e, $64, $fd
'-'                             rdlong  $110, ptra              'to get next 240 chars with colours
	byte	$00, $21, $06, $fb
'-' p9                          mov     pb, #$10f+COLS/2        'setup LUT read pointer at end
	byte	$37, $ef, $07, $f6
'-' p10         if_z            sub     pb, #COLS/4             '...of where character data is
	byte	$14, $ee, $87, $a1
'-' 
'-'                             mov     save, ptrb              'save pointer register
	byte	$f9, $e3, $03, $f6
'-'                             mov     ptrb, #$1ff             'setup write location in LUT RAM
	byte	$ff, $f3, $07, $f6
'-' 
'-' p1          if_z            sets    adv, #COLS              'increase by half normal columns
	byte	$50, $46, $be, $a9
'-' p2          if_nz           sets    adv, #COLS*2            'increase by normal columns
	byte	$a0, $46, $be, $59
'-' 
'-' patchtext
'-'                             mov     a, #%11000 wc           'reset starting lookup index
	byte	$18, $e4, $17, $f6
'-' p3          if_z            rep     @endwide, #COLS/2       '2100 clocks for 40 double wide
	byte	$28, $36, $dc, $ac
'-' p4          if_nz           rep     @endnormal, #COLS       '2760 clocks for 80 normal wide
	byte	$50, $24, $dc, $5c
'-'                             skipf   a                       'skip 2 of the next 5 instructions
	byte	$32, $e4, $63, $fd
'-'                             xor     a, #%11110              'flip skip sequence for next time
	byte	$1e, $e4, $67, $f5
'-'                             rdlut   d, pb                   'read pair of characters/colours
	byte	$f7, $eb, $a3, $fa
'-'                             getword c, d, #1                'select first word in long (skipf)
	byte	$f5, $e9, $3b, $f9
'-'                             getword c, d, #0                'select second word in long (skipf)
	byte	$f5, $e9, $33, $f9
'-'                             sub     pb, #1                  'decrement LUT read index (skipf)
	byte	$01, $ee, $87, $f1
'-'                             getbyte b, c, #0                'extract font offset for char
	byte	$f4, $e7, $e3, $f8
'-'                             altgb   b, #font                'determine font lookup address
	byte	$aa, $e7, $6f, $f9
'-'                             getbyte pixels, 0-0, #0         'get font for character's scanline
	byte	$00, $e0, $e3, $f8
'-' testflash                   bitl    c, #15 wcz              'test (and clear) flashing bit
	byte	$0f, $e8, $1f, $f4
'-' flash       if_c            and     pixels, #$ff            'make it all background if flashing
	byte	$ff, $e0, $07, $c5
'-'                             movbyts c, #%01010101           'colours becomes BF_BF_BF_BF
	byte	$55, $e8, $ff, $f9
'-'                             mov     b, c                    'grab a copy for muxing step next
	byte	$f4, $e7, $03, $f6
'-'                             rol     b, #4                   'b becomes FB_FB_FB_FB
	byte	$04, $e6, $27, $f0
'-'                             setq    ##$F0FF000F             'mux mask adjusts fg and bg colours
	byte	$80, $7f, $f8, $ff, $28, $1e, $64, $fd
'-'                             muxq    c, b                    'c becomes FF_FB_BF_BB
	byte	$f3, $e9, $f3, $f9
'-'                             testb   modedata, #10 wz        'repeat columns test, z was trashed
	byte	$0a, $0e, $0c, $f4
'-' endnormal                                                   'end rep 2 instructions early (skipf)
'-'             if_nz           movbyts c, pixels               'select pixel colours for char
	byte	$f0, $e9, $fb, $59
'-'             if_nz           wrlut   c, ptrb--               'write coloured pixel data into LUT
	byte	$ff, $e9, $37, $5c
'-' 
'-'                             setword pixels, pixels, #1      'replicate low words in long
	byte	$f0, $e1, $2b, $f9
'-'                             mergew  pixels                  '...to then double pixels
	byte	$63, $e0, $63, $fd
'-'                             mov     b, c                    'save a copy before we lose colours
	byte	$f4, $e7, $03, $f6
'-'                             movbyts c, pixels               'compute 4 lower colours of char
	byte	$f0, $e9, $fb, $f9
'-'                             ror     pixels, #8              'get upper 8 pixels
	byte	$08, $e0, $07, $f0
'-'                             movbyts b, pixels               'compute 4 higher colours of char
	byte	$f0, $e7, $fb, $f9
'-' endwide                                                     'end rep 2 instructions early (skipf)
'-'             if_z            wrlut   b, ptrb--               'save it to LUT RAM
	byte	$ff, $e7, $37, $ac
'-'             if_z            wrlut   c, ptrb--               'save it to LUT RAM
	byte	$ff, $e9, $37, $ac
'-' endpatchtext
'-'                             mov     ptrb, save              'restore ptrb
	byte	$f1, $f3, $03, $f6
'-' p5                          setq2   #COLS-1                 'write all column pixels to HUB RAM
	byte	$29, $9e, $64, $fd
'-' p11                         wrlong  $200-COLS, ptrb         'from LUT storage
	byte	$80, $61, $67, $fc
'-' 
'-'                             'do both cursors here
'-' p8                          bitz    increment, #2           'setup whether cursor is doubled
	byte	$02, $34, $86, $f4
'-'                             bitz    scaling, #0               'and multiply offset accordingly
	byte	$00, $16, $86, $f4
'-' 
'-'                             rep     @endcursor, #2          'repeat twice for two cursors
	byte	$02, $28, $dc, $fc
'-'                             mov     c, cursor1+0            'get cursor data
	byte	$0c, $e8, $03, $f6
'-'                             xor     $-1, #1                 'alternate cursors
	byte	$01, $10, $66, $f5
'-'                             getbyte a, c, #2                'get cursor's x position (col)
	byte	$f4, $e5, $f3, $f8
'-' scaling                     shl     a, #2+0                 'transform x to long address offset
	byte	$02, $e4, $67, $f0
'-'                             add     a, ptrb                 'add offset to start of line buffer
	byte	$f9, $e5, $03, $f1
'-'                             getnib  b, c, #2
	byte	$f4, $e7, $53, $f8
'-'                             sub     b, #1 wc
	byte	$01, $e6, $97, $f1
'-'                             subr    b, rowheight
	byte	$eb, $e7, $c3, $f2
'-'             if_nc           cmp     b, rowscan wcz          'compare this scanline count
	byte	$ef, $e7, $1b, $32
'-'                             testb   c, #13 xorc
	byte	$0d, $e8, $d7, $f4
'-'                             getbyte b, c, #3                'get cursor's y position (row)
	byte	$f4, $e7, $fb, $f8
'-'             if_z_or_c       cmp     b, row wz               'check if cursor is on this row
	byte	$ec, $e7, $0b, $e2
'-'                             testb   c, #15 andz             'check if cursor is enabled
	byte	$0f, $e8, $4f, $f4
'-' 
'-'                             testb   c, #12 wc               'select the blink phase to apply
	byte	$0c, $e8, $17, $f4
'-' cursflash                   testb   fieldcount, #4-0 xorc   'get flashing bit from field count
	byte	$04, $3e, $d7, $f4
'-'             if_c            testb   c, #14 andz             'if blink, apply blink to z
	byte	$0e, $e8, $4f, $c4
'-' 
'-'                          '  setnib  c, c, #1                'replicate colour nibble in byte 0
'-'                             movbyts c, #0                   'replicate colour over all 8 pixels
	byte	$00, $e8, $ff, $f9
'-' wr1         if_z            wrlong  c, a                    'write cursor color to line buffer
	byte	$f2, $e9, $63, $ac
'-' increment                   add     a, #0-0 wc              'advance to next long if wide text
	byte	$00, $e4, $17, $f1
'-' wr2         if_z            wrlong  c, a                    'repeat to get double wide cursor
	byte	$f2, $e9, $63, $ac
'-' endcursor
'-'                             testbn  modedata, #11 wz        'z=1 if line doubling off
	byte	$0b, $0e, $2c, $f4
'-'                             testbn  scanline, #0 orz        'z=1 if second line
	byte	$00, $dc, $af, $f4
'-'             if_z            incmod  rowscan, rowheight wc   'z=1 & c=1 if wrapped
	byte	$eb, $df, $13, $a7
'-' 
'-'                             testb   modedata, #12 andz
	byte	$0c, $0e, $4c, $f4
'-'             if_z_and_c      add     rowscan, #1
	byte	$01, $de, $07, $81
'-'             if_z_and_nc     incmod  rowscan, rowheight wc
	byte	$eb, $df, $13, $27
'-' 
'-'                             wrc     d
	byte	$6c, $ea, $63, $fd
'-' adv         if_c            add     ptra, #0-0              'advance by half or full columns
	byte	$00, $f0, $07, $c1
'-'             if_c            add     ptra, skew              'allows windowing into wider screen
	byte	$11, $f0, $03, $c1
'-'                             jmp     #selectbuf              'select next buffer to write to
	byte	$84, $00, $90, $fd
'-' 
'-' '..................................................................................................
'-' ' Code to generate next graphics scan line and handle external memory access
'-' 
'-' gen_gfx
'-'                             mov     save, ptrb              'preserve for fifo use later
	byte	$f9, $e3, $03, $f6
'-'                             mov     d, ptra                 'preserve initial source pointer
	byte	$f8, $eb, $03, $f6
'-'                             getnib  b, screenaddr1, #7
	byte	$08, $e6, $7b, $f8
'-' extm_test                   mul     b, #96 wz               'check for external memory usage
	byte	$60, $e6, $0f, $fa
'-'                             add     b, mailbox
	byte	$01, $e6, $03, $f1
'-'                             testb   modedata, #13 wc        'check transparent/sprite mode and
	byte	$0d, $0e, $14, $f4
'-'             if_c_and_z      mov     save, ptra              '...display from ptra if no ext mem
	byte	$f8, $e3, $03, $86
'-'             if_nz           getnib  a, screenaddr1, #6      'extract bank address
	byte	$08, $e4, $73, $58
'-'             if_nz           setnib  ptra, a, #6             'copy into external request
	byte	$f2, $f1, $33, $58
'-'             if_nz           setnib  ptra, #EXTMEMREQ, #7    'add memory read request to address
	byte	$0b, $f0, $3f, $58
'-' p6          if_nz           mov     a, #COLS                'transfer column "units" of memory data
	byte	$50, $e4, $07, $56
'-'             if_nz           shl     a, bppidx               '...multiplied by bpp into HUB RAM
	byte	$ea, $e5, $63, $50
'-'             if_nz           setq    #2-1                    'write 2 values
	byte	$28, $02, $64, $5d
'-'             if_nz           wrlong  save, b                 'setup memory request information
	byte	$f3, $e3, $63, $5c
'-'                             sub     b, #4
	byte	$04, $e6, $87, $f1
'-'             if_nz           wrlong  ptra, b                 'initiate memory read request
	byte	$f3, $f1, $63, $5c
'-'             if_nz           add     ptra, linebufsize       'increase ptra by this amount
	byte	$04, $f0, $03, $51
'-'                             bitnz   statusaddr, #20         'remember for late mouse render
	byte	$14, $00, $a4, $f4
'-'             if_c_or_nz      jmp     #copy_done              'no need to do any copy this time
	byte	$28, $00, $90, $dd
'-' 
'-'                             testb   modedata, #10 wc        'check for pixel width doubling
	byte	$0a, $0e, $14, $f4
'-'             if_nc           setd    writeback, #$188        'no doubling, copied from same addr
	byte	$88, $83, $b6, $39
'-'             if_c            setd    writeback, #$110        'data copied from different place
	byte	$10, $83, $b6, $c9
'-'                             mov     c, transfers            'setup number of read burst loops
	byte	$ec, $e9, $03, $f6
'-' transferloop                setq2   #0-0                    'block copy from HUB source to LUT
	byte	$29, $00, $64, $fd
'-'                             rdlong  $188, ptra++
	byte	$61, $11, $07, $fb
'-' double      if_c            callpb  #0-0, #doublepixels     'double pixels when enabled
	byte	$1a, $00, $5c, $cb
'-' burst                       setq2   #0-0                    'setup output burst for hub writes
	byte	$29, $00, $64, $fd
'-' writeback                   wrlong  $0-0, ptrb++            '...and write back to line buffer
	byte	$e1, $01, $64, $fc
'-'                             djnz    c, #transferloop        'repeat
	byte	$fa, $e9, $6f, $fb
'-' copy_done
'-'                             add     ptra, skew              'allow for some horizontal panning
	byte	$11, $f0, $03, $f1
'-'                             testbn  scanline, #0 wz         'check odd/even line state
	byte	$00, $dc, $2f, $f4
'-'                             testb   modedata, #11 wc        'check for line doubled mode
	byte	$0b, $0e, $14, $f4
'-'             if_c_and_nz     mov     ptra, d                 'rewind source ptr to repeat line
	byte	$f5, $f1, $03, $46
'-' 
'-' selectbuf                   testb   ptrb, #31 wz
	byte	$1f, $f2, $0f, $f4
'-'             if_nz           mov     ptrb, linebuf1
	byte	$02, $f2, $03, $56
'-'             if_z            mov     ptrb, linebuf2
	byte	$03, $f2, $03, $a6
'-' 
'-'                             sub     wrap, #1 wz             'check for wrap around to 2nd buf
	byte	$01, $20, $8c, $f1
'-'             if_z            mov     ptra, screenaddr2       'handle it
	byte	$09, $f0, $03, $a6
'-'             if_z            mov     screenaddr1,screenaddr2 'copy into screenaddr1 for later
	byte	$09, $10, $00, $a6
'-'                             testb   modedata, #9 wc
	byte	$09, $0e, $14, $f4
'-'             if_c_and_z      mov     wrap, rowscan
	byte	$ef, $21, $00, $86
'-' setrowscan  if_z_and_nc     mov     rowscan, #0
	byte	$00, $de, $07, $26
'-'             if_z_and_nc     mov     d, #1
	byte	$01, $ea, $07, $26
'-'             if_nc           add     row, d
	byte	$f5, $d9, $03, $31
'-' 
'-'                             add     scanline, #1
	byte	$01, $dc, $07, $f1
'-'                             bitl    statusaddr, #20 wcz     'test&clear when mouse is rendered
	byte	$14, $00, $1c, $f4
'-'                             testb   modedata, #15 wz        'test if mouse shown in this region
	byte	$0f, $0e, $0c, $f4
'-'                             getword d, status, #0           'get current scanline from top in d
	byte	$12, $ea, $33, $f9
'-'              if_z_and_c     rdlong  a, b                    'check the ext memory request status
	byte	$f3, $e5, $03, $8b
'-'              if_z_and_c     tjs     a, #$-1                 'wait until complete line is read
	byte	$fe, $e5, $b7, $8b
'-' 
'-'              if_z           callpb  save, #do_mouse
	byte	$3a, $e3, $57, $ab
'-' '            if_z_and_nc     callpb  save, #do_mouse         'c=0, render the mouse before hsync
'-' nullmode                                                    'c=1 is returned for a late mouse
'-'             _ret_           setbyte status, #0, #3          'update status - doing active lines
	byte	$00, $24, $dc, $08
'-' 
'-' '..................................................................................................
'-' ' Code to double pixels in all the different colour depths
'-' 
'-' doublepixels
'-'                             push    ptra                    'preserve current pointers
	byte	$2a, $f0, $63, $fd
'-'                             push    ptrb
	byte	$2a, $f2, $63, $fd
'-'                             mov     ptra, #$188             'setup pointers for LUT accesses
	byte	$88, $f1, $07, $f6
'-'                             mov     ptrb, #$110
	byte	$10, $f3, $07, $f6
'-' doubleloop                  rep     #0-0, pb                'patched pixel doubling loop count
	byte	$f7, $01, $d8, $fc
'-'                             skipf   pattern                 '1  2  4  8 16 32
	byte	$32, $d6, $63, $fd
'-'                             rdlut   a, ptra++               '*  *  *  *  *  *
	byte	$61, $e5, $a7, $fa
'-'                             setq    nibblemask              '      *
	byte	$28, $fc, $62, $fd
'-'                             splitw  a                       '   *
	byte	$62, $e4, $63, $fd
'-'                             mov     b, a                    '*  *  *  *  *
	byte	$f2, $e7, $03, $f6
'-'                             movbyts a, #%%2020              '   *
	byte	$88, $e4, $ff, $f9
'-'                             movbyts a, #%%1100              '      *  *
	byte	$50, $e4, $ff, $f9
'-'                             movbyts a, #%%1010              '*           *
	byte	$44, $e4, $ff, $f9
'-'                             wrlut   a, ptrb++               '               *
	byte	$e1, $e5, $37, $fc
'-'                             mergeb  a                       '   *
	byte	$61, $e4, $63, $fd
'-'                             mergew  a                       '*
	byte	$63, $e4, $63, $fd
'-'                             mov     pb, a                   '      *
	byte	$f2, $ef, $03, $f6
'-'                             shl     pb, #4                  '      *
	byte	$04, $ee, $67, $f0
'-'                             muxq    a, pb                   '      *
	byte	$f7, $e5, $f3, $f9
'-'                             wrlut   a, ptrb++               '*  *  *  *  *  *Short 32bpp loop
	byte	$e1, $e5, $37, $fc
'-'                             movbyts b, #%%3131              '   *           |returns here but
	byte	$dd, $e6, $ff, $f9
'-'                             movbyts b, #%%3322              '      *  *     |falls through at
	byte	$fa, $e6, $ff, $f9
'-'                             movbyts b, #%%3232              '*           *  |end after its REP
	byte	$ee, $e6, $ff, $f9
'-'                             mergew  b                       '*              |block completes.
	byte	$63, $e6, $63, $fd
'-'                             mergeb  b                       '   *           |
	byte	$61, $e6, $63, $fd
'-'                             mov     pb, b                   '      *        |
	byte	$f3, $ef, $03, $f6
'-'                             shl     pb, #4                  '      *        |
	byte	$04, $ee, $67, $f0
'-'                             muxq    b, pb                   '      *        |
	byte	$f7, $e7, $f3, $f9
'-'                             wrlut   b, ptrb++               '*  *  *  *  *  |<skipped for 32bpp
	byte	$e1, $e7, $37, $fc
'-'                             jmp     #exitmouse              'share common code to restore ptrs
	byte	$5c, $fd, $9f, $fd
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-' ' Initialized data
'-' '--------------------------------------------------------------------------------------------------
'-' '                   __instr_skip_patterns____instcount
'-' doublebits  long    %01111001101110110110110_000001001
	byte	$09, $6c, $bb, $79
'-' doublenits  long    %01110111001111011100010_000001010
	byte	$0a, $c4, $3d, $77
'-' doublenibs  long    %00001110100001111010100_000001110
	byte	$0e, $a8, $87, $0e
'-' doublebytes long    %01111110101111111010110_000000111
	byte	$07, $ac, $bf, $7e
'-' doublewords long    %01111101101111110110110_000000111
	byte	$07, $6c, $bf, $7d
'-' doublelongs long    %10000000001111101111110_000000100
	byte	$04, $fc, $3e, $80
'-' 
'-' nibblemask  long    $0ff00ff0
	byte	$f0, $0f, $f0, $0f
'-' 
'-' bpptable
'-'             long    $0001_00_08                             '1bpp
	byte	$08, $00, $01, $00
'-'             long    $0003_00_08                             '2bpp
	byte	$08, $00, $03, $00
'-'             long    $000F_00_0C                             '4bpp
	byte	$0c, $00, $0f, $00
'-'             long    $00FF_00_14                             '8bpp
	byte	$14, $00, $ff, $00
'-'             long    $FFFF_00_24                             '16bpp
	byte	$24, $00, $ff, $ff
'-'             long    $0000_00_44                             '32bpp
	byte	$44, $00, $00, $00
'-' 
'-' modetable             'bppidx_gfxburst_transfer_nib7_nib4
'-'             long    %00000000_00000000_00000001_0111_0010 + ((COLS/2)-1-(COLS/4)) << 16
	byte	$72, $01, $13, $00
'-'             long    %00000001_00000000_00000001_0111_0100 + ((COLS/2)-1) << 16
	byte	$74, $01, $27, $01
'-'             long    %00000010_00000000_00000010_0111_0110 + ((COLS/2)-1) << 16
	byte	$76, $02, $27, $02
'-'             long    %00000011_00000000_00000100_0111_1000 + ((COLS/2)-1) << 16
	byte	$78, $04, $27, $03
'-'             long    %00000011_00000000_00000100_1011_0011 + ((COLS/2)-1) << 16
	byte	$b3, $04, $27, $03
'-'             long    %00000011_00000000_00000100_1011_0100 + ((COLS/2)-1) << 16
	byte	$b4, $04, $27, $03
'-'             long    %00000100_00000000_00001000_1011_0101 + ((COLS/2)-1) << 16
	byte	$b5, $08, $27, $04
'-'             long    %00000101_00000000_00010000_1011_0110 + ((COLS/2)-1) << 16
	byte	$b6, $10, $27, $05
'-'             long    %00000011_00000000_00000100_1011_0010 + ((COLS/2)-1) << 16
	byte	$b2, $04, $27, $03
'-' 
'-' 
'-'                     '_CHNL0_(R)__CHNL1_(G)__CHNL0_(B)_
'-' sync_000    long    %1101010100_1101010100_1101010100_11    '-vsync -hsync
	byte	$53, $4d, $35, $d5
'-' sync_001    long    %1101010100_1101010100_0010101011_10    '-vsync +hsync
	byte	$ae, $42, $35, $d5
'-' sync_002    long    %1101010100_1101010100_0101010100_11    '+vsync -hsync
	byte	$53, $45, $35, $d5
'-' sync_003    long    %1101010100_1101010100_1010101011_10    '+vsync +hsync
	byte	$ae, $4a, $35, $d5
'-' 
'-' m_bs        long    $7fe10000 + H_FP                        'front porch before sync
	byte	$10, $00, $e1, $7f
'-' m_sn        long    $7fe10000 + H_SYNC                      'sync
	byte	$60, $00, $e1, $7f
'-' m_br        long    $7fe10000                               'breezeway
	byte	$00, $00, $e1, $7f
'-' m_cb        long    $7fe10000                               'colour burst
	byte	$00, $00, $e1, $7f
'-' m_bv        long    $7fe10000 + H_BP                        'back porch before visible
	byte	$30, $00, $e1, $7f
'-' 
'-' m_vi        long    $7fe10000 + H_VISIBLE + H_FP            'visible
	byte	$90, $02, $e1, $7f
'-' m_rf        long    $7fe60000 + H_VISIBLE                   'visible 8x4b for LUT lookup
	byte	$80, $02, $e6, $7f
'-' 
'-' m_brdr      long    $7fe10000
	byte	$00, $00, $e1, $7f
'-' m_half      long    $7fe10000 + 864/2
	byte	$b0, $01, $e1, $7f
'-' m_slim      long    $7fe10000 + 432 - 64 - 68
	byte	$2c, $01, $e1, $7f
'-' 
'-' 
'-' 
'-' colourburst long    COLOUR_BURST_PAL                        'colour burst colour (patched)
	byte	$01, $51, $a3, $d8
'-' vis_pixels  long    H_VISIBLE
	byte	$80, $02, $00, $00
'-' vis_lines   long    V_VISIBLE
	byte	$e0, $01, $00, $00
'-' fieldcount  long    0
	byte	$00, $00, $00, $00
'-' 
'-' cmodval
'-' lutoffset   long    setupcode - videodriver                 'offset of LUT init code in HUB
	byte	$38, $07, $00, $00
'-' videomode
'-' vsyncpin    long    %1111111111_00                          'used to flip hsync
	byte	$fc, $0f, $00, $00
'-' dacmode_s                                                   'hsync 123-ohm 3.3V value below
'-' hsync0      long    %0000_0000_000_1011000000000_01_00000_0
	byte	$40, $00, $16, $00
'-' dacmode_c                                                   'R/G/B 75-ohm 2.0V value below
'-' hsync1      long    %0000_0000_000_1011100000000_01_00000_0
	byte	$40, $00, $17, $00
'-' 
'-' fieldparams
'-' palflipcq   long    0
	byte	$00, $00, $00, $00
'-' globalmouse long    0
	byte	$00, $00, $00, $00
'-' borders     long    0
	byte	$00, $00, $00, $00
'-' brdrcolour  long    0
	byte	$00, $00, $00, $00
'-' regionsize  long    0
	byte	$00, $00, $00, $00
'-' cq          long    CV_PAL_EVEN
	byte	$80, $09, $30, $c6
'-' font                                                        '64 entry font table stored here
'-'                                                             '...as well as scratch/sync code
'-' 
'-'             ' SDTV interlaced sync code (larger PAL variant is coded, NTSC is patched over this)
'-' 
'-' interlacedsd                                                'some different sync code patches
'-' cy                          testb   fieldcount, #0 wc       'field interlace state
	byte	$00, $3e, $17, $f4
'-' ci          if_c            call    #\hsync                 'deal with interlaced field lines
	byte	$52, $00, $a0, $cd
'-'             if_c            xcont   m_slim, hsync0          'send a slim half line
	byte	$a2, $37, $c3, $cc
'-' bitmask
'-' ntsc1                       rep #2, #5-0                    'defaults to PAL
	byte	$05, $04, $dc, $fc
'-' muxmask                     xcont   sync_000, hsync1        'generate horizontal blanking/sync
	byte	$a3, $1d, $c3, $fc
'-' offset                      xcont   sync_001, hsync0
	byte	$a2, $1f, $c3, $fc
'-' 
'-'                             decod   status, #31             'update status - in vertical sync
	byte	$1f, $24, $c4, $f9
'-' bpp                         setbyte status, fieldcount, #2  'update field counter in status
	byte	$9f, $25, $d0, $f8
'-' writestat                   wrlong  status, statusaddr
	byte	$00, $24, $60, $fc
'-' 
'-' ntsc2                       rep #2, #5-0                    'defaults to PAL
	byte	$05, $04, $dc, $fc
'-'                             xcont   sync_002, hsync1        'generate horizontal blanking/sync
	byte	$a3, $21, $c3, $fc
'-'                             xcont   sync_003, hsync0
	byte	$a2, $23, $c3, $fc
'-' 
'-' ntsc3                       rep #2, #5-0                    'defaults to PAL
	byte	$05, $04, $dc, $fc
'-'                             xcont   sync_000, hsync1        'generate horizontal blanking/sync
	byte	$a3, $1d, $c3, $fc
'-'                             xcont   sync_001, hsync0
	byte	$a2, $1f, $c3, $fc
'-'                                                             'PAL variant below is the default
'-'                                                             'while NTSC gets patched
'-' ntsc4       if_c            xor     patchvbp, #1            'generate CQ XOR flip on fields 2,3
	byte	$01, $46, $64, $c5
'-' ntsc5       if_c            callpa  #1, #$+(blank_pal-syncspace-ntsc5+interlacedsd)  'relocated call
	byte	$09, $02, $4c, $cb
'-' ntsc6       if_nc           xcont   m_half, hsync0          'remainder after half line (PAL)
	byte	$a2, $35, $c3, $3c
'-' 
'-' 
'-'                 ' HDTV interlaced sync code
'-' 
'-' interlacedhd
'-'                             testb   fieldcount, #0 wc       'get field interlace state
	byte	$00, $3e, $17, $f4
'-'             if_c            call    #\hsync                 'deal with interlaced field lines
	byte	$52, $00, $a0, $cd
'-'             if_c            xcont   m_half, hsync0          'send a half line with sync high
	byte	$a2, $35, $c3, $cc
'-' 
'-'             if_c            mov     a, m_vi
	byte	$97, $e5, $03, $c6
'-'             if_nc           mov     a, m_half
	byte	$9a, $e5, $03, $36
'-' 
'-'                             decod   status, #31             'update status - in vertical sync
	byte	$1f, $24, $c4, $f9
'-'                             setbyte status, fieldcount, #2  'update field counter in status
	byte	$9f, $25, $d0, $f8
'-' 
'-' hdloopstart                 mov     b, #10-0
	byte	$0a, $e6, $07, $f6
'-' hdloop                      call    #\hsync
	byte	$52, $00, $a0, $fd
'-'                             xcont   m_half, hsync1
	byte	$a3, $35, $c3, $fc
'-'                             xcont   m_bs, hsync0
	byte	$a2, $25, $c3, $fc
'-'                             djnz    b, #hdloop
	byte	$fc, $e7, $6f, $fb
'-' 
'-'                             call    #\hsync
	byte	$52, $00, $a0, $fd
'-'                             xcont   m_half, hsync0          'generate horizontal blanking/sync
	byte	$a2, $35, $c3, $fc
'-'                             xcont   m_bs, hsync0
	byte	$a2, $25, $c3, $fc
'-'                             call    #\hsync
	byte	$52, $00, $a0, $fd
'-'                             xcont   a, hsync0
	byte	$a2, $e5, $c3, $fc
'-'             if_nc           xcont   m_bs, hsync0
	byte	$a2, $25, $c3, $3c
'-' 
'-'             org     font+64                                 'pad out remainder of font/scratch area
'-' '--------------------------------------------------------------------------------------------------
'-' ' Uninitialized data
'-' '--------------------------------------------------------------------------------------------------
'-' 
'-' bppidx      res     1
'-' bppidx      res     1
'-' rowheight                                   'name used in text mode only
'-' pattern     res     1                       'name used in gfx mode only
'-' pattern     res     1                       'name used in gfx mode only
'-' row                                         'name used in text mode only
'-' transfers   res     1                       'name used in gfx mode only
'-' transfers   res     1                       'name used in gfx mode only
'-' palselect   res     1
'-' palselect   res     1
'-' scanline    res     1
'-' scanline    res     1
'-' rowscan     res     1
'-' rowscan     res     1
'-' pixels      res     1
'-' pixels      res     1
'-' 
'-' save        res     1
'-' save        res     1
'-' a           res     1
'-' a           res     1
'-' b           res     1
'-' b           res     1
'-' c           res     1
'-' c           res     1
'-' d           res     1
'-' d           res     1
'-' 
'-'             fit     $1f6                    'ensure we fit in the COG
'-'             fit     $1f6                    'ensure we fit in the COG
'-' '--------------------------------------------------------------------------------------------------
'-' ' LUT RAM code (startup configuration only)
'-' '--------------------------------------------------------------------------------------------------
'-'             orgh
'-' setupcode
'-'             org     $200
'-' 
'-' ' temporary configuration code loaded to LUT and executed during driver startup
'-'                             rdlong  ptrb, ptra[-5]          'read pin & custom timing info
	byte	$3b, $f3, $07, $fb
'-'  '                           wrlong  c, ptra[-5]             'write our our COG ID
'-'                             mov     pb, ptrb                'make a copy to preserve things
	byte	$f9, $ef, $03, $f6
'-'                             bith    linebuf1, #31           'setup buffer toggle bit states
	byte	$1f, $04, $24, $f4
'-'                             bitl    linebuf2, #31           '..in both line buffer addresses
	byte	$1f, $06, $04, $f4
'-'                             mov     save, linebuf1          'initialize for the first time
	byte	$02, $e2, $03, $f6
'-'                             testb   ptrb, #31 wc            'test for analog (0) or digital (1)
	byte	$1f, $f2, $17, $f4
'-'             if_c            jmp     #setupdvi               'if digital, do DVI setup
	byte	$9c, $02, $90, $cd
'-'                             testb   ptrb, #30 wc            'test for TV mode (1) or RGB (0)
	byte	$1e, $f2, $17, $f4
'-'                             shl     c, #8                   'move cog ID into place for OR
	byte	$08, $e8, $67, $f0
'-'                             or      dacmode_s, c            'install cog ID into sync DAC
	byte	$f4, $45, $43, $f5
'-'                             or      dacmode_c, c            'install cog ID into colour DACs
	byte	$f4, $47, $43, $f5
'-'             if_nc           jmp     #setupvga               'if not TV mode, do VGA setup
	byte	$30, $03, $90, $3d
'-' 
'-' setuptv
'-'                             call    #\setuptiming
	byte	$1f, $03, $a0, $fd
'-'                             getnib  a, pb, #5               'extract pin group
	byte	$f7, $e5, $6b, $f8
'-'                             mul     a, #4                   'convert pin group to pin base
	byte	$04, $e4, $07, $fa
'-'                             getbyte b, pb, #3               'get syncoptions field
	byte	$f7, $e7, $fb, $f8
'-'                             testb   b, #5 wc                'test for HD sync (1), SD sync (0)
	byte	$05, $e6, $17, $f4
'-'             if_c            jmp     #hdtvsync
	byte	$7c, $01, $90, $cd
'-'                             testb   b, #2 wc                'test for composite (0), other (1)
	byte	$02, $e6, $17, $f4
'-'             if_nc           jmp     #compositevideo
	byte	$18, $00, $90, $3d
'-'                             rczr    b wcz                   'convert two lsb's into flags
	byte	$6a, $e6, $7b, $fd
'-'             if_c            jmp     #componentvideo
	byte	$10, $01, $90, $cd
'-' 
'-' s_video
'-'                             mov     cmodval, #%00_10_1000_0 'enable Y/C video generation
	byte	$50, $40, $07, $f6
'-'                             add     a, #(1<<6)              'setup two pins (Y+C)
	byte	$40, $e4, $07, $f1
'-'             if_z            add     a, #(1<<6)              'setup three pins (Y+C+Composite)
	byte	$40, $e4, $07, $a1
'-'                             jmp     #sdtvcommon
	byte	$0c, $00, $90, $fd
'-' 
'-' compositevideo
'-'                             mov     cmodval, #%00_11_1000_0 'enable composite video generation
	byte	$70, $40, $07, $f6
'-'                             and     b, #3                   'get selected output DAC ID
	byte	$03, $e6, $07, $f5
'-'                             add     a, b                    'add to DAC ID offset
	byte	$f3, $e5, $03, $f1
'-' sdtvcommon
'-'                             wrpin   dacmode_c, a            'enable DAC mode on DAC pin(s)
	byte	$f2, $47, $03, $fc
'-'                             dirh    a                       'enable pin output
	byte	$41, $e4, $63, $fd
'-'                             mov     hsync0, #1              'idle hsync
	byte	$01, $44, $07, $f6
'-'                             mov     hsync1, #2 wz           'active hsync, clear z
	byte	$02, $46, $0f, $f6
'-' 
'-'                             'sync_000 holds sync/2
'-'                             'sync_001 holds line/2 - sync/2
'-'                             'sync_002 holds line/2 - sync
'-'                             'sync_003 holds sync
'-' interlacedcommon
'-'             if_nz           setr    hsync, #$198            'remove xzero if CVBS or S-Video
	byte	$98, $a5, $ac, $59
'-'                             getword a, m_vi, #0             'get visible + front porch pixels
	byte	$97, $e5, $33, $f9
'-'                             getword b, m_bv, #0             'get back porch pixels
	byte	$96, $e7, $33, $f9
'-'                             add     a, b                    'sum them together
	byte	$f3, $e5, $03, $f1
'-'                             getword b, m_sn, #0             'get sync width to be added
	byte	$93, $e7, $33, $f9
'-'                             add     a, b                    'a contains total pixels/line (H)
	byte	$f3, $e5, $03, $f1
'-'                             mov     sync_003, b             'store the sync width
	byte	$f3, $23, $03, $f6
'-'                             shr     b, #1                   'b now contains half sync width
	byte	$01, $e6, $47, $f0
'-'                             mov     sync_000, b             'store the half sync width
	byte	$f3, $1d, $03, $f6
'-' 
'-'                             shr     a, #1 wc                'a = H/2
	byte	$01, $e4, $57, $f0
'-'                             setword m_half, a, #0           'setup m_half for half a scan line
	byte	$f2, $35, $23, $f9
'-'                             mov     b, a                    'preserve H/2
	byte	$f2, $e7, $03, $f6
'-'                             sub     a, sync_000             'a = H/2 - sync/2
	byte	$8e, $e5, $83, $f1
'-'              if_c           add     a, #1
	byte	$01, $e4, $07, $c1
'-'                             mov     sync_001, a             'save this value
	byte	$f2, $1f, $03, $f6
'-'                             sub     b, sync_003             'b = H/2 - sync
	byte	$91, $e7, $83, $f1
'-'              if_c           add     b, #1
	byte	$01, $e6, $07, $c1
'-'                             mov     sync_002, b             'save this value
	byte	$f3, $21, $03, $f6
'-'                             mov     m_slim, m_half          'compute m_slim next
	byte	$9a, $37, $03, $f6
'-'                             sub     m_slim, sync_003        'm_slim is half line - sync width
	byte	$91, $37, $83, $f1
'-'                             getword b, m_bv, #0             'get back porch pixels
	byte	$96, $e7, $33, $f9
'-'                             sub     m_slim, b               'subtract them from m_slim
	byte	$f3, $37, $83, $f1
'-'              if_c           add     m_slim, #1
	byte	$01, $36, $07, $c1
'-' 
'-'                             getbyte a, c, #0                'get colour burst pixels
	byte	$f4, $e5, $e3, $f8
'-'                             setword m_cb, a, #0             'store it in m_cb streamer mode
	byte	$f2, $2b, $23, $f9
'-'                             sub     b, a                    'subtract burst from back porch
	byte	$f2, $e7, $83, $f1
'-'                             getbyte a, c, #1                'get breezeway pixels
	byte	$f4, $e5, $eb, $f8
'-'                             setword m_br, a, #0             'store it in m_br streamer mode
	byte	$f2, $29, $23, $f9
'-'                             sub     b, a                    'compensate for breezeway size
	byte	$f2, $e7, $83, $f1
'-'             if_nz           setword m_bv, b, #0             'write updated value to back porch
	byte	$f3, $2d, $23, $59
'-'                                                             '..but not for interlaced component
'-' 
'-'                             mov     a, patchvfp
	byte	$3b, $e4, $03, $f6
'-'                             shr     a, #9
	byte	$09, $e4, $47, $f0
'-'                             test    a, #$1ff wz
	byte	$ff, $e5, $cf, $f7
'-'             if_z            mov     patchvfp, writestat     'no front porch (just equalization)
	byte	$b2, $77, $00, $a6
'-' 
'-'                             testb   pb, #27 wz              'test for NTSC/PAL (patch for NTSC)
	byte	$1b, $ee, $0f, $f4
'-'             if_nz           sets    ntsc1, #6               'NTSC uses 6 equalizing pulses
	byte	$06, $5a, $bf, $59
'-'             if_nz           sets    ntsc2, #6               'NTSC uses 6 serrated vsync pulses
	byte	$06, $66, $bf, $59
'-'             if_nz           sets    ntsc3, #6               'NTSC uses 6 equalizing pulses
	byte	$06, $6c, $bf, $59
'-'             if_nz           mov     ntsc4, #0               'not used for NTSC case
	byte	$00, $72, $07, $56
'-'             if_nz           mov     ntsc5, #0               'not used for NTSC case
	byte	$00, $74, $07, $56
'-'             if_nz           setnib  ntsc6, #%1100, #7       'turn on if_c condition for NTSC
	byte	$0c, $76, $3f, $58
'-'             if_nz           mov     colourburst, ##COLOUR_BURST_NTSC
	byte	$80, $4c, $3e, $5f, $01, $38, $07, $56
'-' 
'-'                             testb   pb, #28 wc              'test for interlaced/progressive
	byte	$1c, $ee, $17, $f4
'-'             if_z_and_nc     sets    ntsc1, #4               'prog PAL uses 4 equalizing pulses
	byte	$04, $5a, $bf, $29
'-'             if_nc           mov     cy, #0
	byte	$00, $54, $07, $36
'-'             if_nc           mov     ci, #0
	byte	$00, $56, $07, $36
'-'             if_nc           mov     ntsc4, #0
	byte	$00, $72, $07, $36
'-'             if_nc           mov     ntsc5, #0
	byte	$00, $74, $07, $36
'-'             if_nc           mov     ntsc6, #0
	byte	$00, $76, $07, $36
'-' 
'-'                             getword a, m_sn, #1             'get sync streamer mode top word
	byte	$93, $e5, $3b, $f9
'-'                             setword sync_000, a, #1         'and use to build streamer modes
	byte	$f2, $1d, $2b, $f9
'-'                             setword sync_001, a, #1
	byte	$f2, $1f, $2b, $f9
'-'                             setword sync_002, a, #1
	byte	$f2, $21, $2b, $f9
'-'                             setword sync_003, a, #1
	byte	$f2, $23, $2b, $f9
'-' 
'-'                             callpa  #interlacedsd, #copysync
	byte	$50, $54, $4f, $fb
'-'                             jmp     #setupclk               'now setup the clock
	byte	$bc, $02, $90, $fd
'-' 
'-' componentvideo
'-'                             mov     cmodval, #%00_01_1_0100 'enable component video generation
	byte	$34, $40, $07, $f6
'-'             if_nz           xor     cmodval, #%1100         'flip Y/Pr sync outputs if chosen
	byte	$0c, $40, $67, $55
'-'                             add     a, #(2<<6)+1            'skip DAC0 and setup pins (Y+Pr+Pb)
	byte	$81, $e4, $07, $f1
'-'                             wrpin   dacmode_c, a            'enable DACs in pin group
	byte	$f2, $47, $03, $fc
'-'                             dirh    a                       'enable pin group output
	byte	$41, $e4, $63, $fd
'-'                             testb   pb, #28 wz              'test for interlaced/progressive
	byte	$1c, $ee, $0f, $f4
'-' 
'-'                             mov     dobreeze, #0            'kill unwanted instructions
	byte	$00, $a8, $04, $f6
'-'                             mov     doburst, #0
	byte	$00, $ac, $04, $f6
'-'                             mov     sync_003, #0            'idle hsync, idle vsync
	byte	$00, $22, $07, $f6
'-'                             mov     sync_002, #(-BLANK_LEVEL & $ff)  'active hsync, idle vsync
	byte	$c7, $20, $07, $f6
'-'                             mov     sync_001, #0            'idle hsync, active vsync
	byte	$00, $1e, $07, $f6
'-'                             mov     sync_000, #(-BLANK_LEVEL & $ff)  'active hsync, active vsync
	byte	$c7, $1c, $07, $f6
'-'                             mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
	byte	$91, $45, $03, $f6
'-'                             mov     hsync1, sync_002        'vsync off, hsync on
	byte	$90, $47, $03, $f6
'-'             if_z            jmp     #interlacedcommon       'interlaced sync version
	byte	$e0, $fe, $9f, $ad
'-' 
'-'                             mov     proghd1, #0             'progressive sync version
	byte	$00, $82, $04, $f6
'-'                             mov     proghd3, #0
	byte	$00, $9e, $04, $f6
'-'                             mov     vsyncon, #0
	byte	$00, $84, $04, $f6
'-'                             mov     vsyncoff, #0
	byte	$00, $92, $04, $f6
'-' 
'-'                             getword m_slim, m_vi, #0        'get normal visible + fp width
	byte	$97, $37, $33, $f9
'-'                             getword a, m_sn, #0             'get normal sync width
	byte	$93, $e5, $33, $f9
'-'                             sub     m_slim, a               'save the delta for vsync interval
	byte	$f2, $37, $83, $f1
'-'                             jmp     #setupclk
	byte	$60, $02, $90, $fd
'-' 
'-' hdtvsync
'-'                             mov     cmodval, #%00_01_1000_0 'enable component video generation
	byte	$30, $40, $07, $f6
'-'                             add     a, #1                   'skip base DAC0
	byte	$01, $e4, $07, $f1
'-'                             add     a, #(2<<6)              'setup three pins (Y+Pr+Pb)
	byte	$80, $e4, $07, $f1
'-'                             wrpin   dacmode_c, a            'enable DACs on these 3 pins
	byte	$f2, $47, $03, $fc
'-'                             dirh    a                       'enable pin output
	byte	$41, $e4, $63, $fd
'-'                             testb   b, #4 wz                'check for interlaced/progressive
	byte	$04, $e6, $0f, $f4
'-'                             and     b, #7                   'use 3 lsb's as sync outputs
	byte	$07, $e6, $07, $f5
'-'                             shl     b, #1
	byte	$01, $e6, $67, $f0
'-'                             or      cmodval, b
	byte	$f3, $41, $43, $f5
'-'                             getword a, m_sn, #0             'get the sync width in pixels
	byte	$93, $e5, $33, $f9
'-'                             shr     a, #1 wc                'split it into two halves
	byte	$01, $e4, $57, $f0
'-'                             setword m_sn, a, #0             'use first half for low sync
	byte	$f2, $27, $23, $f9
'-'                             mov     m_cb, m_sn              'use second half for high sync
	byte	$93, $2b, $03, $f6
'-'             if_c            add     m_cb, #1                'compensate for any odd pixels
	byte	$01, $2a, $07, $c1
'-'                             mov     colourburst, #((+105*60/128)&$ff)
	byte	$31, $38, $07, $f6
'-'                             mov     hsync1, #((-105*60/128)&$ff)
	byte	$cf, $46, $07, $f6
'-'                             mov     hsync0, #0
	byte	$00, $44, $07, $f6
'-'             if_z            jmp     #hdtvinterlaced         'do interlaced version
	byte	$48, $00, $90, $ad
'-' 
'-' hdtvprogressive
'-'                             mov     proghd0, #0             'kill unwanted instructions
	byte	$00, $80, $04, $f6
'-'                             mov     proghd2, #0
	byte	$00, $9c, $04, $f6
'-'                             mov     vsyncon, #0
	byte	$00, $84, $04, $f6
'-'                             mov     vsyncoff, #0
	byte	$00, $92, $04, $f6
'-'                             mov     flipref, dobreeze       'rearrange streamer instructions
	byte	$54, $ae, $00, $f6
'-'                             mov     dobreeze, #0            'nop away old instruction
	byte	$00, $a8, $04, $f6
'-'                             setnib  flipref, #0, #7         'return early during normal lines
	byte	$00, $ae, $3c, $f8
'-'                             sets    bp, #hsync1             'use negative sync "colour"
	byte	$a3, $b1, $bc, $f9
'-'                             mov     m_br, m_bv              'use breezeway to do back porch
	byte	$96, $29, $03, $f6
'-'                             getword a, m_bv, #0             'get back porch width
	byte	$96, $e5, $33, $f9
'-'                             getword m_slim, m_vi, #0        'get normal visible + fp width
	byte	$97, $37, $33, $f9
'-'                             sub     m_slim, a               'save the delta for vsync interval
	byte	$f2, $37, $83, $f1
'-'                             setword m_bv, m_slim, #0        'and keep it in m_bv during vsync
	byte	$9b, $2d, $23, $f9
'-' 
'-'                             mov     sync_003, hsync0        'idle hsync, idle vsync
	byte	$a2, $23, $03, $f6
'-'                             mov     sync_002, hsync1        'active hsync, idle vsync
	byte	$a3, $21, $03, $f6
'-'                             mov     sync_001, hsync0        'idle hsync, active vsync
	byte	$a2, $1f, $03, $f6
'-'                             mov     sync_000, hsync1        'active hsync, active vsync
	byte	$a3, $1d, $03, $f6
'-'                             jmp     #setupclk
	byte	$d0, $01, $90, $fd
'-' 
'-' hdtvinterlaced
'-'                             mov     a, patchvsync           'get vertical sync line count
	byte	$48, $e4, $03, $f6
'-'                             shr     a, #9                   '...stored in the d-field
	byte	$09, $e4, $47, $f0
'-'                             shl     a, #1                   'double it (they are half lines)
	byte	$01, $e4, $67, $f0
'-'                             sets    hdloopstart, a          'patch into hd code before copy
	byte	$f2, $87, $bb, $f9
'-'                             callpa  #interlacedhd, #copysync
	byte	$0f, $78, $4f, $fb
'-' 
'-'                             getword a, m_vi, #0             'get visible + front porch pixels
	byte	$97, $e5, $33, $f9
'-'                             getword b, m_bv, #0             'get back porch pixels
	byte	$96, $e7, $33, $f9
'-'                             add     a, b                    'sum them together
	byte	$f3, $e5, $03, $f1
'-'                             getword b, m_sn, #0             'get sync width to be added
	byte	$93, $e7, $33, $f9
'-'                             add     a, b                    'a contains total pixels/line (H)
	byte	$f3, $e5, $03, $f1
'-'                             shr     a, #1                   'a is half line size
	byte	$01, $e4, $47, $f0
'-'                             mov     m_half, m_vi
	byte	$97, $35, $03, $f6
'-'                             sub     m_half, a
	byte	$f2, $35, $83, $f1
'-'                             getword a, m_bs, #0
	byte	$92, $e5, $33, $f9
'-'                             sub     m_half, a
	byte	$f2, $35, $83, $f1
'-'                             sub     patchvbp, ##$200        'one line gets used by vsync code
	byte	$01, $00, $00, $ff, $00, $46, $84, $f1
'-' 
'-'                             mov     dobreeze, #0            'nop away old instruction
	byte	$00, $a8, $04, $f6
'-'                             mov     flipref, #0
	byte	$00, $ae, $04, $f6
'-'                             jmp     #setupclk
	byte	$80, $01, $90, $fd
'-' 
'-' copysync                    setd    pa, #syncspace          'copy code into space for sync
	byte	$3f, $ec, $b7, $f9
'-'                             rep     #2, #18                 'repeat 2 instructions 18 times
	byte	$12, $04, $dc, $fc
'-'                             alti    pa, #%111_111           'auto increment
	byte	$3f, $ec, $a7, $f9
'-'                             mov     0-0, 0-0                'copy longs
	byte	$00, $00, $00, $f6
'-'                             ret
	byte	$2d, $00, $64, $fd
'-' 
'-' setupdvi                                                    'code configures for DVI
'-'                             mov     dobreeze, #0
	byte	$00, $a8, $04, $f6
'-'                             mov     doburst, #0
	byte	$00, $ac, $04, $f6
'-'                             mov     m_slim, #0
	byte	$00, $36, $07, $f6
'-'                             mov     proghd1, #0
	byte	$00, $82, $04, $f6
'-'                             mov     proghd3, #0
	byte	$00, $9e, $04, $f6
'-'                             call    #\setuptiming           'check for any timing override
	byte	$1f, $03, $a0, $fd
'-' 
'-'             if_z            xor     sync_000, vsyncpin      'setup hsync polarity
	byte	$a1, $1d, $63, $a5
'-'             if_z            xor     sync_001, vsyncpin      'flip if +hsync
	byte	$a1, $1f, $63, $a5
'-'             if_z            xor     sync_002, vsyncpin      'hsync is otherwise negative
	byte	$a1, $21, $63, $a5
'-'             if_z            xor     sync_003, vsyncpin      'vsync_pin data holds flip mask
	byte	$a1, $23, $63, $a5
'-' 
'-'             if_c            bitnot  sync_000, #11           'setup vsync polarity
	byte	$0b, $1c, $e7, $c4
'-'             if_c            bitnot  sync_001, #11           'flipping bit 11 makes +vsync
	byte	$0b, $1e, $e7, $c4
'-'             if_c            bitnot  sync_002, #11           'vsync is otherwise negative
	byte	$0b, $20, $e7, $c4
'-'             if_c            bitnot  sync_003, #11           'by default
	byte	$0b, $22, $e7, $c4
'-' 
'-'                             mov     vsyncoff, #0            'disable sync output instructions
	byte	$00, $92, $04, $f6
'-'                             mov     vsyncon, #0
	byte	$00, $84, $04, $f6
'-' 
'-'                             mov     cmodval, #%10_00_0000_0 'enable DVI in CMOD
	byte	$00, $41, $07, $f6
'-'                             getnib  a, pb, #5               'extract pin group
	byte	$f7, $e5, $6b, $f8
'-'                             bitl    a, #3 wcz               'test forward/backward DVI order
	byte	$03, $e4, $1f, $f4
'-'                             bitc    cmodval, #7             'setup in CMOD
	byte	$07, $40, $47, $f4
'-'                             shl     a, #4
	byte	$04, $e4, $67, $f0
'-'                             skipf   #%100000000
	byte	$32, $00, $66, $fd
'-'                             or      a, #$81
	byte	$81, $e4, $47, $f5
'-' setupstreamer               setbyte m_bs, a, #2
	byte	$f2, $25, $d3, $f8
'-'                             setbyte m_sn, a, #2
	byte	$f2, $27, $d3, $f8
'-'                             setbyte m_bv, a, #2
	byte	$f2, $2d, $d3, $f8
'-'                             setbyte m_vi, a, #2
	byte	$f2, $2f, $d3, $f8
'-'                             setbyte m_brdr, a, #2
	byte	$f2, $33, $d3, $f8
'-'                             add     a, #5
	byte	$05, $e4, $07, $f1
'-'                             setbyte m_rf, a, #2
	byte	$f2, $31, $d3, $f8
'-'                             ret
	byte	$2d, $00, $64, $fd
'-'                             sub     a, #$86
	byte	$86, $e4, $87, $f1
'-'                             shr     a, #1
	byte	$01, $e4, $47, $f0
'-'                             or      a, #7<<6
	byte	$c0, $e5, $47, $f5
'-' 
'-'                             wrpin   ##%10110_1111_0111_10_00000_0, a  '123 ohm BITDAC for pins
	byte	$7b, $0b, $80, $ff, $f2, $01, $0b, $fc
'-' 
'-'                             drvl    a                       'enable DVI output pins in group
	byte	$58, $e4, $63, $fd
'-'                             mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
	byte	$91, $45, $03, $f6
'-'                             mov     hsync1, sync_002        'vsync off, hsync on
	byte	$90, $47, $03, $f6
'-'                             mov     a, ##$0CCCCCCC+1        'always set frequency to 1/10 clk
	byte	$66, $66, $06, $ff, $cd, $e4, $07, $f6
'-'                             jmp     #applyclks
	byte	$f4, $00, $90, $fd
'-' 
'-' setupvga                                                    'code configures for analog/VGA
'-'                             mov     dobreeze, #0
	byte	$00, $a8, $04, $f6
'-'                             mov     doburst, #0
	byte	$00, $ac, $04, $f6
'-'                             mov     m_slim, #0
	byte	$00, $36, $07, $f6
'-'                             mov     proghd1, #0
	byte	$00, $82, $04, $f6
'-'                             mov     proghd3, #0
	byte	$00, $9e, $04, $f6
'-'                             mov     cmodval, #%00_01_0000_0
	byte	$20, $40, $07, $f6
'-'                             call    #\setuptiming           'check for any timing override
	byte	$1f, $03, $a0, $fd
'-' 
'-'                             bitnz   cmodval, #0             'set hsync polarity default
	byte	$00, $40, $a7, $f4
'-'                             getbyte vsyncpin, pb, #3        'get the vsync pin
	byte	$f7, $43, $fb, $f8
'-' 
'-'                             mov     b, vsyncpin             'get the sync/options field
	byte	$a1, $e7, $03, $f6
'-'                             and     b, #%111100             'get base pin of vsync
	byte	$3c, $e6, $07, $f5
'-' 
'-'                             getbyte a, pb, #2               'extract analog 4-pin group
	byte	$f7, $e5, $f3, $f8
'-' 
'-'                             shr     a, #1
	byte	$01, $e4, $47, $f0
'-'                             and     a, #$70
	byte	$70, $e4, $07, $f5
'-'                             or      a, #$01
	byte	$01, $e4, $47, $f5
'-'                             call    #\setupstreamer
	byte	$c5, $02, $a0, $fd
'-' 
'-'                             getnib  a, pb, #5               'extract analog 4-pin group
	byte	$f7, $e5, $6b, $f8
'-'                             mul     a, #4                   'convert to real pin base number
	byte	$04, $e4, $07, $fa
'-' 
'-'                             mov     sync_003, #0            'idle hsync, idle vsync
	byte	$00, $22, $07, $f6
'-'                             mov     sync_002, #1            'active hsync, idle vsync
	byte	$01, $20, $07, $f6
'-'                             mov     sync_001, #0            'idle hsync, active vsync
	byte	$00, $1e, $07, $f6
'-'                             mov     sync_000, #1            'active hsync, active vsync
	byte	$01, $1c, $07, $f6
'-' 
'-'                             cmp     a, b wz                 'check if pin group matches
	byte	$f3, $e5, $0b, $f2
'-' 
'-'                             ' 5pin VGA: RGBHV
'-'             if_nz           drvnc   vsyncpin                'start with inactive vsync
	byte	$5b, $42, $63, $5d
'-'                             setd    vsyncon, vsyncpin
	byte	$a1, $85, $b0, $f9
'-'             if_nz           mov     vsyncoff, vsyncon       'use correct method for vsync
	byte	$42, $92, $00, $56
'-'             if_nz           jmp     #setup_4pins            'done 5 pin VGA, go setup pins
	byte	$3c, $00, $90, $5d
'-'                             test    vsyncpin, #3 wz         'test 2 lsbs of vsync, 4 cases
	byte	$03, $42, $cf, $f7
'-'                                                             '00: RGBS 1Vp-p sync into 75ohms
'-'                                                             '01: RGB/YPrPb with sync on DAC1
'-'                                                             '10: RGB/YPrPb with sync on DAC2
'-'                                                             '11: RGB/YPrPb with sync on DAC3
'-' 
'-'                             ' 4pin VGA: RGBS (VGA with Composite Sync)
'-'             if_z            mov     dacmode_s, dacmode_c    'drive 75 ohm sync input, not ttl
	byte	$a3, $45, $03, $a6
'-'             if_z            mov     vsyncon, vsyncoff       'use correct method for vsync
	byte	$49, $84, $00, $a6
'-'             if_z            jmp     #setup_4pins
	byte	$2c, $00, $90, $ad
'-'                             ' 3pin VGA: RGB/component cases: eg. SyncOnGreen or YPrPb
'-'                             sets    vsyncoff, #0
	byte	$00, $92, $bc, $f9
'-'                             mov     vsyncon, vsyncoff
	byte	$49, $84, $00, $f6
'-'                             mov     sync_000, #0
	byte	$00, $1c, $07, $f6
'-'                             mov     sync_001, #(256-BLANK_LEVEL)
	byte	$c7, $1e, $07, $f6
'-'                             mov     sync_002, #(256-BLANK_LEVEL)
	byte	$c7, $20, $07, $f6
'-'                             mov     sync_003, #0
	byte	$00, $22, $07, $f6
'-'                             mov     b, #1
	byte	$01, $e6, $07, $f6
'-'                             and     vsyncpin, #3
	byte	$03, $42, $07, $f5
'-'                             shl     b, vsyncpin
	byte	$a1, $e7, $63, $f0
'-'                             or      cmodval, b
	byte	$f3, $41, $43, $f5
'-'                             jmp     #setup_3pins
	byte	$08, $00, $90, $fd
'-' setup_4pins
'-'                             wrpin   dacmode_s, a            'setup sync mode on DAC0 in group
	byte	$f2, $45, $03, $fc
'-'                             dirh    a                       'enable the sync pin
	byte	$41, $e4, $63, $fd
'-' setup_3pins
'-'                             add     a, #1 + (2<<6)          'setup next pin group
	byte	$81, $e4, $07, $f1
'-'                             wrpin   dacmode_c, a            'setup colour mode on DACs1-3
	byte	$f2, $47, $03, $fc
'-'                             dirh    a                       'enable this pin group
	byte	$41, $e4, $63, $fd
'-'                             mov     hsync0, sync_003        'vsync & hsync off (neg polarity)
	byte	$91, $45, $03, $f6
'-'                             mov     hsync1, sync_002        'vsync off, hsync on
	byte	$90, $47, $03, $f6
'-' 
'-' setupclk
'-'                             rdlong  a, ptrb[4]              'get xfrq value or divider
	byte	$84, $e5, $07, $fb
'-'                             getword b, a, #1                'extract upper long
	byte	$f2, $e7, $3b, $f9
'-'                             test    b wz                    'check if xrfq value or divider
	byte	$f3, $e7, $cb, $f7
'-'             if_nz           jmp     #applyclks              'for dividers, upper long is 0
	byte	$20, $00, $90, $5d
'-'                             getword c, a, #0                'get fractional pixel clock ratio
	byte	$f2, $e9, $33, $f9
'-'                             test    c wz                    'check for divide by zero case
	byte	$f4, $e9, $cb, $f7
'-' 
'-'             if_z            mov     c, ##2560               '..if so, assume divider is 10.000
	byte	$05, $00, $00, $af, $00, $e8, $07, $a6
'-'                             qfrac   #$80, c                 'divide $80_0000_0000 by ratio
	byte	$f4, $01, $29, $fd
'-'                             getqx   a                       'get quotient
	byte	$18, $e4, $63, $fd
'-'                             getqy   b wz                    'get remainder and test for 0
	byte	$19, $e6, $6b, $fd
'-'             if_nz           add     a,  #1                  'round up if a fractional result
	byte	$01, $e4, $07, $51
'-' applyclks
'-'                             call    #copymono1              'determine type of text mode possible
	byte	$38, $01, $b0, $fd
'-'                             rdlong  b, ptrb[6]              'read CFRQ parameter
	byte	$86, $e7, $07, $fb
'-'                             testb   statusaddr, #21 wz      'check if we want a delayed start
	byte	$15, $00, $0c, $f4
'-'             if_z            waitatn                         '...if so, wait for ATN
	byte	$24, $3c, $60, $ad
'-'                             cogid   c
	byte	$01, $e8, $63, $fd
'-'                             setnib  writestat1, c, #0
	byte	$f4, $45, $00, $f8
'-'                             setcmod cmodval                 'setup using cmod register
	byte	$3c, $40, $63, $fd
'-'                             setcfrq b                       'set the colour modulator rate
	byte	$3b, $e6, $63, $fd
'-'                             setxfrq a                       'set the streamer rate
	byte	$1d, $e4, $63, $fd
'-'                             jmp     #fieldloop              'begin outputting video frames
	byte	$d0, $f3, $9f, $fd
'-' 
'-' setuptiming
'-'                             zerox   ptrb, #19               'check if we have custom timing
	byte	$13, $f2, $47, $f7
'-'                             tjnz    ptrb, #customtiming     'skip if we do
	byte	$03, $f2, $9f, $fb
'-'                             mov     a, #H_SYNC_POLARITY     'setup some default polarities
	byte	$00, $e4, $07, $f6
'-'                             sub     a, #1 wz                'z=1 if positive hsync desired
	byte	$01, $e4, $8f, $f1
'-'             _ret_           ones    a, #V_SYNC_POLARITY wc  'c=1 if positive vsync desired
	byte	$00, $e4, $b7, $07
'-'                             'read in custom timing block and patch all COG code accordingly
'-' customtiming
'-'                             rdlong  a, ptrb[2]              'read custom horizontal timing
	byte	$82, $e5, $07, $fb
'-'                             getbyte b, a, #0                'get columns
	byte	$f2, $e7, $e3, $f8
'-'                             fles    b, #240                 'set maximum of 1920 pixels
	byte	$f0, $e6, $67, $f3
'-'                             mov     vis_pixels, b           'save as visible columns
	byte	$f3, $3b, $03, $f6
'-'                             mul     vis_pixels, #8          'convert to pixels
	byte	$08, $3a, $07, $fa
'-'                             sets    p1, b                   'patch columns into code
	byte	$f3, $c3, $b9, $f9
'-'                             sets    p4, b
	byte	$f3, $cb, $b9, $f9
'-'                             sets    p6, b
	byte	$f3, $61, $ba, $f9
'-'                             sets    p0, b
	byte	$f3, $0d, $b9, $f9
'-'                             mov     c, b
	byte	$f3, $e9, $03, $f6
'-'                             shl     b, #1                   'compute columns*2
	byte	$01, $e6, $67, $f0
'-'                             sets    p2, b                   'patch columns*2 into code
	byte	$f3, $c5, $b9, $f9
'-'                             shr     b, #2                   'compute columns/2
	byte	$02, $e6, $47, $f0
'-'                             sets    p3, b                   'patch columns/2 into code
	byte	$f3, $c9, $b9, $f9
'-'                             sets    p9, b
	byte	$f3, $bb, $b9, $f9
'-'                             sub     p9, #1
	byte	$01, $ba, $85, $f1
'-'                             setd    readrow, p9             'patch columns/2 - 1 into code
	byte	$dd, $b6, $b1, $f9
'-'                             add     p9, #$110
	byte	$10, $bb, $05, $f1
'-'                             mov     d, #1
	byte	$01, $ea, $07, $f6
'-'                             subr    d, b
	byte	$f3, $eb, $c3, $f2
'-'                             setd    row, #modetable+1
	byte	$86, $d9, $b7, $f9
'-'                             rep     #2, #8
	byte	$08, $04, $dc, $fc
'-'                             alti    row, #%111_000
	byte	$38, $d8, $a7, $f9
'-' settable                    setbyte 0-0, d, #2
	byte	$f5, $01, $d0, $f8
'-'                             shr     b, #1                   'compute columns/4
	byte	$01, $e6, $47, $f0
'-'                             sub     d, b
	byte	$f3, $eb, $83, $f1
'-'                             setbyte modetable, d, #2
	byte	$f5, $0b, $d3, $f8
'-'                             sets    p10, b
	byte	$f3, $bd, $b9, $f9
'-'                             sub     c, #1                   'compute columns -1
	byte	$01, $e8, $87, $f1
'-'                             setd    p5, c                   'patch columns - 1 into code
	byte	$f4, $07, $b2, $f9
'-'                             subr    c, #$1ff
	byte	$ff, $e9, $c7, $f2
'-'                             setd    p11, c
	byte	$f4, $09, $b2, $f9
'-'                             setword m_vi, vis_pixels, #0    'setup streamer blank line
	byte	$9d, $2f, $23, $f9
'-'                             setword m_rf, vis_pixels, #0    'setup streamer visible line
	byte	$9d, $31, $23, $f9
'-'                             rdword  c, ptrb[10]             'read extended sync timing
	byte	$8a, $e9, $e7, $fa
'-'                             getnib  b, c, #0                'get bits 8-11 of back porch
	byte	$f4, $e7, $43, $f8
'-'                             rolbyte b, a, #1                'get back porch pixels bits 7-0
	byte	$f2, $e7, $0b, $f9
'-'                             setword m_bv, b, #0             'setup H_BP
	byte	$f3, $2d, $23, $f9
'-'                             getnib  b, c, #1                'get bits 8-11 of horizontal sync
	byte	$f4, $e7, $4b, $f8
'-'                             rolbyte b, a, #2                'get horizontal sync pixels bits 7-0
	byte	$f2, $e7, $13, $f9
'-'                             setword m_sn, b, #0             'setup H_SYNC
	byte	$f3, $27, $23, $f9
'-'                             bitl    a, #31 wcz              'get hsync polarity into Z flag
	byte	$1f, $e4, $1f, $f4
'-'                             getbyte b, a, #3                'get front porch pixels bit6-0
	byte	$f2, $e7, $fb, $f8
'-'                             shr     c, #1                   'realign extended front porch
	byte	$01, $e8, $47, $f0
'-'                             andn    c, #$7f                 'mask 7 LSBs of unwanted data
	byte	$7f, $e8, $27, $f5
'-'                             or      b, c                    'include extended front porch bits
	byte	$f4, $e7, $43, $f5
'-'                             setword m_bs, b, #0             'setup H_FP
	byte	$f3, $25, $23, $f9
'-'                             add     m_vi, b                 'include front porch in blank line
	byte	$f3, $2f, $03, $f1
'-'                             rdlong  a, ptrb[3]              'read custom vertical timing
	byte	$83, $e5, $07, $fb
'-'                             testb   a, #31 wc               'get vsync polarity into C flag
	byte	$1f, $e4, $17, $f4
'-'                             mov     vis_lines, ##$7FF       'setup 11 bit mask
	byte	$03, $00, $00, $ff, $ff, $3d, $07, $f6
'-'                             and     vis_lines, a            'extract 11 LSb's
	byte	$f2, $3d, $03, $f5
'-'                             shr     a, #11
	byte	$0b, $e4, $47, $f0
'-'                             setd    patchvbp, a             'setup V_BP
	byte	$f2, $47, $b0, $f9
'-'                             shr     a, #9
	byte	$09, $e4, $47, $f0
'-'                             mov     b, #7                   '3 bit mask
	byte	$07, $e6, $07, $f6
'-'                             and     b, a                    'extract 3 LSB's
	byte	$f2, $e7, $03, $f5
'-'                             setd    patchvsync, b           'setup V_SYNC
	byte	$f3, $91, $b0, $f9
'-'                             shr     a, #3
	byte	$03, $e4, $47, $f0
'-'             if_c            bitnot  a, #8                   'clear this bit for next setd
	byte	$08, $e4, $e7, $c4
'-'                             setd    patchvfp, a             'setup V_FP
	byte	$f2, $77, $b0, $f9
'-'                             rdword  c, ptrb[11]             'read colour burst params
	byte	$8b, $e9, $e7, $fa
'-'                             ret                             'returned flags contain polarities!
	byte	$2d, $00, $64, $fd
'-' 
'-' copymono1
'-'                             testbn   statusaddr, #20 wc     'check if mono text is not forced
	byte	$14, $00, $34, $f4
'-'                             bitl     statusaddr, #20        'also clear this flag for later use
	byte	$14, $00, $04, $f4
'-'             if_c            cmp      a, ##$1999999B wc      'then check if at least 5x p2:pixel clock ratio
	byte	$cc, $cc, $0c, $cf, $9b, $e5, $17, $c2
'-'             if_c            ret                             'if so, return to stick with colour text
	byte	$2d, $00, $64, $cd
'-'                             sets     scaling, #0            'otherwise we can only do mono text
	byte	$00, $16, $be, $f9
'-'                             sets     p8, #0
	byte	$00, $0a, $be, $f9
'-'                             setr     wr1, #$188             'patch opcode to wrbyte
	byte	$88, $33, $ae, $f9
'-'                             setr     wr2, #$188             'patch opcode to wrbyte
	byte	$88, $37, $ae, $f9
'-'                             cmp      a, ##$2AAAAAAC wc      'check if at least 3x p2:pixel clock ratio
	byte	$55, $55, $15, $ff, $ac, $e4, $17, $f2
'-'             if_c            jmp      #copymono2             'if so, we can support text attributes
	byte	$14, $01, $90, $cd
'-'                             setnib   writestat2, #1, #0     'mono without attributes
	byte	$01, $74, $04, $f8
'-'                             mov      ptra, #p4a-$200
	byte	$99, $f1, $07, $f6
'-'                             rdlut    d, ptra
	byte	$00, $eb, $a7, $fa
'-'                             mov      c, p10                 'extract COLS/4
	byte	$de, $e8, $03, $f6
'-'                             sets     d, c                   'patch and writeback to LUT
	byte	$f4, $eb, $bb, $f9
'-'                             wrlut    d, ptra--
	byte	$7f, $eb, $37, $fc
'-'                             mov      b, c
	byte	$f4, $e7, $03, $f6
'-'                             and      c, #$1ff
	byte	$ff, $e9, $07, $f5
'-'                             shr      c, #1                  'compute COLS/8
	byte	$01, $e8, $47, $f0
'-'                             rdlut    d, ptra
	byte	$00, $eb, $a7, $fa
'-'                             sets     d, c                   'patch and writeback to LUT
	byte	$f4, $eb, $bb, $f9
'-'                             wrlut    d, ptra
	byte	$00, $eb, $37, $fc
'-'                             sub      b, #1
	byte	$01, $e6, $87, $f1
'-'                             setd     p5, b
	byte	$f3, $07, $b2, $f9
'-'                             subr     b, #$1ff
	byte	$ff, $e7, $c7, $f2
'-'                             setd     p11, b
	byte	$f3, $09, $b2, $f9
'-'                             mov      flasher, #0            'disable flashing
	byte	$00, $7c, $04, $f6
'-'                             mov      p12, #0
	byte	$00, $b0, $05, $f6
'-'                             mov      p13, #0
	byte	$00, $b2, $05, $f6
'-'                             sets     p7, #0
	byte	$00, $fa, $bc, $f9
'-'                             cmp      a, ##$4000_0002 wc     'check if at least 2x pixel clock ratio
	byte	$00, $00, $20, $ff, $02, $e4, $17, $f2
'-'             if_c            jmp      #nodisablemono         '...if so, skip disabling mono text
	byte	$24, $00, $90, $cd
'-'                             mov      c, p10                 'get COLS/4
	byte	$de, $e8, $03, $f6
'-'                             sets     d, c                   'patch instruction
	byte	$f4, $eb, $bb, $f9
'-'                             setnib   d, #$f, #7             'remove conditional execution
	byte	$0f, $ea, $3f, $f8
'-'                             setd     d, #1                  'rep loop is now one instruction
	byte	$01, $ea, $b7, $f9
'-'                             wrlut    d, ptra                'write back to LUT
	byte	$00, $eb, $37, $fc
'-'                             rdlut    d, ptra[-2]            'read two new instructions to copy
	byte	$3e, $eb, $a7, $fa
'-'                             wrlut    d, ptra[1]             'and patch LUT
	byte	$01, $eb, $37, $fc
'-'                             rdlut    d, ptra[-1]            'this text mode will only show the background
	byte	$3f, $eb, $a7, $fa
'-'                             wrlut    d, ptra[2]             'colour with no actual text
	byte	$02, $eb, $37, $fc
'-' nodisablemono
'-'                             setd     c, #patchtext
	byte	$e3, $e8, $b7, $f9
'-'                             mov      ptra, #startmono1-$200
	byte	$98, $f1, $07, $f6
'-'                             rep      #2, #(endmono1-startmono1)
	byte	$1b, $04, $dc, $fc
'-'                             alti     c, #%111_000
	byte	$38, $e8, $a7, $f9
'-'                             rdlut    0-0, ptra++
	byte	$61, $01, $a4, $fa
'-'                             ret
	byte	$2d, $00, $64, $fd
'-' 
'-' 
'-' ' this mono text mode code only support text without attributes
'-'                             wrlut   #0, ptrb--              'these instructions disable
	byte	$ff, $01, $3c, $fc
'-'                             jmp     #\endpatchtext          'mono text mode if required
	byte	$02, $01, $80, $fd
'-' startmono1
'-' p3a         if_z            rep     @endwide2, #COLS/8      'double wide mode
	byte	$0a, $32, $dc, $ac
'-' p4a         if_nz           rep     @endnormal2, #COLS/4    'single wide mode
	byte	$14, $24, $dc, $5c
'-' 
'-'                             rdlut   d, pb                   'read 2 characters
	byte	$f7, $eb, $a3, $fa
'-'                             sub     pb, #1                  'decrement LUT lookup pos
	byte	$01, $ee, $87, $f1
'-' 
'-'                             getbyte b, d, #2                'get MS char
	byte	$f5, $e7, $f3, $f8
'-'                             altgb   b, #font                'lookup font
	byte	$aa, $e7, $6f, $f9
'-'                             rolbyte c, 0-0, #0              'get pixels
	byte	$00, $e8, $03, $f9
'-' 
'-'                             getbyte b, d, #0                'get LS char
	byte	$f5, $e7, $e3, $f8
'-'                             altgb   b, #font                'lookup font
	byte	$aa, $e7, $6f, $f9
'-'                             rolbyte c, 0-0, #0              'get pixels
	byte	$00, $e8, $03, $f9
'-' 
'-'             if_z            mov     a, c                    'preserve for double wide
	byte	$f4, $e5, $03, $a6
'-'                             rdlut   d, pb                   'read next 2 chars
	byte	$f7, $eb, $a3, $fa
'-'                             sub     pb, #1                  'decrement LUT lookup pos
	byte	$01, $ee, $87, $f1
'-' 
'-'                             getbyte b, d, #2                'get MS char
	byte	$f5, $e7, $f3, $f8
'-'                             altgb   b, #font                'lookup font
	byte	$aa, $e7, $6f, $f9
'-'                             rolbyte c, 0-0, #0              'get pixels
	byte	$00, $e8, $03, $f9
'-' 
'-'                             getbyte b, d, #0                'get LS char
	byte	$f5, $e7, $e3, $f8
'-'                             altgb   b, #font                'lookup font
	byte	$aa, $e7, $6f, $f9
'-'                             rolbyte c, 0-0, #0              'get pixels
	byte	$00, $e8, $03, $f9
'-' 
'-'             if_nz           wrlut   c, ptrb--               'store normal wide pixels
	byte	$ff, $e9, $37, $5c
'-' endnormal2                  setword c, c, #1                'setup MSW
	byte	$f4, $e9, $2b, $f9
'-'                             setword a, a, #1                'setup MSW
	byte	$f2, $e5, $2b, $f9
'-'                             mergew  a                       'double pixels in wide mode
	byte	$63, $e4, $63, $fd
'-'                             mergew  c                       'double pixels in wide mode
	byte	$63, $e8, $63, $fd
'-'             if_z            wrlut   a, ptrb--               'store double wide pixels
	byte	$ff, $e5, $37, $ac
'-'             if_z            wrlut   c, ptrb--               'store double wide pixels
	byte	$ff, $e9, $37, $ac
'-' endwide2
'-'                             jmp     #\endpatchtext
	byte	$02, $01, $80, $fd
'-' endmono1
'-' 
'-' mono2flash                  mov      a, #0
	byte	$00, $e4, $07, $f6
'-'             if_z            mov      a, #$ff
	byte	$ff, $e4, $07, $a6
'-' 
'-' copymono2
'-'                             setnib   writestat2, #2, #0     'mono with attributes
	byte	$02, $74, $04, $f8
'-'                             mov      ptra, #p4b-$200
	byte	$ce, $f1, $07, $f6
'-'                             rdlut    d, ptra
	byte	$00, $eb, $a7, $fa
'-'                             sets     d, p3                  'patch COLS/2 and writeback to LUT
	byte	$e4, $ea, $bb, $f9
'-'                             wrlut    d, ptra--
	byte	$7f, $eb, $37, $fc
'-'                             rdlut    d, ptra
	byte	$00, $eb, $a7, $fa
'-'                             sets     d, p10                 'patch COLS/4 and writeback to LUT
	byte	$de, $ea, $bb, $f9
'-'                             wrlut    d, ptra
	byte	$00, $eb, $37, $fc
'-'                             mov      b, p10                 'extract COLS/4
	byte	$de, $e6, $03, $f6
'-'                             sub      b, #1                  'compute COLS/4 - 1
	byte	$01, $e6, $87, $f1
'-'                             setd     p5, b
	byte	$f3, $07, $b2, $f9
'-'                             subr     b, #$1ff
	byte	$ff, $e7, $c7, $f2
'-'                             setd     p11, b
	byte	$f3, $09, $b2, $f9
'-' 
'-'                             setd     flasher, #p13          'patch flashing register
	byte	$d9, $7c, $b4, $f9
'-'                             sets     p7, #0
	byte	$00, $fa, $bc, $f9
'-'                             mov      ptra, #(mono2flash-$200)
	byte	$b3, $f1, $07, $f6
'-'                             rdlut    p12, ptra++
	byte	$61, $b1, $a5, $fa
'-'                             rdlut    p13, ptra++
	byte	$61, $b3, $a5, $fa
'-' 
'-'                             setd     c, #patchtext
	byte	$e3, $e8, $b7, $f9
'-'                             mov      ptra, #startmono2-$200
	byte	$cd, $f1, $07, $f6
'-'                             rep      #2, #(endmono2-startmono2)
	byte	$17, $04, $dc, $fc
'-'                             alti     c, #%111_000
	byte	$38, $e8, $a7, $f9
'-'                             rdlut    0-0, ptra++
	byte	$61, $01, $a4, $fa
'-'                             ret
	byte	$2d, $00, $64, $fd
'-' 
'-' 
'-' ' this mono text mode code supports inverse and flashing attributes
'-' startmono2
'-' p3b         if_z            rep     @endwide3, #COLS/4      'double wide mode
	byte	$14, $2a, $dc, $ac
'-' p4b         if_nz           rep     @endnormal3, #COLS/2    'single wide mode
	byte	$28, $22, $dc, $5c
'-' 
'-'                             rdlut   d, pb wc                'read 2 characters, get top attr
	byte	$f7, $eb, $b3, $fa
'-'                             sub     pb, #1                  'advance source
	byte	$01, $ee, $87, $f1
'-' 
'-'                             getbyte b, d, #2                'get MS char
	byte	$f5, $e7, $f3, $f8
'-'                             altgb   b, #font                'lookup font
	byte	$aa, $e7, $6f, $f9
'-'                             rolbyte c, 0-0, #0              'get pixels
	byte	$00, $e8, $03, $f9
'-'             if_c            andn    c, a                    'if flashing set to background (0)
	byte	$f2, $e9, $23, $c5
'-'                             testb   d, #28 wc               'test for inverse attribute
	byte	$1c, $ea, $17, $f4
'-'             if_c            xor     c, #$ff                 '...and apply it
	byte	$ff, $e8, $67, $c5
'-' 
'-'                             getbyte b, d, #0                'get LS char
	byte	$f5, $e7, $e3, $f8
'-'                             altgb   b, #font                'lookup font
	byte	$aa, $e7, $6f, $f9
'-'                             rolbyte c, 0-0, #0              'get pixels
	byte	$00, $e8, $03, $f9
'-'                             testb   d, #15 wc               'test flashing attribute
	byte	$0f, $ea, $17, $f4
'-'             if_c            andn    c, a                    'if flashing set to background (0)
	byte	$f2, $e9, $23, $c5
'-'                             testb   d, #12 wc               'test for inverse attribute
	byte	$0c, $ea, $17, $f4
'-'             if_c            xor     c, #$ff                 '...and apply it
	byte	$ff, $e8, $67, $c5
'-' 
'-'                             testb   pb, #0 wc
	byte	$00, $ee, $17, $f4
'-'             if_nz_and_c     wrlut   c, ptrb--               'store normal wide pixels every second iteration
	byte	$ff, $e9, $37, $4c
'-' 
'-' endnormal3                  setword c, c, #1                'setup MSW
	byte	$f4, $e9, $2b, $f9
'-'                             mergew  c                       'double pixels in wide mode
	byte	$63, $e8, $63, $fd
'-'             if_z            wrlut   c, ptrb--               'store double wide pixels
	byte	$ff, $e9, $37, $ac
'-' endwide3
'-'                             jmp     #\endpatchtext
	byte	$02, $01, $80, $fd
'-' endmono2
'-' 
'-'             fit $400
'-'             fit $400
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-'             orgh
'-' 
'-' 
'-' 
'-' '  f_xfr        = f_pixel / f_clock * float($7FFF_FFFF)
'-' '  f_csc        = f_color / f_clock * float($7FFF_FFFF) * 2.0
'-' {
'-' }
'-' 
'-' prog240_timing     '720x240p timing @ 60Hz with 13.5MHz pixel clock
'-'             long   CLK108MHz
	byte	$fb, $1a, $10, $01
'-'             long   108000000
	byte	$00, $f3, $6f, $06
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 16<<24) | ( 64<<16) | ( 58<<8 ) | (720/8)
	byte	$5a, $3a, $40, $10
'-'             'long  (SYNC_NEG<<31) | ( 56<<24) | ( 64<<16) | ( 98<<8 ) | (640/8)
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | ( 0<<23) | (  0<<20) | ( 13<<11) | 240
	byte	$f0, $68, $00, $00
'-'             long   8<<8
	byte	$00, $08, $00, $00
'-'             long   (8<<24) + (36<<16)
	byte	$00, $00, $24, $08
'-'             'long    round(3579545.0 / 108000000.0 * float($7FFFFFFF) * 2.0)
'-'             long   284704235/2 'reserved for CFRQ parameter
	byte	$f5, $1e, $7c, $08
'-' 
'-' {
'-' }
'-' 
'-' prog288_timing     '720x288p timing @ 50Hz with 13.5MHz pixel clock
'-'             long   CLK108MHz
	byte	$fb, $1a, $10, $01
'-'             long   108000000
	byte	$00, $f3, $6f, $06
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 12<<24) | ( 64<<16) | ( 68<<8 ) | (720/8)
	byte	$5a, $44, $40, $0c
'-'             'long   (SYNC_NEG<<31) | ( 52<<24) | ( 64<<16) | (108<<8 ) | (640/8)
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 17<<11) | 288
	byte	$20, $89, $50, $00
'-'             long   8<<8
	byte	$00, $08, $00, $00
'-'             long   (16<<24) + (30<<16)
	byte	$00, $00, $1e, $10
'-'             long   352634214/2' reserved for CFRQ parameter
	byte	$b3, $62, $82, $0a
'-' 
'-' int480_timing      '720x480i timing @ 60Hz with 14.31818MHz pixel clock
'-' 
'-'         long CLK114_5MHz
	byte	$0b, $7d, $28, $01
'-'         long 114545454
	byte	$2e, $d3, $d3, $06
'-'                     '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 26<<24) | ( 68<<16) | ( 96<<8 ) | (720/8)
	byte	$5a, $60, $44, $1a
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 13<<11) | 240
	byte	$f0, $68, $50, $00
'-'             long 1<<28
	byte	$00, $00, $00, $10
'-'             long   (16<<24) + (36<<16)
	byte	$00, $00, $24, $10
'-'         long 1<<27
	byte	$00, $00, $00, $08
'-' 
'-' {
'-' }
'-' int576_timing
'-'             long   CLK141_875MHz
	byte	$fb, $e2, $7c, $01
'-'             long   141875000
	byte	$38, $d7, $74, $08
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 32<<24) | ( 66<<16) | ( 90<<8 ) | (720/8)
	byte	$5a, $5a, $42, $20
'-'             'long   (SYNC_NEG<<31) | ( 52<<24) | ( 64<<16) | (108<<8 ) | (640/8)
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | ( 0<<23) | (  5<<20) | ( 17<<11) | 287
	byte	$1f, $89, $50, $00
'-'             long   10<<8
	byte	$00, $0a, $00, $00
'-'             long   (13<<24) + (32<<16)
	byte	$00, $00, $20, $0d
'-'             long   134217728
	byte	$00, $00, $00, $08
'-' 
'-' {
'-' }
'-' 
'-' prog480_timing     '720x480p timing @ 60Hz with 27MHz pixel clock
'-'             long   CLK135MHz
	byte	$fb, $1a, $0c, $01
'-'             long   135000000
	byte	$c0, $ef, $0b, $08
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 16<<24) | ( 48<<16) | ( 74<<8 ) | (720/8)
	byte	$5a, $4a, $30, $10
'-'             'long   (SYNC_NEG<<31) | ( 16<<24) | ( 64<<16) | ( 58<<8 ) | (720/8)
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | ( 7<<23) | (  6<<20) | ( 32<<11) | 480
	byte	$e0, $01, $e1, $03
'-'             long   5<<8
	byte	$00, $05, $00, $00
'-'             long   (8<<24) + (36<<16)
	byte	$00, $00, $24, $08
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' prog576_timing     '720x576p timing @ 50Hz with 27MHz pixel clock
'-'             long   CLK135MHz
	byte	$fb, $1a, $0c, $01
'-'             long   135000000
	byte	$c0, $ef, $0b, $08
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 12<<24) | ( 48<<16) | ( 84<<8 ) | (720/8)
	byte	$5a, $54, $30, $0c
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | ( 5<<23) | (  5<<20) | ( 39<<11) | 576
	byte	$40, $3a, $d1, $02
'-'             long   5<<8
	byte	$00, $05, $00, $00
'-'             long   (8<<24) + (30<<16)
	byte	$00, $00, $1e, $08
'-'             long   176317107   ' reserved for CFRQ parameter
	byte	$b3, $62, $82, $0a
'-' 
'-' vga_timing         'VGA resolution 640x480 60Hz with 25.2MHz pixel clock
'-'             'long   CLK252MHz
'-'             'long   252000000
'-'             long 0
	byte	$00, $00, $00, $00
'-'             long 252000000
	byte	$00, $37, $05, $0f
'-' 
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)
	byte	$50, $30, $60, $10
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | ( 10<<23) | (  2<<20) | ( 33<<11) | 480
	byte	$e0, $09, $21, $05
'-'             long   10 << 8 ' $0ccccccc+1
	byte	$00, $0a, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' dvi_timing         'VGA resolution 640x480 60Hz with 25.2MHz pixel clock
'-'             long   CLK252MHz
	byte	$fb, $3e, $10, $01
'-'             long   252000000
	byte	$00, $37, $05, $0f
'-' 
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)
	byte	$50, $30, $60, $10
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | ( 10<<23) | (  2<<20) | ( 33<<11) | 480
	byte	$e0, $09, $21, $05
'-'             long   10 << 8
	byte	$00, $0a, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' vga400_timing      'VGA resolution 640x400 70Hz with 25.2MHz pixel clock
'-'             long   CLK252MHz
	byte	$fb, $3e, $10, $01
'-'             long   252000000
	byte	$00, $37, $05, $0f
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)
	byte	$50, $30, $60, $10
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_POS<<31) | ( 12<<23) | (  2<<20) | ( 35<<11) | 400
	byte	$90, $19, $21, $86
'-'             long   10 << 8
	byte	$00, $0a, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' wvga_dvi_timing   ' reduced blanking for 800x480 60Hz LCD at 27MHz pixel clk YMMV
'-'             long   CLK270MHz
	byte	$fb, $86, $24, $01
'-'             long   270000000
	byte	$80, $df, $17, $10
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | ( 16<<24) | ( 16<<16) | ( 50<<8 ) | (800/8)
	byte	$64, $32, $10, $90
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_POS<<31) | (  7<<23) | (  3<<20) | ( 20<<11) | 480
	byte	$e0, $a1, $b0, $83
'-'             long    10 << 8
	byte	$00, $0a, $00, $00
'-'             long    0
	byte	$00, $00, $00, $00
'-'             long    0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' ega_timing         'EGA resolution 640x350 70Hz with 25.2MHz pixel clock
'-'             long   CLK252MHz
	byte	$fb, $3e, $10, $01
'-'             long   252000000
	byte	$00, $37, $05, $0f
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | ( 16<<24) | ( 96<<16) | ( 48<<8 ) | (640/8)
	byte	$50, $30, $60, $90
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | ( 37<<23) | (  2<<20) | ( 60<<11) | 350
	byte	$5e, $e1, $a1, $12
'-'             long   10 << 8
	byte	$00, $0a, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' svga_timing   ' SVGA resolution 800x600 60Hz with 40MHz pixel clock
'-'             long   CLK240MHz
	byte	$fb, $3b, $10, $01
'-'             long   240_000000
	byte	$00, $1c, $4e, $0e
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | ( 40<<24) | (128<<16) | ( 88<<8 ) | (800/8)
	byte	$64, $58, $80, $a8
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_POS<<31) | (  1<<23) | (  4<<20) | ( 23<<11) | 600
	byte	$58, $ba, $c0, $80
'-'             long    6 << 8
	byte	$00, $06, $00, $00
'-'             long    0
	byte	$00, $00, $00, $00
'-'             long    0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' svga_dvi_timing   ' massively reduced blanking for 800x600 50Hz at 25.2MHz clk YMMV
'-'             long   CLK252MHz
	byte	$fb, $3e, $10, $01
'-'             long   252000000
	byte	$00, $37, $05, $0f
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | (  8<<24) | (  8<<16) | (  8<<8 ) | (800/8)
	byte	$64, $08, $08, $88
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_POS<<31) | (  2<<23) | (  2<<20) | ( 11<<11) | 600
	byte	$58, $5a, $20, $81
'-'             long    10 << 8
	byte	$00, $0a, $00, $00
'-'             long    0
	byte	$00, $00, $00, $00
'-'             long    0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' xga_timing ' 1024x768@60Hz at 65*5 MHz YMMV
'-'             long   CLK325MHz
	byte	$fb, $40, $0c, $01
'-'             long   325000000
	byte	$40, $1b, $5f, $13
'-'        '    long   CLK200MHz
'-'        '    long   200000000
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 24<<24) | (136<<16) | (160<<8 ) |(1024/8)
	byte	$80, $a0, $88, $18
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | (  3<<23) | (  6<<20) | (29<<11) | 768
	byte	$00, $eb, $e0, $01
'-'             long    5 << 8
	byte	$00, $05, $00, $00
'-'             long    0
	byte	$00, $00, $00, $00
'-'             long    0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' {sxga_timing ' 1280x1024@60Hz at 108*2 MHz YMMV  (216MHz)
'-' }
'-' 
'-' sxga_timing ' 1280x1024@60Hz at 108*3 MHz YMMV  (324MHz)
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   324000000
	byte	$00, $d9, $4f, $13
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | ( 48<<24) | (112<<16) | (248<<8 ) |(1280/8)
	byte	$a0, $f8, $70, $b0
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | (  1<<23) | (  3<<20) | ( 38<<11) | 1024
	byte	$00, $34, $b1, $00
'-'             long   3 << 8
	byte	$00, $03, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' uxga_timing ' 1600x1200@60Hz at 162*2 MHz
'-'             long   CLK325MHz
	byte	$fb, $40, $0c, $01
'-'             long   324000000
	byte	$00, $d9, $4f, $13
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | (64<<24) | (192<<16) | (48<<8 ) |(1600/8)
	byte	$c8, $30, $c0, $c0
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-' 
'-'             long   (SYNC_POS<<31) | (  1<<23) | (  3<<20) | ( 46<<11) | 1200
	byte	$b0, $74, $b1, $80
'-'             long   2 << 8
	byte	$00, $02, $00, $00
'-'                    '_Breezeway__C-Burst__FrontPorchHi__SyncWidthHi__BackPorchHi
'-'                    '  8 bits     8 bits     8 bits        4 bits        4 bits
'-'             long   (1 << 0)  ' Back porch MSBs
	byte	$01, $00, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' 
'-' wuxga_timing ' experimental 1920x1200@60Hz for Dell 2405FPW at 77*4 MHz YMMV
'-'             long   CLK308MHz
	byte	$fb, $4c, $10, $01
'-'             long   308000000
	byte	$00, $b5, $5b, $12
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | ( 16<<24) | ( 16<<16) | (128<<8 ) |(1920/8)
	byte	$f0, $80, $10, $90
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | (  8<<23) | (  3<<20) | ( 23<<11) | 1200
	byte	$b0, $bc, $30, $04
'-'             long   2<<8
	byte	$00, $02, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' hd60_timing
'-'             'long   CLK350MHz
'-'             'long   350000000
'-'             long   CLK297MHz
	byte	$fb, $28, $4d, $01
'-'             long   297000000
	byte	$40, $dc, $b3, $11
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 70<<24) | ( 80<<16) | (220<<8 ) |(1280/8)
	byte	$a0, $dc, $50, $46
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | (  5<<23) | (  5<<20) | ( 20<<11) | 720
	byte	$d0, $a2, $d0, $02
'-'             long   4<<8
	byte	$00, $04, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' hd50_timing
'-'             long   CLK297MHz
	byte	$fb, $28, $4d, $01
'-'             long   297000000
	byte	$40, $dc, $b3, $11
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_NEG<<31) | ( 16<<24) | ( 80<<16) | (220<<8 ) |(1280/8)
	byte	$a0, $dc, $50, $10
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_NEG<<31) | (  5<<23) | (  5<<20) | ( 20<<11) | 720
	byte	$d0, $a2, $d0, $02
'-'             long   4<<8
	byte	$00, $04, $00, $00
'-'                    '_Breezeway__C-Burst__FrontPorchHi__SyncWidthHi__BackPorchHi
'-'                    '  8 bits     8 bits     8 bits        4 bits        4 bits
'-'              long   (3 << 8)                         'extended front porch
	byte	$00, $03, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' fullhd_timing
'-'             long   CLK297MHz
	byte	$fb, $28, $4d, $01
'-'             long   297000000
	byte	$40, $dc, $b3, $11
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | ( 88<<24) | ( 44<<16) | (148 <<8 ) |(1920/8)
	byte	$f0, $94, $2c, $d8
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_POS<<31) | (  4<<23) | (  5<<20) | ( 36<<11) | 1080
	byte	$38, $24, $51, $82
'-'             long   2<<8
	byte	$00, $02, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' fullhd50_timing
'-'             long   CLK297MHz
	byte	$fb, $28, $4d, $01
'-'             long   297000000
	byte	$40, $dc, $b3, $11
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | ( 16<<24) | ( 44<<16) | (148 <<8 ) |(1920/8)
	byte	$f0, $94, $2c, $90
'-'            ' long   (SYNC_POS<<31) | (  0<<24) | ( 44<<16) | (252 <<8 ) |(1920/8)
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     8 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_POS<<31) | (  4<<23) | (  5<<20) | ( 36<<11) | 1080
	byte	$38, $24, $51, $82
'-'             long   2<<8
	byte	$00, $02, $00, $00
'-'                    '_Breezeway__C-Burst__FrontPorchHi__SyncWidthHi__BackPorchHi
'-'                    '  8 bits     8 bits     8 bits        4 bits        4 bits
'-'             long   (4<<8) ' 528 ' 424 '528
	byte	$00, $04, $00, $00
'-'             long   0   ' reserved for CFRQ parameter
	byte	$00, $00, $00, $00
'-' 
'-' hdint_timing
'-'             long   CLK350MHz
	byte	$fb, $45, $0c, $01
'-'             long   350000000
	byte	$80, $93, $dc, $14
'-'                    '_HSyncPolarity___FrontPorch__SyncWidth___BackPorch__Columns
'-'                    '     1 bit         7 bits      8 bits      8 bits    8 bits
'-'             long   (SYNC_POS<<31) | ( 44<<24) | ( 88<<16) | (148<<8 ) |(1920/8)
	byte	$f0, $94, $58, $ac
'-' 
'-'                    '_VSyncPolarity___FrontPorch__SyncWidth___BackPorch__Visible
'-'                    '     1 bit         8 bits      3 bits      9 bits   11 bits
'-'             long   (SYNC_POS<<31) | (  2<<23) | (  5<<20) | ( 15<<11) | 540
	byte	$1c, $7a, $50, $81
'-'             long   5<<8
	byte	$00, $05, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00
'-'             long   0
	byte	$00, $00, $00, $00, $30, $00, $00, $00, $31, $00, $00, $00, $32, $00, $00, $00
	byte	$33, $00, $00, $00, $34, $00, $00, $00, $35, $00, $00, $00, $36, $00, $00, $00
	byte	$37, $00, $00, $00, $38, $00, $00, $00, $39, $00, $00, $00, $41, $00, $00, $00
	byte	$42, $00, $00, $00, $43, $00, $00, $00, $44, $00, $00, $00, $45, $00, $00, $00
	byte	$46, $00, $00, $00
	alignl
_usbnew_0016_dat_
'-'                 org     $000
'-' 
'-' usb_host_start
'-'                 mov     hcog_base_addr, ptrb
	byte	$f9, $8f, $02, $f6
'-' 
'-'                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
	byte	$03, $00, $00, $ff, $a0, $70, $07, $f6
'-'                 shr     htmp, #2                        ' so byte->long for the lut cell count
	byte	$02, $70, $47, $f0
'-'                 loc     pb, #@hlut_start - @usb_host_start
	byte	$bc, $04, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq2   htmp
	byte	$29, $70, $63, $fd
'-'                 rdlong  0, pb                           ' Do the hub->lut copy
	byte	$f7, $01, $00, $fb
'-' 
'-'                 loc     pb, #@usb_host_init - @usb_host_start
	byte	$60, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 jmp     pb                              ' Initialize host and enter main processing loop
	byte	$2c, $ee, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
'-' ' special because the receiving function must not respond with either STALL or
'-' ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
'-' ' non-control endpoint receives a SETUP token, or the function receives a
'-' ' corrupt packet, it must ignore the transaction
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data struct.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error code.
'-' '------------------------------------------------------------------------------
'-' txn_setup
'-'                 setbyte ep_addr_pid, #PID_SETUP, #0
	byte	$2d, $bc, $c6, $f8
'-'                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
	byte	$08, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
	byte	$03, $96, $06, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
	byte	$0c, $a2, $06, $f6
'-'                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
	byte	$f8, $ed, $03, $f6
'-' .setup
'-'                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
	byte	$24, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait
	byte	$7c, $0b, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
	byte	$f6, $f1, $03, $f6
'-'                 jmp     #.setup
	byte	$e0, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' IN/INTERRUPT transaction.
'-' ' Possible function response: STALL or NAK handshake, or DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_in
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$90, $03, $b0, $fd
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #utx_token                      ' Put IN request on the bus
	byte	$bc, $00, $b0, $fd
'-' 
'-'                 ' Fall through to urx_packet
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a packet from a device/function. As host, the only two packet types
'-' ' received are handshakes and IN DATAx.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'-' '     returned.
'-' '------------------------------------------------------------------------------
'-' urx_packet
'-'                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #urx_packet
	byte	$f4, $ff, $9f, $cd
'-'                 getct   hct2
	byte	$1a, $92, $63, $fd
'-'                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
	byte	$4e, $93, $6b, $fa
'-'                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
	byte	$05, $96, $06, $f4
'-'                 mov     newb_flg, #0                    ' Initialize for multi-byte read
	byte	$00, $a8, $06, $f6
'-' .wait_sop
'-'                 rdpin   urx, dm
	byte	$23, $a7, $8a, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #.get_pid
	byte	$08, $00, $90, $cd
'-'                 jnct2   #.wait_sop
	byte	$fc, $25, $cc, $fb
'-'         _ret_   mov     retval, #ERR_TAT
	byte	$05, $be, $06, $06
'-' .get_pid
'-'                 call    #urx_next
	byte	$28, $02, $b0, $fd
'-'                 testb   urx, #BUS_ERRB          wc
	byte	$06, $a6, $16, $f4
'-'         if_nc   jmp     #.chk_pid
	byte	$04, $00, $90, $3d
'-'         _ret_   mov     retval, #ERR_URX
	byte	$02, $be, $06, $06
'-' .chk_pid
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $52
'-'         if_nz   cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
	byte	$38, $00, $90, $ad
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
	byte	$03, $96, $16, $f4
'-'                 cmp     retval, #PID_DATA0      wz
	byte	$c3, $be, $0e, $f2
'-'    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
	byte	$28, $01, $90, $2d
'-'    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
	byte	$10, $00, $90, $8d
'-'                 cmp     retval, #PID_DATA1      wz
	byte	$4b, $be, $0e, $f2
'-'    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
	byte	$1c, $01, $90, $8d
'-'    if_z_and_nc  jmp     #.ack_resend
	byte	$04, $00, $90, $2d
'-'         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
	byte	$04, $be, $06, $06
'-' .ack_resend
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.ack_resend
	byte	$f4, $ff, $9f, $3d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 call    #utx_handshake                  ' Send handshake PID and return to caller
	byte	$98, $01, $b0, $fd
'-'         _ret_   mov     retval, #ERR_DATAX_SYNC
	byte	$09, $be, $06, $06
'-' .chk_eop
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
	byte	$1c, $00, $90, $3d
'-'                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
	byte	$c8, $01, $b0, $fd
'-'                 testb   hstatus, #EOPB          wc
	byte	$05, $96, $16, $f4
'-'         if_c    jmp     #.idle                          ' Low-speed EOP seen
	byte	$10, $00, $90, $cd
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
	byte	$04, $be, $06, $36
'-'         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
	byte	$02, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
	byte	$f4, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send a token packet with CRC5 checksum of address and endpoint. It is the
'-' ' responsibility of the caller to append the appropriate inter-packet delay,
'-' ' if one is required.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - packed with the PID, address and endpoint.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_token
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #utx_token
	byte	$f4, $ff, $9f, $3d
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$04, $0d, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync byte
	byte	$70, $01, $b0, $fd
'-'                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
	byte	$5e, $71, $03, $f6
'-'                 mov     pkt_cnt, #3
	byte	$03, $b8, $06, $f6
'-' .next_byte
'-'                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
	byte	$b8, $a5, $e2, $f8
'-'                 shr     htmp, #8                        ' Shift to next byte to send
	byte	$08, $70, $47, $f0
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $48, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$24, $03, $08, $fc
'-'                 wypin   utx, dm
	byte	$23, $a5, $22, $fc
'-'         _ret_   djnz    pkt_cnt, #.next_byte
	byte	$f9, $b9, $6e, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP/OUT/INTERRUPT transaction.
'-' ' Possible function response in order of precedence: STALL, ACK, NAK.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' '   PTRA - start address of the data buff/struct that has the bytes to send.
'-' '   pkt_data - count of DATAx payload bytes to send.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_out
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$88, $02, $b0, $fd
'-'                 call    #utx_token                      ' Put SETUP/OUT token on the bus
	byte	$b8, $ff, $bf, $fd
'-'                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
	byte	$00, $00, $c0, $ff, $f8, $01, $78, $fc
'-'                 mov     pkt_cnt, pkt_data
	byte	$58, $b9, $02, $f6
'-' 
'-'                 ' Fall through to utx_data
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
'-' ' calculated while the data byte is being shifted out. Since data stage
'-' ' success/fail is not determined until the status stage of the transaction,
'-' ' this routine is only concerned about the current DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - hub start address of the data to read.
'-' '   pkt_cnt - data payload size.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_data
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #utx_data
	byte	$f4, $ff, $9f, $cd
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
	byte	$2c, $0a, $b0, $fd
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$a8, $0c, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$14, $01, $b0, $fd
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
	byte	$03, $96, $16, $f4
'-'         if_nc   mov     utx, #PID_DATA0
	byte	$c3, $a4, $06, $36
'-'         if_c    mov     utx, #PID_DATA1
	byte	$4b, $a4, $06, $c6
'-'                 call    #utx_byte                       ' No CRC calc done on PID
	byte	$00, $01, $b0, $fd
'-'                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
	byte	$1c, $00, $90, $ad
'-' .read_byte
'-'                 rfbyte  utx                             ' Fetch data byte
	byte	$10, $a4, $62, $fd
'-'                 call    #utx_byte
	byte	$f0, $00, $b0, $fd
'-'                 rev     utx                             ' Calculate CRC while the data is shifting out
	byte	$69, $a4, $62, $fd
'-'                 setq    utx                             ' SETQ left-justifies the reflected data byte
	byte	$28, $a4, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$20, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$20, $bb, $da, $f9
'-'                 djnz    pkt_cnt, #.read_byte
	byte	$f9, $b9, $6e, $fb
'-' .send_crc
'-'                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
	byte	$e0, $bb, $e6, $f4
'-'                 getbyte utx, crc, #0
	byte	$5d, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$d0, $00, $b0, $fd
'-'                 getbyte utx, crc, #1
	byte	$5d, $a5, $ea, $f8
'-'                 call    #utx_byte                       ' Last CRC byte out
	byte	$c8, $00, $b0, $fd
'-'                 jmp     #urx_packet                     ' Handle function response/error and back to caller
	byte	$7c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
'-' ' payload bytes are received. The routine reads bytes until EOP is detected and
'-' ' expects that the packet includes at least the CRC word.
'-' '
'-' ' In control transfers, it's possible to recieve fewer data bytes than what
'-' ' was requested, which makes it difficult to determine where the data stops
'-' ' and the CRC word begins. So the CRC calculation is done on every byte of the
'-' ' packet, including the CRC word. The CRC value should then be equal to the
'-' ' USB-16 expected residual value of 0xB001.
'-' '
'-' ' The routine writes the IN packet data to a static max_packet_size buffer
'-' ' so the caller can verify IN success before writing the data to its final
'-' ' destination.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   pkt_data - max byte count expected to be in the packet.
'-' '   newb_flg - signals new byte ready when toggled.
'-' ' On exit:
'-' '   pkt_cnt - actual number of bytes read.
'-' '------------------------------------------------------------------------------
'-' urx_data
'-'                 mov     htmp2, pb
	byte	$f7, $75, $03, $f6
'-'                 mov     pb, urx_buff_p
	byte	$29, $ef, $03, $f6
'-'                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
	byte	$00, $00, $c0, $ff, $f7, $01, $88, $fc
'-'                 mov     pb, htmp2
	byte	$ba, $ef, $03, $f6
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
	byte	$00, $b8, $06, $f6
'-'                 mov     pkt_tmp, pkt_data
	byte	$58, $83, $03, $f6
'-'                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
	byte	$02, $82, $07, $f1
'-' .wait_byte
'-' ' In-line rx for max speed
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   jmp     #.get_byte                      ' New byte!
	byte	$0c, $00, $90, $5d
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_c    jmp     #.chk_crc                       ' At end-of-packet
	byte	$38, $00, $90, $cd
'-'                 jmp     #.wait_byte
	byte	$dc, $ff, $9f, $fd
'-' .get_byte
'-'                 getbyte retval, urx, #1                 ' New byte from smart pins
	byte	$53, $bf, $ea, $f8
'-'                 wfbyte  retval                          ' Add it to the data buffer
	byte	$15, $be, $62, $fd
'-'                 rev     retval                          ' Calculate CRC while next byte is shifting in
	byte	$69, $be, $62, $fd
'-'                 setq    retval                          ' SETQ left-justifies the reflected data byte
	byte	$28, $be, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$20, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$20, $bb, $da, $f9
'-' .end_crc
'-'                 add     pkt_cnt, #1
	byte	$01, $b8, $06, $f1
'-'                 cmp     pkt_cnt, pkt_tmp        wcz
	byte	$c1, $b9, $1a, $f2
'-'         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
	byte	$04, $be, $06, $16
'-'         if_a    ret
	byte	$2d, $00, $64, $1d
'-' ' For full-speed at 80MHz, the time it takes to do the final byte write and
'-' ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
'-' ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
'-' ' to miss it, so cheat a bit and look for SOP clear here.
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
	byte	$a8, $ff, $9f, $3d
'-' ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
'-' .chk_crc
'-'                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
	byte	$02, $b8, $86, $f1
'-'                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
	byte	$58, $00, $00, $ff, $01, $ba, $6e, $f5
'-'         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
	byte	$f0, $fd, $9f, $5d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$34, $09, $b0, $fd
'-' 
'-'                 ' Fall through to utx_handshake
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
'-' ' the appropriate IP delay has been inserted.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - handshake PID to send.
'-' ' On exit:
'-' '   retval unchanged.
'-' '------------------------------------------------------------------------------
'-' utx_handshake
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$b0, $0b, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$1c, $00, $b0, $fd
'-'                 mov     utx, retval
	byte	$5f, $a5, $02, $f6
'-'                 call    #utx_byte                       ' Send handshake PID
	byte	$14, $00, $b0, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
	byte	$f4, $ff, $9f, $3d
'-'                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
	byte	$4e, $99, $02, $f6
'-'                 jmp     #poll_waitx
	byte	$08, $09, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for the USB tx buffer to empty and feed it a new byte.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   utx - byte to transmit.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_byte
'-'                 testp   dp                      wc
	byte	$40, $48, $72, $fd
'-'         if_nc   jmp     #utx_byte
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$24, $03, $08, $fc
'-'                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
	byte	$1f, $94, $62, $fd
'-'         _ret_   wypin   utx, dm
	byte	$23, $a5, $22, $0c
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Fetch the next data byte of a packet. Always check receiver status for EOP.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the byte read.
'-' '   urx - the receiver status. The caller must check the hstatus reg EOP flag
'-' '     on return. If EOP is set, the byte in reg retval remains as the last byte
'-' '     received.
'-' '------------------------------------------------------------------------------
'-' urx_next
'-'                 rdpin   urx, dm
	byte	$23, $a7, $8a, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
	byte	$53, $bf, $ea, $58
'-'         if_nz   ret                                     ' New byte is priority, so return now
	byte	$2d, $00, $64, $5d
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
	byte	$d8, $ff, $9f, $4d
'-'         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
	byte	$05, $96, $26, $34
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
'-' ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
'-' ' length, and the PID is not included in the CRC calculation:
'-' '  CRC5  FRAME_NUMBER SOF (full-speed)
'-' '  CRC5  ENDP ADDRESS PID
'-' ' %00000_1111_1111111_xxxxxxxx
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - stuffed with the function endpoint, address and
'-' '     SETUP/IN/OUT/SOF PID according to the USB standard.
'-' ' On exit:
'-' '   ep_addr_pid - CRC value appended to the packet.
'-' '------------------------------------------------------------------------------
'-' calc_crc5
'-'                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
	byte	$ff, $03, $00, $ff, $ff, $bd, $06, $f5
'-'                 mov     htmp, ep_addr_pid
	byte	$5e, $71, $03, $f6
'-'                 shr     htmp, #8                        ' PID not included in CRC calc
	byte	$08, $70, $47, $f0
'-'                 mov     crc, #$1f                       ' Initial CRC5 value
	byte	$1f, $ba, $06, $f6
'-'                 rev     htmp                            ' Input data reflected
	byte	$69, $70, $63, $fd
'-'                 setq    htmp                            ' CRCNIB setup for data bits 0..7
	byte	$28, $70, $63, $fd
'-'                 crcnib  crc, #USB5_POLY
	byte	$14, $ba, $de, $f9
'-'                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
	byte	$14, $ba, $de, $f9
'-'                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
	byte	$09, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 xor     crc, #$1f                       ' Final XOR value
	byte	$1f, $ba, $66, $f5
'-'                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
	byte	$13, $ba, $66, $f0
'-'         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
	byte	$5d, $bd, $42, $05
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed/low-speed frame timing interrupt service routine.
'-' '------------------------------------------------------------------------------
'-' isr1_fsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$23, $6d, $13, $fc
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $48, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$24, $03, $08, $fc
'-'                 mov     utx, #PID_SOF
	byte	$a5, $a4, $06, $f6
'-'                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
	byte	$23, $01, $29, $fc
'-'                 call    #utx_byte                       ' Send token PID byte
	byte	$4c, $ff, $bf, $fd
'-'                 mov     icrc, #$1f                      ' Prime the CRC5 pump
	byte	$1f, $b6, $06, $f6
'-'                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
	byte	$59, $b5, $02, $f6
'-'                 rev     sof_pkt                         ' Input data reflected
	byte	$69, $b4, $62, $fd
'-'                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
	byte	$28, $b4, $62, $fd
'-'                 crcnib  icrc, #USB5_POLY
	byte	$14, $b6, $de, $f9
'-'                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
	byte	$14, $b6, $de, $f9
'-'                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
	byte	$59, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$2c, $ff, $bf, $fd
'-'                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
	byte	$08, $b4, $66, $f0
'-'                 rep     #2, #3                          ' Three data bits left to process
	byte	$03, $04, $dc, $fc
'-'                 shl     sof_pkt, #1             wc
	byte	$01, $b4, $76, $f0
'-'                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
	byte	$14, $b6, $d6, $f9
'-'                 xor     icrc, #$1f                      ' Final XOR value
	byte	$1f, $b6, $66, $f5
'-'                 getbyte utx, frame, #1                  ' Send remaining frame number bits
	byte	$59, $a5, $ea, $f8
'-'                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
	byte	$03, $b6, $66, $f0
'-'                 or      utx, icrc
	byte	$5b, $a5, $42, $f5
'-'                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
	byte	$08, $ff, $bf, $fd
'-'                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
	byte	$a3, $81, $03, $f6
'-'                 jmp     #isr1_wait
	byte	$20, $00, $90, $fd
'-' isr1_lsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $48, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$24, $03, $08, $fc
'-'                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
	byte	$23, $09, $28, $fc
'-'                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
	byte	$a2, $81, $03, $f6
'-' isr1_wait
'-'                 rqpin   utx, dm
	byte	$23, $a5, $82, $fa
'-'                 testb   utx, #SOPB                 wc
	byte	$04, $a4, $16, $f4
'-'         if_c    jmp     #isr1_wait
	byte	$f4, $ff, $9f, $cd
'-'                 add     frame, #1                       ' Next frame# and check for wrap around
	byte	$01, $b2, $06, $f1
'-'                 and     frame, ##$7ff
	byte	$03, $00, $00, $ff, $ff, $b3, $06, $f5
'-'                 waitx   isrtmp1                         ' Make sure bus is idle
	byte	$1f, $80, $63, $fd
'-'                 reti1
	byte	$f5, $ff, $3b, $fb
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a window within the 1ms frame boundary that will ensure that a
'-' ' transaction will complete before the next frame is triggered.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' wait_txn_ok
'-'                 getct   htmp2
	byte	$1a, $74, $63, $fd
'-'                 sub     htmp2, iframe_ct_base
	byte	$49, $75, $83, $f1
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    cmp     htmp2, _txn_ok_ls_      wcz
	byte	$a0, $75, $1b, $c2
'-'         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
	byte	$a1, $75, $1b, $32
'-'         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
	byte	$e8, $ff, $9f, $1d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A device connection was detected, or a bus reset was requested by the USB
'-' ' client. Set the appropriate smart pin FS/LS speed mode to match the device
'-' ' and perform a reset sequence prior to device enumeration.
'-' '------------------------------------------------------------------------------
'-' dev_reset
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
	byte	$01, $a6, $16, $f4
'-'         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
	byte	$f4, $03, $b0, $cd
'-'         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
	byte	$e0, $03, $b0, $3d
'-' reset
'-'                 setint1 #0                              ' Don't want frame interrupt while in reset
	byte	$25, $00, $64, $fd
'-'                 wypin   #OUT_SE0, dm                    ' Assert bus reset
	byte	$23, $03, $28, $fc
'-'                 waitx   _reset_hold_                    ' Spec is >= 10ms
	byte	$1f, $5a, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$23, $01, $28, $fc
'-'                 mov     frame, #0                       ' Reset the frame timespan count
	byte	$00, $b2, $06, $f6
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
	byte	$59, $71, $03, $f6
'-'                 add     htmp, #36
	byte	$24, $70, $07, $f1
'-'                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
	byte	$25, $02, $64, $fd
'-' .framewait
'-'                 cmp     frame, htmp             wcz
	byte	$b8, $b3, $1a, $f2
'-'         if_b    jmp     #.framewait
	byte	$f8, $ff, $9f, $cd
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - source address.
'-' '   PB - destination address.
'-' '   hr0 - length of copy, in bytes.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hmemcpy
'-'                 rdbyte  htmp, ptra++
	byte	$61, $71, $c7, $fa
'-'                 wrbyte  htmp, pb
	byte	$f7, $71, $43, $fc
'-'                 add     pb, #1
	byte	$01, $ee, $07, $f1
'-'         _ret_   djnz    hr0, #hmemcpy
	byte	$fc, $85, $6f, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
'-' ' loop until the errant device is disconnected.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' host_error
'-'           if ERROR_LED >= 0
'-'                 drvl    host_error_led
	byte	$58, $4c, $62, $fd
'-'           end
'-'                 jmp     #host_reset                     ' See if it works...
	byte	$9c, $07, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get HID descriptor buffer for current port
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   PB - HID descriptor buffer pointer
'-' '------------------------------------------------------------------------------
'-' get_hid_descr_buffer
'-'                 mov     pb, hdev_port
	byte	$2f, $ef, $03, $f6
'-'                 cmpsub  pb, #1
	byte	$01, $ee, $e7, $f2
'-'                 mul     pb, #HID_DESCR_LEN
	byte	$00, $ef, $07, $fa
'-'         _ret_   add     pb, hid_descr_p
	byte	$27, $ef, $03, $01
'-' 
'-' 
'-' usb16_poly_r    long    USB16_POLY
	byte	$01, $a0, $00, $00
'-' 
'-' ' USB commands and error codes
'-' cmd_data        long    0
	byte	$00, $00, $00, $00
'-' usb_err_code    long    ERR_NONE
	byte	$00, $00, $00, $00
'-' 
'-' ' Parameters block assigned at cog startup
'-' dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
	byte	$12, $00, $00, $00
'-' dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
	byte	$13, $00, $00, $00
'-' usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
	byte	$ff, $ff, $ff, $ff
'-' if ACTIVITY_LED >= 0
'-' host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
'-' end
'-' if ERROR_LED >= 0
'-' host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
	byte	$38, $00, $00, $00
'-' end
'-' hid_descr_p     long    0
	byte	$00, $00, $00, $00
'-' 'hid_report_p    long    0, 0[MAX_DEVICES]
'-' 'hkbd_report_p   long    0
'-' hub_descr_p     long    0
	byte	$00, $00, $00, $00
'-' urx_buff_p      long    0
	byte	$00, $00, $00, $00
'-' dev_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' con_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' cache_start_p   long    0
	byte	$00, $00, $00, $00
'-' cache_end_p     long    0
	byte	$00, $00, $00, $00
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_out_ptr  long    0
'-' end
'-' save_sysclk     long    0         ' Save the current sysclock as the client may change it
	byte	$00, $00, $00, $00
'-' 
'-' hdev_init_start
'-' hdev_port       res     1
'-' hdev_port       res     1
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' kbm_next_datax  res     1
'-' kbm_next_datax  res     1
'-' hub_intf_num    res     1
'-' hub_intf_num    res     1
'-' hub_next_datax  res     1
'-' hub_next_datax  res     1
'-' hub_status_chg  res     1
'-' hub_status_chg  res     1
'-' hub_port_status res     1
'-' hub_port_status res     1
'-' if HAVE_MOUSE
'-' ms_intf_num     res     1
'-' ms_in_max_pkt   res     1
'-' end
'-' kb_intf_num     res     1
'-' kb_intf_num     res     1
'-' kb_interval     res     1
'-' kb_interval     res     1
'-' kb_in_max_pkt   res     1
'-' kb_in_max_pkt   res     1
'-' kb_max_index    res     1
'-' kb_max_index    res     1
'-' kb_led_states   res     1
'-' kb_led_states   res     1
'-' gp_intf_num     res     1
'-' gp_intf_num     res     1
'-' gp_interval     res     1
'-' gp_interval     res     1
'-' gp_max_index    res     1
'-' gp_max_index    res     1
'-' gp_descr_len    res     1+MAX_DEVICES
'-' gp_descr_len    res     1+MAX_DEVICES
'-' hdev_init_end
'-' 
'-' ' Initialized at cog startup:
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' iframe_ct_new   res     1
'-' iframe_ct_new   res     1
'-' iframe_ct_base  res     1
'-' iframe_ct_base  res     1
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' 
'-' ' This register block is reset to zero when a USB device connects
'-' hreg_init_start
'-' hstatus         res     1         ' Host status flags
'-' hstatus         res     1         ' Host status flags
'-' hctwait         res     1         ' Poll-based wait clocks
'-' hctwait         res     1         ' Poll-based wait clocks
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' xfer_retry      res     1         ' Control transfer retry count
'-' xfer_retry      res     1         ' Control transfer retry count
'-' retry           res     1         ' Transaction retry count
'-' retry           res     1         ' Transaction retry count
'-' utx             res     1         ' Byte to transmit on USB
'-' utx             res     1         ' Byte to transmit on USB
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' frame           res     1         ' USB 1ms frame counter value
'-' frame           res     1         ' USB 1ms frame counter value
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' crc             res     1         ' Used for CRC16 calculation
'-' crc             res     1         ' Used for CRC16 calculation
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' retval          res     1         ' Global success/fail return parameter
'-' retval          res     1         ' Global success/fail return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' ' Device stuff
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_bcd        res     1
'-' hdev_bcd        res     1
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' ' Keyboard/mouse stuff
'-' hctrl_ep_addr   res     1
'-' hctrl_ep_addr   res     1
'-' hctrl_max_pkt   res     1
'-' hctrl_max_pkt   res     1
'-' hconfig_base    res     1
'-' hconfig_base    res     1
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_class      res     1
'-' hdev_class      res     1
'-' hdev_subclass   res     1
'-' hdev_subclass   res     1
'-' hdev_protocol   res     1
'-' hdev_protocol   res     1
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' if HAVE_MOUSE
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' end
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_out_addr   res     1
'-' hdev_out_addr   res     1
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
'-' end
'-' 
'-' hreg_init_end
'-' 
'-' hidr_start
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_flags      res     1
'-' hidr_flags      res     1
'-' hidr_axis       res     4
'-' hidr_axis       res     4
'-' hidr_buttons    res     1
'-' hidr_buttons    res     1
'-' hidr_hats       res     1
'-' hidr_hats       res     1
'-' '' Above are actually useful values, 6 longs
'-' hidr_type       res     1
'-' hidr_type       res     1
'-' hidr_id         res     1
'-' hidr_id         res     1
'-' hidr_offset     res     1
'-' hidr_offset     res     1
'-' hidr_usage_idx  res     1
'-' hidr_usage_idx  res     1
'-' ' below need to be push/pop'd
'-' hidr_state      res     1
'-' hidr_state      res     1
'-' hidr_size       res     1
'-' hidr_size       res     1
'-' hidr_count      res     1
'-' hidr_count      res     1
'-' hidr_lminmax    res     1
'-' hidr_lminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_end
'-' 
'-' ' Variables dependent on the system freqency
'-' _var_64_lower_  res     1
'-' _var_64_lower_  res     1
'-' _var_64_upper_  res     1
'-' _var_64_upper_  res     1
'-' _12Mbps_        res     1
'-' _12Mbps_        res     1
'-' _1_5Mbps_       res     1
'-' _1_5Mbps_       res     1
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1us_           res     1         ' 1us
'-' _1us_           res     1         ' 1us
'-' _10us_          res     1         ' 10us
'-' _10us_          res     1         ' 10us
'-' _33us_          res     1         ' 33us
'-' _33us_          res     1         ' 33us
'-' _txn_err_       res     1         ' 250us
'-' _txn_err_       res     1         ' 250us
'-' _500us_         res     1         ' 500us
'-' _500us_         res     1         ' 500us
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _preamble_wait_ res     1
'-' _preamble_wait_ res     1
'-' _1ms_           res     1         ' 1ms
'-' _1ms_           res     1         ' 1ms
'-' _2ms_           res     1         ' 2ms
'-' _2ms_           res     1         ' 2ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _4ms_           res     1         ' 4ms
'-' _4ms_           res     1         ' 4ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _reset_hold_    res     1         ' 15ms
'-' _reset_hold_    res     1         ' 15ms
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _21ms_          res     1         ' 21ms
'-' _21ms_          res     1         ' 21ms
'-' _100ms_         res     1         ' 100ms
'-' _100ms_         res     1         ' 100ms
'-' _500ms_         res     1         ' 500ms
'-' _500ms_         res     1         ' 500ms
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' '------------------------------------------------------------------------------
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_d_ls_nco_  res     1
'-' _usb_d_ls_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' '------------------------------------------------------------------------------
'-' ' Scratch registers
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp1           res     1
'-' htmp1           res     1
'-' htmp2           res     1
'-' htmp2           res     1
'-' htmp3           res     1
'-' htmp3           res     1
'-' hrep            res     1         ' Repeat count
'-' hrep            res     1         ' Repeat count
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave1          res     1
'-' hsave1          res     1
'-' hsave2          res     1
'-' hsave2          res     1
'-' isrtmp1         res     1
'-' isrtmp1         res     1
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' hr0             res     1         ' Multi-purpose registers
'-' hr0             res     1         ' Multi-purpose registers
'-' hr1             res     1
'-' hr1             res     1
'-' hr2             res     1
'-' hr2             res     1
'-' hr3             res     1
'-' hr3             res     1
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar2           res     1
'-' hpar2           res     1
'-' hpar3           res     1
'-' hpar3           res     1
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' mod_cnt         res     1         ' Used in idle loops
'-' mod_cnt         res     1         ' Used in idle loops
'-' 
'-'                 fit     $1F0
'-'                 fit     $1F0
'-'                 org     $200
'-' hlut_start
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed is the host's native speed, so all that is needed is to set the FS
'-' ' settings to startup defaults.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: Save/restore caller C flag state if C is changed in this routine!
'-' '------------------------------------------------------------------------------
'-' set_speed_full
'-'                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$d0, $e8, $07, $f6
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
	byte	$a3, $9b, $02, $06
'-' '                ret                             wcz     ' Restore caller flags on exit
'-' 
'-' '------------------------------------------------------------------------------
'-' ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
'-' ' is a downstream hub connected (not yet implemented), the baud generator
'-' ' remains set at the full-speed rate, but signaling is switched to low-speed,
'-' ' which reverses the D-/D+ polarity. The polarity can be changed without
'-' ' putting the smart pins into reset.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: CZ flags restored to caller states
'-' '------------------------------------------------------------------------------
'-' set_speed_low
'-'                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
	byte	$80, $96, $ce, $f7
'-'         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$ed, $e8, $07, $a6
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
	byte	$23, $69, $13, $fc
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a4, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a2, $9b, $02, $f6
'-'                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
	byte	$02, $96, $26, $f4
'-'                 ret                             wcz     ' Restore caller flags on exit
	byte	$2d, $00, $7c, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform configuration stuff required when a device intitially connects.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' on_connect
'-'                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$02, $84, $07, $f6
'-'                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
	byte	$d8, $fb, $bf, $fd
'-' .retry
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
	byte	$01, $8c, $07, $c6
'-'         if_nc   mov     hpar1, #USB_SPEED_FULL
	byte	$02, $8c, $07, $36
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$2c, $15, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$2a, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$f4, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.get_dev_desc
	byte	$18, $00, $90, $ad
'-'                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$4c, $03, $b0, $fd
'-'                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$01, $84, $8f, $f1
'-'         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
	byte	$f0, $fb, $9f, $ad
'-'                 call    #reset                          ' Try another reset to see if the device responds
	byte	$a4, $fb, $bf, $fd
'-'                 jmp     #.retry
	byte	$b8, $ff, $9f, $fd
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$2a, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
	byte	$28, $03, $b0, $fd
'-'                 call    #reset
	byte	$88, $fb, $bf, $fd
'-'                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
	byte	$44, $15, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
	byte	$01, $11, $5c, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$d8, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$04, $03, $b0, $fd
'-'                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
	byte	$04, $00, $00, $ff, $00, $bc, $06, $f6
'-'                 call    #calc_crc5
	byte	$34, $fa, $bf, $fd
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
	byte	$2c, $15, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$2a, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$78, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$2a, $f1, $03, $f6
'-'                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
	byte	$07, $db, $c6, $fa
'-'                 mov     hctwait, _500us_
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $02, $b0, $fd
'-'                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$34, $15, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$2b, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$48, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$2b, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $85, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $87, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $71, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $84, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $86, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $71, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #host_error
	byte	$2c, $fb, $9f, $cd
'-'                 loc     pa, #@init_kbdm_data - @usb_host_start
	byte	$a0, $10, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-'                 loc     pa, #@hparse_con_desc - @usb_host_start
	byte	$94, $0d, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 jmp     pa
	byte	$2c, $ec, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
'-' ' Status reporting is always in the function-to-host direction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data in hub.
'-' '   PB - start address of the buffer/struct to be written to during the IN data
'-' '     stage.
'-' '   ep_addr_pid - device address, endpoint and CRC5.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'-' '     contains the count of data stage bytes actually received, which must
'-' '     always be <= the count requested.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_read
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8d, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $8f, $03, $f6
'-'                 mov     hpar3, pb                       ' Save dest buffer pointer
	byte	$f7, $91, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$c0, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to caller to handle error
	byte	$2d, $00, $64, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$90, $01, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 mov     nak_retry, ##IN_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
	byte	$55, $b1, $02, $16
'-' .nak_retry
'-'                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
	byte	$0c, $a2, $06, $f6
'-' .in_retry
'-'                 call    #txn_in
	byte	$bc, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$28, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$a8, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$14, $02, $b0, $fd
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak_retry                     ' Function not ready to send data
	byte	$dc, $ff, $9f, $ad
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$94, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.in_retry                      ' Bus error retry
	byte	$d0, $ff, $9f, $5d
'-'                 ret                                     ' The transfer has failed
	byte	$2d, $00, $64, $fd
'-' .commit
'-'                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.pre_status                    ' and also end-of-data
	byte	$38, $00, $90, $ad
'-'                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
	byte	$29, $f1, $03, $f6
'-'                 mov     hr0, pkt_cnt
	byte	$5c, $85, $03, $f6
'-'                 cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $f2
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$6c, $fa, $bf, $5d
'-'                 add     stage_data, pkt_cnt             ' Update bytes received on commit
	byte	$5c, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
	byte	$56, $af, $0a, $f2
'-'         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
	byte	$1c, $00, $90, $ad
'-'                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
	byte	$58, $b9, $1a, $f2
'-'         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
	byte	$14, $00, $90, $cd
'-'         if_a    mov     retval, #ERR_PACKET
	byte	$04, $be, $06, $16
'-'         if_a    mov     context_retval, retval          ' In this case overall and context are the same
	byte	$5f, $c1, $02, $16
'-'         if_a    ret                                     ' Caller must handle ERR_PACKET
	byte	$2d, $00, $64, $1d
'-'                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $f4
'-'                 jmp     #.data                          ' Start next IN transaction
	byte	$78, $ff, $9f, $fd
'-' .pre_status
'-'                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
	byte	$57, $ad, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $f8
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-'                 mov     nak_retry, ##OUT_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-' .out_retry
'-'                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
	byte	$34, $f7, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret                                     ' All is good when ACK
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$18, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$84, $01, $b0, $fd
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
	byte	$d8, $ff, $9f, $5d
'-'                 ret                                     ' Caller must handle transfer retirement
	byte	$2d, $00, $64, $fd
'-' ' I've encountered transfer STALL, even though the data looks correct, and
'-' ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
'-' ' ControlRead() transfer gets things unstuck most of the time...
'-' .xfer_retry
'-'                 mov     hctwait, _xfer_wait_
	byte	$ab, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$58, $01, $b0, $fd
'-'                 call    #wait_txn_ok
	byte	$8c, $f9, $bf, $fd
'-'                 mov     ep_addr_pid, hpar1
	byte	$c6, $bd, $02, $f6
'-'                 mov     ptra, hpar2
	byte	$c7, $f1, $03, $f6
'-'                 mov     pb, hpar3
	byte	$c8, $ef, $03, $f6
'-'                 djnz    xfer_retry, #.xfer_start
	byte	$bb, $a1, $6e, $fb
'-'                 mov     context_retval, retval          ' Preserve the USB error code
	byte	$5f, $c1, $02, $f6
'-'         _ret_   mov     retval, #ERR_XFER_RETRY
	byte	$07, $be, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
'-' ' reporting is always in the function-to-host direction. It is assumed that
'-' ' the SETUP data struct is filled with the required values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - points to the start of the struct for the SETUP data.
'-' '   PB - the start address of the struct/buffer to be read for the OUT data
'-' '     stage.
'-' '   ep_addr_pid - the proper CRC'd address and endpoint to use.
'-' ' On exit:
'-' '   retval - used to convey the success/failure of each stage.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_write
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8d, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $8f, $03, $f6
'-'                 mov     hpar3, pb
	byte	$f7, $91, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
	byte	$00, $9e, $06, $f6
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$84, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
	byte	$ec, $00, $90, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$54, $00, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
	byte	$e1, $bc, $c6, $f8
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
	byte	$55, $b1, $02, $16
'-' .out_retry
'-'                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
	byte	$f7, $f1, $03, $f6
'-'                 call    #txn_out
	byte	$88, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit                        ' Function got the data
	byte	$10, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$e0, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry
	byte	$e4, $ff, $9f, $5d
'-'                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
	byte	$a4, $00, $90, $fd
'-' .commit
'-'                 mov     pb, ptra                        ' Save the current buffer/struct location
	byte	$f8, $ef, $03, $f6
'-'                 add     stage_data, pkt_data
	byte	$58, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz
	byte	$56, $af, $0a, $f2
'-'         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $54
'-'         if_nz   jmp     #.data                          ' More data to send
	byte	$bc, $ff, $9f, $5d
'-' pre_status_in
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .status_retry
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 call    #txn_in
	byte	$44, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
	byte	$d2, $be, $0e, $f2
'-'         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
	byte	$00, $b0, $0e, $a2
'-'         if_z    jmp     #dwnstream_reset                ' Control Write finished
	byte	$74, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait                     ' NAK or bus error, so delay a bit
	byte	$98, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.status_retry
	byte	$d8, $ff, $9f, $5d
'-' '               ret                                     ' Caller must handle transfer retirement
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - The function address and endpoint for the IN request.
'-' '   hpar2 - Address of the IN data buffer
'-' '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
'-' ' On exit:
'-' '   retval - the result of the operation.
'-' '   hpar3 - the count of IN data bytes actually received.
'-' '------------------------------------------------------------------------------
'-' do_int_in
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 getword htmp, hpar3, #0
	byte	$c8, $71, $33, $f9
'-'                 cmp     htmp, #PID_DATA0        wz
	byte	$c3, $70, $0f, $f2
'-'                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
	byte	$03, $96, $a6, $f4
'-'                 mov     retry, #TXN_RETRIES
	byte	$0c, $a2, $06, $f6
'-' .retry
'-'                 getword pkt_data, hpar3, #1             ' IN max packet length
	byte	$c8, $b1, $3a, $f9
'-'                 call    #txn_in
	byte	$00, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK if data received
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$1c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
	byte	$5a, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.post_ret                      ' The caller must handle either
	byte	$24, $00, $90, $ad
'-'                 call    #retry_wait
	byte	$54, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    jmp     #.post_ret
	byte	$18, $00, $90, $ad
'-'                 jmp     #.retry
	byte	$d4, $ff, $9f, $fd
'-' .commit
'-'                 mov     ptra, urx_buff_p                ' Copy the rx buffer
	byte	$29, $f1, $03, $f6
'-'                 mov     pb, hpar2                       ' to the destination buffer
	byte	$c7, $ef, $03, $f6
'-'                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
	byte	$5c, $85, $0b, $f6
'-'         if_nz   cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $52
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$c0, $f8, $bf, $5d
'-' .post_ret
'-'                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
	byte	$5c, $91, $03, $f6
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Resets the downstream hub port to FS
'-' '------------------------------------------------------------------------------
'-' dwnstream_reset
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_nc   ret                                     ' No LS device, reset not needed
	byte	$2d, $00, $64, $3d
'-' 
'-'                 bitl    _usb_h_ls_nco_, #14
	byte	$0e, $68, $07, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$23, $6d, $13, $fc
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The one millisecond frame timer is implemented as an interrupt service
'-' ' routine. Since this timing is critical, care must be taken to avoid any
'-' ' instructions that can delay the interrupt branch, which will likely upset
'-' ' the timer. WAITX is among those instructions, so any time you're inside
'-' ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hctwait - wait interval in sysclocks.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' poll_waitx
'-'                 getct   hct2
	byte	$1a, $92, $63, $fd
'-'                 addct2  hct2, hctwait
	byte	$4c, $93, $6b, $fa
'-' .wait
'-'                 jnct2   #.wait
	byte	$ff, $25, $cc, $fb
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transaction retry handling for NAK/STALL or bus error.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - transaction response PID or error code.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' retry_wait
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret                                     ' STALL is special case
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak
	byte	$14, $00, $90, $ad
'-'                 mov     hctwait, _txn_err_              ' Transaction error wait...
	byte	$9e, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$d8, $ff, $bf, $fd
'-' .dec
'-'                 sub     retry, #1               wz
	byte	$01, $a2, $8e, $f1
'-'         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
	byte	$06, $be, $06, $a6
'-'                 ret                                     ' Retry result to caller
	byte	$2d, $00, $64, $fd
'-' .nak
'-'                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
	byte	$9d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $ff, $bf, $fd
'-'                 cmp     nak_retry, #NAK_NOLIMIT wz
	byte	$00, $9e, $0e, $f2
'-'         if_z    ret                                     ' Indefinite NAK retries
	byte	$2d, $00, $64, $ad
'-'                 sub     nak_retry, #1           wz
	byte	$01, $9e, $8e, $f1
'-'         if_z    mov     retval, #ERR_NAK
	byte	$08, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' host_reset
'-'                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
	byte	$25, $00, $64, $fd
'-'                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
	byte	$14, $70, $07, $fb
'-' ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
'-'                 cmp     htmp, ##168_000_000     wcz
	byte	$bd, $01, $05, $ff, $00, $70, $1f, $f2
'-'         if_be   mov     utx_tweak, #0
	byte	$00, $94, $06, $e6
'-'         if_a    mov     utx_tweak, #3   '#20
	byte	$03, $94, $06, $16
'-' ' Check to see if the system clock has been changed.
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2e, $71, $0b, $f2
'-'         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$a0, $0b, $a0, $5e
'-'         if_nz   add     pb, hcog_base_addr
	byte	$47, $ef, $03, $51
'-'         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $5d
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $46, $62, $fd
'-'                 dirl    dp
	byte	$40, $48, $62, $fd
'-' 
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $23, $ed, $08, $fc
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
	byte	$23, $6d, $13, $fc
'-' .enable
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $46, $62, $fd
'-'                 dirh    dp
	byte	$41, $48, $62, $fd
'-'                 waitx   _1us_
	byte	$1f, $36, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$23, $01, $28, $fc
'-' 
'-'                 ' Handle Port protection enable and startup delay
'-'                 cmps    usb_enable_pin, #0      wc
	byte	$00, $4a, $56, $f2
'-'         if_ae   drvl    usb_enable_pin                 ' disable port
	byte	$58, $4a, $62, $3d
'-'                 waitx   _21ms_                          ' Wait a while for everything to turn off
	byte	$1f, $5e, $63, $fd
'-'         if_ae   drvh    usb_enable_pin                  ' Enable the port
	byte	$59, $4a, $62, $3d
'-'                 waitx   _21ms_                          ' Hold to let the idle state get settled
	byte	$1f, $5e, $63, $fd
'-' 
'-'                 'call #dev_reset ' TODO THINK ABOUT THIS
'-' 
'-' discon_entry
'-'                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
	byte	$03, $96, $07, $f6
'-' 
'-'                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
	byte	$4b, $ed, $b7, $f9
'-'                 rep     @.regloop,#hreg_init_end - hreg_init_start
	byte	$3a, $04, $dc, $fc
'-'                 alti    pa, #%000_111_000
	byte	$38, $ec, $a7, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' .regloop
'-'               
'-'         if HAVE_HIDPAD
'-'         end
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-'                 ' Fall through to disconnected loop
'-' 
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' Device connect handling (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
'-' ' device to connect (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' disconnected
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
	byte	$14, $86, $07, $fb
'-'                 cmp     hr1, save_sysclk        wz
	byte	$2e, $87, $0b, $f2
'-'         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
	byte	$7c, $ff, $9f, $5d
'-'                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
	byte	$03, $86, $47, $f0
'-'                 waitx   hr1                             ' it down to smaller wait chunks
	byte	$1f, $86, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
	byte	$e0, $ff, $9f, $ad
'-'         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
	byte	$28, $00, $90, $5d
'-' .se1_test
'-'                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$0c, $ff, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
	byte	$00, $be, $06, $56
'-'         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
	byte	$b0, $ff, $9f, $5d
'-' .se1            'SE1 is a fatal error condition
'-'                 mov     hctwait, _100ms_
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$f4, $fe, $bf, $fd
'-'                 mov     retval, #ERR_SE1
	byte	$03, $be, $06, $f6
'-'                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
	byte	$98, $f7, $bf, $fd
'-' .connect_test                                           ' Test lines until stable J/K state seen
'-'                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
	byte	$1f, $60, $63, $fd
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #discon_entry                   ' D+ and D- low
	byte	$90, $ff, $9f, $ad
'-'         if_e    jmp     #.se1_test                      ' D+ and D- high
	byte	$c4, $ff, $9f, $ad
'-' connected
'-'                 bith    hstatus, #CONNECTEDB            ' Device plugged in
	byte	$01, $96, $26, $f4
'-'                 call    #on_connect                     ' Initial device configuration
	byte	$44, $fb, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #discon_entry
	byte	$7c, $ff, $9f, $5d
'-' .set_pulse
'-'                 getct   _pulse_time_
	byte	$1a, $64, $63, $fd
'-'                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
	byte	$b1, $65, $03, $f1
'-' ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
'-' ' of 1ms and make a correction, if necessary.
'-' '                mov     htmp, _1ms_
'-' '                subs    htmp, iframe_delta
'-' '                adds    _frame1ms_clks_, htmp
'-' '                debug(udec(_frame1ms_clks_))
'-' 
'-'                 ' Fall through to idle/processing loop
'-'                 cmp     hdev_port, #MAX_DEVICES wcz
	byte	$07, $5e, $1e, $f2
'-'         if_a    mov     hdev_port, #0 
	byte	$00, $5e, $06, $16
'-' 
'-' hidle
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_c    jmp     #.se0_test
	byte	$78, $00, $90, $cd
'-'                 pollct3                         wc
	byte	$24, $06, $70, $fd
'-'         if_nc   jmp     #.nopoll
	byte	$48, $00, $90, $3d
'-'                 getct   hct3
	byte	$1a, $94, $63, $fd
'-'                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
	byte	$a7, $95, $73, $fa
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5f, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $70, $e3, $f8
'-' 
'-'                 cmp     htmp, #HUB_READY        wz
	byte	$09, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_hub_status - @usb_host_start
	byte	$c0, $12, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$20, $00, $90, $ad
'-' 
'-'         if _HAVE_GAMEPAD
'-'         end
'-' 
'-'         if HAVE_MOUSE
'-'         end
'-' 
'-'                 cmp     htmp, #KB_READY         wz
	byte	$03, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$28, $11, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$14, $00, $90, $ad
'-' 
'-'                 cmp     htmp, #KBM_READY        wz
	byte	$05, $70, $0f, $f2
'-'         if_nz   jmp     #.skip_poll
	byte	$14, $00, $90, $5d
'-'                 bitnot  hstatus, #KBM_TOGGLEB   wcz
	byte	$09, $96, $fe, $f4
'-'         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$28, $11, $80, $3e
'-'         if HAVE_MOUSE
'-'         else
'-'         if_c    jmp     #.skip_poll
	byte	$08, $00, $90, $cd
'-'         end
'-' 
'-' .poll
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-' .skip_poll
'-' 
'-'                 incmod  hdev_port, #MAX_DEVICES
	byte	$07, $5e, $06, $f7
'-' 
'-' .nopoll
'-'                 cmp     cmd_data, #CMD_SUSPEND  wz
	byte	$0e, $42, $0e, $f2
'-'         if_z    jmp     #hsuspend
	byte	$44, $00, $90, $ad
'-'                 cmp     cmd_data, #CMD_RESET    wz
	byte	$10, $42, $0e, $f2
'-'         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
	byte	$00, $42, $06, $a6
'-'         if_z    jmp     #host_reset                     ' See if it works...
	byte	$98, $fe, $9f, $ad
'-'                 getct   hr0
	byte	$1a, $84, $63, $fd
'-'                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
	byte	$b2, $85, $1b, $f2
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'         if_ae   getct   _pulse_time_
	byte	$1a, $64, $63, $3d
'-'         if_ae   add     _pulse_time_, _500ms_
	byte	$b1, $65, $03, $31
'-'                 jmp     #hidle
	byte	$7c, $ff, $9f, $fd
'-' ' Check for extended SE0 state on the bus
'-' .se0_test
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
	byte	$2c, $fe, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$23, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_nc   jmp     #hidle                          ' Bus still IDLE
	byte	$68, $ff, $9f, $3d
'-'                 call    #wait_txn_ok
	byte	$54, $f6, $bf, $fd
'-'                 wypin   ##OUT_IDLE, dm                  ' Float USB
	byte	$00, $00, $80, $ff, $23, $01, $28, $fc
'-'                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
'-'                 jmp     #discon_entry                   ' Device disconnected
	byte	$c4, $fe, $9f, $fd
'-' 
'-' hsuspend
'-'                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
	byte	$44, $f6, $bf, $fd
'-'                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
	byte	$25, $00, $64, $fd
'-'                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
	byte	$1f, $52, $63, $fd
'-'                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
	byte	$23, $01, $28, $fc
'-'                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
	byte	$00, $42, $06, $f6
'-'                 mov     mod_cnt, #0
	byte	$00, $96, $07, $f6
'-' 
'-'                 ' Fall through to resume wait loop
'-' 
'-' hwait_resume
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
	byte	$14, $86, $07, $fb
'-'                 shr     hr1, #2
	byte	$02, $86, $47, $f0
'-'                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
	byte	$1f, $86, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 cmp     cmd_data, #CMD_RESUME   wz
	byte	$0f, $42, $0e, $f2
'-'         if_nz   jmp     #hwait_resume
	byte	$ec, $ff, $9f, $5d
'-'                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
	byte	$14, $70, $07, $fb
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2e, $71, $0b, $f2
'-'         if_z    jmp     #.resume
	byte	$18, $00, $90, $ad
'-'                 loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$a0, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $fd
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
	byte	$23, $6d, $13, $3c
'-'         if_c    wxpin   _usb_h_ls_nco_, dm
	byte	$23, $69, $13, $cc
'-' .resume
'-'                 wypin   #OUT_K, dm
	byte	$23, $05, $28, $fc
'-'                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
	byte	$1f, $5c, $63, $fd
'-'                 wypin   #OUT_SE0, dm
	byte	$23, $03, $28, $fc
'-'                 mov     htmp, _ip_delay_ls_
	byte	$a2, $71, $03, $f6
'-'                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
	byte	$01, $70, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $70, $63, $fd
'-'                 wypin   #OUT_J, dm
	byte	$23, $07, $28, $fc
'-'                 shr     htmp, #1
	byte	$01, $70, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $70, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$23, $01, $28, $fc
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 setint1 #1                              ' Enable the 1ms frame ISR
	byte	$25, $02, $64, $fd
'-'                 mov     hctwait, _4ms_
	byte	$aa, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
	byte	$80, $fd, $bf, $fd
'-'         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
	byte	$00, $42, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send preamble to enable low-speed HUB ports
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   USB baud rate set to low-speed
'-' '------------------------------------------------------------------------------
'-' utx_pre
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $46, $62, $fd
'-'                 dirl    dp
	byte	$40, $48, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   #0, dm                          ' Disable smartpin mode
	byte	$23, $01, $08, $fc
'-'                 drvl    dm
	byte	$58, $46, $62, $fd
'-'                 drvh    dp
	byte	$59, $48, $62, $fd
'-' 
'-'                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
	byte	$1e, $00, $00, $ff, $80, $70, $07, $f6
'-' 
'-'                 rep     @.l1, #16 + 1
	byte	$11, $08, $dc, $fc
'-'                 shr     htmp, #1        wc
	byte	$01, $70, $57, $f0
'-'         if_nc   setq    #1
	byte	$28, $02, $64, $3d
'-'         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
	byte	$4f, $46, $62, $3d
'-'                 waitx   _preamble_wait_
	byte	$1f, $4c, $63, $fd
'-' .l1
'-' 
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $46, $62, $fd
'-'                 dirl    dp
	byte	$40, $48, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $23, $ed, $08, $fc
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
	byte	$23, $69, $13, $fc
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $46, $62, $fd
'-'                 dirh    dp
	byte	$41, $48, $62, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$23, $01, $28, $fc
'-' 
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a4, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a2, $9b, $02, $06
'-' 
'-' hlut_end
'-'                 fit     $400
'-'                 fit     $400
'-'                 orgh
'-' if OVERLAP_MEMORY
'-'                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
'-' end
'-' '------------------------------------------------------------------------------
'-' ' Routines called from cog space.
'-' '------------------------------------------------------------------------------
'-' ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'-' '------------------------------------------------------------------------------
'-' 
'-' '------------------------------------------------------------------------------
'-' ' USB host cog initialization.
'-' '------------------------------------------------------------------------------
'-' usb_host_init
'-'                 ' Initialize buffer pointers
'-'         if OVERLAP_MEMORY
'-'         else
'-'                 loc     pb, #hid_descr
	byte	$ac, $0a, $b0, $fe
'-'         end
'-'                 mov     hid_descr_p, pb
	byte	$f7, $4f, $02, $f6
'-'                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
'-'                 {
'-'                 }
'-'         
'-'                 {
'-'                 }
'-'                 'loc     pb,#hkbd_report
'-'                 'mov     hkbd_report_p,pb
'-' 
'-'                 loc     pb, #hub_descr
	byte	$c4, $11, $b0, $fe
'-'                 mov     hub_descr_p, pb
	byte	$f7, $51, $02, $f6
'-'                 loc     pb, #urx_buff
	byte	$c5, $11, $b0, $fe
'-'                 mov     urx_buff_p, pb
	byte	$f7, $53, $02, $f6
'-'                 loc     pb, #dev_desc_buff
	byte	$3d, $12, $b0, $fe
'-'                 mov     dev_desc_buff_p, pb
	byte	$f7, $55, $02, $f6
'-'                 loc     pb, #con_desc_buff
	byte	$47, $12, $b0, $fe
'-'                 mov     con_desc_buff_p, pb
	byte	$f7, $57, $02, $f6
'-'                 loc     pb, #usb_cache_start
	byte	$84, $0a, $b0, $fe
'-'                 mov     cache_start_p, pb
	byte	$f7, $59, $02, $f6
'-'                 loc     pb, #usb_cache_end
	byte	$a5, $11, $b0, $fe
'-'                 mov     cache_end_p, pb
	byte	$f7, $5b, $02, $f6
'-' 
'-'         if ERROR_LED >= 0
'-'                 drvh    host_error_led                  ' Ensure fatal error LED is inactive
	byte	$59, $4c, $62, $fd
'-'         end
'-' 
'-'                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
'-'                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
'-'                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
'-' ' Configure and enable the Serial Host USB port.
'-'                 jmp     #host_reset                     ' Initialize host and enter main processing loop
	byte	$03, $03, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Timing calculations happen before any interrupt(s) are enabled.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   htmp - current CLKFREQ value.
'-' '------------------------------------------------------------------------------
'-' hinit_usb_timings
'-' '                getct   htmp2
'-'                 mov     save_sysclk, htmp
	byte	$b8, $5d, $02, $f6
'-'                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
	byte	$8d, $5b, $80, $ff, $2e, $01, $2a, $fd
'-'                 getqx   _12Mbps_
	byte	$18, $30, $63, $fd
'-'                 shr     _12Mbps_, #16           wc
	byte	$10, $30, $57, $f0
'-'                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
	byte	$00, $30, $27, $f1
'-'                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
	byte	$03, $6c, $07, $f6
'-'                 shl     _usb_h_fs_nco_, #14
	byte	$0e, $6c, $67, $f0
'-'                 add     _usb_h_fs_nco_, _12Mbps_
	byte	$98, $6d, $03, $f1
'-'                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
	byte	$01, $6e, $07, $f6
'-'                 shl     _usb_d_fs_nco_, #14
	byte	$0e, $6e, $67, $f0
'-'                 add     _usb_d_fs_nco_, _12Mbps_
	byte	$98, $6f, $03, $f1
'-'                 mov     _1_5Mbps_, _12Mbps_
	byte	$98, $33, $03, $f6
'-'                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
	byte	$03, $32, $47, $f0
'-'                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
	byte	$02, $68, $07, $f6
'-'                 shl     _usb_h_ls_nco_, #14
	byte	$0e, $68, $67, $f0
'-'                 add     _usb_h_ls_nco_, _1_5Mbps_
	byte	$99, $69, $03, $f1
'-'                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
	byte	$99, $6b, $03, $f6
'-'                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
	byte	$80, $00, $00, $ff, $00, $5c, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1b
	byte	$65, $cd, $1d, $ff, $00, $2e, $27, $fd
'-'                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
	byte	$18, $34, $63, $fd
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $5c, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1m
	byte	$a1, $07, $00, $ff, $40, $2e, $27, $fd
'-'                 getqx   _1us_                           ' 1us as 32,9 fixed point
	byte	$18, $36, $63, $fd
'-'                 mov     hsave0, _1us_                   ' Save it to compute other us values
	byte	$9b, $7b, $03, $f6
'-'                 shr     _1us_, #9               wc
	byte	$09, $36, $57, $f0
'-'                 addx    _1us_, #0                       ' Round to final value
	byte	$00, $36, $27, $f1
'-'                 qmul    hsave0, #10                     ' Calc 10us
	byte	$0a, $7a, $07, $fd
'-'                 getqx   _10us_
	byte	$18, $38, $63, $fd
'-'                 shr     _10us_, #9              wc
	byte	$09, $38, $57, $f0
'-'                 addx    _10us_, #0                      ' 10us
	byte	$00, $38, $27, $f1
'-'                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
	byte	$21, $7a, $07, $fd
'-'                 getqx   _33us_
	byte	$18, $3a, $63, $fd
'-'                 shr     _33us_, #9              wc
	byte	$09, $3a, $57, $f0
'-'                 addx    _33us_, #0                      ' 33us
	byte	$00, $3a, $27, $f1
'-'                 qmul    hsave0, #250                    ' Calc 250us
	byte	$fa, $7a, $07, $fd
'-'                 getqx   _txn_err_
	byte	$18, $3c, $63, $fd
'-'                 shr     _txn_err_, #9           wc
	byte	$09, $3c, $57, $f0
'-'                 addx    _txn_err_, #0                   ' 250us
	byte	$00, $3c, $27, $f1
'-'                 qmul    hsave0, #500                    ' Calc 500us
	byte	$f4, $7b, $07, $fd
'-'                 getqx   _500us_
	byte	$18, $3e, $63, $fd
'-'                 shr     _500us_, #9             wc
	byte	$09, $3e, $57, $f0
'-'                 addx    _500us_, #0                     ' 500us
	byte	$00, $3e, $27, $f1
'-'                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
	byte	$01, $00, $00, $ff, $9a, $7a, $07, $fd
'-'                 getqx   _txn_ok_ls_
	byte	$18, $40, $63, $fd
'-'                 shr     _txn_ok_ls_, #9         wc
	byte	$09, $40, $57, $f0
'-'                 addx    _txn_ok_ls_, #0                 ' 666us
	byte	$00, $40, $27, $f1
'-'                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
	byte	$01, $00, $00, $ff, $52, $7b, $07, $fd
'-'                 getqx   _txn_ok_fs_
	byte	$18, $42, $63, $fd
'-'                 shr     _txn_ok_fs_, #9         wc
	byte	$09, $42, $57, $f0
'-'                 addx    _txn_ok_fs_, #0                 ' 850us
	byte	$00, $42, $27, $f1
'-'                 mov     _ip_delay_ls_, _1ns16fp_
	byte	$9a, $45, $03, $f6
'-'                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
	byte	$05, $00, $00, $ff, $80, $44, $07, $fa
'-'                 shr     _ip_delay_ls_, #16      wc
	byte	$10, $44, $57, $f0
'-'                 addx    _ip_delay_ls_, #0
	byte	$00, $44, $27, $f1
'-'                 mov     _tat_wait_ls_, _1ns16fp_
	byte	$9a, $49, $03, $f6
'-'                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
	byte	$1c, $00, $00, $ff, $c0, $49, $07, $fa
'-'                 shr     _tat_wait_ls_, #16      wc
	byte	$10, $48, $57, $f0
'-'                 addx    _tat_wait_ls_, #0
	byte	$00, $48, $27, $f1
'-'                 mov     _ip_delay_fs_, _1ns16fp_
	byte	$9a, $47, $03, $f6
'-'                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
	byte	$00, $00, $00, $ff, $4e, $47, $07, $fa
'-'                 shr     _ip_delay_fs_, #16      wc
	byte	$10, $46, $57, $f0
'-'                 addx    _ip_delay_fs_, #0
	byte	$00, $46, $27, $f1
'-'                 mov     _tat_wait_fs_, _1ns16fp_
	byte	$9a, $4b, $03, $f6
'-'                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
	byte	$04, $00, $00, $ff, $23, $4b, $07, $fa
'-'                 shr     _tat_wait_fs_, #16      wc
	byte	$10, $4a, $57, $f0
'-'                 addx    _tat_wait_fs_, #0
	byte	$00, $4a, $27, $f1
'-'                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
	byte	$8d, $5b, $00, $ff, $00, $5d, $16, $fd
'-'                 getqx   _preamble_wait_
	byte	$18, $4c, $63, $fd
'-'                 sub     _preamble_wait_,# 9 - 1
	byte	$08, $4c, $87, $f1
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $5c, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1thou
	byte	$01, $00, $00, $ff, $e8, $2f, $27, $fd
'-'                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
	byte	$18, $4e, $63, $fd
'-'                 shr     _1ms_, #9               wc
	byte	$09, $4e, $57, $f0
'-'                 addx    _1ms_, #0                       ' 1ms
	byte	$00, $4e, $27, $f1
'-'                 mov     _frame1ms_clks_, ##-14
	byte	$ff, $ff, $7f, $ff, $f2, $67, $07, $f6
'-'                 adds    _frame1ms_clks_, _1ms_
	byte	$a7, $67, $43, $f1
'-'                 mov     _2ms_, _1ms_
	byte	$a7, $51, $03, $f6
'-'                 shl     _2ms_, #1                       ' 2ms
	byte	$01, $50, $67, $f0
'-'                 mov     _suspend_wait_, _1ms_
	byte	$a7, $53, $03, $f6
'-'                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
	byte	$a7, $53, $03, $f1
'-'                 mov     _4ms_, _1ms_
	byte	$a7, $55, $03, $f6
'-'                 shl     _4ms_, #2                       ' 4ms
	byte	$02, $54, $67, $f0
'-'                 mov     _xfer_wait_, _4ms_
	byte	$aa, $57, $03, $f6
'-'                 add     _xfer_wait_, _1ms_              ' 5ms
	byte	$a7, $57, $03, $f1
'-'                 mov     _reset_hold_, _xfer_wait_       ' 5ms
	byte	$ab, $5b, $03, $f6
'-'                 mov     _resume_hold_, _reset_hold_
	byte	$ad, $5d, $03, $f6
'-'                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
	byte	$02, $5c, $67, $f0
'-'                 mov     _100ms_, _resume_hold_          ' 20ms
	byte	$ae, $61, $03, $f6
'-'                 shl     _100ms_, #1                     ' 40ms
	byte	$01, $60, $67, $f0
'-'                 mov     _8ms_, _1ms_
	byte	$a7, $59, $03, $f6
'-'                 shl     _8ms_, #3                       ' 8ms
	byte	$03, $58, $67, $f0
'-'                 shl     _reset_hold_, #1                ' 10ms
	byte	$01, $5a, $67, $f0
'-'                 add     _100ms_, _reset_hold_           ' 50ms
	byte	$ad, $61, $03, $f1
'-'                 add     _reset_hold_, _xfer_wait_       ' 15ms
	byte	$ab, $5b, $03, $f1
'-'                 mov     _21ms_, _xfer_wait_             ' 5ms
	byte	$ab, $5f, $03, $f6
'-'                 shl     _21ms_, #2                      ' 20ms
	byte	$02, $5e, $67, $f0
'-'                 add     _21ms_, _1ms_                   ' 21ms
	byte	$a7, $5f, $03, $f1
'-'                 mov     _500ms_, _100ms_                ' 50ms
	byte	$b0, $63, $03, $f6
'-'                 shl     _100ms_, #1                     ' 100ms
	byte	$01, $60, $67, $f0
'-'                 shl     _500ms_, #3                     ' 400ms
	byte	$03, $62, $67, $f0
'-'         _ret_   add     _500ms_, _100ms_                ' 500ms
	byte	$b0, $63, $03, $01
'-' '        _ret_   mov     _1sec_, save_sysclk
'-' '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'-' '                ret
'-' {
'-' }
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Parse a configuration descriptor chain to see if the device is a recognized
'-' ' one. If it is, start the task progression that will configure the device for
'-' ' use.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hconfig_base - start address of the cached config descriptor chain.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hparse_con_desc
'-'                 mov     ptrb, dev_desc_buff_p
	byte	$2a, $f3, $03, $f6
'-'                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
	byte	$82, $71, $07, $fb
'-'                 altr    hdev_port,#hdev_id
	byte	$61, $5f, $86, $f9
'-'                 movbyts htmp,#%%1032
	byte	$4e, $70, $ff, $f9
'-'                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
	byte	$86, $d3, $e6, $fa
'-'                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
'-' 
'-'                 mov     pa, #CON_wTotalLen
	byte	$02, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
	byte	$f6, $df, $e2, $fa
'-'                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
'-' ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
'-' ' that defines a keyboard and/or mouse.
'-'                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
	byte	$6e, $eb, $c2, $fa
'-' .next_intf
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #hset_config
	byte	$84, $01, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $70, $0f, $f2
'-'         if_z    jmp     #.intf
	byte	$0c, $00, $90, $ad
'-'                 rdbyte  htmp, ptrb
	byte	$80, $71, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b8, $eb, $02, $f1
'-'                 jmp     #.next_intf
	byte	$d8, $ff, $9f, $fd
'-' .intf
'-'                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
	byte	$00, $8e, $07, $f6
'-'                 mov     hpar3, #0
	byte	$00, $90, $07, $f6
'-'                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
	byte	$82, $e1, $c6, $fa
'-'                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
	byte	$85, $e3, $c6, $fa
'-'                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
	byte	$86, $e5, $c6, $fa
'-'                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
	byte	$87, $e7, $c6, $fa
'-'                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
'-' 
'-' .endp
'-'                 rdbyte  htmp, ptrb
	byte	$80, $71, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b8, $eb, $02, $f1
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #.get_device
	byte	$78, $00, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $70, $0f, $f2
'-'         if_z    jmp     #.get_device
	byte	$64, $00, $90, $ad
'-'                 cmp     htmp, #TYPE_ENDPOINT    wz
	byte	$05, $70, $0f, $f2
'-'         if_z    jmp     #.get_ep
	byte	$04, $00, $90, $ad
'-'                 jmp     #.endp
	byte	$d0, $ff, $9f, $fd
'-' .get_ep
'-'                 rdbyte  hr1, ptrb[ENDP_bAddress]
	byte	$82, $87, $c7, $fa
'-'                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
	byte	$07, $86, $17, $f4
'-'                 shl     hr1, #8 + 7
	byte	$0f, $86, $67, $f0
'-'                 mov     htmp, hctrl_ep_addr
	byte	$6c, $71, $03, $f6
'-'                 and     htmp, ##ADDR_MASK
	byte	$3f, $00, $00, $ff, $00, $71, $07, $f5
'-'                 or      htmp, hr1                       ' endpoint address
	byte	$c3, $71, $43, $f5
'-'                 cmp     hpar2, #0               wz
	byte	$00, $8e, $0f, $f2
'-'  if_z_and_c     jmp     #.in_ep
	byte	$0c, $00, $90, $8d
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'  if_z_and_nc    jmp     #.out_ep
	byte	$18, $00, $90, $2d
'-'                 jmp     #.endp
	byte	$a0, $ff, $9f, $fd
'-' .in_ep
'-'                 mov     hpar2, htmp                     ' IN endpoint
	byte	$b8, $8f, $03, $f6
'-'                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
	byte	$84, $89, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $85, $c7, $fa
'-'                 setbyte hr2, hr0, #3
	byte	$c2, $89, $db, $f8
'-'                 jmp     #.endp
	byte	$8c, $ff, $9f, $fd
'-' .out_ep
'-'                 mov     hpar3, htmp                     ' OUT endpoint
	byte	$b8, $91, $03, $f6
'-'                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8b, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $85, $c7, $fa
'-'                 setbyte hr3, hr0, #3
	byte	$c2, $8b, $db, $f8
'-'                 jmp     #.endp
	byte	$78, $ff, $9f, $fd
'-' 
'-' .get_device
'-'                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
	byte	$ff, $e2, $0e, $f2
'-'         if_z    cmp     hdev_subclass, #$5D     wz
	byte	$5d, $e4, $0e, $a2
'-'         if_z    cmp     hdev_protocol, #$01     wz
	byte	$01, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$44, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HUB  wz
	byte	$09, $e2, $0e, $f2
'-'         if_z    jmp     #.hub
	byte	$74, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HID              wz
	byte	$03, $e2, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No HID class, ignore
	byte	$18, $ff, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_z    jmp     #.gamepad
	byte	$2c, $00, $90, $ad
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
	byte	$01, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
	byte	$08, $ff, $9f, $5d
'-' .keyboard
'-'                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
	byte	$01, $e6, $0e, $f2
'-'         if HAVE_MOUSE
'-'         else
'-'         if_nz   jmp     #.next_intf                     ' No Keyboard
	byte	$00, $ff, $9f, $5d
'-'         end
'-'                 cmp     hkbd_ep_addr, #0    wz
	byte	$00, $f2, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$f8, $fe, $9f, $5d
'-'                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6f, $e2, $f8
'-'                 getbyte kb_interval, hr2, #3
	byte	$c4, $71, $fa, $f8
'-'                 getbyte kb_in_max_pkt, hr2, #0
	byte	$c4, $73, $e2, $f8
'-'                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
	byte	$c7, $f3, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$e4, $fe, $9f, $fd
'-' if HAVE_MOUSE
'-' .mouse
'-' end
'-' .gamepad
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $71, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c7, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$d0, $fe, $9f, $ad
'-'         if HAVE_MOUSE
'-'         end
'-'                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
	byte	$7c, $5f, $8e, $f9
'-'                 cmp     0-0, #0                 wz      ' |
	byte	$00, $00, $0c, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$c4, $fe, $9f, $5d
'-' 
'-'                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $79, $e2, $f8
'-'                 getbyte gp_interval, hr2, #3
	byte	$c4, $7b, $fa, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7c, $5f, $8e, $f9
'-'                 mov     0-0, hpar2                      ' IN endpoint address
	byte	$c7, $01, $00, $f6
'-'                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
	byte	$c8, $09, $03, $f6
'-'                 'debug(udec(gp_intf_num))
'-'                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
'-'                 jmp     #.next_intf
	byte	$ac, $fe, $9f, $fd
'-' .hub
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$a4, $fe, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_nz   cmp     hdev_protocol, #2                   wz
	byte	$02, $e6, $0e, $52
'-'         if_nz   jmp     #.next_intf
	byte	$98, $fe, $9f, $5d
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$90, $fe, $9f, $5d
'-'                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
	byte	$70, $67, $e2, $f8
'-'                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $ed, $02, $f6
'-'                 mov     ep_addr_pid, hpar2              ' IN endpoint address
	byte	$c7, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 mov     hhub_ep_addr, ep_addr_pid
	byte	$5e, $ef, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
	byte	$6c, $bd, $02, $f6
'-'                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
'-'                 jmp     #.next_intf
	byte	$74, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' If a newly-connected device is recognized, do whatever is needed to configure
'-' ' it according to its function, or functions. In the case of this boot protocol
'-' ' keyboard/mouse class driver:
'-' ' - SetConfiguration(config_num)
'-' ' - SetProtocol(boot)
'-' ' - SetIdle(indefinite)
'-' ' - Enter the device interrupt IN polling task stage.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_config
'-' '                mov     hkbd_ep_addr, #0                ' DEBUG
'-' '                mov     hmouse_ep_addr, #0              ' DEBUG
'-'                 mov     htmp2, #DEV_UNKNOWN
	byte	$02, $74, $07, $f6
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7c, $5f, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $a2
'-'         if HAVE_MOUSE
'-'         end
'-'         if_z    cmp     hhub_ep_addr, #0        wz
	byte	$00, $ee, $0e, $a2
'-'         if_z    jmp     #.notify_client                 ' No known device
	byte	$38, $01, $90, $ad
'-' .set_config
'-'                 loc     ptra, #set_config
	byte	$dc, $05, $d0, $fe
'-'                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
	byte	$05, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdbyte  hpar1, pa
	byte	$f6, $8d, $c3, $fa
'-'                 debug("SetConfiguration: ",udec_(hpar1))
'-'                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
	byte	$01, $8d, $57, $fc
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
	byte	$6c, $bd, $02, $f6
'-'                 mov     pb, #0                          ' SetConfiguration() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-' .kbd_config
'-'                 cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $f2
'-'         if_z    jmp     #.mouse_config                  ' No keyboard
	byte	$9c, $00, $90, $ad
'-' 
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.mouse_config                  ' No keyboard
	byte	$88, $00, $90, $5d
'-' 
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $71, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$a4, $05, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$d0, $00, $90, $5d
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8c, $07, $f6
'-'                 getbyte hpar2, kb_intf_num, #0
	byte	$37, $8f, $e3, $f8
'-'                 call    #hset_idle
	byte	$1c, $01, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hkbd_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 mov     hctwait, _2ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
	byte	$01, $76, $06, $f6
'-'         if NUMLOCK_DEFAULT_STATE && RPI_KEYBOARD_NUMLOCK_HACK
'-'         end
'-'                 mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f7, $02, $f6
'-'                 loc     pa, #hkbd_led_rep
	byte	$34, $0d, $90, $fe
'-'                 wrbyte  hkbd_ledstates,pa
	byte	$f6, $f7, $42, $fc
'-'                 call    #hset_kbdled_report
	byte	$18, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$9c, $00, $90, $5d
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $6c, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hkbd_ep_addr, ep_addr_pid
	byte	$5e, $f3, $02, $f6
'-'                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $f1, $02, $f6
'-'                 bitc    hkbd_ctrl_ep, #31
	byte	$1f, $f0, $46, $f4
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
	byte	$00, $f4, $06, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $64, $c6, $f8
'-'                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
	byte	$03, $74, $07, $f6
'-'         if !!HAVE_MOUSE
'-'                 '' If we could have a mouse, fall through into mouse config to detect combo dev
'-'                 jmp     #.notify_client
	byte	$6c, $00, $90, $fd
'-'         end
'-' 
'-' .mouse_config
'-' if HAVE_MOUSE
'-' end
'-' .gamepad_config
'-' if _HAVE_GAMEPAD
'-' 
'-'                 if EMUPAD_MAX_PLAYER > 0
'-'                 
'-' .rule_loop           
'-'                 end
'-' .xinput
'-' .ps3
'-' end
'-' 
'-' .hub_config
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_z    jmp     #.notify_client                 ' No HUB
	byte	$64, $00, $90, $ad
'-'                 mov     htmp, hhub_ep_addr
	byte	$77, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.notify_client                 ' No HUB
	byte	$50, $00, $90, $5d
'-' 
'-'                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
	byte	$24, $05, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, hub_descr_p
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hhub_ep_addr, #0
	byte	$00, $ee, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $00, $90, $5d
'-'                 debug(uhex_byte_array(hub_descr_p,total_data))
'-' 
'-'                 mov     ptra, hub_descr_p
	byte	$28, $f1, $03, $f6
'-'                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
	byte	$02, $77, $c7, $fa
'-'                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
	byte	$07, $76, $27, $f3
'-'                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
'-' .pwr_loop
'-'                 loc     ptra, #set_port_feat            ' Power on ports
	byte	$04, $05, $d0, $fe
'-'                 wrword  #HUB_PORT_POWER, ptra[wValue]
	byte	$01, $11, $5c, $fc
'-'                 wrword  htmp3, ptra[wIndex]
	byte	$02, $77, $57, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 djnz    htmp3, #.pwr_loop
	byte	$fb, $77, $6f, $fb
'-' 
'-'                 mov     hctwait, _500ms_
	byte	$b1, $99, $02, $f6
'-'                 add     hctwait, _100ms_
	byte	$b0, $99, $02, $f1
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 mov     htmp2, #HUB_READY               ' Hub ready
	byte	$09, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$00, $00, $90, $fd
'-' 
'-' .notify_client
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5f, $66, $f9
'-'                 setbyte htmp2                           ' Save device ready
	byte	$ba, $01, $c0, $f8
'-'                 debug(uhex_long(hdev_type,hdev_type+1))
'-'         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Initialize the keyboard/mouse data area to start-up values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' init_kbdm_data
'-'                 mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $f6
'-'                 mov     hdev_ep_addr, #0
	byte	$00, $f8, $06, $f6
'-' 
'-'                 mov     ptra, cache_start_p         ' Clear cached data buffers
	byte	$2c, $f1, $03, $f6
'-'                 mov     pa, cache_end_p
	byte	$2d, $ed, $03, $f6
'-' .loop
'-'                 wrbyte  #0, ptra++
	byte	$61, $01, $4c, $fc
'-'                 cmp     ptra, pa                wcz
	byte	$f6, $f1, $1b, $f2
'-'         if_b    jmp     #.loop
	byte	$f4, $ff, $9f, $cd
'-'         
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' 
'-'                 mov     pa, #hdev_init_start        ' Clear device data registers
	byte	$2f, $ed, $07, $f6
'-' .regloop
'-'                 altd    pa
	byte	$00, $ec, $8f, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-'                 add     pa, #1
	byte	$01, $ec, $07, $f1
'-'                 cmp     pa, #hdev_init_end      wz
	byte	$47, $ed, $0f, $f2
'-'         if_nz   jmp     #.regloop
	byte	$ec, $ff, $9f, $5d
'-' 
'-'                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
	byte	$e1, $e1, $61, $ff, $c3, $61, $06, $f6
'-'                 mov     hdev_next_datax + 1,hdev_next_datax
	byte	$30, $63, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0
	byte	$c3, $64, $c6, $f8
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1
	byte	$c3, $64, $ce, $f8
'-' 
'-'         _ret_   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $68, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
'-' ' function.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'-' '   hpar2 - index number of the target interface.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_idle
'-'                 mov     hctwait, _2ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #set_idle
	byte	$5c, $04, $d0, $fe
'-'                 wrword  hpar1, ptra[wValue]
	byte	$01, $8d, $57, $fc
'-'                 wrword  hpar2, ptra[wIndex]
	byte	$02, $8f, $57, $fc
'-'                 jmp     #control_write
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
'-' ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - device address and enpoint for the request.
'-' ' On exit:
'-' '   retval - transaction result.
'-' '------------------------------------------------------------------------------
'-' hset_kbdled_report
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$50, $04, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
	byte	$01, $00, $80, $ff, $01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
	byte	$03, $03, $5c, $fc
'-'                 mov     pb, urx_buff_p
	byte	$29, $ef, $03, $f6
'-'                 wrbyte  kb_led_states, pb
	byte	$f7, $77, $42, $fc
'-'                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for keyboard activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_kbd_in_report
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$29, $8f, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #0
	byte	$32, $91, $e3, $f8
'-'                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
	byte	$39, $91, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
	byte	$32, $71, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
	byte	$4b, $64, $c6, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
	byte	$c3, $64, $c6, $58
'-' 
'-'                 mov     kb_max_index, hpar3             ' Save actual bytes read
	byte	$c8, $75, $02, $f6
'-'                 call    #hkbd_compare
	byte	$18, $00, $b0, $fd
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' .led_check
'-'                 mov     htmp, kb_led_states
	byte	$3b, $71, $03, $f6
'-'                 cmp     hkbd_ledstates, htmp    wz
	byte	$b8, $f7, $0a, $f2
'-'         if_z    ret                                     ' No toggle key indicator changes, so we're done
	byte	$2d, $00, $64, $ad
'-'                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
	byte	$7b, $77, $02, $f6
'-'                 mov     ep_addr_pid, hkbd_ctrl_ep
	byte	$78, $bd, $02, $f6
'-'                 jmp     #hset_kbdled_report             ' Set report and ignore errors
	byte	$88, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Compare current and previous keyboard data buffers for keypress changes.
'-' '------------------------------------------------------------------------------
'-' hkbd_compare
'-'                 mov     ptra, urx_buff_p
	byte	$29, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$8c, $0b, $f0, $fe
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $75, $07, $fb
'-'                 cmp     htmp1, htmp2    wz
	byte	$ba, $73, $0b, $f2
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $75, $07, $fb
'-'         if_z    cmp     htmp1, htmp2    wz
	byte	$ba, $73, $0b, $a2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-' 
'-'                 loc     ptra, #hkbd_report
	byte	$6c, $0b, $d0, $fe
'-' 
'-'                 ' Handle modifiers
'-'                 rdbyte  hpar2, urx_buff_p
	byte	$29, $8f, $c3, $fa
'-'                 rdbyte  hr1, ptra
	byte	$00, $87, $c7, $fa
'-'                 rolword hr1,hpar2,#0
	byte	$c7, $87, $43, $f9
'-'                 mergew  hr1
	byte	$63, $86, $63, $fd
'-'                 mov     pa,#8
	byte	$08, $ec, $07, $f6
'-' .modloop
'-'                 rczr    hr1     wcz ' New value in C, old value in Z
	byte	$6a, $86, $7b, $fd
'-'                 mov     hpar1,#$E8
	byte	$e8, $8c, $07, $f6
'-'                 sub     hpar1,pa
	byte	$f6, $8d, $83, $f1
'-'       if_c_ne_z call    #hkbd_translate
	byte	$a0, $00, $b0, $6d
'-'                 djnz    pa,#.modloop
	byte	$fb, $ed, $6f, $fb
'-' 
'-' .release        modc    _set    wc
	byte	$6f, $e0, $75, $fd
'-'                 'alts    hdev_port, #hid_report_p
'-'                 'mov     ptra, hid_report_p
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .rl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8d, $cf, $fa
'-'         if_z    jmp     #.rl3
	byte	$20, $00, $90, $ad
'-'                 mov     ptrb, urx_buff_p
	byte	$29, $f3, $03, $f6
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .rl2            rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b8, $8d, $0b, $f2
'-'         if_z    jmp     #.rl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.rl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$68, $00, $b0, $fd
'-' .rl3            djnz    pa, #.rl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-'                 mov     hpar3, #0
	byte	$00, $90, $07, $f6
'-'                 bith    hpar3, #31
	byte	$1f, $90, $27, $f4
'-' 
'-' .press          modc    _clr    wc
	byte	$6f, $00, $74, $fd
'-'                 mov     ptra, urx_buff_p
	byte	$29, $f1, $03, $f6
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .pl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8d, $cf, $fa
'-'         if_z    jmp     #.pl3
	byte	$20, $00, $90, $ad
'-'                 loc     ptrb, #hkbd_report
	byte	$e8, $0a, $f0, $fe
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .pl2            rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b8, $8d, $0b, $f2
'-'         if_z    jmp     #.pl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.pl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$24, $00, $b0, $fd
'-' .pl3            djnz    pa, #.pl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-' .copy           mov     ptra, urx_buff_p
	byte	$29, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$c0, $0a, $f0, $fe
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 wrlong  htmp1, ptrb++
	byte	$e1, $73, $67, $fc
'-'                 wrbyte  hkbd_ledstates,ptrb++
	byte	$e1, $f7, $46, $fc
'-' 
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Translate keyboard scancode to ASCII
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - scancode
'-' '   hpar2 - key modifiers state
'-' '       c - pressed (0) or released (1) flag
'-' ' On exit:
'-' '   hpar1 - bit     31 = 0 pressed, 1 released
'-' '               30..17 = unused
'-' '                   18 = scroll-lock state 
'-' '                   17 = caps-lock state
'-' '                   16 = num-lock state 
'-' '                15..8 = key modifiers state
'-' '                 7..0 = scancode
'-' '------------------------------------------------------------------------------
'-' hkbd_translate
'-'                 cmp     hpar1, #KEY_CAPSLOCK    wz
	byte	$39, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
	byte	$01, $f6, $e6, $24
'-'                 cmp     hpar1, #KEY_NUMLOCK     wz
	byte	$53, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
	byte	$00, $f6, $e6, $24
'-'                 cmp     hpar1, #KEY_SCROLLLOCK  wz
	byte	$47, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
	byte	$02, $f6, $e6, $24
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' 
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' 
'-'         end
'-'                 setbyte hpar1, hpar2, #1
	byte	$c7, $8d, $cb, $f8
'-'                 setbyte hpar1, hkbd_ledstates,#2
	byte	$7b, $8d, $d3, $f8
'-'                 bitc    hpar1, #31
	byte	$1f, $8c, $47, $f4
'-'         if KEYQUEUE_SIZE > 0
'-'                 loc pb,#keyq_head
	byte	$fc, $02, $b0, $fe
'-'                 rdword htmp,pb
	byte	$f7, $71, $e3, $fa
'-'                 getbyte htmp1,htmp,#1 ' tail
	byte	$b8, $73, $eb, $f8
'-'                 getbyte htmp,htmp,#0 ' head
	byte	$b8, $71, $e3, $f8
'-'                 mov htmp2,htmp
	byte	$b8, $75, $03, $f6
'-'                 mul htmp2,#4
	byte	$04, $74, $07, $fa
'-'                 add htmp2,pb
	byte	$f7, $75, $03, $f1
'-'                 add htmp2,#2
	byte	$02, $74, $07, $f1
'-'                 incmod htmp,#KEYQUEUE_SIZE - 1
	byte	$1f, $70, $07, $f7
'-'                 cmp htmp1,htmp wz ' check buffer overflow
	byte	$b8, $73, $0b, $f2
'-'         if_nz   wrlong hpar1,htmp2
	byte	$ba, $8d, $63, $5c
'-'         if_nz   wrbyte htmp,pb
	byte	$f7, $71, $43, $5c
'-'         end
'-'                 ret wcz
	byte	$2d, $00, $7c, $fd
'-' 
'-' if HAVE_MOUSE
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for mouse activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_mouse_in_report
'-' 
'-'         'debug(uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'         else
'-'         end
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'         else
'-'                 { ' Currently not used
'-'                 '}
'-'         end
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'         else
'-'         end
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'         else
'-'         end
'-'                 
'-'         if MOUSE_FULL_PROTOCOL
'-'         else    
'-'         end
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' hget_gp_in_report
'-' 
'-'                 ' FALL THROUGH !!!!
'-' end
'-' if _HAVE_GAMEPAD || MOUSE_FULL_PROTOCOL
'-' '------------------------------------------------------------------------------
'-' ' Decode controller report
'-' '------------------------------------------------------------------------------
'-' hid_decode
'-'         if _HAVE_GAMEPAD
'-'         end
'-'                 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle HID controller (or mouse now
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' hpad_hid
'-' 
'-' .next
'-' .skip
'-' .axes
'-' .l1
'-' .hats
'-' .buttons
'-' .report_id
'-' .usage_page
'-' .usage
'-' .usage_axis
'-' .pushpop
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Read bits from report data buffer
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRB - report buffer
'-' '   hpar1 - start bit
'-' '   hpar2 - number of bits
'-' ' On exit:
'-' '   retval - bits
'-' '------------------------------------------------------------------------------
'-' hpad_getbits
'-' .l1
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Normalize value to signed word (-32768 / 32767)
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - value to normalize
'-' '   hidr_lminmax - min (word 1) max (word 0) value range
'-' '   - or -
'-' '   hidr_pminmax - min (word 1) max (word 0) value range
'-' '   hidr_size - value bits length
'-' ' On exit:
'-' '   retval - normalized value
'-' '------------------------------------------------------------------------------
'-' hpad_normalize
'-' end
'-' 
'-' if _HAVE_GAMEPAD
'-' '------------------------------------------------------------------------------
'-' ' Handle XInput controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_xinput
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle PS3 controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_ps3
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform controller actions
'-' ' On entry:
'-' '    hidr_id        report id
'-' '    hidr_axis      axis value (signed word, 2 axes per long)
'-' '                      X = hidr_axis+0, #0
'-' '                      Y = hidr_axis+0, #1
'-' '                      Z = hidr_axis+1, #0
'-' '                     RX = hidr_axis+1, #1
'-' '                     RY = hidr_axis+2, #0
'-' '                     RZ = hidr_axis+2, #1
'-' '                     Sl = hidr_axis+3, #0
'-' '                     Wh = hidr_axis+3, #1
'-' '    hidr_buttons   buttons state (bits 0 to 31)
'-' '    hidr_hats      hats state (byte 0, 1, 2, 3)
'-' '
'-' '                     -------3 -------2 -------1 -------0 byte
'-' '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
'-' '    hidr_flags       xxxxxxxx_wsrrrzyx_hhhhaaaa_bbbbbbbb
'-' '                              hlzyx||| |||||||| ++++++++ n. buttons
'-' '                              |||||||| ||||++++--------- n. axes
'-' '                              |||||||| ++++------------- n. hats
'-' '                              ++++++++------------------ valid axes
'-' '------------------------------------------------------------------------------
'-' hpad_translate
'-' 
'-' 
'-'         if HAVE_HIDPAD
'-'         end
'-' 
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' .emupad_no_hat
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' .emupad_slot_over
'-'         end
'-' 
'-'         if 0
'-'                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
'-' 
'-'                 debug("    btn: ", ubin_long_(hidr_buttons))
'-' 
'-'         end
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' '------------------------------------------------------------------------------
'-' ' Clear EmuPad state
'-' '------------------------------------------------------------------------------
'-' emupad_reset
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get EmuPad Player number for current device (into retval)
'-' ' Z flag is also set if current device is valid
'-' ' (Value may be larger than EMUPAD_MAX_PLAYER !)
'-' '------------------------------------------------------------------------------
'-' emupad_getnum
'-' .loop
'-' '------------------------------------------------------------------------------
'-' ' Handle disconnect of device (call after emupad_getnum returns with Z set)
'-' '------------------------------------------------------------------------------
'-' emupad_discon
'-' .loop         
'-'         
'-'         ' FALL THROUGH!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Update EmuPad reports (all of them...)
'-' '------------------------------------------------------------------------------
'-' emupad_write_reports
'-' .devloop
'-' 
'-' end
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_hub_status
'-'                 mov     ep_addr_pid, hhub_ep_addr
	byte	$77, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$29, $8f, $03, $f6
'-'                 setword hpar3, hub_next_datax, #0
	byte	$34, $91, $23, $f9
'-'                 setword hpar3, #1, #1
	byte	$01, $90, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.data
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
	byte	$1a, $01, $80, $5d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .data
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 cmp     hub_next_datax, #PID_DATA0  wz
	byte	$c3, $68, $0e, $f2
'-'         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
	byte	$4b, $68, $06, $a6
'-'         if_nz   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $68, $06, $56
'-'                 rdlong  hub_status_chg, urx_buff_p
	byte	$29, $6b, $02, $fb
'-'                 debug(ubin_long(hub_status_chg))
'-' 
'-'                 mov     hdev_port, #1
	byte	$01, $5e, $06, $f6
'-' .loop
'-'                 testb   hub_status_chg, hdev_port wz
	byte	$2f, $6b, $0a, $f4
'-'         if_x1   call    #hub_port_handler
	byte	$0c, $00, $b0, $ad
'-'                 incmod  hdev_port, #7           wcz
	byte	$07, $5e, $1e, $f7
'-'         if_nc   jmp     #.loop
	byte	$f0, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' hub_port_handler
'-'                 mov     ep_addr_pid, hhub_ctrl_ep
	byte	$76, $bd, $02, $f6
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$64, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$29, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5f, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$29, $6d, $02, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-' 
'-'                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
	byte	$10, $6c, $0e, $f4
'-'         if_x0   jmp     #.other
	byte	$50, $01, $90, $5d
'-'                 loc     ptra, #clr_port_feat
	byte	$40, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
	byte	$01, $21, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5f, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
	byte	$00, $6c, $0e, $f4
'-'         if_x0   jmp     #.disconnect
	byte	$7c, $01, $90, $5d
'-'                 mov     hctwait, _100ms_
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 loc     ptra, #set_port_feat            ' reset port
	byte	$18, $02, $d0, $fe
'-'                 wrword  #HUB_PORT_RESET, ptra[wValue]
	byte	$01, $09, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5f, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp3, #2
	byte	$02, $76, $07, $f6
'-' .wait_reset
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$0c, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$29, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5f, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$29, $6d, $02, $fb
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
	byte	$14, $6c, $0e, $f4
'-'         if_x0   djnz    htmp3, #.wait_reset
	byte	$f7, $77, $6f, $5b
'-' 
'-'                 loc     ptra, #clr_port_feat
	byte	$e8, $01, $d0, $fe
'-'                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5f, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
	byte	$24, $70, $07, $f6
'-' .wait_recover
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 djnz    htmp,#.wait_recover
	byte	$fd, $71, $6f, $fb
'-' 
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $6c, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$64, $01, $d0, $fe
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$2a, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$20, $01, $90, $5d
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$2a, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
	byte	$58, $01, $d0, $fe
'-'                 mov     htmp, hdev_port             ' Address is hub port number
	byte	$2f, $71, $03, $f6
'-'                 wrword  htmp, ptra[wValue]
	byte	$01, $71, $57, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$fc, $00, $90, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$ef, $02, $a0, $fd
'-'                 mov     ep_addr_pid, hdev_port
	byte	$2f, $bd, $02, $f6
'-'                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
	byte	$08, $bc, $66, $f0
'-'                 call    #calc_crc5
	byte	$be, $00, $a0, $fd
'-'                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
	byte	$14, $01, $d0, $fe
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$2a, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$cc, $00, $90, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$2a, $f1, $03, $f6
'-'                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
'-'                 mov     hctwait, _500us_
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$f0, $00, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$2b, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$a4, $00, $90, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$2b, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $85, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $87, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $71, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $84, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $86, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $71, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #.done
	byte	$7c, $00, $90, $cd
'-'                 call    #hparse_con_desc
	byte	$10, $f9, $bf, $fd
'-'                 jmp     #.done
	byte	$74, $00, $90, $fd
'-' 
'-' .other
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz
	byte	$14, $6c, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$28, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
	byte	$11, $6c, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
	byte	$01, $23, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$1c, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
	byte	$12, $6c, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
	byte	$01, $25, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$10, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
	byte	$13, $6c, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
	byte	$01, $27, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$04, $00, $90, $ad
'-'                 jmp     #.done
	byte	$40, $00, $90, $fd
'-' .reset_feature
'-'                 loc     ptra, #clr_port_feat
	byte	$bc, $00, $d0, $fe
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5f, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 jmp     #.done
	byte	$30, $00, $90, $fd
'-' .disconnect
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5f, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $70, $e3, $f8
'-'                 cmp     htmp,#KB_READY wz
	byte	$03, $70, $0f, $f2
'-'         if_nz   cmp     htmp,#KBM_READY wz
	byte	$05, $70, $0f, $52
'-'         if_z    mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $a6
'-'         if_z    mov     hkbd_ctrl_ep, #0
	byte	$00, $f0, $06, $a6
'-'         if_z    mov     kb_led_states, #0
	byte	$00, $76, $06, $a6
'-'         if_z    mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f7, $02, $a6
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-'         if HAVE_MOUSE
'-'         end
'-'         if HAVE_HIDPAD
'-'         end
'-' 
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5f, $66, $f9
'-'                 setbyte #0
	byte	$00, $00, $c4, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7c, $5f, $8e, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' 
'-' .done
'-'                 bitl    _usb_h_ls_nco_, #14     wcz
	byte	$0e, $68, $1f, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$23, $6d, $13, $cc
'-'                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $f6
'-' 
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$6c, $00, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$29, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5f, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, ptra
	byte	$00, $6d, $06, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Partially populated SETUP packets
'-' '------------------------------------------------------------------------------
'-' get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_DEVICE << 8
	byte	$00, $01
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_CONFIG << 8
	byte	$00, $02
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_CONFIG
	byte	$09
'-'                 word    0       ' Configuration value
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
	byte	$00, $00
'-' set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_ADDR
	byte	$05
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
'-' ' wValue field dictates which protocol should be used.
'-' '
'-' ' When initialized, all devices default to report protocol. However the host
'-' ' should not make any assumptions about the device state and should set the
'-' ' desired protocol whenever initializing a device.
'-' '------------------------------------------------------------------------------
'-' set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_PROTO
	byte	$0b
'-'                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
	byte	$00, $00
'-'                                                 ' (HID 1.11 Section 7.2.6).
'-'                 word    0               ' Interface index number.
	byte	$00, $00
'-'                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_IDLE
	byte	$0a
'-'                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
	byte	$00, $00
'-'                                         ' reporting until a change is detected in the report data
'-' 
'-'                                         ' (HID 1.11 Section 7.2.4).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
	byte	$00, $00
'-' set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_REPORT
	byte	$09
'-'                 word    0       ' Byte1 = report type, byte0 = ReportID.
	byte	$00, $00
'-'                                         ' (HID 1.11 Section 7.2.2).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Size of the report, in bytes.
	byte	$00, $00
'-' get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
	byte	$81
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_REPORT << 8
	byte	$00, $22
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
	byte	$a0
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_HUB << 8
	byte	$00, $29
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_SET_FEATURE
	byte	$03
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_CLEAR_FEATURE
	byte	$01
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
	byte	$a3
'-'                 byte    REQ_GET_STATUS
	byte	$00
'-'                 word    0
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    4       ' Number of bytes to transfer if there is a data stage
	byte	$04, $00
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' ps3_enable_cmd  byte    $42, $0C, $00, $00
'-' ps3_command_buff
'-'                 byte    $00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
'-'                 byte    $FF, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
'-'                 byte    $00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00
'-' '------------------------------------------------------------------------------
'-' xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
'-'                                         ' 0x01 All blinking
'-'                                         ' 0x02 1 flashes, then on
'-'                                         ' 0x03 2 flashes, then on
'-'                                         ' 0x04 3 flashes, then on
'-'                                         ' 0x05 4 flashes, then on
'-'                                         ' 0x06 1 on
'-'                                         ' 0x07 2 on
'-'                                         ' 0x08 3 on
'-'                                         ' 0x09 4 on
'-'                                         ' 0x0A Rotating (e.g. 1-2-4-3)
'-'                                         ' 0x0B Blinking*
'-'                                         ' 0x0C Slow blinking*
'-'                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
'-' xinp_rumble_cmd byte    $00, $08, $00
'-'                 byte    $00             ' Left rumble
'-'                 byte    $00             ' Right rumble
'-'                 byte    $00, $00, $00
'-' 
'-' xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
'-'                 '' of certain wired 8bitdo gamepads.
'-'                 byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
'-'                 byte    REQ_GET_DESC
'-'                 word    TYPE_STRING << 8 + 4
'-'                 word    $0409   ' Zero or Language ID (Section 9.6.7)
'-'                 word    2       ' Number of bytes to transfer if there is a data stage
'-' end
'-' alignl
'-' 
'-' if HAVE_MOUSE
'-' mouse_limits long 0[2]
'-' mouse_outptr long 0
'-' end
'-' 
'-' if KEYQUEUE_SIZE > 0
'-' keyq_head byte 0
	byte	$00
'-' keyq_tail byte 0
	byte	$00
'-' keyq_data long 0[KEYQUEUE_SIZE]
	byte	$00[130]
'-' alignl
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_rule_buffer
'-' if EMUPAD_BUILTIN_RULES
'-' file "padmap_builtin.dat"
'-' end
'-' byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
'-' '' Default rule directly follows!
'-' byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The USB data cache area gets zero-filled at every device disconnect
'-' '------------------------------------------------------------------------------
'-' usb_cache_start
'-' 
'-' ' HID descriptor and report buffers
'-' if !!OVERLAP_MEMORY
'-' hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
	byte	$00[1792]
'-' end
'-' hkbd_report     byte    0[8]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' hkbd_led_rep    byte    0
	byte	$00, $00, $00, $00
'-' alignl
'-' 
'-' hid_stack       long 0[(hidr_end - hidr_state) * 1]
	byte	$00[20]
'-' 
'-' if HAVE_HIDPAD
'-' hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
'-' end
'-' 
'-' ' HUB descriptor
'-' hub_descr       byte    0   ' bDescLength
	byte	$00
'-'                 byte    0   ' bDescriptorType
	byte	$00
'-'                 byte    0   ' bNbrPorts
	byte	$00
'-'                 word    0   ' wHubCharacteristics
	byte	$00, $00
'-'                 byte    0   ' bPwrOn2PwrGood
	byte	$00
'-'                 byte    0   ' bHubContrCurrent
	byte	$00
'-'                 byte    0   ' DeviceRemoveable
	byte	$00
'-'                 byte    0   ' PortPwrCtrlMask
	byte	$00
'-' 
'-' usb_cache_end
'-' 
'-' if HAVE_MOUSE
'-' mouse_xacc      long 0
'-' mouse_yacc      long 0
'-' mouse_zacc      long 0
'-' mouse_bstate    byte 0
'-' mouse_lpending  byte 0
'-' mouse_rpending  byte 0
'-' mouse_mpending  byte 0
'-' mouse_lock      byte 0
'-'                 byte 0[3] ' padding
'-' end
'-' 
'-' urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
	byte	$00[128]
'-' dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
	byte	$00[18]
'-' con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
	byte	$00[256]
'-' 
'-' driver_cog      byte    0                       ' Current driver cog + 1
	byte	$00
	alignl
_fs9p_cc_dat_
	byte	$18, $04, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[1036]
	alignl
__system__dat_
	byte	$00[8]
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[660]
	long	(19 {__system____root_opendir})<<20
	long	(20 {__system____root_closedir})<<20
	long	(21 {__system____root_readdir})<<20
	long	(22 {__system____root_stat})<<20
	byte	$00[28]
__methodtable__
	long	@_hostfs_sendrecv
	long	@_fatfs_cc_v_close
	long	@_fatfs_cc_v_read
	long	@_fatfs_cc_v_write
	long	@_fatfs_cc_v_lseek
	long	@_fatfs_cc_v_ioctl
	long	@_fatfs_cc_v_flush
	long	@_fatfs_cc_v_open
	long	@_fatfs_cc_v_creat
	long	@_fatfs_cc_v_opendir
	long	@_fatfs_cc_v_closedir
	long	@_fatfs_cc_v_readdir
	long	@_fatfs_cc_v_stat
	long	@_fatfs_cc_v_mkdir
	long	@_fatfs_cc_v_rmdir
	long	@_fatfs_cc_v_remove
	long	@_fatfs_cc_v_rename
	long	@_fatfs_cc_v_init
	long	@_fatfs_cc_v_deinit
	long	@__system____root_opendir
	long	@__system____root_closedir
	long	@__system____root_readdir
	long	@__system____root_stat
	long	@_libc_a___default_putc
	long	@_libc_a___default_getc
	long	@_libc_a___default_flush
	long	@__system___tx
	long	@__system___rx
	long	@_libc_a__rxtxioctl_0726
	long	@_libc_a___dummy_flush_0727
__heap_base
	long	0[1502]
objmem
	long	0[90544]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
_var03
	res	1
_var04
	res	1
_var05
	res	1
_var06
	res	1
_var07
	res	1
_var08
	res	1
_var09
	res	1
_var10
	res	1
_var11
	res	1
_var12
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
arg05
	res	1
arg06
	res	1
arg07
	res	1
arg08
	res	1
arg09
	res	1
arg10
	res	1
arg11
	res	1
local01
	res	1
local02
	res	1
local03
	res	1
local04
	res	1
local05
	res	1
local06
	res	1
local07
	res	1
local08
	res	1
local09
	res	1
local10
	res	1
local11
	res	1
local12
	res	1
local13
	res	1
local14
	res	1
local15
	res	1
local16
	res	1
local17
	res	1
local18
	res	1
local19
	res	1
local20
	res	1
local21
	res	1
local22
	res	1
local23
	res	1
local24
	res	1
local25
	res	1
local26
	res	1
local27
	res	1
local28
	res	1
local29
	res	1
local30
	res	1
local31
	res	1
local32
	res	1
local33
	res	1
local34
	res	1
local35
	res	1
local36
	res	1
local37
	res	1
local38
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	480
